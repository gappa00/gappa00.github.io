/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/index.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/babel-loader/lib/index.js!./node_modules/vue-loader/lib/index.js?!./src/components/main/main.vue?vue&type=script&lang=js&":
/*!*************************************************************************************************************************************************!*\
  !*** ./node_modules/babel-loader/lib!./node_modules/vue-loader/lib??vue-loader-options!./src/components/main/main.vue?vue&type=script&lang=js& ***!
  \*************************************************************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var vuedraggable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vuedraggable */ "./node_modules/vuedraggable/dist/vuedraggable.umd.js");
/* harmony import */ var vuedraggable__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(vuedraggable__WEBPACK_IMPORTED_MODULE_0__);
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//

/* harmony default export */ __webpack_exports__["default"] = ({
  name: 'App',
  data: function data() {
    return {
      nameFirst: '',
      nameSecond: '',
      nameLast: '',
      age: '',
      peoples: [],
      showFromLocal: false
    };
  },
  watch: {},
  mounted: function mounted() {
    if (localStorage.age) {
      this.savedAge = localStorage.age;
    }

    if (localStorage.peoplesLocal) {
      this.peoples = JSON.parse(localStorage.peoplesLocal);
      this.showFromLocal = true;
    }
  },
  components: {
    draggable: vuedraggable__WEBPACK_IMPORTED_MODULE_0___default.a
  },
  methods: {
    addNew: function addNew() {
      this.peoples.push({
        nameFirst: this.nameFirst,
        nameSecond: this.nameSecond,
        nameLast: this.nameLast,
        savedAge: this.age
      });
      this.showFromLocal = true;
      localStorage.peoplesLocal = JSON.stringify(this.peoples);
      console.log(localStorage.peoplesLocal); //JSON.parse(localStorage.peoplesLocal)
    },
    clearLocal: function clearLocal() {
      this.peoples = [];
      localStorage.clear();
      this.showFromLocal = false;
    },
    clearInput: function clearInput() {
      this.nameFirst = this.nameSecond = this.nameLast = this.age = '';
    },
    deleteChelik: function deleteChelik(index) {
      this.peoples.splice(index, 1);
      console.log(this.peoples);
      console.log(index);
      localStorage.peoplesLocal = JSON.stringify(this.peoples);

      if (this.peoples.length == 0) {
        this.clearLocal();
      }
    }
  },
  created: function created() {}
});

/***/ }),

/***/ "./node_modules/css-loader/dist/cjs.js!./node_modules/vue-loader/lib/loaders/stylePostLoader.js!./node_modules/sass-loader/dist/cjs.js!./src/components/main/main.scss?vue&type=style&index=0&lang=scss&":
/*!***************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js!./node_modules/vue-loader/lib/loaders/stylePostLoader.js!./node_modules/sass-loader/dist/cjs.js!./src/components/main/main.scss?vue&type=style&index=0&lang=scss& ***!
  \***************************************************************************************************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Imports
var ___CSS_LOADER_API_IMPORT___ = __webpack_require__(/*! ../../../node_modules/css-loader/dist/runtime/api.js */ "./node_modules/css-loader/dist/runtime/api.js");
exports = ___CSS_LOADER_API_IMPORT___(false);
exports.push([module.i, "@import url(https://fonts.googleapis.com/css2?family=Source+Sans+Pro:wght@200&display=swap);"]);
// Module
exports.push([module.i, "body {\n  font-family: 'Source Sans Pro', sans-serif;\n}\n.main {\n  height: 100vh;\n  display: flex;\n  align-items: center;\n  background-color: aliceblue;\n}\n.todo-app {\n  max-width: 600px;\n  width: 100%;\n  margin: 0 auto;\n  text-align: center;\n  background: #d7e5ff;\n  border-radius: 8px;\n  padding: 10px;\n  border: 1px solid #a0a0a0;\n}\n.chelik-input div {\n  display: flex;\n  flex-direction: column;\n  flex-wrap: wrap;\n  align-items: flex-start;\n  max-width: 380px;\n  margin: 0 auto 16px;\n}\n.chelik-input input {\n  width: -webkit-fill-available;\n}\n.moving-item {\n  opacity: 0.5;\n  background: #000;\n  border: 1px solid #4299e1;\n}\n.chelik-info__wrap {\n  display: flex;\n  flex-direction: column;\n  background: aliceblue;\n  border: 1px solid #a0a0a0;\n  border-radius: 10px;\n  margin: 32px 0;\n}\n.chelik-info__title {\n  width: 100%;\n  border-bottom: 1px solid #a0a0a0;\n  height: 32px;\n  line-height: 30px;\n}\n.chelik-info__properties-list {\n  display: flex;\n  height: 30px;\n  line-height: 30px;\n  justify-content: flex-start;\n  align-items: center;\n}\n.chelik-info__properties-index {\n  width: 20%;\n  border-right: 1px solid #a0a0a0;\n}\n.chelik-info__properties-name {\n  width: 45%;\n  border-right: 1px solid #a0a0a0;\n}\n.chelik-info__properties-age {\n  width: 24%;\n  border-right: 1px solid #a0a0a0;\n}\n.chelik-info__properties-blank {\n  width: 11%;\n}\n.chelik-info__list {\n  display: flex;\n  flex-direction: column;\n  line-height: 30px;\n}\n.chelik-info__item {\n  display: flex;\n  justify-content: flex-start;\n  border-top: 1px solid #a0a0a0;\n  min-height: 32px;\n}\n.chelik-info__item-index {\n  width: 20%;\n  border-right: 1px solid #a0a0a0;\n}\n.chelik-info__item-name {\n  width: 45%;\n  border-right: 1px solid #a0a0a0;\n}\n.chelik-info__item-age {\n  width: 24%;\n  border-right: 1px solid #a0a0a0;\n}\n.chelik-info__item-del {\n  width: 11%;\n}\n.chelik-info__item-index, .chelik-info__item-age, .chelik-info__item-del {\n  display: flex;\n  justify-content: center;\n  align-items: center;\n}\nbutton {\n  margin: 0px auto;\n}\n", ""]);
// Exports
module.exports = exports;


/***/ }),

/***/ "./node_modules/css-loader/dist/runtime/api.js":
/*!*****************************************************!*\
  !*** ./node_modules/css-loader/dist/runtime/api.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
  MIT License http://www.opensource.org/licenses/mit-license.php
  Author Tobias Koppers @sokra
*/
// css base code, injected by the css-loader
// eslint-disable-next-line func-names

module.exports = function (useSourceMap) {
  var list = []; // return the list of modules as css string

  list.toString = function toString() {
    return this.map(function (item) {
      var content = cssWithMappingToString(item, useSourceMap);

      if (item[2]) {
        return "@media ".concat(item[2], " {").concat(content, "}");
      }

      return content;
    }).join('');
  }; // import a list of modules into the list
  // eslint-disable-next-line func-names


  list.i = function (modules, mediaQuery, dedupe) {
    if (typeof modules === 'string') {
      // eslint-disable-next-line no-param-reassign
      modules = [[null, modules, '']];
    }

    var alreadyImportedModules = {};

    if (dedupe) {
      for (var i = 0; i < this.length; i++) {
        // eslint-disable-next-line prefer-destructuring
        var id = this[i][0];

        if (id != null) {
          alreadyImportedModules[id] = true;
        }
      }
    }

    for (var _i = 0; _i < modules.length; _i++) {
      var item = [].concat(modules[_i]);

      if (dedupe && alreadyImportedModules[item[0]]) {
        // eslint-disable-next-line no-continue
        continue;
      }

      if (mediaQuery) {
        if (!item[2]) {
          item[2] = mediaQuery;
        } else {
          item[2] = "".concat(mediaQuery, " and ").concat(item[2]);
        }
      }

      list.push(item);
    }
  };

  return list;
};

function cssWithMappingToString(item, useSourceMap) {
  var content = item[1] || ''; // eslint-disable-next-line prefer-destructuring

  var cssMapping = item[3];

  if (!cssMapping) {
    return content;
  }

  if (useSourceMap && typeof btoa === 'function') {
    var sourceMapping = toComment(cssMapping);
    var sourceURLs = cssMapping.sources.map(function (source) {
      return "/*# sourceURL=".concat(cssMapping.sourceRoot || '').concat(source, " */");
    });
    return [content].concat(sourceURLs).concat([sourceMapping]).join('\n');
  }

  return [content].join('\n');
} // Adapted from convert-source-map (MIT)


function toComment(sourceMap) {
  // eslint-disable-next-line no-undef
  var base64 = btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap))));
  var data = "sourceMappingURL=data:application/json;charset=utf-8;base64,".concat(base64);
  return "/*# ".concat(data, " */");
}

/***/ }),

/***/ "./node_modules/process/browser.js":
/*!*****************************************!*\
  !*** ./node_modules/process/browser.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// shim for using process in browser
var process = module.exports = {}; // cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
  throw new Error('setTimeout has not been defined');
}

function defaultClearTimeout() {
  throw new Error('clearTimeout has not been defined');
}

(function () {
  try {
    if (typeof setTimeout === 'function') {
      cachedSetTimeout = setTimeout;
    } else {
      cachedSetTimeout = defaultSetTimout;
    }
  } catch (e) {
    cachedSetTimeout = defaultSetTimout;
  }

  try {
    if (typeof clearTimeout === 'function') {
      cachedClearTimeout = clearTimeout;
    } else {
      cachedClearTimeout = defaultClearTimeout;
    }
  } catch (e) {
    cachedClearTimeout = defaultClearTimeout;
  }
})();

function runTimeout(fun) {
  if (cachedSetTimeout === setTimeout) {
    //normal enviroments in sane situations
    return setTimeout(fun, 0);
  } // if setTimeout wasn't available but was latter defined


  if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
    cachedSetTimeout = setTimeout;
    return setTimeout(fun, 0);
  }

  try {
    // when when somebody has screwed with setTimeout but no I.E. maddness
    return cachedSetTimeout(fun, 0);
  } catch (e) {
    try {
      // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
      return cachedSetTimeout.call(null, fun, 0);
    } catch (e) {
      // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
      return cachedSetTimeout.call(this, fun, 0);
    }
  }
}

function runClearTimeout(marker) {
  if (cachedClearTimeout === clearTimeout) {
    //normal enviroments in sane situations
    return clearTimeout(marker);
  } // if clearTimeout wasn't available but was latter defined


  if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
    cachedClearTimeout = clearTimeout;
    return clearTimeout(marker);
  }

  try {
    // when when somebody has screwed with setTimeout but no I.E. maddness
    return cachedClearTimeout(marker);
  } catch (e) {
    try {
      // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
      return cachedClearTimeout.call(null, marker);
    } catch (e) {
      // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
      // Some versions of I.E. have different rules for clearTimeout vs setTimeout
      return cachedClearTimeout.call(this, marker);
    }
  }
}

var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
  if (!draining || !currentQueue) {
    return;
  }

  draining = false;

  if (currentQueue.length) {
    queue = currentQueue.concat(queue);
  } else {
    queueIndex = -1;
  }

  if (queue.length) {
    drainQueue();
  }
}

function drainQueue() {
  if (draining) {
    return;
  }

  var timeout = runTimeout(cleanUpNextTick);
  draining = true;
  var len = queue.length;

  while (len) {
    currentQueue = queue;
    queue = [];

    while (++queueIndex < len) {
      if (currentQueue) {
        currentQueue[queueIndex].run();
      }
    }

    queueIndex = -1;
    len = queue.length;
  }

  currentQueue = null;
  draining = false;
  runClearTimeout(timeout);
}

process.nextTick = function (fun) {
  var args = new Array(arguments.length - 1);

  if (arguments.length > 1) {
    for (var i = 1; i < arguments.length; i++) {
      args[i - 1] = arguments[i];
    }
  }

  queue.push(new Item(fun, args));

  if (queue.length === 1 && !draining) {
    runTimeout(drainQueue);
  }
}; // v8 likes predictible objects


function Item(fun, array) {
  this.fun = fun;
  this.array = array;
}

Item.prototype.run = function () {
  this.fun.apply(null, this.array);
};

process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues

process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) {
  return [];
};

process.binding = function (name) {
  throw new Error('process.binding is not supported');
};

process.cwd = function () {
  return '/';
};

process.chdir = function (dir) {
  throw new Error('process.chdir is not supported');
};

process.umask = function () {
  return 0;
};

/***/ }),

/***/ "./node_modules/setimmediate/setImmediate.js":
/*!***************************************************!*\
  !*** ./node_modules/setimmediate/setImmediate.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global, process) {(function (global, undefined) {
  "use strict";

  if (global.setImmediate) {
    return;
  }

  var nextHandle = 1; // Spec says greater than zero

  var tasksByHandle = {};
  var currentlyRunningATask = false;
  var doc = global.document;
  var registerImmediate;

  function setImmediate(callback) {
    // Callback can either be a function or a string
    if (typeof callback !== "function") {
      callback = new Function("" + callback);
    } // Copy function arguments


    var args = new Array(arguments.length - 1);

    for (var i = 0; i < args.length; i++) {
      args[i] = arguments[i + 1];
    } // Store and register the task


    var task = {
      callback: callback,
      args: args
    };
    tasksByHandle[nextHandle] = task;
    registerImmediate(nextHandle);
    return nextHandle++;
  }

  function clearImmediate(handle) {
    delete tasksByHandle[handle];
  }

  function run(task) {
    var callback = task.callback;
    var args = task.args;

    switch (args.length) {
      case 0:
        callback();
        break;

      case 1:
        callback(args[0]);
        break;

      case 2:
        callback(args[0], args[1]);
        break;

      case 3:
        callback(args[0], args[1], args[2]);
        break;

      default:
        callback.apply(undefined, args);
        break;
    }
  }

  function runIfPresent(handle) {
    // From the spec: "Wait until any invocations of this algorithm started before this one have completed."
    // So if we're currently running a task, we'll need to delay this invocation.
    if (currentlyRunningATask) {
      // Delay by doing a setTimeout. setImmediate was tried instead, but in Firefox 7 it generated a
      // "too much recursion" error.
      setTimeout(runIfPresent, 0, handle);
    } else {
      var task = tasksByHandle[handle];

      if (task) {
        currentlyRunningATask = true;

        try {
          run(task);
        } finally {
          clearImmediate(handle);
          currentlyRunningATask = false;
        }
      }
    }
  }

  function installNextTickImplementation() {
    registerImmediate = function (handle) {
      process.nextTick(function () {
        runIfPresent(handle);
      });
    };
  }

  function canUsePostMessage() {
    // The test against `importScripts` prevents this implementation from being installed inside a web worker,
    // where `global.postMessage` means something completely different and can't be used for this purpose.
    if (global.postMessage && !global.importScripts) {
      var postMessageIsAsynchronous = true;
      var oldOnMessage = global.onmessage;

      global.onmessage = function () {
        postMessageIsAsynchronous = false;
      };

      global.postMessage("", "*");
      global.onmessage = oldOnMessage;
      return postMessageIsAsynchronous;
    }
  }

  function installPostMessageImplementation() {
    // Installs an event handler on `global` for the `message` event: see
    // * https://developer.mozilla.org/en/DOM/window.postMessage
    // * http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#crossDocumentMessages
    var messagePrefix = "setImmediate$" + Math.random() + "$";

    var onGlobalMessage = function (event) {
      if (event.source === global && typeof event.data === "string" && event.data.indexOf(messagePrefix) === 0) {
        runIfPresent(+event.data.slice(messagePrefix.length));
      }
    };

    if (global.addEventListener) {
      global.addEventListener("message", onGlobalMessage, false);
    } else {
      global.attachEvent("onmessage", onGlobalMessage);
    }

    registerImmediate = function (handle) {
      global.postMessage(messagePrefix + handle, "*");
    };
  }

  function installMessageChannelImplementation() {
    var channel = new MessageChannel();

    channel.port1.onmessage = function (event) {
      var handle = event.data;
      runIfPresent(handle);
    };

    registerImmediate = function (handle) {
      channel.port2.postMessage(handle);
    };
  }

  function installReadyStateChangeImplementation() {
    var html = doc.documentElement;

    registerImmediate = function (handle) {
      // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted
      // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.
      var script = doc.createElement("script");

      script.onreadystatechange = function () {
        runIfPresent(handle);
        script.onreadystatechange = null;
        html.removeChild(script);
        script = null;
      };

      html.appendChild(script);
    };
  }

  function installSetTimeoutImplementation() {
    registerImmediate = function (handle) {
      setTimeout(runIfPresent, 0, handle);
    };
  } // If supported, we should attach to the prototype of global, since that is where setTimeout et al. live.


  var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global);
  attachTo = attachTo && attachTo.setTimeout ? attachTo : global; // Don't get fooled by e.g. browserify environments.

  if ({}.toString.call(global.process) === "[object process]") {
    // For Node.js before 0.9
    installNextTickImplementation();
  } else if (canUsePostMessage()) {
    // For non-IE10 modern browsers
    installPostMessageImplementation();
  } else if (global.MessageChannel) {
    // For web workers, where supported
    installMessageChannelImplementation();
  } else if (doc && "onreadystatechange" in doc.createElement("script")) {
    // For IE 6â€“8
    installReadyStateChangeImplementation();
  } else {
    // For older browsers
    installSetTimeoutImplementation();
  }

  attachTo.setImmediate = setImmediate;
  attachTo.clearImmediate = clearImmediate;
})(typeof self === "undefined" ? typeof global === "undefined" ? this : global : self);
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js"), __webpack_require__(/*! ./../process/browser.js */ "./node_modules/process/browser.js")))

/***/ }),

/***/ "./node_modules/sortablejs/modular/sortable.esm.js":
/*!*********************************************************!*\
  !*** ./node_modules/sortablejs/modular/sortable.esm.js ***!
  \*********************************************************/
/*! exports provided: default, MultiDrag, Sortable, Swap */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MultiDrag", function() { return MultiDragPlugin; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Sortable", function() { return Sortable; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Swap", function() { return SwapPlugin; });
/**!
 * Sortable 1.10.2
 * @author	RubaXa   <trash@rubaxa.org>
 * @author	owenm    <owen23355@gmail.com>
 * @license MIT
 */
function _typeof(obj) {
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof = function (obj) {
      return typeof obj;
    };
  } else {
    _typeof = function (obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }

  return _typeof(obj);
}

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

function _objectSpread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    var ownKeys = Object.keys(source);

    if (typeof Object.getOwnPropertySymbols === 'function') {
      ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) {
        return Object.getOwnPropertyDescriptor(source, sym).enumerable;
      }));
    }

    ownKeys.forEach(function (key) {
      _defineProperty(target, key, source[key]);
    });
  }

  return target;
}

function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;

  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }

  return target;
}

function _objectWithoutProperties(source, excluded) {
  if (source == null) return {};

  var target = _objectWithoutPropertiesLoose(source, excluded);

  var key, i;

  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);

    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }

  return target;
}

function _toConsumableArray(arr) {
  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread();
}

function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr)) {
    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];

    return arr2;
  }
}

function _iterableToArray(iter) {
  if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter);
}

function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance");
}

var version = "1.10.2";

function userAgent(pattern) {
  if (typeof window !== 'undefined' && window.navigator) {
    return !! /*@__PURE__*/navigator.userAgent.match(pattern);
  }
}

var IE11OrLess = userAgent(/(?:Trident.*rv[ :]?11\.|msie|iemobile|Windows Phone)/i);
var Edge = userAgent(/Edge/i);
var FireFox = userAgent(/firefox/i);
var Safari = userAgent(/safari/i) && !userAgent(/chrome/i) && !userAgent(/android/i);
var IOS = userAgent(/iP(ad|od|hone)/i);
var ChromeForAndroid = userAgent(/chrome/i) && userAgent(/android/i);
var captureMode = {
  capture: false,
  passive: false
};

function on(el, event, fn) {
  el.addEventListener(event, fn, !IE11OrLess && captureMode);
}

function off(el, event, fn) {
  el.removeEventListener(event, fn, !IE11OrLess && captureMode);
}

function matches(
/**HTMLElement*/
el,
/**String*/
selector) {
  if (!selector) return;
  selector[0] === '>' && (selector = selector.substring(1));

  if (el) {
    try {
      if (el.matches) {
        return el.matches(selector);
      } else if (el.msMatchesSelector) {
        return el.msMatchesSelector(selector);
      } else if (el.webkitMatchesSelector) {
        return el.webkitMatchesSelector(selector);
      }
    } catch (_) {
      return false;
    }
  }

  return false;
}

function getParentOrHost(el) {
  return el.host && el !== document && el.host.nodeType ? el.host : el.parentNode;
}

function closest(
/**HTMLElement*/
el,
/**String*/
selector,
/**HTMLElement*/
ctx, includeCTX) {
  if (el) {
    ctx = ctx || document;

    do {
      if (selector != null && (selector[0] === '>' ? el.parentNode === ctx && matches(el, selector) : matches(el, selector)) || includeCTX && el === ctx) {
        return el;
      }

      if (el === ctx) break;
      /* jshint boss:true */
    } while (el = getParentOrHost(el));
  }

  return null;
}

var R_SPACE = /\s+/g;

function toggleClass(el, name, state) {
  if (el && name) {
    if (el.classList) {
      el.classList[state ? 'add' : 'remove'](name);
    } else {
      var className = (' ' + el.className + ' ').replace(R_SPACE, ' ').replace(' ' + name + ' ', ' ');
      el.className = (className + (state ? ' ' + name : '')).replace(R_SPACE, ' ');
    }
  }
}

function css(el, prop, val) {
  var style = el && el.style;

  if (style) {
    if (val === void 0) {
      if (document.defaultView && document.defaultView.getComputedStyle) {
        val = document.defaultView.getComputedStyle(el, '');
      } else if (el.currentStyle) {
        val = el.currentStyle;
      }

      return prop === void 0 ? val : val[prop];
    } else {
      if (!(prop in style) && prop.indexOf('webkit') === -1) {
        prop = '-webkit-' + prop;
      }

      style[prop] = val + (typeof val === 'string' ? '' : 'px');
    }
  }
}

function matrix(el, selfOnly) {
  var appliedTransforms = '';

  if (typeof el === 'string') {
    appliedTransforms = el;
  } else {
    do {
      var transform = css(el, 'transform');

      if (transform && transform !== 'none') {
        appliedTransforms = transform + ' ' + appliedTransforms;
      }
      /* jshint boss:true */

    } while (!selfOnly && (el = el.parentNode));
  }

  var matrixFn = window.DOMMatrix || window.WebKitCSSMatrix || window.CSSMatrix || window.MSCSSMatrix;
  /*jshint -W056 */

  return matrixFn && new matrixFn(appliedTransforms);
}

function find(ctx, tagName, iterator) {
  if (ctx) {
    var list = ctx.getElementsByTagName(tagName),
        i = 0,
        n = list.length;

    if (iterator) {
      for (; i < n; i++) {
        iterator(list[i], i);
      }
    }

    return list;
  }

  return [];
}

function getWindowScrollingElement() {
  var scrollingElement = document.scrollingElement;

  if (scrollingElement) {
    return scrollingElement;
  } else {
    return document.documentElement;
  }
}
/**
 * Returns the "bounding client rect" of given element
 * @param  {HTMLElement} el                       The element whose boundingClientRect is wanted
 * @param  {[Boolean]} relativeToContainingBlock  Whether the rect should be relative to the containing block of (including) the container
 * @param  {[Boolean]} relativeToNonStaticParent  Whether the rect should be relative to the relative parent of (including) the contaienr
 * @param  {[Boolean]} undoScale                  Whether the container's scale() should be undone
 * @param  {[HTMLElement]} container              The parent the element will be placed in
 * @return {Object}                               The boundingClientRect of el, with specified adjustments
 */


function getRect(el, relativeToContainingBlock, relativeToNonStaticParent, undoScale, container) {
  if (!el.getBoundingClientRect && el !== window) return;
  var elRect, top, left, bottom, right, height, width;

  if (el !== window && el !== getWindowScrollingElement()) {
    elRect = el.getBoundingClientRect();
    top = elRect.top;
    left = elRect.left;
    bottom = elRect.bottom;
    right = elRect.right;
    height = elRect.height;
    width = elRect.width;
  } else {
    top = 0;
    left = 0;
    bottom = window.innerHeight;
    right = window.innerWidth;
    height = window.innerHeight;
    width = window.innerWidth;
  }

  if ((relativeToContainingBlock || relativeToNonStaticParent) && el !== window) {
    // Adjust for translate()
    container = container || el.parentNode; // solves #1123 (see: https://stackoverflow.com/a/37953806/6088312)
    // Not needed on <= IE11

    if (!IE11OrLess) {
      do {
        if (container && container.getBoundingClientRect && (css(container, 'transform') !== 'none' || relativeToNonStaticParent && css(container, 'position') !== 'static')) {
          var containerRect = container.getBoundingClientRect(); // Set relative to edges of padding box of container

          top -= containerRect.top + parseInt(css(container, 'border-top-width'));
          left -= containerRect.left + parseInt(css(container, 'border-left-width'));
          bottom = top + elRect.height;
          right = left + elRect.width;
          break;
        }
        /* jshint boss:true */

      } while (container = container.parentNode);
    }
  }

  if (undoScale && el !== window) {
    // Adjust for scale()
    var elMatrix = matrix(container || el),
        scaleX = elMatrix && elMatrix.a,
        scaleY = elMatrix && elMatrix.d;

    if (elMatrix) {
      top /= scaleY;
      left /= scaleX;
      width /= scaleX;
      height /= scaleY;
      bottom = top + height;
      right = left + width;
    }
  }

  return {
    top: top,
    left: left,
    bottom: bottom,
    right: right,
    width: width,
    height: height
  };
}
/**
 * Checks if a side of an element is scrolled past a side of its parents
 * @param  {HTMLElement}  el           The element who's side being scrolled out of view is in question
 * @param  {String}       elSide       Side of the element in question ('top', 'left', 'right', 'bottom')
 * @param  {String}       parentSide   Side of the parent in question ('top', 'left', 'right', 'bottom')
 * @return {HTMLElement}               The parent scroll element that the el's side is scrolled past, or null if there is no such element
 */


function isScrolledPast(el, elSide, parentSide) {
  var parent = getParentAutoScrollElement(el, true),
      elSideVal = getRect(el)[elSide];
  /* jshint boss:true */

  while (parent) {
    var parentSideVal = getRect(parent)[parentSide],
        visible = void 0;

    if (parentSide === 'top' || parentSide === 'left') {
      visible = elSideVal >= parentSideVal;
    } else {
      visible = elSideVal <= parentSideVal;
    }

    if (!visible) return parent;
    if (parent === getWindowScrollingElement()) break;
    parent = getParentAutoScrollElement(parent, false);
  }

  return false;
}
/**
 * Gets nth child of el, ignoring hidden children, sortable's elements (does not ignore clone if it's visible)
 * and non-draggable elements
 * @param  {HTMLElement} el       The parent element
 * @param  {Number} childNum      The index of the child
 * @param  {Object} options       Parent Sortable's options
 * @return {HTMLElement}          The child at index childNum, or null if not found
 */


function getChild(el, childNum, options) {
  var currentChild = 0,
      i = 0,
      children = el.children;

  while (i < children.length) {
    if (children[i].style.display !== 'none' && children[i] !== Sortable.ghost && children[i] !== Sortable.dragged && closest(children[i], options.draggable, el, false)) {
      if (currentChild === childNum) {
        return children[i];
      }

      currentChild++;
    }

    i++;
  }

  return null;
}
/**
 * Gets the last child in the el, ignoring ghostEl or invisible elements (clones)
 * @param  {HTMLElement} el       Parent element
 * @param  {selector} selector    Any other elements that should be ignored
 * @return {HTMLElement}          The last child, ignoring ghostEl
 */


function lastChild(el, selector) {
  var last = el.lastElementChild;

  while (last && (last === Sortable.ghost || css(last, 'display') === 'none' || selector && !matches(last, selector))) {
    last = last.previousElementSibling;
  }

  return last || null;
}
/**
 * Returns the index of an element within its parent for a selected set of
 * elements
 * @param  {HTMLElement} el
 * @param  {selector} selector
 * @return {number}
 */


function index(el, selector) {
  var index = 0;

  if (!el || !el.parentNode) {
    return -1;
  }
  /* jshint boss:true */


  while (el = el.previousElementSibling) {
    if (el.nodeName.toUpperCase() !== 'TEMPLATE' && el !== Sortable.clone && (!selector || matches(el, selector))) {
      index++;
    }
  }

  return index;
}
/**
 * Returns the scroll offset of the given element, added with all the scroll offsets of parent elements.
 * The value is returned in real pixels.
 * @param  {HTMLElement} el
 * @return {Array}             Offsets in the format of [left, top]
 */


function getRelativeScrollOffset(el) {
  var offsetLeft = 0,
      offsetTop = 0,
      winScroller = getWindowScrollingElement();

  if (el) {
    do {
      var elMatrix = matrix(el),
          scaleX = elMatrix.a,
          scaleY = elMatrix.d;
      offsetLeft += el.scrollLeft * scaleX;
      offsetTop += el.scrollTop * scaleY;
    } while (el !== winScroller && (el = el.parentNode));
  }

  return [offsetLeft, offsetTop];
}
/**
 * Returns the index of the object within the given array
 * @param  {Array} arr   Array that may or may not hold the object
 * @param  {Object} obj  An object that has a key-value pair unique to and identical to a key-value pair in the object you want to find
 * @return {Number}      The index of the object in the array, or -1
 */


function indexOfObject(arr, obj) {
  for (var i in arr) {
    if (!arr.hasOwnProperty(i)) continue;

    for (var key in obj) {
      if (obj.hasOwnProperty(key) && obj[key] === arr[i][key]) return Number(i);
    }
  }

  return -1;
}

function getParentAutoScrollElement(el, includeSelf) {
  // skip to window
  if (!el || !el.getBoundingClientRect) return getWindowScrollingElement();
  var elem = el;
  var gotSelf = false;

  do {
    // we don't need to get elem css if it isn't even overflowing in the first place (performance)
    if (elem.clientWidth < elem.scrollWidth || elem.clientHeight < elem.scrollHeight) {
      var elemCSS = css(elem);

      if (elem.clientWidth < elem.scrollWidth && (elemCSS.overflowX == 'auto' || elemCSS.overflowX == 'scroll') || elem.clientHeight < elem.scrollHeight && (elemCSS.overflowY == 'auto' || elemCSS.overflowY == 'scroll')) {
        if (!elem.getBoundingClientRect || elem === document.body) return getWindowScrollingElement();
        if (gotSelf || includeSelf) return elem;
        gotSelf = true;
      }
    }
    /* jshint boss:true */

  } while (elem = elem.parentNode);

  return getWindowScrollingElement();
}

function extend(dst, src) {
  if (dst && src) {
    for (var key in src) {
      if (src.hasOwnProperty(key)) {
        dst[key] = src[key];
      }
    }
  }

  return dst;
}

function isRectEqual(rect1, rect2) {
  return Math.round(rect1.top) === Math.round(rect2.top) && Math.round(rect1.left) === Math.round(rect2.left) && Math.round(rect1.height) === Math.round(rect2.height) && Math.round(rect1.width) === Math.round(rect2.width);
}

var _throttleTimeout;

function throttle(callback, ms) {
  return function () {
    if (!_throttleTimeout) {
      var args = arguments,
          _this = this;

      if (args.length === 1) {
        callback.call(_this, args[0]);
      } else {
        callback.apply(_this, args);
      }

      _throttleTimeout = setTimeout(function () {
        _throttleTimeout = void 0;
      }, ms);
    }
  };
}

function cancelThrottle() {
  clearTimeout(_throttleTimeout);
  _throttleTimeout = void 0;
}

function scrollBy(el, x, y) {
  el.scrollLeft += x;
  el.scrollTop += y;
}

function clone(el) {
  var Polymer = window.Polymer;
  var $ = window.jQuery || window.Zepto;

  if (Polymer && Polymer.dom) {
    return Polymer.dom(el).cloneNode(true);
  } else if ($) {
    return $(el).clone(true)[0];
  } else {
    return el.cloneNode(true);
  }
}

function setRect(el, rect) {
  css(el, 'position', 'absolute');
  css(el, 'top', rect.top);
  css(el, 'left', rect.left);
  css(el, 'width', rect.width);
  css(el, 'height', rect.height);
}

function unsetRect(el) {
  css(el, 'position', '');
  css(el, 'top', '');
  css(el, 'left', '');
  css(el, 'width', '');
  css(el, 'height', '');
}

var expando = 'Sortable' + new Date().getTime();

function AnimationStateManager() {
  var animationStates = [],
      animationCallbackId;
  return {
    captureAnimationState: function captureAnimationState() {
      animationStates = [];
      if (!this.options.animation) return;
      var children = [].slice.call(this.el.children);
      children.forEach(function (child) {
        if (css(child, 'display') === 'none' || child === Sortable.ghost) return;
        animationStates.push({
          target: child,
          rect: getRect(child)
        });

        var fromRect = _objectSpread({}, animationStates[animationStates.length - 1].rect); // If animating: compensate for current animation


        if (child.thisAnimationDuration) {
          var childMatrix = matrix(child, true);

          if (childMatrix) {
            fromRect.top -= childMatrix.f;
            fromRect.left -= childMatrix.e;
          }
        }

        child.fromRect = fromRect;
      });
    },
    addAnimationState: function addAnimationState(state) {
      animationStates.push(state);
    },
    removeAnimationState: function removeAnimationState(target) {
      animationStates.splice(indexOfObject(animationStates, {
        target: target
      }), 1);
    },
    animateAll: function animateAll(callback) {
      var _this = this;

      if (!this.options.animation) {
        clearTimeout(animationCallbackId);
        if (typeof callback === 'function') callback();
        return;
      }

      var animating = false,
          animationTime = 0;
      animationStates.forEach(function (state) {
        var time = 0,
            target = state.target,
            fromRect = target.fromRect,
            toRect = getRect(target),
            prevFromRect = target.prevFromRect,
            prevToRect = target.prevToRect,
            animatingRect = state.rect,
            targetMatrix = matrix(target, true);

        if (targetMatrix) {
          // Compensate for current animation
          toRect.top -= targetMatrix.f;
          toRect.left -= targetMatrix.e;
        }

        target.toRect = toRect;

        if (target.thisAnimationDuration) {
          // Could also check if animatingRect is between fromRect and toRect
          if (isRectEqual(prevFromRect, toRect) && !isRectEqual(fromRect, toRect) && // Make sure animatingRect is on line between toRect & fromRect
          (animatingRect.top - toRect.top) / (animatingRect.left - toRect.left) === (fromRect.top - toRect.top) / (fromRect.left - toRect.left)) {
            // If returning to same place as started from animation and on same axis
            time = calculateRealTime(animatingRect, prevFromRect, prevToRect, _this.options);
          }
        } // if fromRect != toRect: animate


        if (!isRectEqual(toRect, fromRect)) {
          target.prevFromRect = fromRect;
          target.prevToRect = toRect;

          if (!time) {
            time = _this.options.animation;
          }

          _this.animate(target, animatingRect, toRect, time);
        }

        if (time) {
          animating = true;
          animationTime = Math.max(animationTime, time);
          clearTimeout(target.animationResetTimer);
          target.animationResetTimer = setTimeout(function () {
            target.animationTime = 0;
            target.prevFromRect = null;
            target.fromRect = null;
            target.prevToRect = null;
            target.thisAnimationDuration = null;
          }, time);
          target.thisAnimationDuration = time;
        }
      });
      clearTimeout(animationCallbackId);

      if (!animating) {
        if (typeof callback === 'function') callback();
      } else {
        animationCallbackId = setTimeout(function () {
          if (typeof callback === 'function') callback();
        }, animationTime);
      }

      animationStates = [];
    },
    animate: function animate(target, currentRect, toRect, duration) {
      if (duration) {
        css(target, 'transition', '');
        css(target, 'transform', '');
        var elMatrix = matrix(this.el),
            scaleX = elMatrix && elMatrix.a,
            scaleY = elMatrix && elMatrix.d,
            translateX = (currentRect.left - toRect.left) / (scaleX || 1),
            translateY = (currentRect.top - toRect.top) / (scaleY || 1);
        target.animatingX = !!translateX;
        target.animatingY = !!translateY;
        css(target, 'transform', 'translate3d(' + translateX + 'px,' + translateY + 'px,0)');
        repaint(target); // repaint

        css(target, 'transition', 'transform ' + duration + 'ms' + (this.options.easing ? ' ' + this.options.easing : ''));
        css(target, 'transform', 'translate3d(0,0,0)');
        typeof target.animated === 'number' && clearTimeout(target.animated);
        target.animated = setTimeout(function () {
          css(target, 'transition', '');
          css(target, 'transform', '');
          target.animated = false;
          target.animatingX = false;
          target.animatingY = false;
        }, duration);
      }
    }
  };
}

function repaint(target) {
  return target.offsetWidth;
}

function calculateRealTime(animatingRect, fromRect, toRect, options) {
  return Math.sqrt(Math.pow(fromRect.top - animatingRect.top, 2) + Math.pow(fromRect.left - animatingRect.left, 2)) / Math.sqrt(Math.pow(fromRect.top - toRect.top, 2) + Math.pow(fromRect.left - toRect.left, 2)) * options.animation;
}

var plugins = [];
var defaults = {
  initializeByDefault: true
};
var PluginManager = {
  mount: function mount(plugin) {
    // Set default static properties
    for (var option in defaults) {
      if (defaults.hasOwnProperty(option) && !(option in plugin)) {
        plugin[option] = defaults[option];
      }
    }

    plugins.push(plugin);
  },
  pluginEvent: function pluginEvent(eventName, sortable, evt) {
    var _this = this;

    this.eventCanceled = false;

    evt.cancel = function () {
      _this.eventCanceled = true;
    };

    var eventNameGlobal = eventName + 'Global';
    plugins.forEach(function (plugin) {
      if (!sortable[plugin.pluginName]) return; // Fire global events if it exists in this sortable

      if (sortable[plugin.pluginName][eventNameGlobal]) {
        sortable[plugin.pluginName][eventNameGlobal](_objectSpread({
          sortable: sortable
        }, evt));
      } // Only fire plugin event if plugin is enabled in this sortable,
      // and plugin has event defined


      if (sortable.options[plugin.pluginName] && sortable[plugin.pluginName][eventName]) {
        sortable[plugin.pluginName][eventName](_objectSpread({
          sortable: sortable
        }, evt));
      }
    });
  },
  initializePlugins: function initializePlugins(sortable, el, defaults, options) {
    plugins.forEach(function (plugin) {
      var pluginName = plugin.pluginName;
      if (!sortable.options[pluginName] && !plugin.initializeByDefault) return;
      var initialized = new plugin(sortable, el, sortable.options);
      initialized.sortable = sortable;
      initialized.options = sortable.options;
      sortable[pluginName] = initialized; // Add default options from plugin

      _extends(defaults, initialized.defaults);
    });

    for (var option in sortable.options) {
      if (!sortable.options.hasOwnProperty(option)) continue;
      var modified = this.modifyOption(sortable, option, sortable.options[option]);

      if (typeof modified !== 'undefined') {
        sortable.options[option] = modified;
      }
    }
  },
  getEventProperties: function getEventProperties(name, sortable) {
    var eventProperties = {};
    plugins.forEach(function (plugin) {
      if (typeof plugin.eventProperties !== 'function') return;

      _extends(eventProperties, plugin.eventProperties.call(sortable[plugin.pluginName], name));
    });
    return eventProperties;
  },
  modifyOption: function modifyOption(sortable, name, value) {
    var modifiedValue;
    plugins.forEach(function (plugin) {
      // Plugin must exist on the Sortable
      if (!sortable[plugin.pluginName]) return; // If static option listener exists for this option, call in the context of the Sortable's instance of this plugin

      if (plugin.optionListeners && typeof plugin.optionListeners[name] === 'function') {
        modifiedValue = plugin.optionListeners[name].call(sortable[plugin.pluginName], value);
      }
    });
    return modifiedValue;
  }
};

function dispatchEvent(_ref) {
  var sortable = _ref.sortable,
      rootEl = _ref.rootEl,
      name = _ref.name,
      targetEl = _ref.targetEl,
      cloneEl = _ref.cloneEl,
      toEl = _ref.toEl,
      fromEl = _ref.fromEl,
      oldIndex = _ref.oldIndex,
      newIndex = _ref.newIndex,
      oldDraggableIndex = _ref.oldDraggableIndex,
      newDraggableIndex = _ref.newDraggableIndex,
      originalEvent = _ref.originalEvent,
      putSortable = _ref.putSortable,
      extraEventProperties = _ref.extraEventProperties;
  sortable = sortable || rootEl && rootEl[expando];
  if (!sortable) return;
  var evt,
      options = sortable.options,
      onName = 'on' + name.charAt(0).toUpperCase() + name.substr(1); // Support for new CustomEvent feature

  if (window.CustomEvent && !IE11OrLess && !Edge) {
    evt = new CustomEvent(name, {
      bubbles: true,
      cancelable: true
    });
  } else {
    evt = document.createEvent('Event');
    evt.initEvent(name, true, true);
  }

  evt.to = toEl || rootEl;
  evt.from = fromEl || rootEl;
  evt.item = targetEl || rootEl;
  evt.clone = cloneEl;
  evt.oldIndex = oldIndex;
  evt.newIndex = newIndex;
  evt.oldDraggableIndex = oldDraggableIndex;
  evt.newDraggableIndex = newDraggableIndex;
  evt.originalEvent = originalEvent;
  evt.pullMode = putSortable ? putSortable.lastPutMode : undefined;

  var allEventProperties = _objectSpread({}, extraEventProperties, PluginManager.getEventProperties(name, sortable));

  for (var option in allEventProperties) {
    evt[option] = allEventProperties[option];
  }

  if (rootEl) {
    rootEl.dispatchEvent(evt);
  }

  if (options[onName]) {
    options[onName].call(sortable, evt);
  }
}

var pluginEvent = function pluginEvent(eventName, sortable) {
  var _ref = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},
      originalEvent = _ref.evt,
      data = _objectWithoutProperties(_ref, ["evt"]);

  PluginManager.pluginEvent.bind(Sortable)(eventName, sortable, _objectSpread({
    dragEl: dragEl,
    parentEl: parentEl,
    ghostEl: ghostEl,
    rootEl: rootEl,
    nextEl: nextEl,
    lastDownEl: lastDownEl,
    cloneEl: cloneEl,
    cloneHidden: cloneHidden,
    dragStarted: moved,
    putSortable: putSortable,
    activeSortable: Sortable.active,
    originalEvent: originalEvent,
    oldIndex: oldIndex,
    oldDraggableIndex: oldDraggableIndex,
    newIndex: newIndex,
    newDraggableIndex: newDraggableIndex,
    hideGhostForTarget: _hideGhostForTarget,
    unhideGhostForTarget: _unhideGhostForTarget,
    cloneNowHidden: function cloneNowHidden() {
      cloneHidden = true;
    },
    cloneNowShown: function cloneNowShown() {
      cloneHidden = false;
    },
    dispatchSortableEvent: function dispatchSortableEvent(name) {
      _dispatchEvent({
        sortable: sortable,
        name: name,
        originalEvent: originalEvent
      });
    }
  }, data));
};

function _dispatchEvent(info) {
  dispatchEvent(_objectSpread({
    putSortable: putSortable,
    cloneEl: cloneEl,
    targetEl: dragEl,
    rootEl: rootEl,
    oldIndex: oldIndex,
    oldDraggableIndex: oldDraggableIndex,
    newIndex: newIndex,
    newDraggableIndex: newDraggableIndex
  }, info));
}

var dragEl,
    parentEl,
    ghostEl,
    rootEl,
    nextEl,
    lastDownEl,
    cloneEl,
    cloneHidden,
    oldIndex,
    newIndex,
    oldDraggableIndex,
    newDraggableIndex,
    activeGroup,
    putSortable,
    awaitingDragStarted = false,
    ignoreNextClick = false,
    sortables = [],
    tapEvt,
    touchEvt,
    lastDx,
    lastDy,
    tapDistanceLeft,
    tapDistanceTop,
    moved,
    lastTarget,
    lastDirection,
    pastFirstInvertThresh = false,
    isCircumstantialInvert = false,
    targetMoveDistance,
    // For positioning ghost absolutely
ghostRelativeParent,
    ghostRelativeParentInitialScroll = [],
    // (left, top)
_silent = false,
    savedInputChecked = [];
/** @const */

var documentExists = typeof document !== 'undefined',
    PositionGhostAbsolutely = IOS,
    CSSFloatProperty = Edge || IE11OrLess ? 'cssFloat' : 'float',
    // This will not pass for IE9, because IE9 DnD only works on anchors
supportDraggable = documentExists && !ChromeForAndroid && !IOS && 'draggable' in document.createElement('div'),
    supportCssPointerEvents = function () {
  if (!documentExists) return; // false when <= IE11

  if (IE11OrLess) {
    return false;
  }

  var el = document.createElement('x');
  el.style.cssText = 'pointer-events:auto';
  return el.style.pointerEvents === 'auto';
}(),
    _detectDirection = function _detectDirection(el, options) {
  var elCSS = css(el),
      elWidth = parseInt(elCSS.width) - parseInt(elCSS.paddingLeft) - parseInt(elCSS.paddingRight) - parseInt(elCSS.borderLeftWidth) - parseInt(elCSS.borderRightWidth),
      child1 = getChild(el, 0, options),
      child2 = getChild(el, 1, options),
      firstChildCSS = child1 && css(child1),
      secondChildCSS = child2 && css(child2),
      firstChildWidth = firstChildCSS && parseInt(firstChildCSS.marginLeft) + parseInt(firstChildCSS.marginRight) + getRect(child1).width,
      secondChildWidth = secondChildCSS && parseInt(secondChildCSS.marginLeft) + parseInt(secondChildCSS.marginRight) + getRect(child2).width;

  if (elCSS.display === 'flex') {
    return elCSS.flexDirection === 'column' || elCSS.flexDirection === 'column-reverse' ? 'vertical' : 'horizontal';
  }

  if (elCSS.display === 'grid') {
    return elCSS.gridTemplateColumns.split(' ').length <= 1 ? 'vertical' : 'horizontal';
  }

  if (child1 && firstChildCSS["float"] && firstChildCSS["float"] !== 'none') {
    var touchingSideChild2 = firstChildCSS["float"] === 'left' ? 'left' : 'right';
    return child2 && (secondChildCSS.clear === 'both' || secondChildCSS.clear === touchingSideChild2) ? 'vertical' : 'horizontal';
  }

  return child1 && (firstChildCSS.display === 'block' || firstChildCSS.display === 'flex' || firstChildCSS.display === 'table' || firstChildCSS.display === 'grid' || firstChildWidth >= elWidth && elCSS[CSSFloatProperty] === 'none' || child2 && elCSS[CSSFloatProperty] === 'none' && firstChildWidth + secondChildWidth > elWidth) ? 'vertical' : 'horizontal';
},
    _dragElInRowColumn = function _dragElInRowColumn(dragRect, targetRect, vertical) {
  var dragElS1Opp = vertical ? dragRect.left : dragRect.top,
      dragElS2Opp = vertical ? dragRect.right : dragRect.bottom,
      dragElOppLength = vertical ? dragRect.width : dragRect.height,
      targetS1Opp = vertical ? targetRect.left : targetRect.top,
      targetS2Opp = vertical ? targetRect.right : targetRect.bottom,
      targetOppLength = vertical ? targetRect.width : targetRect.height;
  return dragElS1Opp === targetS1Opp || dragElS2Opp === targetS2Opp || dragElS1Opp + dragElOppLength / 2 === targetS1Opp + targetOppLength / 2;
},

/**
 * Detects first nearest empty sortable to X and Y position using emptyInsertThreshold.
 * @param  {Number} x      X position
 * @param  {Number} y      Y position
 * @return {HTMLElement}   Element of the first found nearest Sortable
 */
_detectNearestEmptySortable = function _detectNearestEmptySortable(x, y) {
  var ret;
  sortables.some(function (sortable) {
    if (lastChild(sortable)) return;
    var rect = getRect(sortable),
        threshold = sortable[expando].options.emptyInsertThreshold,
        insideHorizontally = x >= rect.left - threshold && x <= rect.right + threshold,
        insideVertically = y >= rect.top - threshold && y <= rect.bottom + threshold;

    if (threshold && insideHorizontally && insideVertically) {
      return ret = sortable;
    }
  });
  return ret;
},
    _prepareGroup = function _prepareGroup(options) {
  function toFn(value, pull) {
    return function (to, from, dragEl, evt) {
      var sameGroup = to.options.group.name && from.options.group.name && to.options.group.name === from.options.group.name;

      if (value == null && (pull || sameGroup)) {
        // Default pull value
        // Default pull and put value if same group
        return true;
      } else if (value == null || value === false) {
        return false;
      } else if (pull && value === 'clone') {
        return value;
      } else if (typeof value === 'function') {
        return toFn(value(to, from, dragEl, evt), pull)(to, from, dragEl, evt);
      } else {
        var otherGroup = (pull ? to : from).options.group.name;
        return value === true || typeof value === 'string' && value === otherGroup || value.join && value.indexOf(otherGroup) > -1;
      }
    };
  }

  var group = {};
  var originalGroup = options.group;

  if (!originalGroup || _typeof(originalGroup) != 'object') {
    originalGroup = {
      name: originalGroup
    };
  }

  group.name = originalGroup.name;
  group.checkPull = toFn(originalGroup.pull, true);
  group.checkPut = toFn(originalGroup.put);
  group.revertClone = originalGroup.revertClone;
  options.group = group;
},
    _hideGhostForTarget = function _hideGhostForTarget() {
  if (!supportCssPointerEvents && ghostEl) {
    css(ghostEl, 'display', 'none');
  }
},
    _unhideGhostForTarget = function _unhideGhostForTarget() {
  if (!supportCssPointerEvents && ghostEl) {
    css(ghostEl, 'display', '');
  }
}; // #1184 fix - Prevent click event on fallback if dragged but item not changed position


if (documentExists) {
  document.addEventListener('click', function (evt) {
    if (ignoreNextClick) {
      evt.preventDefault();
      evt.stopPropagation && evt.stopPropagation();
      evt.stopImmediatePropagation && evt.stopImmediatePropagation();
      ignoreNextClick = false;
      return false;
    }
  }, true);
}

var nearestEmptyInsertDetectEvent = function nearestEmptyInsertDetectEvent(evt) {
  if (dragEl) {
    evt = evt.touches ? evt.touches[0] : evt;

    var nearest = _detectNearestEmptySortable(evt.clientX, evt.clientY);

    if (nearest) {
      // Create imitation event
      var event = {};

      for (var i in evt) {
        if (evt.hasOwnProperty(i)) {
          event[i] = evt[i];
        }
      }

      event.target = event.rootEl = nearest;
      event.preventDefault = void 0;
      event.stopPropagation = void 0;

      nearest[expando]._onDragOver(event);
    }
  }
};

var _checkOutsideTargetEl = function _checkOutsideTargetEl(evt) {
  if (dragEl) {
    dragEl.parentNode[expando]._isOutsideThisEl(evt.target);
  }
};
/**
 * @class  Sortable
 * @param  {HTMLElement}  el
 * @param  {Object}       [options]
 */


function Sortable(el, options) {
  if (!(el && el.nodeType && el.nodeType === 1)) {
    throw "Sortable: `el` must be an HTMLElement, not ".concat({}.toString.call(el));
  }

  this.el = el; // root element

  this.options = options = _extends({}, options); // Export instance

  el[expando] = this;
  var defaults = {
    group: null,
    sort: true,
    disabled: false,
    store: null,
    handle: null,
    draggable: /^[uo]l$/i.test(el.nodeName) ? '>li' : '>*',
    swapThreshold: 1,
    // percentage; 0 <= x <= 1
    invertSwap: false,
    // invert always
    invertedSwapThreshold: null,
    // will be set to same as swapThreshold if default
    removeCloneOnHide: true,
    direction: function direction() {
      return _detectDirection(el, this.options);
    },
    ghostClass: 'sortable-ghost',
    chosenClass: 'sortable-chosen',
    dragClass: 'sortable-drag',
    ignore: 'a, img',
    filter: null,
    preventOnFilter: true,
    animation: 0,
    easing: null,
    setData: function setData(dataTransfer, dragEl) {
      dataTransfer.setData('Text', dragEl.textContent);
    },
    dropBubble: false,
    dragoverBubble: false,
    dataIdAttr: 'data-id',
    delay: 0,
    delayOnTouchOnly: false,
    touchStartThreshold: (Number.parseInt ? Number : window).parseInt(window.devicePixelRatio, 10) || 1,
    forceFallback: false,
    fallbackClass: 'sortable-fallback',
    fallbackOnBody: false,
    fallbackTolerance: 0,
    fallbackOffset: {
      x: 0,
      y: 0
    },
    supportPointer: Sortable.supportPointer !== false && 'PointerEvent' in window,
    emptyInsertThreshold: 5
  };
  PluginManager.initializePlugins(this, el, defaults); // Set default options

  for (var name in defaults) {
    !(name in options) && (options[name] = defaults[name]);
  }

  _prepareGroup(options); // Bind all private methods


  for (var fn in this) {
    if (fn.charAt(0) === '_' && typeof this[fn] === 'function') {
      this[fn] = this[fn].bind(this);
    }
  } // Setup drag mode


  this.nativeDraggable = options.forceFallback ? false : supportDraggable;

  if (this.nativeDraggable) {
    // Touch start threshold cannot be greater than the native dragstart threshold
    this.options.touchStartThreshold = 1;
  } // Bind events


  if (options.supportPointer) {
    on(el, 'pointerdown', this._onTapStart);
  } else {
    on(el, 'mousedown', this._onTapStart);
    on(el, 'touchstart', this._onTapStart);
  }

  if (this.nativeDraggable) {
    on(el, 'dragover', this);
    on(el, 'dragenter', this);
  }

  sortables.push(this.el); // Restore sorting

  options.store && options.store.get && this.sort(options.store.get(this) || []); // Add animation state manager

  _extends(this, AnimationStateManager());
}

Sortable.prototype =
/** @lends Sortable.prototype */
{
  constructor: Sortable,
  _isOutsideThisEl: function _isOutsideThisEl(target) {
    if (!this.el.contains(target) && target !== this.el) {
      lastTarget = null;
    }
  },
  _getDirection: function _getDirection(evt, target) {
    return typeof this.options.direction === 'function' ? this.options.direction.call(this, evt, target, dragEl) : this.options.direction;
  },
  _onTapStart: function _onTapStart(
  /** Event|TouchEvent */
  evt) {
    if (!evt.cancelable) return;

    var _this = this,
        el = this.el,
        options = this.options,
        preventOnFilter = options.preventOnFilter,
        type = evt.type,
        touch = evt.touches && evt.touches[0] || evt.pointerType && evt.pointerType === 'touch' && evt,
        target = (touch || evt).target,
        originalTarget = evt.target.shadowRoot && (evt.path && evt.path[0] || evt.composedPath && evt.composedPath()[0]) || target,
        filter = options.filter;

    _saveInputCheckedState(el); // Don't trigger start event when an element is been dragged, otherwise the evt.oldindex always wrong when set option.group.


    if (dragEl) {
      return;
    }

    if (/mousedown|pointerdown/.test(type) && evt.button !== 0 || options.disabled) {
      return; // only left button and enabled
    } // cancel dnd if original target is content editable


    if (originalTarget.isContentEditable) {
      return;
    }

    target = closest(target, options.draggable, el, false);

    if (target && target.animated) {
      return;
    }

    if (lastDownEl === target) {
      // Ignoring duplicate `down`
      return;
    } // Get the index of the dragged element within its parent


    oldIndex = index(target);
    oldDraggableIndex = index(target, options.draggable); // Check filter

    if (typeof filter === 'function') {
      if (filter.call(this, evt, target, this)) {
        _dispatchEvent({
          sortable: _this,
          rootEl: originalTarget,
          name: 'filter',
          targetEl: target,
          toEl: el,
          fromEl: el
        });

        pluginEvent('filter', _this, {
          evt: evt
        });
        preventOnFilter && evt.cancelable && evt.preventDefault();
        return; // cancel dnd
      }
    } else if (filter) {
      filter = filter.split(',').some(function (criteria) {
        criteria = closest(originalTarget, criteria.trim(), el, false);

        if (criteria) {
          _dispatchEvent({
            sortable: _this,
            rootEl: criteria,
            name: 'filter',
            targetEl: target,
            fromEl: el,
            toEl: el
          });

          pluginEvent('filter', _this, {
            evt: evt
          });
          return true;
        }
      });

      if (filter) {
        preventOnFilter && evt.cancelable && evt.preventDefault();
        return; // cancel dnd
      }
    }

    if (options.handle && !closest(originalTarget, options.handle, el, false)) {
      return;
    } // Prepare `dragstart`


    this._prepareDragStart(evt, touch, target);
  },
  _prepareDragStart: function _prepareDragStart(
  /** Event */
  evt,
  /** Touch */
  touch,
  /** HTMLElement */
  target) {
    var _this = this,
        el = _this.el,
        options = _this.options,
        ownerDocument = el.ownerDocument,
        dragStartFn;

    if (target && !dragEl && target.parentNode === el) {
      var dragRect = getRect(target);
      rootEl = el;
      dragEl = target;
      parentEl = dragEl.parentNode;
      nextEl = dragEl.nextSibling;
      lastDownEl = target;
      activeGroup = options.group;
      Sortable.dragged = dragEl;
      tapEvt = {
        target: dragEl,
        clientX: (touch || evt).clientX,
        clientY: (touch || evt).clientY
      };
      tapDistanceLeft = tapEvt.clientX - dragRect.left;
      tapDistanceTop = tapEvt.clientY - dragRect.top;
      this._lastX = (touch || evt).clientX;
      this._lastY = (touch || evt).clientY;
      dragEl.style['will-change'] = 'all';

      dragStartFn = function dragStartFn() {
        pluginEvent('delayEnded', _this, {
          evt: evt
        });

        if (Sortable.eventCanceled) {
          _this._onDrop();

          return;
        } // Delayed drag has been triggered
        // we can re-enable the events: touchmove/mousemove


        _this._disableDelayedDragEvents();

        if (!FireFox && _this.nativeDraggable) {
          dragEl.draggable = true;
        } // Bind the events: dragstart/dragend


        _this._triggerDragStart(evt, touch); // Drag start event


        _dispatchEvent({
          sortable: _this,
          name: 'choose',
          originalEvent: evt
        }); // Chosen item


        toggleClass(dragEl, options.chosenClass, true);
      }; // Disable "draggable"


      options.ignore.split(',').forEach(function (criteria) {
        find(dragEl, criteria.trim(), _disableDraggable);
      });
      on(ownerDocument, 'dragover', nearestEmptyInsertDetectEvent);
      on(ownerDocument, 'mousemove', nearestEmptyInsertDetectEvent);
      on(ownerDocument, 'touchmove', nearestEmptyInsertDetectEvent);
      on(ownerDocument, 'mouseup', _this._onDrop);
      on(ownerDocument, 'touchend', _this._onDrop);
      on(ownerDocument, 'touchcancel', _this._onDrop); // Make dragEl draggable (must be before delay for FireFox)

      if (FireFox && this.nativeDraggable) {
        this.options.touchStartThreshold = 4;
        dragEl.draggable = true;
      }

      pluginEvent('delayStart', this, {
        evt: evt
      }); // Delay is impossible for native DnD in Edge or IE

      if (options.delay && (!options.delayOnTouchOnly || touch) && (!this.nativeDraggable || !(Edge || IE11OrLess))) {
        if (Sortable.eventCanceled) {
          this._onDrop();

          return;
        } // If the user moves the pointer or let go the click or touch
        // before the delay has been reached:
        // disable the delayed drag


        on(ownerDocument, 'mouseup', _this._disableDelayedDrag);
        on(ownerDocument, 'touchend', _this._disableDelayedDrag);
        on(ownerDocument, 'touchcancel', _this._disableDelayedDrag);
        on(ownerDocument, 'mousemove', _this._delayedDragTouchMoveHandler);
        on(ownerDocument, 'touchmove', _this._delayedDragTouchMoveHandler);
        options.supportPointer && on(ownerDocument, 'pointermove', _this._delayedDragTouchMoveHandler);
        _this._dragStartTimer = setTimeout(dragStartFn, options.delay);
      } else {
        dragStartFn();
      }
    }
  },
  _delayedDragTouchMoveHandler: function _delayedDragTouchMoveHandler(
  /** TouchEvent|PointerEvent **/
  e) {
    var touch = e.touches ? e.touches[0] : e;

    if (Math.max(Math.abs(touch.clientX - this._lastX), Math.abs(touch.clientY - this._lastY)) >= Math.floor(this.options.touchStartThreshold / (this.nativeDraggable && window.devicePixelRatio || 1))) {
      this._disableDelayedDrag();
    }
  },
  _disableDelayedDrag: function _disableDelayedDrag() {
    dragEl && _disableDraggable(dragEl);
    clearTimeout(this._dragStartTimer);

    this._disableDelayedDragEvents();
  },
  _disableDelayedDragEvents: function _disableDelayedDragEvents() {
    var ownerDocument = this.el.ownerDocument;
    off(ownerDocument, 'mouseup', this._disableDelayedDrag);
    off(ownerDocument, 'touchend', this._disableDelayedDrag);
    off(ownerDocument, 'touchcancel', this._disableDelayedDrag);
    off(ownerDocument, 'mousemove', this._delayedDragTouchMoveHandler);
    off(ownerDocument, 'touchmove', this._delayedDragTouchMoveHandler);
    off(ownerDocument, 'pointermove', this._delayedDragTouchMoveHandler);
  },
  _triggerDragStart: function _triggerDragStart(
  /** Event */
  evt,
  /** Touch */
  touch) {
    touch = touch || evt.pointerType == 'touch' && evt;

    if (!this.nativeDraggable || touch) {
      if (this.options.supportPointer) {
        on(document, 'pointermove', this._onTouchMove);
      } else if (touch) {
        on(document, 'touchmove', this._onTouchMove);
      } else {
        on(document, 'mousemove', this._onTouchMove);
      }
    } else {
      on(dragEl, 'dragend', this);
      on(rootEl, 'dragstart', this._onDragStart);
    }

    try {
      if (document.selection) {
        // Timeout neccessary for IE9
        _nextTick(function () {
          document.selection.empty();
        });
      } else {
        window.getSelection().removeAllRanges();
      }
    } catch (err) {}
  },
  _dragStarted: function _dragStarted(fallback, evt) {
    awaitingDragStarted = false;

    if (rootEl && dragEl) {
      pluginEvent('dragStarted', this, {
        evt: evt
      });

      if (this.nativeDraggable) {
        on(document, 'dragover', _checkOutsideTargetEl);
      }

      var options = this.options; // Apply effect

      !fallback && toggleClass(dragEl, options.dragClass, false);
      toggleClass(dragEl, options.ghostClass, true);
      Sortable.active = this;
      fallback && this._appendGhost(); // Drag start event

      _dispatchEvent({
        sortable: this,
        name: 'start',
        originalEvent: evt
      });
    } else {
      this._nulling();
    }
  },
  _emulateDragOver: function _emulateDragOver() {
    if (touchEvt) {
      this._lastX = touchEvt.clientX;
      this._lastY = touchEvt.clientY;

      _hideGhostForTarget();

      var target = document.elementFromPoint(touchEvt.clientX, touchEvt.clientY);
      var parent = target;

      while (target && target.shadowRoot) {
        target = target.shadowRoot.elementFromPoint(touchEvt.clientX, touchEvt.clientY);
        if (target === parent) break;
        parent = target;
      }

      dragEl.parentNode[expando]._isOutsideThisEl(target);

      if (parent) {
        do {
          if (parent[expando]) {
            var inserted = void 0;
            inserted = parent[expando]._onDragOver({
              clientX: touchEvt.clientX,
              clientY: touchEvt.clientY,
              target: target,
              rootEl: parent
            });

            if (inserted && !this.options.dragoverBubble) {
              break;
            }
          }

          target = parent; // store last element
        }
        /* jshint boss:true */
        while (parent = parent.parentNode);
      }

      _unhideGhostForTarget();
    }
  },
  _onTouchMove: function _onTouchMove(
  /**TouchEvent*/
  evt) {
    if (tapEvt) {
      var options = this.options,
          fallbackTolerance = options.fallbackTolerance,
          fallbackOffset = options.fallbackOffset,
          touch = evt.touches ? evt.touches[0] : evt,
          ghostMatrix = ghostEl && matrix(ghostEl, true),
          scaleX = ghostEl && ghostMatrix && ghostMatrix.a,
          scaleY = ghostEl && ghostMatrix && ghostMatrix.d,
          relativeScrollOffset = PositionGhostAbsolutely && ghostRelativeParent && getRelativeScrollOffset(ghostRelativeParent),
          dx = (touch.clientX - tapEvt.clientX + fallbackOffset.x) / (scaleX || 1) + (relativeScrollOffset ? relativeScrollOffset[0] - ghostRelativeParentInitialScroll[0] : 0) / (scaleX || 1),
          dy = (touch.clientY - tapEvt.clientY + fallbackOffset.y) / (scaleY || 1) + (relativeScrollOffset ? relativeScrollOffset[1] - ghostRelativeParentInitialScroll[1] : 0) / (scaleY || 1); // only set the status to dragging, when we are actually dragging

      if (!Sortable.active && !awaitingDragStarted) {
        if (fallbackTolerance && Math.max(Math.abs(touch.clientX - this._lastX), Math.abs(touch.clientY - this._lastY)) < fallbackTolerance) {
          return;
        }

        this._onDragStart(evt, true);
      }

      if (ghostEl) {
        if (ghostMatrix) {
          ghostMatrix.e += dx - (lastDx || 0);
          ghostMatrix.f += dy - (lastDy || 0);
        } else {
          ghostMatrix = {
            a: 1,
            b: 0,
            c: 0,
            d: 1,
            e: dx,
            f: dy
          };
        }

        var cssMatrix = "matrix(".concat(ghostMatrix.a, ",").concat(ghostMatrix.b, ",").concat(ghostMatrix.c, ",").concat(ghostMatrix.d, ",").concat(ghostMatrix.e, ",").concat(ghostMatrix.f, ")");
        css(ghostEl, 'webkitTransform', cssMatrix);
        css(ghostEl, 'mozTransform', cssMatrix);
        css(ghostEl, 'msTransform', cssMatrix);
        css(ghostEl, 'transform', cssMatrix);
        lastDx = dx;
        lastDy = dy;
        touchEvt = touch;
      }

      evt.cancelable && evt.preventDefault();
    }
  },
  _appendGhost: function _appendGhost() {
    // Bug if using scale(): https://stackoverflow.com/questions/2637058
    // Not being adjusted for
    if (!ghostEl) {
      var container = this.options.fallbackOnBody ? document.body : rootEl,
          rect = getRect(dragEl, true, PositionGhostAbsolutely, true, container),
          options = this.options; // Position absolutely

      if (PositionGhostAbsolutely) {
        // Get relatively positioned parent
        ghostRelativeParent = container;

        while (css(ghostRelativeParent, 'position') === 'static' && css(ghostRelativeParent, 'transform') === 'none' && ghostRelativeParent !== document) {
          ghostRelativeParent = ghostRelativeParent.parentNode;
        }

        if (ghostRelativeParent !== document.body && ghostRelativeParent !== document.documentElement) {
          if (ghostRelativeParent === document) ghostRelativeParent = getWindowScrollingElement();
          rect.top += ghostRelativeParent.scrollTop;
          rect.left += ghostRelativeParent.scrollLeft;
        } else {
          ghostRelativeParent = getWindowScrollingElement();
        }

        ghostRelativeParentInitialScroll = getRelativeScrollOffset(ghostRelativeParent);
      }

      ghostEl = dragEl.cloneNode(true);
      toggleClass(ghostEl, options.ghostClass, false);
      toggleClass(ghostEl, options.fallbackClass, true);
      toggleClass(ghostEl, options.dragClass, true);
      css(ghostEl, 'transition', '');
      css(ghostEl, 'transform', '');
      css(ghostEl, 'box-sizing', 'border-box');
      css(ghostEl, 'margin', 0);
      css(ghostEl, 'top', rect.top);
      css(ghostEl, 'left', rect.left);
      css(ghostEl, 'width', rect.width);
      css(ghostEl, 'height', rect.height);
      css(ghostEl, 'opacity', '0.8');
      css(ghostEl, 'position', PositionGhostAbsolutely ? 'absolute' : 'fixed');
      css(ghostEl, 'zIndex', '100000');
      css(ghostEl, 'pointerEvents', 'none');
      Sortable.ghost = ghostEl;
      container.appendChild(ghostEl); // Set transform-origin

      css(ghostEl, 'transform-origin', tapDistanceLeft / parseInt(ghostEl.style.width) * 100 + '% ' + tapDistanceTop / parseInt(ghostEl.style.height) * 100 + '%');
    }
  },
  _onDragStart: function _onDragStart(
  /**Event*/
  evt,
  /**boolean*/
  fallback) {
    var _this = this;

    var dataTransfer = evt.dataTransfer;
    var options = _this.options;
    pluginEvent('dragStart', this, {
      evt: evt
    });

    if (Sortable.eventCanceled) {
      this._onDrop();

      return;
    }

    pluginEvent('setupClone', this);

    if (!Sortable.eventCanceled) {
      cloneEl = clone(dragEl);
      cloneEl.draggable = false;
      cloneEl.style['will-change'] = '';

      this._hideClone();

      toggleClass(cloneEl, this.options.chosenClass, false);
      Sortable.clone = cloneEl;
    } // #1143: IFrame support workaround


    _this.cloneId = _nextTick(function () {
      pluginEvent('clone', _this);
      if (Sortable.eventCanceled) return;

      if (!_this.options.removeCloneOnHide) {
        rootEl.insertBefore(cloneEl, dragEl);
      }

      _this._hideClone();

      _dispatchEvent({
        sortable: _this,
        name: 'clone'
      });
    });
    !fallback && toggleClass(dragEl, options.dragClass, true); // Set proper drop events

    if (fallback) {
      ignoreNextClick = true;
      _this._loopId = setInterval(_this._emulateDragOver, 50);
    } else {
      // Undo what was set in _prepareDragStart before drag started
      off(document, 'mouseup', _this._onDrop);
      off(document, 'touchend', _this._onDrop);
      off(document, 'touchcancel', _this._onDrop);

      if (dataTransfer) {
        dataTransfer.effectAllowed = 'move';
        options.setData && options.setData.call(_this, dataTransfer, dragEl);
      }

      on(document, 'drop', _this); // #1276 fix:

      css(dragEl, 'transform', 'translateZ(0)');
    }

    awaitingDragStarted = true;
    _this._dragStartId = _nextTick(_this._dragStarted.bind(_this, fallback, evt));
    on(document, 'selectstart', _this);
    moved = true;

    if (Safari) {
      css(document.body, 'user-select', 'none');
    }
  },
  // Returns true - if no further action is needed (either inserted or another condition)
  _onDragOver: function _onDragOver(
  /**Event*/
  evt) {
    var el = this.el,
        target = evt.target,
        dragRect,
        targetRect,
        revert,
        options = this.options,
        group = options.group,
        activeSortable = Sortable.active,
        isOwner = activeGroup === group,
        canSort = options.sort,
        fromSortable = putSortable || activeSortable,
        vertical,
        _this = this,
        completedFired = false;

    if (_silent) return;

    function dragOverEvent(name, extra) {
      pluginEvent(name, _this, _objectSpread({
        evt: evt,
        isOwner: isOwner,
        axis: vertical ? 'vertical' : 'horizontal',
        revert: revert,
        dragRect: dragRect,
        targetRect: targetRect,
        canSort: canSort,
        fromSortable: fromSortable,
        target: target,
        completed: completed,
        onMove: function onMove(target, after) {
          return _onMove(rootEl, el, dragEl, dragRect, target, getRect(target), evt, after);
        },
        changed: changed
      }, extra));
    } // Capture animation state


    function capture() {
      dragOverEvent('dragOverAnimationCapture');

      _this.captureAnimationState();

      if (_this !== fromSortable) {
        fromSortable.captureAnimationState();
      }
    } // Return invocation when dragEl is inserted (or completed)


    function completed(insertion) {
      dragOverEvent('dragOverCompleted', {
        insertion: insertion
      });

      if (insertion) {
        // Clones must be hidden before folding animation to capture dragRectAbsolute properly
        if (isOwner) {
          activeSortable._hideClone();
        } else {
          activeSortable._showClone(_this);
        }

        if (_this !== fromSortable) {
          // Set ghost class to new sortable's ghost class
          toggleClass(dragEl, putSortable ? putSortable.options.ghostClass : activeSortable.options.ghostClass, false);
          toggleClass(dragEl, options.ghostClass, true);
        }

        if (putSortable !== _this && _this !== Sortable.active) {
          putSortable = _this;
        } else if (_this === Sortable.active && putSortable) {
          putSortable = null;
        } // Animation


        if (fromSortable === _this) {
          _this._ignoreWhileAnimating = target;
        }

        _this.animateAll(function () {
          dragOverEvent('dragOverAnimationComplete');
          _this._ignoreWhileAnimating = null;
        });

        if (_this !== fromSortable) {
          fromSortable.animateAll();
          fromSortable._ignoreWhileAnimating = null;
        }
      } // Null lastTarget if it is not inside a previously swapped element


      if (target === dragEl && !dragEl.animated || target === el && !target.animated) {
        lastTarget = null;
      } // no bubbling and not fallback


      if (!options.dragoverBubble && !evt.rootEl && target !== document) {
        dragEl.parentNode[expando]._isOutsideThisEl(evt.target); // Do not detect for empty insert if already inserted


        !insertion && nearestEmptyInsertDetectEvent(evt);
      }

      !options.dragoverBubble && evt.stopPropagation && evt.stopPropagation();
      return completedFired = true;
    } // Call when dragEl has been inserted


    function changed() {
      newIndex = index(dragEl);
      newDraggableIndex = index(dragEl, options.draggable);

      _dispatchEvent({
        sortable: _this,
        name: 'change',
        toEl: el,
        newIndex: newIndex,
        newDraggableIndex: newDraggableIndex,
        originalEvent: evt
      });
    }

    if (evt.preventDefault !== void 0) {
      evt.cancelable && evt.preventDefault();
    }

    target = closest(target, options.draggable, el, true);
    dragOverEvent('dragOver');
    if (Sortable.eventCanceled) return completedFired;

    if (dragEl.contains(evt.target) || target.animated && target.animatingX && target.animatingY || _this._ignoreWhileAnimating === target) {
      return completed(false);
    }

    ignoreNextClick = false;

    if (activeSortable && !options.disabled && (isOwner ? canSort || (revert = !rootEl.contains(dragEl)) // Reverting item into the original list
    : putSortable === this || (this.lastPutMode = activeGroup.checkPull(this, activeSortable, dragEl, evt)) && group.checkPut(this, activeSortable, dragEl, evt))) {
      vertical = this._getDirection(evt, target) === 'vertical';
      dragRect = getRect(dragEl);
      dragOverEvent('dragOverValid');
      if (Sortable.eventCanceled) return completedFired;

      if (revert) {
        parentEl = rootEl; // actualization

        capture();

        this._hideClone();

        dragOverEvent('revert');

        if (!Sortable.eventCanceled) {
          if (nextEl) {
            rootEl.insertBefore(dragEl, nextEl);
          } else {
            rootEl.appendChild(dragEl);
          }
        }

        return completed(true);
      }

      var elLastChild = lastChild(el, options.draggable);

      if (!elLastChild || _ghostIsLast(evt, vertical, this) && !elLastChild.animated) {
        // If already at end of list: Do not insert
        if (elLastChild === dragEl) {
          return completed(false);
        } // assign target only if condition is true


        if (elLastChild && el === evt.target) {
          target = elLastChild;
        }

        if (target) {
          targetRect = getRect(target);
        }

        if (_onMove(rootEl, el, dragEl, dragRect, target, targetRect, evt, !!target) !== false) {
          capture();
          el.appendChild(dragEl);
          parentEl = el; // actualization

          changed();
          return completed(true);
        }
      } else if (target.parentNode === el) {
        targetRect = getRect(target);
        var direction = 0,
            targetBeforeFirstSwap,
            differentLevel = dragEl.parentNode !== el,
            differentRowCol = !_dragElInRowColumn(dragEl.animated && dragEl.toRect || dragRect, target.animated && target.toRect || targetRect, vertical),
            side1 = vertical ? 'top' : 'left',
            scrolledPastTop = isScrolledPast(target, 'top', 'top') || isScrolledPast(dragEl, 'top', 'top'),
            scrollBefore = scrolledPastTop ? scrolledPastTop.scrollTop : void 0;

        if (lastTarget !== target) {
          targetBeforeFirstSwap = targetRect[side1];
          pastFirstInvertThresh = false;
          isCircumstantialInvert = !differentRowCol && options.invertSwap || differentLevel;
        }

        direction = _getSwapDirection(evt, target, targetRect, vertical, differentRowCol ? 1 : options.swapThreshold, options.invertedSwapThreshold == null ? options.swapThreshold : options.invertedSwapThreshold, isCircumstantialInvert, lastTarget === target);
        var sibling;

        if (direction !== 0) {
          // Check if target is beside dragEl in respective direction (ignoring hidden elements)
          var dragIndex = index(dragEl);

          do {
            dragIndex -= direction;
            sibling = parentEl.children[dragIndex];
          } while (sibling && (css(sibling, 'display') === 'none' || sibling === ghostEl));
        } // If dragEl is already beside target: Do not insert


        if (direction === 0 || sibling === target) {
          return completed(false);
        }

        lastTarget = target;
        lastDirection = direction;
        var nextSibling = target.nextElementSibling,
            after = false;
        after = direction === 1;

        var moveVector = _onMove(rootEl, el, dragEl, dragRect, target, targetRect, evt, after);

        if (moveVector !== false) {
          if (moveVector === 1 || moveVector === -1) {
            after = moveVector === 1;
          }

          _silent = true;
          setTimeout(_unsilent, 30);
          capture();

          if (after && !nextSibling) {
            el.appendChild(dragEl);
          } else {
            target.parentNode.insertBefore(dragEl, after ? nextSibling : target);
          } // Undo chrome's scroll adjustment (has no effect on other browsers)


          if (scrolledPastTop) {
            scrollBy(scrolledPastTop, 0, scrollBefore - scrolledPastTop.scrollTop);
          }

          parentEl = dragEl.parentNode; // actualization
          // must be done before animation

          if (targetBeforeFirstSwap !== undefined && !isCircumstantialInvert) {
            targetMoveDistance = Math.abs(targetBeforeFirstSwap - getRect(target)[side1]);
          }

          changed();
          return completed(true);
        }
      }

      if (el.contains(dragEl)) {
        return completed(false);
      }
    }

    return false;
  },
  _ignoreWhileAnimating: null,
  _offMoveEvents: function _offMoveEvents() {
    off(document, 'mousemove', this._onTouchMove);
    off(document, 'touchmove', this._onTouchMove);
    off(document, 'pointermove', this._onTouchMove);
    off(document, 'dragover', nearestEmptyInsertDetectEvent);
    off(document, 'mousemove', nearestEmptyInsertDetectEvent);
    off(document, 'touchmove', nearestEmptyInsertDetectEvent);
  },
  _offUpEvents: function _offUpEvents() {
    var ownerDocument = this.el.ownerDocument;
    off(ownerDocument, 'mouseup', this._onDrop);
    off(ownerDocument, 'touchend', this._onDrop);
    off(ownerDocument, 'pointerup', this._onDrop);
    off(ownerDocument, 'touchcancel', this._onDrop);
    off(document, 'selectstart', this);
  },
  _onDrop: function _onDrop(
  /**Event*/
  evt) {
    var el = this.el,
        options = this.options; // Get the index of the dragged element within its parent

    newIndex = index(dragEl);
    newDraggableIndex = index(dragEl, options.draggable);
    pluginEvent('drop', this, {
      evt: evt
    });
    parentEl = dragEl && dragEl.parentNode; // Get again after plugin event

    newIndex = index(dragEl);
    newDraggableIndex = index(dragEl, options.draggable);

    if (Sortable.eventCanceled) {
      this._nulling();

      return;
    }

    awaitingDragStarted = false;
    isCircumstantialInvert = false;
    pastFirstInvertThresh = false;
    clearInterval(this._loopId);
    clearTimeout(this._dragStartTimer);

    _cancelNextTick(this.cloneId);

    _cancelNextTick(this._dragStartId); // Unbind events


    if (this.nativeDraggable) {
      off(document, 'drop', this);
      off(el, 'dragstart', this._onDragStart);
    }

    this._offMoveEvents();

    this._offUpEvents();

    if (Safari) {
      css(document.body, 'user-select', '');
    }

    css(dragEl, 'transform', '');

    if (evt) {
      if (moved) {
        evt.cancelable && evt.preventDefault();
        !options.dropBubble && evt.stopPropagation();
      }

      ghostEl && ghostEl.parentNode && ghostEl.parentNode.removeChild(ghostEl);

      if (rootEl === parentEl || putSortable && putSortable.lastPutMode !== 'clone') {
        // Remove clone(s)
        cloneEl && cloneEl.parentNode && cloneEl.parentNode.removeChild(cloneEl);
      }

      if (dragEl) {
        if (this.nativeDraggable) {
          off(dragEl, 'dragend', this);
        }

        _disableDraggable(dragEl);

        dragEl.style['will-change'] = ''; // Remove classes
        // ghostClass is added in dragStarted

        if (moved && !awaitingDragStarted) {
          toggleClass(dragEl, putSortable ? putSortable.options.ghostClass : this.options.ghostClass, false);
        }

        toggleClass(dragEl, this.options.chosenClass, false); // Drag stop event

        _dispatchEvent({
          sortable: this,
          name: 'unchoose',
          toEl: parentEl,
          newIndex: null,
          newDraggableIndex: null,
          originalEvent: evt
        });

        if (rootEl !== parentEl) {
          if (newIndex >= 0) {
            // Add event
            _dispatchEvent({
              rootEl: parentEl,
              name: 'add',
              toEl: parentEl,
              fromEl: rootEl,
              originalEvent: evt
            }); // Remove event


            _dispatchEvent({
              sortable: this,
              name: 'remove',
              toEl: parentEl,
              originalEvent: evt
            }); // drag from one list and drop into another


            _dispatchEvent({
              rootEl: parentEl,
              name: 'sort',
              toEl: parentEl,
              fromEl: rootEl,
              originalEvent: evt
            });

            _dispatchEvent({
              sortable: this,
              name: 'sort',
              toEl: parentEl,
              originalEvent: evt
            });
          }

          putSortable && putSortable.save();
        } else {
          if (newIndex !== oldIndex) {
            if (newIndex >= 0) {
              // drag & drop within the same list
              _dispatchEvent({
                sortable: this,
                name: 'update',
                toEl: parentEl,
                originalEvent: evt
              });

              _dispatchEvent({
                sortable: this,
                name: 'sort',
                toEl: parentEl,
                originalEvent: evt
              });
            }
          }
        }

        if (Sortable.active) {
          /* jshint eqnull:true */
          if (newIndex == null || newIndex === -1) {
            newIndex = oldIndex;
            newDraggableIndex = oldDraggableIndex;
          }

          _dispatchEvent({
            sortable: this,
            name: 'end',
            toEl: parentEl,
            originalEvent: evt
          }); // Save sorting


          this.save();
        }
      }
    }

    this._nulling();
  },
  _nulling: function _nulling() {
    pluginEvent('nulling', this);
    rootEl = dragEl = parentEl = ghostEl = nextEl = cloneEl = lastDownEl = cloneHidden = tapEvt = touchEvt = moved = newIndex = newDraggableIndex = oldIndex = oldDraggableIndex = lastTarget = lastDirection = putSortable = activeGroup = Sortable.dragged = Sortable.ghost = Sortable.clone = Sortable.active = null;
    savedInputChecked.forEach(function (el) {
      el.checked = true;
    });
    savedInputChecked.length = lastDx = lastDy = 0;
  },
  handleEvent: function handleEvent(
  /**Event*/
  evt) {
    switch (evt.type) {
      case 'drop':
      case 'dragend':
        this._onDrop(evt);

        break;

      case 'dragenter':
      case 'dragover':
        if (dragEl) {
          this._onDragOver(evt);

          _globalDragOver(evt);
        }

        break;

      case 'selectstart':
        evt.preventDefault();
        break;
    }
  },

  /**
   * Serializes the item into an array of string.
   * @returns {String[]}
   */
  toArray: function toArray() {
    var order = [],
        el,
        children = this.el.children,
        i = 0,
        n = children.length,
        options = this.options;

    for (; i < n; i++) {
      el = children[i];

      if (closest(el, options.draggable, this.el, false)) {
        order.push(el.getAttribute(options.dataIdAttr) || _generateId(el));
      }
    }

    return order;
  },

  /**
   * Sorts the elements according to the array.
   * @param  {String[]}  order  order of the items
   */
  sort: function sort(order) {
    var items = {},
        rootEl = this.el;
    this.toArray().forEach(function (id, i) {
      var el = rootEl.children[i];

      if (closest(el, this.options.draggable, rootEl, false)) {
        items[id] = el;
      }
    }, this);
    order.forEach(function (id) {
      if (items[id]) {
        rootEl.removeChild(items[id]);
        rootEl.appendChild(items[id]);
      }
    });
  },

  /**
   * Save the current sorting
   */
  save: function save() {
    var store = this.options.store;
    store && store.set && store.set(this);
  },

  /**
   * For each element in the set, get the first element that matches the selector by testing the element itself and traversing up through its ancestors in the DOM tree.
   * @param   {HTMLElement}  el
   * @param   {String}       [selector]  default: `options.draggable`
   * @returns {HTMLElement|null}
   */
  closest: function closest$1(el, selector) {
    return closest(el, selector || this.options.draggable, this.el, false);
  },

  /**
   * Set/get option
   * @param   {string} name
   * @param   {*}      [value]
   * @returns {*}
   */
  option: function option(name, value) {
    var options = this.options;

    if (value === void 0) {
      return options[name];
    } else {
      var modifiedValue = PluginManager.modifyOption(this, name, value);

      if (typeof modifiedValue !== 'undefined') {
        options[name] = modifiedValue;
      } else {
        options[name] = value;
      }

      if (name === 'group') {
        _prepareGroup(options);
      }
    }
  },

  /**
   * Destroy
   */
  destroy: function destroy() {
    pluginEvent('destroy', this);
    var el = this.el;
    el[expando] = null;
    off(el, 'mousedown', this._onTapStart);
    off(el, 'touchstart', this._onTapStart);
    off(el, 'pointerdown', this._onTapStart);

    if (this.nativeDraggable) {
      off(el, 'dragover', this);
      off(el, 'dragenter', this);
    } // Remove draggable attributes


    Array.prototype.forEach.call(el.querySelectorAll('[draggable]'), function (el) {
      el.removeAttribute('draggable');
    });

    this._onDrop();

    this._disableDelayedDragEvents();

    sortables.splice(sortables.indexOf(this.el), 1);
    this.el = el = null;
  },
  _hideClone: function _hideClone() {
    if (!cloneHidden) {
      pluginEvent('hideClone', this);
      if (Sortable.eventCanceled) return;
      css(cloneEl, 'display', 'none');

      if (this.options.removeCloneOnHide && cloneEl.parentNode) {
        cloneEl.parentNode.removeChild(cloneEl);
      }

      cloneHidden = true;
    }
  },
  _showClone: function _showClone(putSortable) {
    if (putSortable.lastPutMode !== 'clone') {
      this._hideClone();

      return;
    }

    if (cloneHidden) {
      pluginEvent('showClone', this);
      if (Sortable.eventCanceled) return; // show clone at dragEl or original position

      if (rootEl.contains(dragEl) && !this.options.group.revertClone) {
        rootEl.insertBefore(cloneEl, dragEl);
      } else if (nextEl) {
        rootEl.insertBefore(cloneEl, nextEl);
      } else {
        rootEl.appendChild(cloneEl);
      }

      if (this.options.group.revertClone) {
        this.animate(dragEl, cloneEl);
      }

      css(cloneEl, 'display', '');
      cloneHidden = false;
    }
  }
};

function _globalDragOver(
/**Event*/
evt) {
  if (evt.dataTransfer) {
    evt.dataTransfer.dropEffect = 'move';
  }

  evt.cancelable && evt.preventDefault();
}

function _onMove(fromEl, toEl, dragEl, dragRect, targetEl, targetRect, originalEvent, willInsertAfter) {
  var evt,
      sortable = fromEl[expando],
      onMoveFn = sortable.options.onMove,
      retVal; // Support for new CustomEvent feature

  if (window.CustomEvent && !IE11OrLess && !Edge) {
    evt = new CustomEvent('move', {
      bubbles: true,
      cancelable: true
    });
  } else {
    evt = document.createEvent('Event');
    evt.initEvent('move', true, true);
  }

  evt.to = toEl;
  evt.from = fromEl;
  evt.dragged = dragEl;
  evt.draggedRect = dragRect;
  evt.related = targetEl || toEl;
  evt.relatedRect = targetRect || getRect(toEl);
  evt.willInsertAfter = willInsertAfter;
  evt.originalEvent = originalEvent;
  fromEl.dispatchEvent(evt);

  if (onMoveFn) {
    retVal = onMoveFn.call(sortable, evt, originalEvent);
  }

  return retVal;
}

function _disableDraggable(el) {
  el.draggable = false;
}

function _unsilent() {
  _silent = false;
}

function _ghostIsLast(evt, vertical, sortable) {
  var rect = getRect(lastChild(sortable.el, sortable.options.draggable));
  var spacer = 10;
  return vertical ? evt.clientX > rect.right + spacer || evt.clientX <= rect.right && evt.clientY > rect.bottom && evt.clientX >= rect.left : evt.clientX > rect.right && evt.clientY > rect.top || evt.clientX <= rect.right && evt.clientY > rect.bottom + spacer;
}

function _getSwapDirection(evt, target, targetRect, vertical, swapThreshold, invertedSwapThreshold, invertSwap, isLastTarget) {
  var mouseOnAxis = vertical ? evt.clientY : evt.clientX,
      targetLength = vertical ? targetRect.height : targetRect.width,
      targetS1 = vertical ? targetRect.top : targetRect.left,
      targetS2 = vertical ? targetRect.bottom : targetRect.right,
      invert = false;

  if (!invertSwap) {
    // Never invert or create dragEl shadow when target movemenet causes mouse to move past the end of regular swapThreshold
    if (isLastTarget && targetMoveDistance < targetLength * swapThreshold) {
      // multiplied only by swapThreshold because mouse will already be inside target by (1 - threshold) * targetLength / 2
      // check if past first invert threshold on side opposite of lastDirection
      if (!pastFirstInvertThresh && (lastDirection === 1 ? mouseOnAxis > targetS1 + targetLength * invertedSwapThreshold / 2 : mouseOnAxis < targetS2 - targetLength * invertedSwapThreshold / 2)) {
        // past first invert threshold, do not restrict inverted threshold to dragEl shadow
        pastFirstInvertThresh = true;
      }

      if (!pastFirstInvertThresh) {
        // dragEl shadow (target move distance shadow)
        if (lastDirection === 1 ? mouseOnAxis < targetS1 + targetMoveDistance // over dragEl shadow
        : mouseOnAxis > targetS2 - targetMoveDistance) {
          return -lastDirection;
        }
      } else {
        invert = true;
      }
    } else {
      // Regular
      if (mouseOnAxis > targetS1 + targetLength * (1 - swapThreshold) / 2 && mouseOnAxis < targetS2 - targetLength * (1 - swapThreshold) / 2) {
        return _getInsertDirection(target);
      }
    }
  }

  invert = invert || invertSwap;

  if (invert) {
    // Invert of regular
    if (mouseOnAxis < targetS1 + targetLength * invertedSwapThreshold / 2 || mouseOnAxis > targetS2 - targetLength * invertedSwapThreshold / 2) {
      return mouseOnAxis > targetS1 + targetLength / 2 ? 1 : -1;
    }
  }

  return 0;
}
/**
 * Gets the direction dragEl must be swapped relative to target in order to make it
 * seem that dragEl has been "inserted" into that element's position
 * @param  {HTMLElement} target       The target whose position dragEl is being inserted at
 * @return {Number}                   Direction dragEl must be swapped
 */


function _getInsertDirection(target) {
  if (index(dragEl) < index(target)) {
    return 1;
  } else {
    return -1;
  }
}
/**
 * Generate id
 * @param   {HTMLElement} el
 * @returns {String}
 * @private
 */


function _generateId(el) {
  var str = el.tagName + el.className + el.src + el.href + el.textContent,
      i = str.length,
      sum = 0;

  while (i--) {
    sum += str.charCodeAt(i);
  }

  return sum.toString(36);
}

function _saveInputCheckedState(root) {
  savedInputChecked.length = 0;
  var inputs = root.getElementsByTagName('input');
  var idx = inputs.length;

  while (idx--) {
    var el = inputs[idx];
    el.checked && savedInputChecked.push(el);
  }
}

function _nextTick(fn) {
  return setTimeout(fn, 0);
}

function _cancelNextTick(id) {
  return clearTimeout(id);
} // Fixed #973:


if (documentExists) {
  on(document, 'touchmove', function (evt) {
    if ((Sortable.active || awaitingDragStarted) && evt.cancelable) {
      evt.preventDefault();
    }
  });
} // Export utils


Sortable.utils = {
  on: on,
  off: off,
  css: css,
  find: find,
  is: function is(el, selector) {
    return !!closest(el, selector, el, false);
  },
  extend: extend,
  throttle: throttle,
  closest: closest,
  toggleClass: toggleClass,
  clone: clone,
  index: index,
  nextTick: _nextTick,
  cancelNextTick: _cancelNextTick,
  detectDirection: _detectDirection,
  getChild: getChild
};
/**
 * Get the Sortable instance of an element
 * @param  {HTMLElement} element The element
 * @return {Sortable|undefined}         The instance of Sortable
 */

Sortable.get = function (element) {
  return element[expando];
};
/**
 * Mount a plugin to Sortable
 * @param  {...SortablePlugin|SortablePlugin[]} plugins       Plugins being mounted
 */


Sortable.mount = function () {
  for (var _len = arguments.length, plugins = new Array(_len), _key = 0; _key < _len; _key++) {
    plugins[_key] = arguments[_key];
  }

  if (plugins[0].constructor === Array) plugins = plugins[0];
  plugins.forEach(function (plugin) {
    if (!plugin.prototype || !plugin.prototype.constructor) {
      throw "Sortable: Mounted plugin must be a constructor function, not ".concat({}.toString.call(plugin));
    }

    if (plugin.utils) Sortable.utils = _objectSpread({}, Sortable.utils, plugin.utils);
    PluginManager.mount(plugin);
  });
};
/**
 * Create sortable instance
 * @param {HTMLElement}  el
 * @param {Object}      [options]
 */


Sortable.create = function (el, options) {
  return new Sortable(el, options);
}; // Export


Sortable.version = version;
var autoScrolls = [],
    scrollEl,
    scrollRootEl,
    scrolling = false,
    lastAutoScrollX,
    lastAutoScrollY,
    touchEvt$1,
    pointerElemChangedInterval;

function AutoScrollPlugin() {
  function AutoScroll() {
    this.defaults = {
      scroll: true,
      scrollSensitivity: 30,
      scrollSpeed: 10,
      bubbleScroll: true
    }; // Bind all private methods

    for (var fn in this) {
      if (fn.charAt(0) === '_' && typeof this[fn] === 'function') {
        this[fn] = this[fn].bind(this);
      }
    }
  }

  AutoScroll.prototype = {
    dragStarted: function dragStarted(_ref) {
      var originalEvent = _ref.originalEvent;

      if (this.sortable.nativeDraggable) {
        on(document, 'dragover', this._handleAutoScroll);
      } else {
        if (this.options.supportPointer) {
          on(document, 'pointermove', this._handleFallbackAutoScroll);
        } else if (originalEvent.touches) {
          on(document, 'touchmove', this._handleFallbackAutoScroll);
        } else {
          on(document, 'mousemove', this._handleFallbackAutoScroll);
        }
      }
    },
    dragOverCompleted: function dragOverCompleted(_ref2) {
      var originalEvent = _ref2.originalEvent; // For when bubbling is canceled and using fallback (fallback 'touchmove' always reached)

      if (!this.options.dragOverBubble && !originalEvent.rootEl) {
        this._handleAutoScroll(originalEvent);
      }
    },
    drop: function drop() {
      if (this.sortable.nativeDraggable) {
        off(document, 'dragover', this._handleAutoScroll);
      } else {
        off(document, 'pointermove', this._handleFallbackAutoScroll);
        off(document, 'touchmove', this._handleFallbackAutoScroll);
        off(document, 'mousemove', this._handleFallbackAutoScroll);
      }

      clearPointerElemChangedInterval();
      clearAutoScrolls();
      cancelThrottle();
    },
    nulling: function nulling() {
      touchEvt$1 = scrollRootEl = scrollEl = scrolling = pointerElemChangedInterval = lastAutoScrollX = lastAutoScrollY = null;
      autoScrolls.length = 0;
    },
    _handleFallbackAutoScroll: function _handleFallbackAutoScroll(evt) {
      this._handleAutoScroll(evt, true);
    },
    _handleAutoScroll: function _handleAutoScroll(evt, fallback) {
      var _this = this;

      var x = (evt.touches ? evt.touches[0] : evt).clientX,
          y = (evt.touches ? evt.touches[0] : evt).clientY,
          elem = document.elementFromPoint(x, y);
      touchEvt$1 = evt; // IE does not seem to have native autoscroll,
      // Edge's autoscroll seems too conditional,
      // MACOS Safari does not have autoscroll,
      // Firefox and Chrome are good

      if (fallback || Edge || IE11OrLess || Safari) {
        autoScroll(evt, this.options, elem, fallback); // Listener for pointer element change

        var ogElemScroller = getParentAutoScrollElement(elem, true);

        if (scrolling && (!pointerElemChangedInterval || x !== lastAutoScrollX || y !== lastAutoScrollY)) {
          pointerElemChangedInterval && clearPointerElemChangedInterval(); // Detect for pointer elem change, emulating native DnD behaviour

          pointerElemChangedInterval = setInterval(function () {
            var newElem = getParentAutoScrollElement(document.elementFromPoint(x, y), true);

            if (newElem !== ogElemScroller) {
              ogElemScroller = newElem;
              clearAutoScrolls();
            }

            autoScroll(evt, _this.options, newElem, fallback);
          }, 10);
          lastAutoScrollX = x;
          lastAutoScrollY = y;
        }
      } else {
        // if DnD is enabled (and browser has good autoscrolling), first autoscroll will already scroll, so get parent autoscroll of first autoscroll
        if (!this.options.bubbleScroll || getParentAutoScrollElement(elem, true) === getWindowScrollingElement()) {
          clearAutoScrolls();
          return;
        }

        autoScroll(evt, this.options, getParentAutoScrollElement(elem, false), false);
      }
    }
  };
  return _extends(AutoScroll, {
    pluginName: 'scroll',
    initializeByDefault: true
  });
}

function clearAutoScrolls() {
  autoScrolls.forEach(function (autoScroll) {
    clearInterval(autoScroll.pid);
  });
  autoScrolls = [];
}

function clearPointerElemChangedInterval() {
  clearInterval(pointerElemChangedInterval);
}

var autoScroll = throttle(function (evt, options, rootEl, isFallback) {
  // Bug: https://bugzilla.mozilla.org/show_bug.cgi?id=505521
  if (!options.scroll) return;
  var x = (evt.touches ? evt.touches[0] : evt).clientX,
      y = (evt.touches ? evt.touches[0] : evt).clientY,
      sens = options.scrollSensitivity,
      speed = options.scrollSpeed,
      winScroller = getWindowScrollingElement();
  var scrollThisInstance = false,
      scrollCustomFn; // New scroll root, set scrollEl

  if (scrollRootEl !== rootEl) {
    scrollRootEl = rootEl;
    clearAutoScrolls();
    scrollEl = options.scroll;
    scrollCustomFn = options.scrollFn;

    if (scrollEl === true) {
      scrollEl = getParentAutoScrollElement(rootEl, true);
    }
  }

  var layersOut = 0;
  var currentParent = scrollEl;

  do {
    var el = currentParent,
        rect = getRect(el),
        top = rect.top,
        bottom = rect.bottom,
        left = rect.left,
        right = rect.right,
        width = rect.width,
        height = rect.height,
        canScrollX = void 0,
        canScrollY = void 0,
        scrollWidth = el.scrollWidth,
        scrollHeight = el.scrollHeight,
        elCSS = css(el),
        scrollPosX = el.scrollLeft,
        scrollPosY = el.scrollTop;

    if (el === winScroller) {
      canScrollX = width < scrollWidth && (elCSS.overflowX === 'auto' || elCSS.overflowX === 'scroll' || elCSS.overflowX === 'visible');
      canScrollY = height < scrollHeight && (elCSS.overflowY === 'auto' || elCSS.overflowY === 'scroll' || elCSS.overflowY === 'visible');
    } else {
      canScrollX = width < scrollWidth && (elCSS.overflowX === 'auto' || elCSS.overflowX === 'scroll');
      canScrollY = height < scrollHeight && (elCSS.overflowY === 'auto' || elCSS.overflowY === 'scroll');
    }

    var vx = canScrollX && (Math.abs(right - x) <= sens && scrollPosX + width < scrollWidth) - (Math.abs(left - x) <= sens && !!scrollPosX);
    var vy = canScrollY && (Math.abs(bottom - y) <= sens && scrollPosY + height < scrollHeight) - (Math.abs(top - y) <= sens && !!scrollPosY);

    if (!autoScrolls[layersOut]) {
      for (var i = 0; i <= layersOut; i++) {
        if (!autoScrolls[i]) {
          autoScrolls[i] = {};
        }
      }
    }

    if (autoScrolls[layersOut].vx != vx || autoScrolls[layersOut].vy != vy || autoScrolls[layersOut].el !== el) {
      autoScrolls[layersOut].el = el;
      autoScrolls[layersOut].vx = vx;
      autoScrolls[layersOut].vy = vy;
      clearInterval(autoScrolls[layersOut].pid);

      if (vx != 0 || vy != 0) {
        scrollThisInstance = true;
        /* jshint loopfunc:true */

        autoScrolls[layersOut].pid = setInterval(function () {
          // emulate drag over during autoscroll (fallback), emulating native DnD behaviour
          if (isFallback && this.layer === 0) {
            Sortable.active._onTouchMove(touchEvt$1); // To move ghost if it is positioned absolutely

          }

          var scrollOffsetY = autoScrolls[this.layer].vy ? autoScrolls[this.layer].vy * speed : 0;
          var scrollOffsetX = autoScrolls[this.layer].vx ? autoScrolls[this.layer].vx * speed : 0;

          if (typeof scrollCustomFn === 'function') {
            if (scrollCustomFn.call(Sortable.dragged.parentNode[expando], scrollOffsetX, scrollOffsetY, evt, touchEvt$1, autoScrolls[this.layer].el) !== 'continue') {
              return;
            }
          }

          scrollBy(autoScrolls[this.layer].el, scrollOffsetX, scrollOffsetY);
        }.bind({
          layer: layersOut
        }), 24);
      }
    }

    layersOut++;
  } while (options.bubbleScroll && currentParent !== winScroller && (currentParent = getParentAutoScrollElement(currentParent, false)));

  scrolling = scrollThisInstance; // in case another function catches scrolling as false in between when it is not
}, 30);

var drop = function drop(_ref) {
  var originalEvent = _ref.originalEvent,
      putSortable = _ref.putSortable,
      dragEl = _ref.dragEl,
      activeSortable = _ref.activeSortable,
      dispatchSortableEvent = _ref.dispatchSortableEvent,
      hideGhostForTarget = _ref.hideGhostForTarget,
      unhideGhostForTarget = _ref.unhideGhostForTarget;
  if (!originalEvent) return;
  var toSortable = putSortable || activeSortable;
  hideGhostForTarget();
  var touch = originalEvent.changedTouches && originalEvent.changedTouches.length ? originalEvent.changedTouches[0] : originalEvent;
  var target = document.elementFromPoint(touch.clientX, touch.clientY);
  unhideGhostForTarget();

  if (toSortable && !toSortable.el.contains(target)) {
    dispatchSortableEvent('spill');
    this.onSpill({
      dragEl: dragEl,
      putSortable: putSortable
    });
  }
};

function Revert() {}

Revert.prototype = {
  startIndex: null,
  dragStart: function dragStart(_ref2) {
    var oldDraggableIndex = _ref2.oldDraggableIndex;
    this.startIndex = oldDraggableIndex;
  },
  onSpill: function onSpill(_ref3) {
    var dragEl = _ref3.dragEl,
        putSortable = _ref3.putSortable;
    this.sortable.captureAnimationState();

    if (putSortable) {
      putSortable.captureAnimationState();
    }

    var nextSibling = getChild(this.sortable.el, this.startIndex, this.options);

    if (nextSibling) {
      this.sortable.el.insertBefore(dragEl, nextSibling);
    } else {
      this.sortable.el.appendChild(dragEl);
    }

    this.sortable.animateAll();

    if (putSortable) {
      putSortable.animateAll();
    }
  },
  drop: drop
};

_extends(Revert, {
  pluginName: 'revertOnSpill'
});

function Remove() {}

Remove.prototype = {
  onSpill: function onSpill(_ref4) {
    var dragEl = _ref4.dragEl,
        putSortable = _ref4.putSortable;
    var parentSortable = putSortable || this.sortable;
    parentSortable.captureAnimationState();
    dragEl.parentNode && dragEl.parentNode.removeChild(dragEl);
    parentSortable.animateAll();
  },
  drop: drop
};

_extends(Remove, {
  pluginName: 'removeOnSpill'
});

var lastSwapEl;

function SwapPlugin() {
  function Swap() {
    this.defaults = {
      swapClass: 'sortable-swap-highlight'
    };
  }

  Swap.prototype = {
    dragStart: function dragStart(_ref) {
      var dragEl = _ref.dragEl;
      lastSwapEl = dragEl;
    },
    dragOverValid: function dragOverValid(_ref2) {
      var completed = _ref2.completed,
          target = _ref2.target,
          onMove = _ref2.onMove,
          activeSortable = _ref2.activeSortable,
          changed = _ref2.changed,
          cancel = _ref2.cancel;
      if (!activeSortable.options.swap) return;
      var el = this.sortable.el,
          options = this.options;

      if (target && target !== el) {
        var prevSwapEl = lastSwapEl;

        if (onMove(target) !== false) {
          toggleClass(target, options.swapClass, true);
          lastSwapEl = target;
        } else {
          lastSwapEl = null;
        }

        if (prevSwapEl && prevSwapEl !== lastSwapEl) {
          toggleClass(prevSwapEl, options.swapClass, false);
        }
      }

      changed();
      completed(true);
      cancel();
    },
    drop: function drop(_ref3) {
      var activeSortable = _ref3.activeSortable,
          putSortable = _ref3.putSortable,
          dragEl = _ref3.dragEl;
      var toSortable = putSortable || this.sortable;
      var options = this.options;
      lastSwapEl && toggleClass(lastSwapEl, options.swapClass, false);

      if (lastSwapEl && (options.swap || putSortable && putSortable.options.swap)) {
        if (dragEl !== lastSwapEl) {
          toSortable.captureAnimationState();
          if (toSortable !== activeSortable) activeSortable.captureAnimationState();
          swapNodes(dragEl, lastSwapEl);
          toSortable.animateAll();
          if (toSortable !== activeSortable) activeSortable.animateAll();
        }
      }
    },
    nulling: function nulling() {
      lastSwapEl = null;
    }
  };
  return _extends(Swap, {
    pluginName: 'swap',
    eventProperties: function eventProperties() {
      return {
        swapItem: lastSwapEl
      };
    }
  });
}

function swapNodes(n1, n2) {
  var p1 = n1.parentNode,
      p2 = n2.parentNode,
      i1,
      i2;
  if (!p1 || !p2 || p1.isEqualNode(n2) || p2.isEqualNode(n1)) return;
  i1 = index(n1);
  i2 = index(n2);

  if (p1.isEqualNode(p2) && i1 < i2) {
    i2++;
  }

  p1.insertBefore(n2, p1.children[i1]);
  p2.insertBefore(n1, p2.children[i2]);
}

var multiDragElements = [],
    multiDragClones = [],
    lastMultiDragSelect,
    // for selection with modifier key down (SHIFT)
multiDragSortable,
    initialFolding = false,
    // Initial multi-drag fold when drag started
folding = false,
    // Folding any other time
dragStarted = false,
    dragEl$1,
    clonesFromRect,
    clonesHidden;

function MultiDragPlugin() {
  function MultiDrag(sortable) {
    // Bind all private methods
    for (var fn in this) {
      if (fn.charAt(0) === '_' && typeof this[fn] === 'function') {
        this[fn] = this[fn].bind(this);
      }
    }

    if (sortable.options.supportPointer) {
      on(document, 'pointerup', this._deselectMultiDrag);
    } else {
      on(document, 'mouseup', this._deselectMultiDrag);
      on(document, 'touchend', this._deselectMultiDrag);
    }

    on(document, 'keydown', this._checkKeyDown);
    on(document, 'keyup', this._checkKeyUp);
    this.defaults = {
      selectedClass: 'sortable-selected',
      multiDragKey: null,
      setData: function setData(dataTransfer, dragEl) {
        var data = '';

        if (multiDragElements.length && multiDragSortable === sortable) {
          multiDragElements.forEach(function (multiDragElement, i) {
            data += (!i ? '' : ', ') + multiDragElement.textContent;
          });
        } else {
          data = dragEl.textContent;
        }

        dataTransfer.setData('Text', data);
      }
    };
  }

  MultiDrag.prototype = {
    multiDragKeyDown: false,
    isMultiDrag: false,
    delayStartGlobal: function delayStartGlobal(_ref) {
      var dragged = _ref.dragEl;
      dragEl$1 = dragged;
    },
    delayEnded: function delayEnded() {
      this.isMultiDrag = ~multiDragElements.indexOf(dragEl$1);
    },
    setupClone: function setupClone(_ref2) {
      var sortable = _ref2.sortable,
          cancel = _ref2.cancel;
      if (!this.isMultiDrag) return;

      for (var i = 0; i < multiDragElements.length; i++) {
        multiDragClones.push(clone(multiDragElements[i]));
        multiDragClones[i].sortableIndex = multiDragElements[i].sortableIndex;
        multiDragClones[i].draggable = false;
        multiDragClones[i].style['will-change'] = '';
        toggleClass(multiDragClones[i], this.options.selectedClass, false);
        multiDragElements[i] === dragEl$1 && toggleClass(multiDragClones[i], this.options.chosenClass, false);
      }

      sortable._hideClone();

      cancel();
    },
    clone: function clone(_ref3) {
      var sortable = _ref3.sortable,
          rootEl = _ref3.rootEl,
          dispatchSortableEvent = _ref3.dispatchSortableEvent,
          cancel = _ref3.cancel;
      if (!this.isMultiDrag) return;

      if (!this.options.removeCloneOnHide) {
        if (multiDragElements.length && multiDragSortable === sortable) {
          insertMultiDragClones(true, rootEl);
          dispatchSortableEvent('clone');
          cancel();
        }
      }
    },
    showClone: function showClone(_ref4) {
      var cloneNowShown = _ref4.cloneNowShown,
          rootEl = _ref4.rootEl,
          cancel = _ref4.cancel;
      if (!this.isMultiDrag) return;
      insertMultiDragClones(false, rootEl);
      multiDragClones.forEach(function (clone) {
        css(clone, 'display', '');
      });
      cloneNowShown();
      clonesHidden = false;
      cancel();
    },
    hideClone: function hideClone(_ref5) {
      var _this = this;

      var sortable = _ref5.sortable,
          cloneNowHidden = _ref5.cloneNowHidden,
          cancel = _ref5.cancel;
      if (!this.isMultiDrag) return;
      multiDragClones.forEach(function (clone) {
        css(clone, 'display', 'none');

        if (_this.options.removeCloneOnHide && clone.parentNode) {
          clone.parentNode.removeChild(clone);
        }
      });
      cloneNowHidden();
      clonesHidden = true;
      cancel();
    },
    dragStartGlobal: function dragStartGlobal(_ref6) {
      var sortable = _ref6.sortable;

      if (!this.isMultiDrag && multiDragSortable) {
        multiDragSortable.multiDrag._deselectMultiDrag();
      }

      multiDragElements.forEach(function (multiDragElement) {
        multiDragElement.sortableIndex = index(multiDragElement);
      }); // Sort multi-drag elements

      multiDragElements = multiDragElements.sort(function (a, b) {
        return a.sortableIndex - b.sortableIndex;
      });
      dragStarted = true;
    },
    dragStarted: function dragStarted(_ref7) {
      var _this2 = this;

      var sortable = _ref7.sortable;
      if (!this.isMultiDrag) return;

      if (this.options.sort) {
        // Capture rects,
        // hide multi drag elements (by positioning them absolute),
        // set multi drag elements rects to dragRect,
        // show multi drag elements,
        // animate to rects,
        // unset rects & remove from DOM
        sortable.captureAnimationState();

        if (this.options.animation) {
          multiDragElements.forEach(function (multiDragElement) {
            if (multiDragElement === dragEl$1) return;
            css(multiDragElement, 'position', 'absolute');
          });
          var dragRect = getRect(dragEl$1, false, true, true);
          multiDragElements.forEach(function (multiDragElement) {
            if (multiDragElement === dragEl$1) return;
            setRect(multiDragElement, dragRect);
          });
          folding = true;
          initialFolding = true;
        }
      }

      sortable.animateAll(function () {
        folding = false;
        initialFolding = false;

        if (_this2.options.animation) {
          multiDragElements.forEach(function (multiDragElement) {
            unsetRect(multiDragElement);
          });
        } // Remove all auxiliary multidrag items from el, if sorting enabled


        if (_this2.options.sort) {
          removeMultiDragElements();
        }
      });
    },
    dragOver: function dragOver(_ref8) {
      var target = _ref8.target,
          completed = _ref8.completed,
          cancel = _ref8.cancel;

      if (folding && ~multiDragElements.indexOf(target)) {
        completed(false);
        cancel();
      }
    },
    revert: function revert(_ref9) {
      var fromSortable = _ref9.fromSortable,
          rootEl = _ref9.rootEl,
          sortable = _ref9.sortable,
          dragRect = _ref9.dragRect;

      if (multiDragElements.length > 1) {
        // Setup unfold animation
        multiDragElements.forEach(function (multiDragElement) {
          sortable.addAnimationState({
            target: multiDragElement,
            rect: folding ? getRect(multiDragElement) : dragRect
          });
          unsetRect(multiDragElement);
          multiDragElement.fromRect = dragRect;
          fromSortable.removeAnimationState(multiDragElement);
        });
        folding = false;
        insertMultiDragElements(!this.options.removeCloneOnHide, rootEl);
      }
    },
    dragOverCompleted: function dragOverCompleted(_ref10) {
      var sortable = _ref10.sortable,
          isOwner = _ref10.isOwner,
          insertion = _ref10.insertion,
          activeSortable = _ref10.activeSortable,
          parentEl = _ref10.parentEl,
          putSortable = _ref10.putSortable;
      var options = this.options;

      if (insertion) {
        // Clones must be hidden before folding animation to capture dragRectAbsolute properly
        if (isOwner) {
          activeSortable._hideClone();
        }

        initialFolding = false; // If leaving sort:false root, or already folding - Fold to new location

        if (options.animation && multiDragElements.length > 1 && (folding || !isOwner && !activeSortable.options.sort && !putSortable)) {
          // Fold: Set all multi drag elements's rects to dragEl's rect when multi-drag elements are invisible
          var dragRectAbsolute = getRect(dragEl$1, false, true, true);
          multiDragElements.forEach(function (multiDragElement) {
            if (multiDragElement === dragEl$1) return;
            setRect(multiDragElement, dragRectAbsolute); // Move element(s) to end of parentEl so that it does not interfere with multi-drag clones insertion if they are inserted
            // while folding, and so that we can capture them again because old sortable will no longer be fromSortable

            parentEl.appendChild(multiDragElement);
          });
          folding = true;
        } // Clones must be shown (and check to remove multi drags) after folding when interfering multiDragElements are moved out


        if (!isOwner) {
          // Only remove if not folding (folding will remove them anyways)
          if (!folding) {
            removeMultiDragElements();
          }

          if (multiDragElements.length > 1) {
            var clonesHiddenBefore = clonesHidden;

            activeSortable._showClone(sortable); // Unfold animation for clones if showing from hidden


            if (activeSortable.options.animation && !clonesHidden && clonesHiddenBefore) {
              multiDragClones.forEach(function (clone) {
                activeSortable.addAnimationState({
                  target: clone,
                  rect: clonesFromRect
                });
                clone.fromRect = clonesFromRect;
                clone.thisAnimationDuration = null;
              });
            }
          } else {
            activeSortable._showClone(sortable);
          }
        }
      }
    },
    dragOverAnimationCapture: function dragOverAnimationCapture(_ref11) {
      var dragRect = _ref11.dragRect,
          isOwner = _ref11.isOwner,
          activeSortable = _ref11.activeSortable;
      multiDragElements.forEach(function (multiDragElement) {
        multiDragElement.thisAnimationDuration = null;
      });

      if (activeSortable.options.animation && !isOwner && activeSortable.multiDrag.isMultiDrag) {
        clonesFromRect = _extends({}, dragRect);
        var dragMatrix = matrix(dragEl$1, true);
        clonesFromRect.top -= dragMatrix.f;
        clonesFromRect.left -= dragMatrix.e;
      }
    },
    dragOverAnimationComplete: function dragOverAnimationComplete() {
      if (folding) {
        folding = false;
        removeMultiDragElements();
      }
    },
    drop: function drop(_ref12) {
      var evt = _ref12.originalEvent,
          rootEl = _ref12.rootEl,
          parentEl = _ref12.parentEl,
          sortable = _ref12.sortable,
          dispatchSortableEvent = _ref12.dispatchSortableEvent,
          oldIndex = _ref12.oldIndex,
          putSortable = _ref12.putSortable;
      var toSortable = putSortable || this.sortable;
      if (!evt) return;
      var options = this.options,
          children = parentEl.children; // Multi-drag selection

      if (!dragStarted) {
        if (options.multiDragKey && !this.multiDragKeyDown) {
          this._deselectMultiDrag();
        }

        toggleClass(dragEl$1, options.selectedClass, !~multiDragElements.indexOf(dragEl$1));

        if (!~multiDragElements.indexOf(dragEl$1)) {
          multiDragElements.push(dragEl$1);
          dispatchEvent({
            sortable: sortable,
            rootEl: rootEl,
            name: 'select',
            targetEl: dragEl$1,
            originalEvt: evt
          }); // Modifier activated, select from last to dragEl

          if (evt.shiftKey && lastMultiDragSelect && sortable.el.contains(lastMultiDragSelect)) {
            var lastIndex = index(lastMultiDragSelect),
                currentIndex = index(dragEl$1);

            if (~lastIndex && ~currentIndex && lastIndex !== currentIndex) {
              // Must include lastMultiDragSelect (select it), in case modified selection from no selection
              // (but previous selection existed)
              var n, i;

              if (currentIndex > lastIndex) {
                i = lastIndex;
                n = currentIndex;
              } else {
                i = currentIndex;
                n = lastIndex + 1;
              }

              for (; i < n; i++) {
                if (~multiDragElements.indexOf(children[i])) continue;
                toggleClass(children[i], options.selectedClass, true);
                multiDragElements.push(children[i]);
                dispatchEvent({
                  sortable: sortable,
                  rootEl: rootEl,
                  name: 'select',
                  targetEl: children[i],
                  originalEvt: evt
                });
              }
            }
          } else {
            lastMultiDragSelect = dragEl$1;
          }

          multiDragSortable = toSortable;
        } else {
          multiDragElements.splice(multiDragElements.indexOf(dragEl$1), 1);
          lastMultiDragSelect = null;
          dispatchEvent({
            sortable: sortable,
            rootEl: rootEl,
            name: 'deselect',
            targetEl: dragEl$1,
            originalEvt: evt
          });
        }
      } // Multi-drag drop


      if (dragStarted && this.isMultiDrag) {
        // Do not "unfold" after around dragEl if reverted
        if ((parentEl[expando].options.sort || parentEl !== rootEl) && multiDragElements.length > 1) {
          var dragRect = getRect(dragEl$1),
              multiDragIndex = index(dragEl$1, ':not(.' + this.options.selectedClass + ')');
          if (!initialFolding && options.animation) dragEl$1.thisAnimationDuration = null;
          toSortable.captureAnimationState();

          if (!initialFolding) {
            if (options.animation) {
              dragEl$1.fromRect = dragRect;
              multiDragElements.forEach(function (multiDragElement) {
                multiDragElement.thisAnimationDuration = null;

                if (multiDragElement !== dragEl$1) {
                  var rect = folding ? getRect(multiDragElement) : dragRect;
                  multiDragElement.fromRect = rect; // Prepare unfold animation

                  toSortable.addAnimationState({
                    target: multiDragElement,
                    rect: rect
                  });
                }
              });
            } // Multi drag elements are not necessarily removed from the DOM on drop, so to reinsert
            // properly they must all be removed


            removeMultiDragElements();
            multiDragElements.forEach(function (multiDragElement) {
              if (children[multiDragIndex]) {
                parentEl.insertBefore(multiDragElement, children[multiDragIndex]);
              } else {
                parentEl.appendChild(multiDragElement);
              }

              multiDragIndex++;
            }); // If initial folding is done, the elements may have changed position because they are now
            // unfolding around dragEl, even though dragEl may not have his index changed, so update event
            // must be fired here as Sortable will not.

            if (oldIndex === index(dragEl$1)) {
              var update = false;
              multiDragElements.forEach(function (multiDragElement) {
                if (multiDragElement.sortableIndex !== index(multiDragElement)) {
                  update = true;
                  return;
                }
              });

              if (update) {
                dispatchSortableEvent('update');
              }
            }
          } // Must be done after capturing individual rects (scroll bar)


          multiDragElements.forEach(function (multiDragElement) {
            unsetRect(multiDragElement);
          });
          toSortable.animateAll();
        }

        multiDragSortable = toSortable;
      } // Remove clones if necessary


      if (rootEl === parentEl || putSortable && putSortable.lastPutMode !== 'clone') {
        multiDragClones.forEach(function (clone) {
          clone.parentNode && clone.parentNode.removeChild(clone);
        });
      }
    },
    nullingGlobal: function nullingGlobal() {
      this.isMultiDrag = dragStarted = false;
      multiDragClones.length = 0;
    },
    destroyGlobal: function destroyGlobal() {
      this._deselectMultiDrag();

      off(document, 'pointerup', this._deselectMultiDrag);
      off(document, 'mouseup', this._deselectMultiDrag);
      off(document, 'touchend', this._deselectMultiDrag);
      off(document, 'keydown', this._checkKeyDown);
      off(document, 'keyup', this._checkKeyUp);
    },
    _deselectMultiDrag: function _deselectMultiDrag(evt) {
      if (typeof dragStarted !== "undefined" && dragStarted) return; // Only deselect if selection is in this sortable

      if (multiDragSortable !== this.sortable) return; // Only deselect if target is not item in this sortable

      if (evt && closest(evt.target, this.options.draggable, this.sortable.el, false)) return; // Only deselect if left click

      if (evt && evt.button !== 0) return;

      while (multiDragElements.length) {
        var el = multiDragElements[0];
        toggleClass(el, this.options.selectedClass, false);
        multiDragElements.shift();
        dispatchEvent({
          sortable: this.sortable,
          rootEl: this.sortable.el,
          name: 'deselect',
          targetEl: el,
          originalEvt: evt
        });
      }
    },
    _checkKeyDown: function _checkKeyDown(evt) {
      if (evt.key === this.options.multiDragKey) {
        this.multiDragKeyDown = true;
      }
    },
    _checkKeyUp: function _checkKeyUp(evt) {
      if (evt.key === this.options.multiDragKey) {
        this.multiDragKeyDown = false;
      }
    }
  };
  return _extends(MultiDrag, {
    // Static methods & properties
    pluginName: 'multiDrag',
    utils: {
      /**
       * Selects the provided multi-drag item
       * @param  {HTMLElement} el    The element to be selected
       */
      select: function select(el) {
        var sortable = el.parentNode[expando];
        if (!sortable || !sortable.options.multiDrag || ~multiDragElements.indexOf(el)) return;

        if (multiDragSortable && multiDragSortable !== sortable) {
          multiDragSortable.multiDrag._deselectMultiDrag();

          multiDragSortable = sortable;
        }

        toggleClass(el, sortable.options.selectedClass, true);
        multiDragElements.push(el);
      },

      /**
       * Deselects the provided multi-drag item
       * @param  {HTMLElement} el    The element to be deselected
       */
      deselect: function deselect(el) {
        var sortable = el.parentNode[expando],
            index = multiDragElements.indexOf(el);
        if (!sortable || !sortable.options.multiDrag || !~index) return;
        toggleClass(el, sortable.options.selectedClass, false);
        multiDragElements.splice(index, 1);
      }
    },
    eventProperties: function eventProperties() {
      var _this3 = this;

      var oldIndicies = [],
          newIndicies = [];
      multiDragElements.forEach(function (multiDragElement) {
        oldIndicies.push({
          multiDragElement: multiDragElement,
          index: multiDragElement.sortableIndex
        }); // multiDragElements will already be sorted if folding

        var newIndex;

        if (folding && multiDragElement !== dragEl$1) {
          newIndex = -1;
        } else if (folding) {
          newIndex = index(multiDragElement, ':not(.' + _this3.options.selectedClass + ')');
        } else {
          newIndex = index(multiDragElement);
        }

        newIndicies.push({
          multiDragElement: multiDragElement,
          index: newIndex
        });
      });
      return {
        items: _toConsumableArray(multiDragElements),
        clones: [].concat(multiDragClones),
        oldIndicies: oldIndicies,
        newIndicies: newIndicies
      };
    },
    optionListeners: {
      multiDragKey: function multiDragKey(key) {
        key = key.toLowerCase();

        if (key === 'ctrl') {
          key = 'Control';
        } else if (key.length > 1) {
          key = key.charAt(0).toUpperCase() + key.substr(1);
        }

        return key;
      }
    }
  });
}

function insertMultiDragElements(clonesInserted, rootEl) {
  multiDragElements.forEach(function (multiDragElement, i) {
    var target = rootEl.children[multiDragElement.sortableIndex + (clonesInserted ? Number(i) : 0)];

    if (target) {
      rootEl.insertBefore(multiDragElement, target);
    } else {
      rootEl.appendChild(multiDragElement);
    }
  });
}
/**
 * Insert multi-drag clones
 * @param  {[Boolean]} elementsInserted  Whether the multi-drag elements are inserted
 * @param  {HTMLElement} rootEl
 */


function insertMultiDragClones(elementsInserted, rootEl) {
  multiDragClones.forEach(function (clone, i) {
    var target = rootEl.children[clone.sortableIndex + (elementsInserted ? Number(i) : 0)];

    if (target) {
      rootEl.insertBefore(clone, target);
    } else {
      rootEl.appendChild(clone);
    }
  });
}

function removeMultiDragElements() {
  multiDragElements.forEach(function (multiDragElement) {
    if (multiDragElement === dragEl$1) return;
    multiDragElement.parentNode && multiDragElement.parentNode.removeChild(multiDragElement);
  });
}

Sortable.mount(new AutoScrollPlugin());
Sortable.mount(Remove, Revert);
/* harmony default export */ __webpack_exports__["default"] = (Sortable);


/***/ }),

/***/ "./node_modules/style-loader/dist/cjs.js!./node_modules/css-loader/dist/cjs.js!./node_modules/vue-loader/lib/loaders/stylePostLoader.js!./node_modules/sass-loader/dist/cjs.js!./src/components/main/main.scss?vue&type=style&index=0&lang=scss&":
/*!*******************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/style-loader/dist/cjs.js!./node_modules/css-loader/dist/cjs.js!./node_modules/vue-loader/lib/loaders/stylePostLoader.js!./node_modules/sass-loader/dist/cjs.js!./src/components/main/main.scss?vue&type=style&index=0&lang=scss& ***!
  \*******************************************************************************************************************************************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var api = __webpack_require__(/*! ../../../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js */ "./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js");
            var content = __webpack_require__(/*! !../../../node_modules/css-loader/dist/cjs.js!../../../node_modules/vue-loader/lib/loaders/stylePostLoader.js!../../../node_modules/sass-loader/dist/cjs.js!./main.scss?vue&type=style&index=0&lang=scss& */ "./node_modules/css-loader/dist/cjs.js!./node_modules/vue-loader/lib/loaders/stylePostLoader.js!./node_modules/sass-loader/dist/cjs.js!./src/components/main/main.scss?vue&type=style&index=0&lang=scss&");

            content = content.__esModule ? content.default : content;

            if (typeof content === 'string') {
              content = [[module.i, content, '']];
            }

var options = {};

options.insert = "head";
options.singleton = false;

var update = api(content, options);



module.exports = content.locals || {};

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js":
/*!****************************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var isOldIE = function isOldIE() {
  var memo;
  return function memorize() {
    if (typeof memo === 'undefined') {
      // Test for IE <= 9 as proposed by Browserhacks
      // @see http://browserhacks.com/#hack-e71d8692f65334173fee715c222cb805
      // Tests for existence of standard globals is to allow style-loader
      // to operate correctly into non-standard environments
      // @see https://github.com/webpack-contrib/style-loader/issues/177
      memo = Boolean(window && document && document.all && !window.atob);
    }

    return memo;
  };
}();

var getTarget = function getTarget() {
  var memo = {};
  return function memorize(target) {
    if (typeof memo[target] === 'undefined') {
      var styleTarget = document.querySelector(target); // Special case to return head of iframe instead of iframe itself

      if (window.HTMLIFrameElement && styleTarget instanceof window.HTMLIFrameElement) {
        try {
          // This will throw an exception if access to iframe is blocked
          // due to cross-origin restrictions
          styleTarget = styleTarget.contentDocument.head;
        } catch (e) {
          // istanbul ignore next
          styleTarget = null;
        }
      }

      memo[target] = styleTarget;
    }

    return memo[target];
  };
}();

var stylesInDom = [];

function getIndexByIdentifier(identifier) {
  var result = -1;

  for (var i = 0; i < stylesInDom.length; i++) {
    if (stylesInDom[i].identifier === identifier) {
      result = i;
      break;
    }
  }

  return result;
}

function modulesToDom(list, options) {
  var idCountMap = {};
  var identifiers = [];

  for (var i = 0; i < list.length; i++) {
    var item = list[i];
    var id = options.base ? item[0] + options.base : item[0];
    var count = idCountMap[id] || 0;
    var identifier = "".concat(id, " ").concat(count);
    idCountMap[id] = count + 1;
    var index = getIndexByIdentifier(identifier);
    var obj = {
      css: item[1],
      media: item[2],
      sourceMap: item[3]
    };

    if (index !== -1) {
      stylesInDom[index].references++;
      stylesInDom[index].updater(obj);
    } else {
      stylesInDom.push({
        identifier: identifier,
        updater: addStyle(obj, options),
        references: 1
      });
    }

    identifiers.push(identifier);
  }

  return identifiers;
}

function insertStyleElement(options) {
  var style = document.createElement('style');
  var attributes = options.attributes || {};

  if (typeof attributes.nonce === 'undefined') {
    var nonce =  true ? __webpack_require__.nc : undefined;

    if (nonce) {
      attributes.nonce = nonce;
    }
  }

  Object.keys(attributes).forEach(function (key) {
    style.setAttribute(key, attributes[key]);
  });

  if (typeof options.insert === 'function') {
    options.insert(style);
  } else {
    var target = getTarget(options.insert || 'head');

    if (!target) {
      throw new Error("Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.");
    }

    target.appendChild(style);
  }

  return style;
}

function removeStyleElement(style) {
  // istanbul ignore if
  if (style.parentNode === null) {
    return false;
  }

  style.parentNode.removeChild(style);
}
/* istanbul ignore next  */


var replaceText = function replaceText() {
  var textStore = [];
  return function replace(index, replacement) {
    textStore[index] = replacement;
    return textStore.filter(Boolean).join('\n');
  };
}();

function applyToSingletonTag(style, index, remove, obj) {
  var css = remove ? '' : obj.media ? "@media ".concat(obj.media, " {").concat(obj.css, "}") : obj.css; // For old IE

  /* istanbul ignore if  */

  if (style.styleSheet) {
    style.styleSheet.cssText = replaceText(index, css);
  } else {
    var cssNode = document.createTextNode(css);
    var childNodes = style.childNodes;

    if (childNodes[index]) {
      style.removeChild(childNodes[index]);
    }

    if (childNodes.length) {
      style.insertBefore(cssNode, childNodes[index]);
    } else {
      style.appendChild(cssNode);
    }
  }
}

function applyToTag(style, options, obj) {
  var css = obj.css;
  var media = obj.media;
  var sourceMap = obj.sourceMap;

  if (media) {
    style.setAttribute('media', media);
  } else {
    style.removeAttribute('media');
  }

  if (sourceMap && typeof btoa !== 'undefined') {
    css += "\n/*# sourceMappingURL=data:application/json;base64,".concat(btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))), " */");
  } // For old IE

  /* istanbul ignore if  */


  if (style.styleSheet) {
    style.styleSheet.cssText = css;
  } else {
    while (style.firstChild) {
      style.removeChild(style.firstChild);
    }

    style.appendChild(document.createTextNode(css));
  }
}

var singleton = null;
var singletonCounter = 0;

function addStyle(obj, options) {
  var style;
  var update;
  var remove;

  if (options.singleton) {
    var styleIndex = singletonCounter++;
    style = singleton || (singleton = insertStyleElement(options));
    update = applyToSingletonTag.bind(null, style, styleIndex, false);
    remove = applyToSingletonTag.bind(null, style, styleIndex, true);
  } else {
    style = insertStyleElement(options);
    update = applyToTag.bind(null, style, options);

    remove = function remove() {
      removeStyleElement(style);
    };
  }

  update(obj);
  return function updateStyle(newObj) {
    if (newObj) {
      if (newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap) {
        return;
      }

      update(obj = newObj);
    } else {
      remove();
    }
  };
}

module.exports = function (list, options) {
  options = options || {}; // Force single-tag solution on IE6-9, which has a hard limit on the # of <style>
  // tags it will allow on a page

  if (!options.singleton && typeof options.singleton !== 'boolean') {
    options.singleton = isOldIE();
  }

  list = list || [];
  var lastIdentifiers = modulesToDom(list, options);
  return function update(newList) {
    newList = newList || [];

    if (Object.prototype.toString.call(newList) !== '[object Array]') {
      return;
    }

    for (var i = 0; i < lastIdentifiers.length; i++) {
      var identifier = lastIdentifiers[i];
      var index = getIndexByIdentifier(identifier);
      stylesInDom[index].references--;
    }

    var newLastIdentifiers = modulesToDom(newList, options);

    for (var _i = 0; _i < lastIdentifiers.length; _i++) {
      var _identifier = lastIdentifiers[_i];

      var _index = getIndexByIdentifier(_identifier);

      if (stylesInDom[_index].references === 0) {
        stylesInDom[_index].updater();

        stylesInDom.splice(_index, 1);
      }
    }

    lastIdentifiers = newLastIdentifiers;
  };
};

/***/ }),

/***/ "./node_modules/timers-browserify/main.js":
/*!************************************************!*\
  !*** ./node_modules/timers-browserify/main.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {var scope = typeof global !== "undefined" && global || typeof self !== "undefined" && self || window;
var apply = Function.prototype.apply; // DOM APIs, for completeness

exports.setTimeout = function () {
  return new Timeout(apply.call(setTimeout, scope, arguments), clearTimeout);
};

exports.setInterval = function () {
  return new Timeout(apply.call(setInterval, scope, arguments), clearInterval);
};

exports.clearTimeout = exports.clearInterval = function (timeout) {
  if (timeout) {
    timeout.close();
  }
};

function Timeout(id, clearFn) {
  this._id = id;
  this._clearFn = clearFn;
}

Timeout.prototype.unref = Timeout.prototype.ref = function () {};

Timeout.prototype.close = function () {
  this._clearFn.call(scope, this._id);
}; // Does not start the time, just sets up the members needed.


exports.enroll = function (item, msecs) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = msecs;
};

exports.unenroll = function (item) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = -1;
};

exports._unrefActive = exports.active = function (item) {
  clearTimeout(item._idleTimeoutId);
  var msecs = item._idleTimeout;

  if (msecs >= 0) {
    item._idleTimeoutId = setTimeout(function onTimeout() {
      if (item._onTimeout) item._onTimeout();
    }, msecs);
  }
}; // setimmediate attaches itself to the global object


__webpack_require__(/*! setimmediate */ "./node_modules/setimmediate/setImmediate.js"); // On some exotic environments, it's not clear which object `setimmediate` was
// able to install onto.  Search each possibility in the same order as the
// `setimmediate` library.


exports.setImmediate = typeof self !== "undefined" && self.setImmediate || typeof global !== "undefined" && global.setImmediate || this && this.setImmediate;
exports.clearImmediate = typeof self !== "undefined" && self.clearImmediate || typeof global !== "undefined" && global.clearImmediate || this && this.clearImmediate;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/vue-loader/lib/loaders/templateLoader.js?!./node_modules/vue-loader/lib/index.js?!./src/components/main/main.vue?vue&type=template&id=5e2104ef&":
/*!***************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib??vue-loader-options!./src/components/main/main.vue?vue&type=template&id=5e2104ef& ***!
  \***************************************************************************************************************************************************************************************************/
/*! exports provided: render, staticRenderFns */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "render", function() { return render; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "staticRenderFns", function() { return staticRenderFns; });
var render = function () {
  var _vm = this
  var _h = _vm.$createElement
  var _c = _vm._self._c || _h
  return _c("div", { staticClass: "main" }, [
    _c("div", { staticClass: "todo-app" }, [
      _c("div", { staticClass: "chelik-input" }, [
        _c("div", [
          _vm._v("\n              Ð¤Ð°Ð¼Ð¸Ð»Ð¸Ñ Ñ‡ÐµÐ»Ð¸ÐºÐ°: "),
          _c("input", {
            directives: [
              {
                name: "model",
                rawName: "v-model",
                value: _vm.nameSecond,
                expression: "nameSecond",
              },
            ],
            domProps: { value: _vm.nameSecond },
            on: {
              input: function ($event) {
                if ($event.target.composing) {
                  return
                }
                _vm.nameSecond = $event.target.value
              },
            },
          }),
        ]),
        _vm._v(" "),
        _c("div", [
          _vm._v("\n              Ð˜Ð¼Ñ Ñ‡ÐµÐ»Ð¸ÐºÐ°: "),
          _c("input", {
            directives: [
              {
                name: "model",
                rawName: "v-model",
                value: _vm.nameFirst,
                expression: "nameFirst",
              },
            ],
            domProps: { value: _vm.nameFirst },
            on: {
              input: function ($event) {
                if ($event.target.composing) {
                  return
                }
                _vm.nameFirst = $event.target.value
              },
            },
          }),
        ]),
        _vm._v(" "),
        _c("div", [
          _vm._v("\n              ÐžÑ‚Ñ‡ÐµÑÑ‚Ð²Ð¾ Ñ‡ÐµÐ»Ð¸ÐºÐ°: "),
          _c("input", {
            directives: [
              {
                name: "model",
                rawName: "v-model",
                value: _vm.nameLast,
                expression: "nameLast",
              },
            ],
            domProps: { value: _vm.nameLast },
            on: {
              input: function ($event) {
                if ($event.target.composing) {
                  return
                }
                _vm.nameLast = $event.target.value
              },
            },
          }),
        ]),
        _vm._v(" "),
        _c("div", [
          _vm._v("\n              Ð’Ð¾Ð·Ñ€Ð°ÑÑ‚ Ñ‡ÐµÐ»Ð¸ÐºÐ°: "),
          _c("input", {
            directives: [
              {
                name: "model",
                rawName: "v-model",
                value: _vm.age,
                expression: "age",
              },
            ],
            domProps: { value: _vm.age },
            on: {
              input: function ($event) {
                if ($event.target.composing) {
                  return
                }
                _vm.age = $event.target.value
              },
            },
          }),
        ]),
      ]),
      _vm._v(" "),
      _c("button", { on: { click: _vm.addNew } }, [_vm._v("Ð”Ð¾Ð±Ð°Ð²Ð¸Ñ‚ÑŒ")]),
      _vm._v(" "),
      _c("button", { on: { click: _vm.clearInput } }, [_vm._v("ÐžÑ‡Ð¸ÑÐ¸Ñ‚ÑŒ Ð²Ð²Ð¾Ð´")]),
      _vm._v(" "),
      _vm.showFromLocal
        ? _c("div", { staticClass: "chelik-table" }, [
            _c(
              "div",
              { staticClass: "chelik-info__wrap" },
              [
                _c("div", { staticClass: "chelik-info__title" }, [
                  _vm._v("Ð—Ð°Ð¿Ð¾Ð¼Ð½ÐµÐ½Ð¾"),
                ]),
                _vm._v(" "),
                _vm._m(0),
                _vm._v(" "),
                _c(
                  "draggable",
                  {
                    staticClass: "chelik-info__list",
                    attrs: {
                      group: "peoples",
                      tag: "div",
                      "ghost-class": "moving-item",
                    },
                    model: {
                      value: _vm.peoples,
                      callback: function ($$v) {
                        _vm.peoples = $$v
                      },
                      expression: "peoples",
                    },
                  },
                  _vm._l(_vm.peoples, function (chelik, index) {
                    return _c(
                      "div",
                      {
                        key: chelik.nameFirst,
                        staticClass: "chelik-info__item",
                      },
                      [
                        _c("div", { staticClass: "chelik-info__item-index" }, [
                          _vm._v(_vm._s(index + 1)),
                        ]),
                        _vm._v(" "),
                        _c("div", { staticClass: "chelik-info__item-name" }, [
                          chelik.nameSecond
                            ? _c("span", [
                                _vm._v(" " + _vm._s(chelik.nameSecond)),
                              ])
                            : _vm._e(),
                          _vm._v(" "),
                          chelik.nameFirst
                            ? _c("span", [_vm._v(_vm._s(chelik.nameFirst))])
                            : _vm._e(),
                          _vm._v(" "),
                          chelik.nameLast
                            ? _c("span", [
                                _vm._v(" " + _vm._s(chelik.nameLast)),
                              ])
                            : _vm._e(),
                        ]),
                        _vm._v(" "),
                        _c("div", { staticClass: "chelik-info__item-age" }, [
                          chelik.savedAge
                            ? _c("span", [_vm._v(_vm._s(chelik.savedAge))])
                            : _vm._e(),
                        ]),
                        _vm._v(" "),
                        _c("div", { staticClass: "chelik-info__item-del" }, [
                          _c(
                            "button",
                            {
                              on: {
                                click: function ($event) {
                                  return _vm.deleteChelik(index)
                                },
                              },
                            },
                            [_vm._v("X")]
                          ),
                        ]),
                      ]
                    )
                  }),
                  0
                ),
              ],
              1
            ),
            _vm._v(" "),
            _c("button", { on: { click: _vm.clearLocal } }, [
              _vm._v("ÐžÑ‡Ð¸ÑÑ‚Ð¸Ñ‚ÑŒ"),
            ]),
          ])
        : _vm._e(),
    ]),
  ])
}
var staticRenderFns = [
  function () {
    var _vm = this
    var _h = _vm.$createElement
    var _c = _vm._self._c || _h
    return _c("div", { staticClass: "chelik-info__properties-list" }, [
      _c("div", { staticClass: "chelik-info__properties-index" }, [
        _vm._v("ÐÐ¾Ð¼ÐµÑ€:"),
      ]),
      _vm._v(" "),
      _c("div", { staticClass: "chelik-info__properties-name" }, [
        _vm._v("Ð¤Ð˜Ðž:"),
      ]),
      _vm._v(" "),
      _c("div", { staticClass: "chelik-info__properties-age" }, [
        _vm._v("Ð’Ð¾Ð·Ñ€Ð°ÑÑ‚:"),
      ]),
      _vm._v(" "),
      _c("div", { staticClass: "chelik-info__properties-blank" }),
    ])
  },
]
render._withStripped = true



/***/ }),

/***/ "./node_modules/vue-loader/lib/runtime/componentNormalizer.js":
/*!********************************************************************!*\
  !*** ./node_modules/vue-loader/lib/runtime/componentNormalizer.js ***!
  \********************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return normalizeComponent; });
/* globals __VUE_SSR_CONTEXT__ */

// IMPORTANT: Do NOT use ES2015 features in this file (except for modules).
// This module is a runtime utility for cleaner component module output and will
// be included in the final webpack user bundle.

function normalizeComponent (
  scriptExports,
  render,
  staticRenderFns,
  functionalTemplate,
  injectStyles,
  scopeId,
  moduleIdentifier, /* server only */
  shadowMode /* vue-cli only */
) {
  // Vue.extend constructor export interop
  var options = typeof scriptExports === 'function'
    ? scriptExports.options
    : scriptExports

  // render functions
  if (render) {
    options.render = render
    options.staticRenderFns = staticRenderFns
    options._compiled = true
  }

  // functional template
  if (functionalTemplate) {
    options.functional = true
  }

  // scopedId
  if (scopeId) {
    options._scopeId = 'data-v-' + scopeId
  }

  var hook
  if (moduleIdentifier) { // server build
    hook = function (context) {
      // 2.3 injection
      context =
        context || // cached call
        (this.$vnode && this.$vnode.ssrContext) || // stateful
        (this.parent && this.parent.$vnode && this.parent.$vnode.ssrContext) // functional
      // 2.2 with runInNewContext: true
      if (!context && typeof __VUE_SSR_CONTEXT__ !== 'undefined') {
        context = __VUE_SSR_CONTEXT__
      }
      // inject component styles
      if (injectStyles) {
        injectStyles.call(this, context)
      }
      // register component module identifier for async chunk inferrence
      if (context && context._registeredComponents) {
        context._registeredComponents.add(moduleIdentifier)
      }
    }
    // used by ssr in case component is cached and beforeCreate
    // never gets called
    options._ssrRegister = hook
  } else if (injectStyles) {
    hook = shadowMode
      ? function () {
        injectStyles.call(
          this,
          (options.functional ? this.parent : this).$root.$options.shadowRoot
        )
      }
      : injectStyles
  }

  if (hook) {
    if (options.functional) {
      // for template-only hot-reload because in that case the render fn doesn't
      // go through the normalizer
      options._injectStyles = hook
      // register for functional component in vue file
      var originalRender = options.render
      options.render = function renderWithStyleInjection (h, context) {
        hook.call(context)
        return originalRender(h, context)
      }
    } else {
      // inject component registration as beforeCreate hook
      var existing = options.beforeCreate
      options.beforeCreate = existing
        ? [].concat(existing, hook)
        : [hook]
    }
  }

  return {
    exports: scriptExports,
    options: options
  }
}


/***/ }),

/***/ "./node_modules/vue/dist/vue.runtime.esm.js":
/*!**************************************************!*\
  !*** ./node_modules/vue/dist/vue.runtime.esm.js ***!
  \**************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(global, setImmediate) {/*!
 * Vue.js v2.6.14
 * (c) 2014-2021 Evan You
 * Released under the MIT License.
 */

/*  */
var emptyObject = Object.freeze({}); // These helpers produce better VM code in JS engines due to their
// explicitness and function inlining.

function isUndef(v) {
  return v === undefined || v === null;
}

function isDef(v) {
  return v !== undefined && v !== null;
}

function isTrue(v) {
  return v === true;
}

function isFalse(v) {
  return v === false;
}
/**
 * Check if value is primitive.
 */


function isPrimitive(value) {
  return typeof value === 'string' || typeof value === 'number' || // $flow-disable-line
  typeof value === 'symbol' || typeof value === 'boolean';
}
/**
 * Quick object check - this is primarily used to tell
 * Objects from primitive values when we know the value
 * is a JSON-compliant type.
 */


function isObject(obj) {
  return obj !== null && typeof obj === 'object';
}
/**
 * Get the raw type string of a value, e.g., [object Object].
 */


var _toString = Object.prototype.toString;

function toRawType(value) {
  return _toString.call(value).slice(8, -1);
}
/**
 * Strict object type check. Only returns true
 * for plain JavaScript objects.
 */


function isPlainObject(obj) {
  return _toString.call(obj) === '[object Object]';
}

function isRegExp(v) {
  return _toString.call(v) === '[object RegExp]';
}
/**
 * Check if val is a valid array index.
 */


function isValidArrayIndex(val) {
  var n = parseFloat(String(val));
  return n >= 0 && Math.floor(n) === n && isFinite(val);
}

function isPromise(val) {
  return isDef(val) && typeof val.then === 'function' && typeof val.catch === 'function';
}
/**
 * Convert a value to a string that is actually rendered.
 */


function toString(val) {
  return val == null ? '' : Array.isArray(val) || isPlainObject(val) && val.toString === _toString ? JSON.stringify(val, null, 2) : String(val);
}
/**
 * Convert an input value to a number for persistence.
 * If the conversion fails, return original string.
 */


function toNumber(val) {
  var n = parseFloat(val);
  return isNaN(n) ? val : n;
}
/**
 * Make a map and return a function for checking if a key
 * is in that map.
 */


function makeMap(str, expectsLowerCase) {
  var map = Object.create(null);
  var list = str.split(',');

  for (var i = 0; i < list.length; i++) {
    map[list[i]] = true;
  }

  return expectsLowerCase ? function (val) {
    return map[val.toLowerCase()];
  } : function (val) {
    return map[val];
  };
}
/**
 * Check if a tag is a built-in tag.
 */


var isBuiltInTag = makeMap('slot,component', true);
/**
 * Check if an attribute is a reserved attribute.
 */

var isReservedAttribute = makeMap('key,ref,slot,slot-scope,is');
/**
 * Remove an item from an array.
 */

function remove(arr, item) {
  if (arr.length) {
    var index = arr.indexOf(item);

    if (index > -1) {
      return arr.splice(index, 1);
    }
  }
}
/**
 * Check whether an object has the property.
 */


var hasOwnProperty = Object.prototype.hasOwnProperty;

function hasOwn(obj, key) {
  return hasOwnProperty.call(obj, key);
}
/**
 * Create a cached version of a pure function.
 */


function cached(fn) {
  var cache = Object.create(null);
  return function cachedFn(str) {
    var hit = cache[str];
    return hit || (cache[str] = fn(str));
  };
}
/**
 * Camelize a hyphen-delimited string.
 */


var camelizeRE = /-(\w)/g;
var camelize = cached(function (str) {
  return str.replace(camelizeRE, function (_, c) {
    return c ? c.toUpperCase() : '';
  });
});
/**
 * Capitalize a string.
 */

var capitalize = cached(function (str) {
  return str.charAt(0).toUpperCase() + str.slice(1);
});
/**
 * Hyphenate a camelCase string.
 */

var hyphenateRE = /\B([A-Z])/g;
var hyphenate = cached(function (str) {
  return str.replace(hyphenateRE, '-$1').toLowerCase();
});
/**
 * Simple bind polyfill for environments that do not support it,
 * e.g., PhantomJS 1.x. Technically, we don't need this anymore
 * since native bind is now performant enough in most browsers.
 * But removing it would mean breaking code that was able to run in
 * PhantomJS 1.x, so this must be kept for backward compatibility.
 */

/* istanbul ignore next */

function polyfillBind(fn, ctx) {
  function boundFn(a) {
    var l = arguments.length;
    return l ? l > 1 ? fn.apply(ctx, arguments) : fn.call(ctx, a) : fn.call(ctx);
  }

  boundFn._length = fn.length;
  return boundFn;
}

function nativeBind(fn, ctx) {
  return fn.bind(ctx);
}

var bind = Function.prototype.bind ? nativeBind : polyfillBind;
/**
 * Convert an Array-like object to a real Array.
 */

function toArray(list, start) {
  start = start || 0;
  var i = list.length - start;
  var ret = new Array(i);

  while (i--) {
    ret[i] = list[i + start];
  }

  return ret;
}
/**
 * Mix properties into target object.
 */


function extend(to, _from) {
  for (var key in _from) {
    to[key] = _from[key];
  }

  return to;
}
/**
 * Merge an Array of Objects into a single Object.
 */


function toObject(arr) {
  var res = {};

  for (var i = 0; i < arr.length; i++) {
    if (arr[i]) {
      extend(res, arr[i]);
    }
  }

  return res;
}
/* eslint-disable no-unused-vars */

/**
 * Perform no operation.
 * Stubbing args to make Flow happy without leaving useless transpiled code
 * with ...rest (https://flow.org/blog/2017/05/07/Strict-Function-Call-Arity/).
 */


function noop(a, b, c) {}
/**
 * Always return false.
 */


var no = function (a, b, c) {
  return false;
};
/* eslint-enable no-unused-vars */

/**
 * Return the same value.
 */


var identity = function (_) {
  return _;
};
/**
 * Check if two values are loosely equal - that is,
 * if they are plain objects, do they have the same shape?
 */


function looseEqual(a, b) {
  if (a === b) {
    return true;
  }

  var isObjectA = isObject(a);
  var isObjectB = isObject(b);

  if (isObjectA && isObjectB) {
    try {
      var isArrayA = Array.isArray(a);
      var isArrayB = Array.isArray(b);

      if (isArrayA && isArrayB) {
        return a.length === b.length && a.every(function (e, i) {
          return looseEqual(e, b[i]);
        });
      } else if (a instanceof Date && b instanceof Date) {
        return a.getTime() === b.getTime();
      } else if (!isArrayA && !isArrayB) {
        var keysA = Object.keys(a);
        var keysB = Object.keys(b);
        return keysA.length === keysB.length && keysA.every(function (key) {
          return looseEqual(a[key], b[key]);
        });
      } else {
        /* istanbul ignore next */
        return false;
      }
    } catch (e) {
      /* istanbul ignore next */
      return false;
    }
  } else if (!isObjectA && !isObjectB) {
    return String(a) === String(b);
  } else {
    return false;
  }
}
/**
 * Return the first index at which a loosely equal value can be
 * found in the array (if value is a plain object, the array must
 * contain an object of the same shape), or -1 if it is not present.
 */


function looseIndexOf(arr, val) {
  for (var i = 0; i < arr.length; i++) {
    if (looseEqual(arr[i], val)) {
      return i;
    }
  }

  return -1;
}
/**
 * Ensure a function is called only once.
 */


function once(fn) {
  var called = false;
  return function () {
    if (!called) {
      called = true;
      fn.apply(this, arguments);
    }
  };
}

var SSR_ATTR = 'data-server-rendered';
var ASSET_TYPES = ['component', 'directive', 'filter'];
var LIFECYCLE_HOOKS = ['beforeCreate', 'created', 'beforeMount', 'mounted', 'beforeUpdate', 'updated', 'beforeDestroy', 'destroyed', 'activated', 'deactivated', 'errorCaptured', 'serverPrefetch'];
/*  */

var config = {
  /**
   * Option merge strategies (used in core/util/options)
   */
  // $flow-disable-line
  optionMergeStrategies: Object.create(null),

  /**
   * Whether to suppress warnings.
   */
  silent: false,

  /**
   * Show production mode tip message on boot?
   */
  productionTip: "development" !== 'production',

  /**
   * Whether to enable devtools
   */
  devtools: "development" !== 'production',

  /**
   * Whether to record perf
   */
  performance: false,

  /**
   * Error handler for watcher errors
   */
  errorHandler: null,

  /**
   * Warn handler for watcher warns
   */
  warnHandler: null,

  /**
   * Ignore certain custom elements
   */
  ignoredElements: [],

  /**
   * Custom user key aliases for v-on
   */
  // $flow-disable-line
  keyCodes: Object.create(null),

  /**
   * Check if a tag is reserved so that it cannot be registered as a
   * component. This is platform-dependent and may be overwritten.
   */
  isReservedTag: no,

  /**
   * Check if an attribute is reserved so that it cannot be used as a component
   * prop. This is platform-dependent and may be overwritten.
   */
  isReservedAttr: no,

  /**
   * Check if a tag is an unknown element.
   * Platform-dependent.
   */
  isUnknownElement: no,

  /**
   * Get the namespace of an element
   */
  getTagNamespace: noop,

  /**
   * Parse the real tag name for the specific platform.
   */
  parsePlatformTagName: identity,

  /**
   * Check if an attribute must be bound using property, e.g. value
   * Platform-dependent.
   */
  mustUseProp: no,

  /**
   * Perform updates asynchronously. Intended to be used by Vue Test Utils
   * This will significantly reduce performance if set to false.
   */
  async: true,

  /**
   * Exposed for legacy reasons
   */
  _lifecycleHooks: LIFECYCLE_HOOKS
};
/*  */

/**
 * unicode letters used for parsing html tags, component names and property paths.
 * using https://www.w3.org/TR/html53/semantics-scripting.html#potentialcustomelementname
 * skipping \u10000-\uEFFFF due to it freezing up PhantomJS
 */

var unicodeRegExp = /a-zA-Z\u00B7\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u037D\u037F-\u1FFF\u200C-\u200D\u203F-\u2040\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD/;
/**
 * Check if a string starts with $ or _
 */

function isReserved(str) {
  var c = (str + '').charCodeAt(0);
  return c === 0x24 || c === 0x5F;
}
/**
 * Define a property.
 */


function def(obj, key, val, enumerable) {
  Object.defineProperty(obj, key, {
    value: val,
    enumerable: !!enumerable,
    writable: true,
    configurable: true
  });
}
/**
 * Parse simple path.
 */


var bailRE = new RegExp("[^" + unicodeRegExp.source + ".$_\\d]");

function parsePath(path) {
  if (bailRE.test(path)) {
    return;
  }

  var segments = path.split('.');
  return function (obj) {
    for (var i = 0; i < segments.length; i++) {
      if (!obj) {
        return;
      }

      obj = obj[segments[i]];
    }

    return obj;
  };
}
/*  */
// can we use __proto__?


var hasProto = ('__proto__' in {}); // Browser environment sniffing

var inBrowser = typeof window !== 'undefined';
var inWeex = typeof WXEnvironment !== 'undefined' && !!WXEnvironment.platform;
var weexPlatform = inWeex && WXEnvironment.platform.toLowerCase();
var UA = inBrowser && window.navigator.userAgent.toLowerCase();
var isIE = UA && /msie|trident/.test(UA);
var isIE9 = UA && UA.indexOf('msie 9.0') > 0;
var isEdge = UA && UA.indexOf('edge/') > 0;
var isAndroid = UA && UA.indexOf('android') > 0 || weexPlatform === 'android';
var isIOS = UA && /iphone|ipad|ipod|ios/.test(UA) || weexPlatform === 'ios';
var isChrome = UA && /chrome\/\d+/.test(UA) && !isEdge;
var isPhantomJS = UA && /phantomjs/.test(UA);
var isFF = UA && UA.match(/firefox\/(\d+)/); // Firefox has a "watch" function on Object.prototype...

var nativeWatch = {}.watch;
var supportsPassive = false;

if (inBrowser) {
  try {
    var opts = {};
    Object.defineProperty(opts, 'passive', {
      get: function get() {
        /* istanbul ignore next */
        supportsPassive = true;
      }
    }); // https://github.com/facebook/flow/issues/285

    window.addEventListener('test-passive', null, opts);
  } catch (e) {}
} // this needs to be lazy-evaled because vue may be required before
// vue-server-renderer can set VUE_ENV


var _isServer;

var isServerRendering = function () {
  if (_isServer === undefined) {
    /* istanbul ignore if */
    if (!inBrowser && !inWeex && typeof global !== 'undefined') {
      // detect presence of vue-server-renderer and avoid
      // Webpack shimming the process
      _isServer = global['process'] && global['process'].env.VUE_ENV === 'server';
    } else {
      _isServer = false;
    }
  }

  return _isServer;
}; // detect devtools


var devtools = inBrowser && window.__VUE_DEVTOOLS_GLOBAL_HOOK__;
/* istanbul ignore next */

function isNative(Ctor) {
  return typeof Ctor === 'function' && /native code/.test(Ctor.toString());
}

var hasSymbol = typeof Symbol !== 'undefined' && isNative(Symbol) && typeof Reflect !== 'undefined' && isNative(Reflect.ownKeys);

var _Set;
/* istanbul ignore if */
// $flow-disable-line


if (typeof Set !== 'undefined' && isNative(Set)) {
  // use native Set when available.
  _Set = Set;
} else {
  // a non-standard Set polyfill that only works with primitive keys.
  _Set = /*@__PURE__*/function () {
    function Set() {
      this.set = Object.create(null);
    }

    Set.prototype.has = function has(key) {
      return this.set[key] === true;
    };

    Set.prototype.add = function add(key) {
      this.set[key] = true;
    };

    Set.prototype.clear = function clear() {
      this.set = Object.create(null);
    };

    return Set;
  }();
}
/*  */


var warn = noop;
var tip = noop;
var generateComponentTrace = noop; // work around flow check

var formatComponentName = noop;

if (true) {
  var hasConsole = typeof console !== 'undefined';
  var classifyRE = /(?:^|[-_])(\w)/g;

  var classify = function (str) {
    return str.replace(classifyRE, function (c) {
      return c.toUpperCase();
    }).replace(/[-_]/g, '');
  };

  warn = function (msg, vm) {
    var trace = vm ? generateComponentTrace(vm) : '';

    if (config.warnHandler) {
      config.warnHandler.call(null, msg, vm, trace);
    } else if (hasConsole && !config.silent) {
      console.error("[Vue warn]: " + msg + trace);
    }
  };

  tip = function (msg, vm) {
    if (hasConsole && !config.silent) {
      console.warn("[Vue tip]: " + msg + (vm ? generateComponentTrace(vm) : ''));
    }
  };

  formatComponentName = function (vm, includeFile) {
    if (vm.$root === vm) {
      return '<Root>';
    }

    var options = typeof vm === 'function' && vm.cid != null ? vm.options : vm._isVue ? vm.$options || vm.constructor.options : vm;
    var name = options.name || options._componentTag;
    var file = options.__file;

    if (!name && file) {
      var match = file.match(/([^/\\]+)\.vue$/);
      name = match && match[1];
    }

    return (name ? "<" + classify(name) + ">" : "<Anonymous>") + (file && includeFile !== false ? " at " + file : '');
  };

  var repeat = function (str, n) {
    var res = '';

    while (n) {
      if (n % 2 === 1) {
        res += str;
      }

      if (n > 1) {
        str += str;
      }

      n >>= 1;
    }

    return res;
  };

  generateComponentTrace = function (vm) {
    if (vm._isVue && vm.$parent) {
      var tree = [];
      var currentRecursiveSequence = 0;

      while (vm) {
        if (tree.length > 0) {
          var last = tree[tree.length - 1];

          if (last.constructor === vm.constructor) {
            currentRecursiveSequence++;
            vm = vm.$parent;
            continue;
          } else if (currentRecursiveSequence > 0) {
            tree[tree.length - 1] = [last, currentRecursiveSequence];
            currentRecursiveSequence = 0;
          }
        }

        tree.push(vm);
        vm = vm.$parent;
      }

      return '\n\nfound in\n\n' + tree.map(function (vm, i) {
        return "" + (i === 0 ? '---> ' : repeat(' ', 5 + i * 2)) + (Array.isArray(vm) ? formatComponentName(vm[0]) + "... (" + vm[1] + " recursive calls)" : formatComponentName(vm));
      }).join('\n');
    } else {
      return "\n\n(found in " + formatComponentName(vm) + ")";
    }
  };
}
/*  */


var uid = 0;
/**
 * A dep is an observable that can have multiple
 * directives subscribing to it.
 */

var Dep = function Dep() {
  this.id = uid++;
  this.subs = [];
};

Dep.prototype.addSub = function addSub(sub) {
  this.subs.push(sub);
};

Dep.prototype.removeSub = function removeSub(sub) {
  remove(this.subs, sub);
};

Dep.prototype.depend = function depend() {
  if (Dep.target) {
    Dep.target.addDep(this);
  }
};

Dep.prototype.notify = function notify() {
  // stabilize the subscriber list first
  var subs = this.subs.slice();

  if ( true && !config.async) {
    // subs aren't sorted in scheduler if not running async
    // we need to sort them now to make sure they fire in correct
    // order
    subs.sort(function (a, b) {
      return a.id - b.id;
    });
  }

  for (var i = 0, l = subs.length; i < l; i++) {
    subs[i].update();
  }
}; // The current target watcher being evaluated.
// This is globally unique because only one watcher
// can be evaluated at a time.


Dep.target = null;
var targetStack = [];

function pushTarget(target) {
  targetStack.push(target);
  Dep.target = target;
}

function popTarget() {
  targetStack.pop();
  Dep.target = targetStack[targetStack.length - 1];
}
/*  */


var VNode = function VNode(tag, data, children, text, elm, context, componentOptions, asyncFactory) {
  this.tag = tag;
  this.data = data;
  this.children = children;
  this.text = text;
  this.elm = elm;
  this.ns = undefined;
  this.context = context;
  this.fnContext = undefined;
  this.fnOptions = undefined;
  this.fnScopeId = undefined;
  this.key = data && data.key;
  this.componentOptions = componentOptions;
  this.componentInstance = undefined;
  this.parent = undefined;
  this.raw = false;
  this.isStatic = false;
  this.isRootInsert = true;
  this.isComment = false;
  this.isCloned = false;
  this.isOnce = false;
  this.asyncFactory = asyncFactory;
  this.asyncMeta = undefined;
  this.isAsyncPlaceholder = false;
};

var prototypeAccessors = {
  child: {
    configurable: true
  }
}; // DEPRECATED: alias for componentInstance for backwards compat.

/* istanbul ignore next */

prototypeAccessors.child.get = function () {
  return this.componentInstance;
};

Object.defineProperties(VNode.prototype, prototypeAccessors);

var createEmptyVNode = function (text) {
  if (text === void 0) text = '';
  var node = new VNode();
  node.text = text;
  node.isComment = true;
  return node;
};

function createTextVNode(val) {
  return new VNode(undefined, undefined, undefined, String(val));
} // optimized shallow clone
// used for static nodes and slot nodes because they may be reused across
// multiple renders, cloning them avoids errors when DOM manipulations rely
// on their elm reference.


function cloneVNode(vnode) {
  var cloned = new VNode(vnode.tag, vnode.data, // #7975
  // clone children array to avoid mutating original in case of cloning
  // a child.
  vnode.children && vnode.children.slice(), vnode.text, vnode.elm, vnode.context, vnode.componentOptions, vnode.asyncFactory);
  cloned.ns = vnode.ns;
  cloned.isStatic = vnode.isStatic;
  cloned.key = vnode.key;
  cloned.isComment = vnode.isComment;
  cloned.fnContext = vnode.fnContext;
  cloned.fnOptions = vnode.fnOptions;
  cloned.fnScopeId = vnode.fnScopeId;
  cloned.asyncMeta = vnode.asyncMeta;
  cloned.isCloned = true;
  return cloned;
}
/*
 * not type checking this file because flow doesn't play well with
 * dynamically accessing methods on Array prototype
 */


var arrayProto = Array.prototype;
var arrayMethods = Object.create(arrayProto);
var methodsToPatch = ['push', 'pop', 'shift', 'unshift', 'splice', 'sort', 'reverse'];
/**
 * Intercept mutating methods and emit events
 */

methodsToPatch.forEach(function (method) {
  // cache original method
  var original = arrayProto[method];
  def(arrayMethods, method, function mutator() {
    var args = [],
        len = arguments.length;

    while (len--) args[len] = arguments[len];

    var result = original.apply(this, args);
    var ob = this.__ob__;
    var inserted;

    switch (method) {
      case 'push':
      case 'unshift':
        inserted = args;
        break;

      case 'splice':
        inserted = args.slice(2);
        break;
    }

    if (inserted) {
      ob.observeArray(inserted);
    } // notify change


    ob.dep.notify();
    return result;
  });
});
/*  */

var arrayKeys = Object.getOwnPropertyNames(arrayMethods);
/**
 * In some cases we may want to disable observation inside a component's
 * update computation.
 */

var shouldObserve = true;

function toggleObserving(value) {
  shouldObserve = value;
}
/**
 * Observer class that is attached to each observed
 * object. Once attached, the observer converts the target
 * object's property keys into getter/setters that
 * collect dependencies and dispatch updates.
 */


var Observer = function Observer(value) {
  this.value = value;
  this.dep = new Dep();
  this.vmCount = 0;
  def(value, '__ob__', this);

  if (Array.isArray(value)) {
    if (hasProto) {
      protoAugment(value, arrayMethods);
    } else {
      copyAugment(value, arrayMethods, arrayKeys);
    }

    this.observeArray(value);
  } else {
    this.walk(value);
  }
};
/**
 * Walk through all properties and convert them into
 * getter/setters. This method should only be called when
 * value type is Object.
 */


Observer.prototype.walk = function walk(obj) {
  var keys = Object.keys(obj);

  for (var i = 0; i < keys.length; i++) {
    defineReactive$$1(obj, keys[i]);
  }
};
/**
 * Observe a list of Array items.
 */


Observer.prototype.observeArray = function observeArray(items) {
  for (var i = 0, l = items.length; i < l; i++) {
    observe(items[i]);
  }
}; // helpers

/**
 * Augment a target Object or Array by intercepting
 * the prototype chain using __proto__
 */


function protoAugment(target, src) {
  /* eslint-disable no-proto */
  target.__proto__ = src;
  /* eslint-enable no-proto */
}
/**
 * Augment a target Object or Array by defining
 * hidden properties.
 */

/* istanbul ignore next */


function copyAugment(target, src, keys) {
  for (var i = 0, l = keys.length; i < l; i++) {
    var key = keys[i];
    def(target, key, src[key]);
  }
}
/**
 * Attempt to create an observer instance for a value,
 * returns the new observer if successfully observed,
 * or the existing observer if the value already has one.
 */


function observe(value, asRootData) {
  if (!isObject(value) || value instanceof VNode) {
    return;
  }

  var ob;

  if (hasOwn(value, '__ob__') && value.__ob__ instanceof Observer) {
    ob = value.__ob__;
  } else if (shouldObserve && !isServerRendering() && (Array.isArray(value) || isPlainObject(value)) && Object.isExtensible(value) && !value._isVue) {
    ob = new Observer(value);
  }

  if (asRootData && ob) {
    ob.vmCount++;
  }

  return ob;
}
/**
 * Define a reactive property on an Object.
 */


function defineReactive$$1(obj, key, val, customSetter, shallow) {
  var dep = new Dep();
  var property = Object.getOwnPropertyDescriptor(obj, key);

  if (property && property.configurable === false) {
    return;
  } // cater for pre-defined getter/setters


  var getter = property && property.get;
  var setter = property && property.set;

  if ((!getter || setter) && arguments.length === 2) {
    val = obj[key];
  }

  var childOb = !shallow && observe(val);
  Object.defineProperty(obj, key, {
    enumerable: true,
    configurable: true,
    get: function reactiveGetter() {
      var value = getter ? getter.call(obj) : val;

      if (Dep.target) {
        dep.depend();

        if (childOb) {
          childOb.dep.depend();

          if (Array.isArray(value)) {
            dependArray(value);
          }
        }
      }

      return value;
    },
    set: function reactiveSetter(newVal) {
      var value = getter ? getter.call(obj) : val;
      /* eslint-disable no-self-compare */

      if (newVal === value || newVal !== newVal && value !== value) {
        return;
      }
      /* eslint-enable no-self-compare */


      if ( true && customSetter) {
        customSetter();
      } // #7981: for accessor properties without setter


      if (getter && !setter) {
        return;
      }

      if (setter) {
        setter.call(obj, newVal);
      } else {
        val = newVal;
      }

      childOb = !shallow && observe(newVal);
      dep.notify();
    }
  });
}
/**
 * Set a property on an object. Adds the new property and
 * triggers change notification if the property doesn't
 * already exist.
 */


function set(target, key, val) {
  if ( true && (isUndef(target) || isPrimitive(target))) {
    warn("Cannot set reactive property on undefined, null, or primitive value: " + target);
  }

  if (Array.isArray(target) && isValidArrayIndex(key)) {
    target.length = Math.max(target.length, key);
    target.splice(key, 1, val);
    return val;
  }

  if (key in target && !(key in Object.prototype)) {
    target[key] = val;
    return val;
  }

  var ob = target.__ob__;

  if (target._isVue || ob && ob.vmCount) {
     true && warn('Avoid adding reactive properties to a Vue instance or its root $data ' + 'at runtime - declare it upfront in the data option.');
    return val;
  }

  if (!ob) {
    target[key] = val;
    return val;
  }

  defineReactive$$1(ob.value, key, val);
  ob.dep.notify();
  return val;
}
/**
 * Delete a property and trigger change if necessary.
 */


function del(target, key) {
  if ( true && (isUndef(target) || isPrimitive(target))) {
    warn("Cannot delete reactive property on undefined, null, or primitive value: " + target);
  }

  if (Array.isArray(target) && isValidArrayIndex(key)) {
    target.splice(key, 1);
    return;
  }

  var ob = target.__ob__;

  if (target._isVue || ob && ob.vmCount) {
     true && warn('Avoid deleting properties on a Vue instance or its root $data ' + '- just set it to null.');
    return;
  }

  if (!hasOwn(target, key)) {
    return;
  }

  delete target[key];

  if (!ob) {
    return;
  }

  ob.dep.notify();
}
/**
 * Collect dependencies on array elements when the array is touched, since
 * we cannot intercept array element access like property getters.
 */


function dependArray(value) {
  for (var e = void 0, i = 0, l = value.length; i < l; i++) {
    e = value[i];
    e && e.__ob__ && e.__ob__.dep.depend();

    if (Array.isArray(e)) {
      dependArray(e);
    }
  }
}
/*  */

/**
 * Option overwriting strategies are functions that handle
 * how to merge a parent option value and a child option
 * value into the final value.
 */


var strats = config.optionMergeStrategies;
/**
 * Options with restrictions
 */

if (true) {
  strats.el = strats.propsData = function (parent, child, vm, key) {
    if (!vm) {
      warn("option \"" + key + "\" can only be used during instance " + 'creation with the `new` keyword.');
    }

    return defaultStrat(parent, child);
  };
}
/**
 * Helper that recursively merges two data objects together.
 */


function mergeData(to, from) {
  if (!from) {
    return to;
  }

  var key, toVal, fromVal;
  var keys = hasSymbol ? Reflect.ownKeys(from) : Object.keys(from);

  for (var i = 0; i < keys.length; i++) {
    key = keys[i]; // in case the object is already observed...

    if (key === '__ob__') {
      continue;
    }

    toVal = to[key];
    fromVal = from[key];

    if (!hasOwn(to, key)) {
      set(to, key, fromVal);
    } else if (toVal !== fromVal && isPlainObject(toVal) && isPlainObject(fromVal)) {
      mergeData(toVal, fromVal);
    }
  }

  return to;
}
/**
 * Data
 */


function mergeDataOrFn(parentVal, childVal, vm) {
  if (!vm) {
    // in a Vue.extend merge, both should be functions
    if (!childVal) {
      return parentVal;
    }

    if (!parentVal) {
      return childVal;
    } // when parentVal & childVal are both present,
    // we need to return a function that returns the
    // merged result of both functions... no need to
    // check if parentVal is a function here because
    // it has to be a function to pass previous merges.


    return function mergedDataFn() {
      return mergeData(typeof childVal === 'function' ? childVal.call(this, this) : childVal, typeof parentVal === 'function' ? parentVal.call(this, this) : parentVal);
    };
  } else {
    return function mergedInstanceDataFn() {
      // instance merge
      var instanceData = typeof childVal === 'function' ? childVal.call(vm, vm) : childVal;
      var defaultData = typeof parentVal === 'function' ? parentVal.call(vm, vm) : parentVal;

      if (instanceData) {
        return mergeData(instanceData, defaultData);
      } else {
        return defaultData;
      }
    };
  }
}

strats.data = function (parentVal, childVal, vm) {
  if (!vm) {
    if (childVal && typeof childVal !== 'function') {
       true && warn('The "data" option should be a function ' + 'that returns a per-instance value in component ' + 'definitions.', vm);
      return parentVal;
    }

    return mergeDataOrFn(parentVal, childVal);
  }

  return mergeDataOrFn(parentVal, childVal, vm);
};
/**
 * Hooks and props are merged as arrays.
 */


function mergeHook(parentVal, childVal) {
  var res = childVal ? parentVal ? parentVal.concat(childVal) : Array.isArray(childVal) ? childVal : [childVal] : parentVal;
  return res ? dedupeHooks(res) : res;
}

function dedupeHooks(hooks) {
  var res = [];

  for (var i = 0; i < hooks.length; i++) {
    if (res.indexOf(hooks[i]) === -1) {
      res.push(hooks[i]);
    }
  }

  return res;
}

LIFECYCLE_HOOKS.forEach(function (hook) {
  strats[hook] = mergeHook;
});
/**
 * Assets
 *
 * When a vm is present (instance creation), we need to do
 * a three-way merge between constructor options, instance
 * options and parent options.
 */

function mergeAssets(parentVal, childVal, vm, key) {
  var res = Object.create(parentVal || null);

  if (childVal) {
     true && assertObjectType(key, childVal, vm);
    return extend(res, childVal);
  } else {
    return res;
  }
}

ASSET_TYPES.forEach(function (type) {
  strats[type + 's'] = mergeAssets;
});
/**
 * Watchers.
 *
 * Watchers hashes should not overwrite one
 * another, so we merge them as arrays.
 */

strats.watch = function (parentVal, childVal, vm, key) {
  // work around Firefox's Object.prototype.watch...
  if (parentVal === nativeWatch) {
    parentVal = undefined;
  }

  if (childVal === nativeWatch) {
    childVal = undefined;
  }
  /* istanbul ignore if */


  if (!childVal) {
    return Object.create(parentVal || null);
  }

  if (true) {
    assertObjectType(key, childVal, vm);
  }

  if (!parentVal) {
    return childVal;
  }

  var ret = {};
  extend(ret, parentVal);

  for (var key$1 in childVal) {
    var parent = ret[key$1];
    var child = childVal[key$1];

    if (parent && !Array.isArray(parent)) {
      parent = [parent];
    }

    ret[key$1] = parent ? parent.concat(child) : Array.isArray(child) ? child : [child];
  }

  return ret;
};
/**
 * Other object hashes.
 */


strats.props = strats.methods = strats.inject = strats.computed = function (parentVal, childVal, vm, key) {
  if (childVal && "development" !== 'production') {
    assertObjectType(key, childVal, vm);
  }

  if (!parentVal) {
    return childVal;
  }

  var ret = Object.create(null);
  extend(ret, parentVal);

  if (childVal) {
    extend(ret, childVal);
  }

  return ret;
};

strats.provide = mergeDataOrFn;
/**
 * Default strategy.
 */

var defaultStrat = function (parentVal, childVal) {
  return childVal === undefined ? parentVal : childVal;
};
/**
 * Validate component names
 */


function checkComponents(options) {
  for (var key in options.components) {
    validateComponentName(key);
  }
}

function validateComponentName(name) {
  if (!new RegExp("^[a-zA-Z][\\-\\.0-9_" + unicodeRegExp.source + "]*$").test(name)) {
    warn('Invalid component name: "' + name + '". Component names ' + 'should conform to valid custom element name in html5 specification.');
  }

  if (isBuiltInTag(name) || config.isReservedTag(name)) {
    warn('Do not use built-in or reserved HTML elements as component ' + 'id: ' + name);
  }
}
/**
 * Ensure all props option syntax are normalized into the
 * Object-based format.
 */


function normalizeProps(options, vm) {
  var props = options.props;

  if (!props) {
    return;
  }

  var res = {};
  var i, val, name;

  if (Array.isArray(props)) {
    i = props.length;

    while (i--) {
      val = props[i];

      if (typeof val === 'string') {
        name = camelize(val);
        res[name] = {
          type: null
        };
      } else if (true) {
        warn('props must be strings when using array syntax.');
      }
    }
  } else if (isPlainObject(props)) {
    for (var key in props) {
      val = props[key];
      name = camelize(key);
      res[name] = isPlainObject(val) ? val : {
        type: val
      };
    }
  } else if (true) {
    warn("Invalid value for option \"props\": expected an Array or an Object, " + "but got " + toRawType(props) + ".", vm);
  }

  options.props = res;
}
/**
 * Normalize all injections into Object-based format
 */


function normalizeInject(options, vm) {
  var inject = options.inject;

  if (!inject) {
    return;
  }

  var normalized = options.inject = {};

  if (Array.isArray(inject)) {
    for (var i = 0; i < inject.length; i++) {
      normalized[inject[i]] = {
        from: inject[i]
      };
    }
  } else if (isPlainObject(inject)) {
    for (var key in inject) {
      var val = inject[key];
      normalized[key] = isPlainObject(val) ? extend({
        from: key
      }, val) : {
        from: val
      };
    }
  } else if (true) {
    warn("Invalid value for option \"inject\": expected an Array or an Object, " + "but got " + toRawType(inject) + ".", vm);
  }
}
/**
 * Normalize raw function directives into object format.
 */


function normalizeDirectives(options) {
  var dirs = options.directives;

  if (dirs) {
    for (var key in dirs) {
      var def$$1 = dirs[key];

      if (typeof def$$1 === 'function') {
        dirs[key] = {
          bind: def$$1,
          update: def$$1
        };
      }
    }
  }
}

function assertObjectType(name, value, vm) {
  if (!isPlainObject(value)) {
    warn("Invalid value for option \"" + name + "\": expected an Object, " + "but got " + toRawType(value) + ".", vm);
  }
}
/**
 * Merge two option objects into a new one.
 * Core utility used in both instantiation and inheritance.
 */


function mergeOptions(parent, child, vm) {
  if (true) {
    checkComponents(child);
  }

  if (typeof child === 'function') {
    child = child.options;
  }

  normalizeProps(child, vm);
  normalizeInject(child, vm);
  normalizeDirectives(child); // Apply extends and mixins on the child options,
  // but only if it is a raw options object that isn't
  // the result of another mergeOptions call.
  // Only merged options has the _base property.

  if (!child._base) {
    if (child.extends) {
      parent = mergeOptions(parent, child.extends, vm);
    }

    if (child.mixins) {
      for (var i = 0, l = child.mixins.length; i < l; i++) {
        parent = mergeOptions(parent, child.mixins[i], vm);
      }
    }
  }

  var options = {};
  var key;

  for (key in parent) {
    mergeField(key);
  }

  for (key in child) {
    if (!hasOwn(parent, key)) {
      mergeField(key);
    }
  }

  function mergeField(key) {
    var strat = strats[key] || defaultStrat;
    options[key] = strat(parent[key], child[key], vm, key);
  }

  return options;
}
/**
 * Resolve an asset.
 * This function is used because child instances need access
 * to assets defined in its ancestor chain.
 */


function resolveAsset(options, type, id, warnMissing) {
  /* istanbul ignore if */
  if (typeof id !== 'string') {
    return;
  }

  var assets = options[type]; // check local registration variations first

  if (hasOwn(assets, id)) {
    return assets[id];
  }

  var camelizedId = camelize(id);

  if (hasOwn(assets, camelizedId)) {
    return assets[camelizedId];
  }

  var PascalCaseId = capitalize(camelizedId);

  if (hasOwn(assets, PascalCaseId)) {
    return assets[PascalCaseId];
  } // fallback to prototype chain


  var res = assets[id] || assets[camelizedId] || assets[PascalCaseId];

  if ( true && warnMissing && !res) {
    warn('Failed to resolve ' + type.slice(0, -1) + ': ' + id, options);
  }

  return res;
}
/*  */


function validateProp(key, propOptions, propsData, vm) {
  var prop = propOptions[key];
  var absent = !hasOwn(propsData, key);
  var value = propsData[key]; // boolean casting

  var booleanIndex = getTypeIndex(Boolean, prop.type);

  if (booleanIndex > -1) {
    if (absent && !hasOwn(prop, 'default')) {
      value = false;
    } else if (value === '' || value === hyphenate(key)) {
      // only cast empty string / same name to boolean if
      // boolean has higher priority
      var stringIndex = getTypeIndex(String, prop.type);

      if (stringIndex < 0 || booleanIndex < stringIndex) {
        value = true;
      }
    }
  } // check default value


  if (value === undefined) {
    value = getPropDefaultValue(vm, prop, key); // since the default value is a fresh copy,
    // make sure to observe it.

    var prevShouldObserve = shouldObserve;
    toggleObserving(true);
    observe(value);
    toggleObserving(prevShouldObserve);
  }

  if (true) {
    assertProp(prop, key, value, vm, absent);
  }

  return value;
}
/**
 * Get the default value of a prop.
 */


function getPropDefaultValue(vm, prop, key) {
  // no default, return undefined
  if (!hasOwn(prop, 'default')) {
    return undefined;
  }

  var def = prop.default; // warn against non-factory defaults for Object & Array

  if ( true && isObject(def)) {
    warn('Invalid default value for prop "' + key + '": ' + 'Props with type Object/Array must use a factory function ' + 'to return the default value.', vm);
  } // the raw prop value was also undefined from previous render,
  // return previous default value to avoid unnecessary watcher trigger


  if (vm && vm.$options.propsData && vm.$options.propsData[key] === undefined && vm._props[key] !== undefined) {
    return vm._props[key];
  } // call factory function for non-Function types
  // a value is Function if its prototype is function even across different execution context


  return typeof def === 'function' && getType(prop.type) !== 'Function' ? def.call(vm) : def;
}
/**
 * Assert whether a prop is valid.
 */


function assertProp(prop, name, value, vm, absent) {
  if (prop.required && absent) {
    warn('Missing required prop: "' + name + '"', vm);
    return;
  }

  if (value == null && !prop.required) {
    return;
  }

  var type = prop.type;
  var valid = !type || type === true;
  var expectedTypes = [];

  if (type) {
    if (!Array.isArray(type)) {
      type = [type];
    }

    for (var i = 0; i < type.length && !valid; i++) {
      var assertedType = assertType(value, type[i], vm);
      expectedTypes.push(assertedType.expectedType || '');
      valid = assertedType.valid;
    }
  }

  var haveExpectedTypes = expectedTypes.some(function (t) {
    return t;
  });

  if (!valid && haveExpectedTypes) {
    warn(getInvalidTypeMessage(name, value, expectedTypes), vm);
    return;
  }

  var validator = prop.validator;

  if (validator) {
    if (!validator(value)) {
      warn('Invalid prop: custom validator check failed for prop "' + name + '".', vm);
    }
  }
}

var simpleCheckRE = /^(String|Number|Boolean|Function|Symbol|BigInt)$/;

function assertType(value, type, vm) {
  var valid;
  var expectedType = getType(type);

  if (simpleCheckRE.test(expectedType)) {
    var t = typeof value;
    valid = t === expectedType.toLowerCase(); // for primitive wrapper objects

    if (!valid && t === 'object') {
      valid = value instanceof type;
    }
  } else if (expectedType === 'Object') {
    valid = isPlainObject(value);
  } else if (expectedType === 'Array') {
    valid = Array.isArray(value);
  } else {
    try {
      valid = value instanceof type;
    } catch (e) {
      warn('Invalid prop type: "' + String(type) + '" is not a constructor', vm);
      valid = false;
    }
  }

  return {
    valid: valid,
    expectedType: expectedType
  };
}

var functionTypeCheckRE = /^\s*function (\w+)/;
/**
 * Use function string name to check built-in types,
 * because a simple equality check will fail when running
 * across different vms / iframes.
 */

function getType(fn) {
  var match = fn && fn.toString().match(functionTypeCheckRE);
  return match ? match[1] : '';
}

function isSameType(a, b) {
  return getType(a) === getType(b);
}

function getTypeIndex(type, expectedTypes) {
  if (!Array.isArray(expectedTypes)) {
    return isSameType(expectedTypes, type) ? 0 : -1;
  }

  for (var i = 0, len = expectedTypes.length; i < len; i++) {
    if (isSameType(expectedTypes[i], type)) {
      return i;
    }
  }

  return -1;
}

function getInvalidTypeMessage(name, value, expectedTypes) {
  var message = "Invalid prop: type check failed for prop \"" + name + "\"." + " Expected " + expectedTypes.map(capitalize).join(', ');
  var expectedType = expectedTypes[0];
  var receivedType = toRawType(value); // check if we need to specify expected value

  if (expectedTypes.length === 1 && isExplicable(expectedType) && isExplicable(typeof value) && !isBoolean(expectedType, receivedType)) {
    message += " with value " + styleValue(value, expectedType);
  }

  message += ", got " + receivedType + " "; // check if we need to specify received value

  if (isExplicable(receivedType)) {
    message += "with value " + styleValue(value, receivedType) + ".";
  }

  return message;
}

function styleValue(value, type) {
  if (type === 'String') {
    return "\"" + value + "\"";
  } else if (type === 'Number') {
    return "" + Number(value);
  } else {
    return "" + value;
  }
}

var EXPLICABLE_TYPES = ['string', 'number', 'boolean'];

function isExplicable(value) {
  return EXPLICABLE_TYPES.some(function (elem) {
    return value.toLowerCase() === elem;
  });
}

function isBoolean() {
  var args = [],
      len = arguments.length;

  while (len--) args[len] = arguments[len];

  return args.some(function (elem) {
    return elem.toLowerCase() === 'boolean';
  });
}
/*  */


function handleError(err, vm, info) {
  // Deactivate deps tracking while processing error handler to avoid possible infinite rendering.
  // See: https://github.com/vuejs/vuex/issues/1505
  pushTarget();

  try {
    if (vm) {
      var cur = vm;

      while (cur = cur.$parent) {
        var hooks = cur.$options.errorCaptured;

        if (hooks) {
          for (var i = 0; i < hooks.length; i++) {
            try {
              var capture = hooks[i].call(cur, err, vm, info) === false;

              if (capture) {
                return;
              }
            } catch (e) {
              globalHandleError(e, cur, 'errorCaptured hook');
            }
          }
        }
      }
    }

    globalHandleError(err, vm, info);
  } finally {
    popTarget();
  }
}

function invokeWithErrorHandling(handler, context, args, vm, info) {
  var res;

  try {
    res = args ? handler.apply(context, args) : handler.call(context);

    if (res && !res._isVue && isPromise(res) && !res._handled) {
      res.catch(function (e) {
        return handleError(e, vm, info + " (Promise/async)");
      }); // issue #9511
      // avoid catch triggering multiple times when nested calls

      res._handled = true;
    }
  } catch (e) {
    handleError(e, vm, info);
  }

  return res;
}

function globalHandleError(err, vm, info) {
  if (config.errorHandler) {
    try {
      return config.errorHandler.call(null, err, vm, info);
    } catch (e) {
      // if the user intentionally throws the original error in the handler,
      // do not log it twice
      if (e !== err) {
        logError(e, null, 'config.errorHandler');
      }
    }
  }

  logError(err, vm, info);
}

function logError(err, vm, info) {
  if (true) {
    warn("Error in " + info + ": \"" + err.toString() + "\"", vm);
  }
  /* istanbul ignore else */


  if ((inBrowser || inWeex) && typeof console !== 'undefined') {
    console.error(err);
  } else {
    throw err;
  }
}
/*  */


var isUsingMicroTask = false;
var callbacks = [];
var pending = false;

function flushCallbacks() {
  pending = false;
  var copies = callbacks.slice(0);
  callbacks.length = 0;

  for (var i = 0; i < copies.length; i++) {
    copies[i]();
  }
} // Here we have async deferring wrappers using microtasks.
// In 2.5 we used (macro) tasks (in combination with microtasks).
// However, it has subtle problems when state is changed right before repaint
// (e.g. #6813, out-in transitions).
// Also, using (macro) tasks in event handler would cause some weird behaviors
// that cannot be circumvented (e.g. #7109, #7153, #7546, #7834, #8109).
// So we now use microtasks everywhere, again.
// A major drawback of this tradeoff is that there are some scenarios
// where microtasks have too high a priority and fire in between supposedly
// sequential events (e.g. #4521, #6690, which have workarounds)
// or even between bubbling of the same event (#6566).


var timerFunc; // The nextTick behavior leverages the microtask queue, which can be accessed
// via either native Promise.then or MutationObserver.
// MutationObserver has wider support, however it is seriously bugged in
// UIWebView in iOS >= 9.3.3 when triggered in touch event handlers. It
// completely stops working after triggering a few times... so, if native
// Promise is available, we will use it:

/* istanbul ignore next, $flow-disable-line */

if (typeof Promise !== 'undefined' && isNative(Promise)) {
  var p = Promise.resolve();

  timerFunc = function () {
    p.then(flushCallbacks); // In problematic UIWebViews, Promise.then doesn't completely break, but
    // it can get stuck in a weird state where callbacks are pushed into the
    // microtask queue but the queue isn't being flushed, until the browser
    // needs to do some other work, e.g. handle a timer. Therefore we can
    // "force" the microtask queue to be flushed by adding an empty timer.

    if (isIOS) {
      setTimeout(noop);
    }
  };

  isUsingMicroTask = true;
} else if (!isIE && typeof MutationObserver !== 'undefined' && (isNative(MutationObserver) || // PhantomJS and iOS 7.x
MutationObserver.toString() === '[object MutationObserverConstructor]')) {
  // Use MutationObserver where native Promise is not available,
  // e.g. PhantomJS, iOS7, Android 4.4
  // (#6466 MutationObserver is unreliable in IE11)
  var counter = 1;
  var observer = new MutationObserver(flushCallbacks);
  var textNode = document.createTextNode(String(counter));
  observer.observe(textNode, {
    characterData: true
  });

  timerFunc = function () {
    counter = (counter + 1) % 2;
    textNode.data = String(counter);
  };

  isUsingMicroTask = true;
} else if (typeof setImmediate !== 'undefined' && isNative(setImmediate)) {
  // Fallback to setImmediate.
  // Technically it leverages the (macro) task queue,
  // but it is still a better choice than setTimeout.
  timerFunc = function () {
    setImmediate(flushCallbacks);
  };
} else {
  // Fallback to setTimeout.
  timerFunc = function () {
    setTimeout(flushCallbacks, 0);
  };
}

function nextTick(cb, ctx) {
  var _resolve;

  callbacks.push(function () {
    if (cb) {
      try {
        cb.call(ctx);
      } catch (e) {
        handleError(e, ctx, 'nextTick');
      }
    } else if (_resolve) {
      _resolve(ctx);
    }
  });

  if (!pending) {
    pending = true;
    timerFunc();
  } // $flow-disable-line


  if (!cb && typeof Promise !== 'undefined') {
    return new Promise(function (resolve) {
      _resolve = resolve;
    });
  }
}
/*  */

/* not type checking this file because flow doesn't play well with Proxy */


var initProxy;

if (true) {
  var allowedGlobals = makeMap('Infinity,undefined,NaN,isFinite,isNaN,' + 'parseFloat,parseInt,decodeURI,decodeURIComponent,encodeURI,encodeURIComponent,' + 'Math,Number,Date,Array,Object,Boolean,String,RegExp,Map,Set,JSON,Intl,BigInt,' + 'require' // for Webpack/Browserify
  );

  var warnNonPresent = function (target, key) {
    warn("Property or method \"" + key + "\" is not defined on the instance but " + 'referenced during render. Make sure that this property is reactive, ' + 'either in the data option, or for class-based components, by ' + 'initializing the property. ' + 'See: https://vuejs.org/v2/guide/reactivity.html#Declaring-Reactive-Properties.', target);
  };

  var warnReservedPrefix = function (target, key) {
    warn("Property \"" + key + "\" must be accessed with \"$data." + key + "\" because " + 'properties starting with "$" or "_" are not proxied in the Vue instance to ' + 'prevent conflicts with Vue internals. ' + 'See: https://vuejs.org/v2/api/#data', target);
  };

  var hasProxy = typeof Proxy !== 'undefined' && isNative(Proxy);

  if (hasProxy) {
    var isBuiltInModifier = makeMap('stop,prevent,self,ctrl,shift,alt,meta,exact');
    config.keyCodes = new Proxy(config.keyCodes, {
      set: function set(target, key, value) {
        if (isBuiltInModifier(key)) {
          warn("Avoid overwriting built-in modifier in config.keyCodes: ." + key);
          return false;
        } else {
          target[key] = value;
          return true;
        }
      }
    });
  }

  var hasHandler = {
    has: function has(target, key) {
      var has = (key in target);
      var isAllowed = allowedGlobals(key) || typeof key === 'string' && key.charAt(0) === '_' && !(key in target.$data);

      if (!has && !isAllowed) {
        if (key in target.$data) {
          warnReservedPrefix(target, key);
        } else {
          warnNonPresent(target, key);
        }
      }

      return has || !isAllowed;
    }
  };
  var getHandler = {
    get: function get(target, key) {
      if (typeof key === 'string' && !(key in target)) {
        if (key in target.$data) {
          warnReservedPrefix(target, key);
        } else {
          warnNonPresent(target, key);
        }
      }

      return target[key];
    }
  };

  initProxy = function initProxy(vm) {
    if (hasProxy) {
      // determine which proxy handler to use
      var options = vm.$options;
      var handlers = options.render && options.render._withStripped ? getHandler : hasHandler;
      vm._renderProxy = new Proxy(vm, handlers);
    } else {
      vm._renderProxy = vm;
    }
  };
}
/*  */


var seenObjects = new _Set();
/**
 * Recursively traverse an object to evoke all converted
 * getters, so that every nested property inside the object
 * is collected as a "deep" dependency.
 */

function traverse(val) {
  _traverse(val, seenObjects);

  seenObjects.clear();
}

function _traverse(val, seen) {
  var i, keys;
  var isA = Array.isArray(val);

  if (!isA && !isObject(val) || Object.isFrozen(val) || val instanceof VNode) {
    return;
  }

  if (val.__ob__) {
    var depId = val.__ob__.dep.id;

    if (seen.has(depId)) {
      return;
    }

    seen.add(depId);
  }

  if (isA) {
    i = val.length;

    while (i--) {
      _traverse(val[i], seen);
    }
  } else {
    keys = Object.keys(val);
    i = keys.length;

    while (i--) {
      _traverse(val[keys[i]], seen);
    }
  }
}

var mark;
var measure;

if (true) {
  var perf = inBrowser && window.performance;
  /* istanbul ignore if */

  if (perf && perf.mark && perf.measure && perf.clearMarks && perf.clearMeasures) {
    mark = function (tag) {
      return perf.mark(tag);
    };

    measure = function (name, startTag, endTag) {
      perf.measure(name, startTag, endTag);
      perf.clearMarks(startTag);
      perf.clearMarks(endTag); // perf.clearMeasures(name)
    };
  }
}
/*  */


var normalizeEvent = cached(function (name) {
  var passive = name.charAt(0) === '&';
  name = passive ? name.slice(1) : name;
  var once$$1 = name.charAt(0) === '~'; // Prefixed last, checked first

  name = once$$1 ? name.slice(1) : name;
  var capture = name.charAt(0) === '!';
  name = capture ? name.slice(1) : name;
  return {
    name: name,
    once: once$$1,
    capture: capture,
    passive: passive
  };
});

function createFnInvoker(fns, vm) {
  function invoker() {
    var arguments$1 = arguments;
    var fns = invoker.fns;

    if (Array.isArray(fns)) {
      var cloned = fns.slice();

      for (var i = 0; i < cloned.length; i++) {
        invokeWithErrorHandling(cloned[i], null, arguments$1, vm, "v-on handler");
      }
    } else {
      // return handler return value for single handlers
      return invokeWithErrorHandling(fns, null, arguments, vm, "v-on handler");
    }
  }

  invoker.fns = fns;
  return invoker;
}

function updateListeners(on, oldOn, add, remove$$1, createOnceHandler, vm) {
  var name, def$$1, cur, old, event;

  for (name in on) {
    def$$1 = cur = on[name];
    old = oldOn[name];
    event = normalizeEvent(name);

    if (isUndef(cur)) {
       true && warn("Invalid handler for event \"" + event.name + "\": got " + String(cur), vm);
    } else if (isUndef(old)) {
      if (isUndef(cur.fns)) {
        cur = on[name] = createFnInvoker(cur, vm);
      }

      if (isTrue(event.once)) {
        cur = on[name] = createOnceHandler(event.name, cur, event.capture);
      }

      add(event.name, cur, event.capture, event.passive, event.params);
    } else if (cur !== old) {
      old.fns = cur;
      on[name] = old;
    }
  }

  for (name in oldOn) {
    if (isUndef(on[name])) {
      event = normalizeEvent(name);
      remove$$1(event.name, oldOn[name], event.capture);
    }
  }
}
/*  */


function mergeVNodeHook(def, hookKey, hook) {
  if (def instanceof VNode) {
    def = def.data.hook || (def.data.hook = {});
  }

  var invoker;
  var oldHook = def[hookKey];

  function wrappedHook() {
    hook.apply(this, arguments); // important: remove merged hook to ensure it's called only once
    // and prevent memory leak

    remove(invoker.fns, wrappedHook);
  }

  if (isUndef(oldHook)) {
    // no existing hook
    invoker = createFnInvoker([wrappedHook]);
  } else {
    /* istanbul ignore if */
    if (isDef(oldHook.fns) && isTrue(oldHook.merged)) {
      // already a merged invoker
      invoker = oldHook;
      invoker.fns.push(wrappedHook);
    } else {
      // existing plain hook
      invoker = createFnInvoker([oldHook, wrappedHook]);
    }
  }

  invoker.merged = true;
  def[hookKey] = invoker;
}
/*  */


function extractPropsFromVNodeData(data, Ctor, tag) {
  // we are only extracting raw values here.
  // validation and default values are handled in the child
  // component itself.
  var propOptions = Ctor.options.props;

  if (isUndef(propOptions)) {
    return;
  }

  var res = {};
  var attrs = data.attrs;
  var props = data.props;

  if (isDef(attrs) || isDef(props)) {
    for (var key in propOptions) {
      var altKey = hyphenate(key);

      if (true) {
        var keyInLowerCase = key.toLowerCase();

        if (key !== keyInLowerCase && attrs && hasOwn(attrs, keyInLowerCase)) {
          tip("Prop \"" + keyInLowerCase + "\" is passed to component " + formatComponentName(tag || Ctor) + ", but the declared prop name is" + " \"" + key + "\". " + "Note that HTML attributes are case-insensitive and camelCased " + "props need to use their kebab-case equivalents when using in-DOM " + "templates. You should probably use \"" + altKey + "\" instead of \"" + key + "\".");
        }
      }

      checkProp(res, props, key, altKey, true) || checkProp(res, attrs, key, altKey, false);
    }
  }

  return res;
}

function checkProp(res, hash, key, altKey, preserve) {
  if (isDef(hash)) {
    if (hasOwn(hash, key)) {
      res[key] = hash[key];

      if (!preserve) {
        delete hash[key];
      }

      return true;
    } else if (hasOwn(hash, altKey)) {
      res[key] = hash[altKey];

      if (!preserve) {
        delete hash[altKey];
      }

      return true;
    }
  }

  return false;
}
/*  */
// The template compiler attempts to minimize the need for normalization by
// statically analyzing the template at compile time.
//
// For plain HTML markup, normalization can be completely skipped because the
// generated render function is guaranteed to return Array<VNode>. There are
// two cases where extra normalization is needed:
// 1. When the children contains components - because a functional component
// may return an Array instead of a single root. In this case, just a simple
// normalization is needed - if any child is an Array, we flatten the whole
// thing with Array.prototype.concat. It is guaranteed to be only 1-level deep
// because functional components already normalize their own children.


function simpleNormalizeChildren(children) {
  for (var i = 0; i < children.length; i++) {
    if (Array.isArray(children[i])) {
      return Array.prototype.concat.apply([], children);
    }
  }

  return children;
} // 2. When the children contains constructs that always generated nested Arrays,
// e.g. <template>, <slot>, v-for, or when the children is provided by user
// with hand-written render functions / JSX. In such cases a full normalization
// is needed to cater to all possible types of children values.


function normalizeChildren(children) {
  return isPrimitive(children) ? [createTextVNode(children)] : Array.isArray(children) ? normalizeArrayChildren(children) : undefined;
}

function isTextNode(node) {
  return isDef(node) && isDef(node.text) && isFalse(node.isComment);
}

function normalizeArrayChildren(children, nestedIndex) {
  var res = [];
  var i, c, lastIndex, last;

  for (i = 0; i < children.length; i++) {
    c = children[i];

    if (isUndef(c) || typeof c === 'boolean') {
      continue;
    }

    lastIndex = res.length - 1;
    last = res[lastIndex]; //  nested

    if (Array.isArray(c)) {
      if (c.length > 0) {
        c = normalizeArrayChildren(c, (nestedIndex || '') + "_" + i); // merge adjacent text nodes

        if (isTextNode(c[0]) && isTextNode(last)) {
          res[lastIndex] = createTextVNode(last.text + c[0].text);
          c.shift();
        }

        res.push.apply(res, c);
      }
    } else if (isPrimitive(c)) {
      if (isTextNode(last)) {
        // merge adjacent text nodes
        // this is necessary for SSR hydration because text nodes are
        // essentially merged when rendered to HTML strings
        res[lastIndex] = createTextVNode(last.text + c);
      } else if (c !== '') {
        // convert primitive to vnode
        res.push(createTextVNode(c));
      }
    } else {
      if (isTextNode(c) && isTextNode(last)) {
        // merge adjacent text nodes
        res[lastIndex] = createTextVNode(last.text + c.text);
      } else {
        // default key for nested array children (likely generated by v-for)
        if (isTrue(children._isVList) && isDef(c.tag) && isUndef(c.key) && isDef(nestedIndex)) {
          c.key = "__vlist" + nestedIndex + "_" + i + "__";
        }

        res.push(c);
      }
    }
  }

  return res;
}
/*  */


function initProvide(vm) {
  var provide = vm.$options.provide;

  if (provide) {
    vm._provided = typeof provide === 'function' ? provide.call(vm) : provide;
  }
}

function initInjections(vm) {
  var result = resolveInject(vm.$options.inject, vm);

  if (result) {
    toggleObserving(false);
    Object.keys(result).forEach(function (key) {
      /* istanbul ignore else */
      if (true) {
        defineReactive$$1(vm, key, result[key], function () {
          warn("Avoid mutating an injected value directly since the changes will be " + "overwritten whenever the provided component re-renders. " + "injection being mutated: \"" + key + "\"", vm);
        });
      } else {}
    });
    toggleObserving(true);
  }
}

function resolveInject(inject, vm) {
  if (inject) {
    // inject is :any because flow is not smart enough to figure out cached
    var result = Object.create(null);
    var keys = hasSymbol ? Reflect.ownKeys(inject) : Object.keys(inject);

    for (var i = 0; i < keys.length; i++) {
      var key = keys[i]; // #6574 in case the inject object is observed...

      if (key === '__ob__') {
        continue;
      }

      var provideKey = inject[key].from;
      var source = vm;

      while (source) {
        if (source._provided && hasOwn(source._provided, provideKey)) {
          result[key] = source._provided[provideKey];
          break;
        }

        source = source.$parent;
      }

      if (!source) {
        if ('default' in inject[key]) {
          var provideDefault = inject[key].default;
          result[key] = typeof provideDefault === 'function' ? provideDefault.call(vm) : provideDefault;
        } else if (true) {
          warn("Injection \"" + key + "\" not found", vm);
        }
      }
    }

    return result;
  }
}
/*  */

/**
 * Runtime helper for resolving raw children VNodes into a slot object.
 */


function resolveSlots(children, context) {
  if (!children || !children.length) {
    return {};
  }

  var slots = {};

  for (var i = 0, l = children.length; i < l; i++) {
    var child = children[i];
    var data = child.data; // remove slot attribute if the node is resolved as a Vue slot node

    if (data && data.attrs && data.attrs.slot) {
      delete data.attrs.slot;
    } // named slots should only be respected if the vnode was rendered in the
    // same context.


    if ((child.context === context || child.fnContext === context) && data && data.slot != null) {
      var name = data.slot;
      var slot = slots[name] || (slots[name] = []);

      if (child.tag === 'template') {
        slot.push.apply(slot, child.children || []);
      } else {
        slot.push(child);
      }
    } else {
      (slots.default || (slots.default = [])).push(child);
    }
  } // ignore slots that contains only whitespace


  for (var name$1 in slots) {
    if (slots[name$1].every(isWhitespace)) {
      delete slots[name$1];
    }
  }

  return slots;
}

function isWhitespace(node) {
  return node.isComment && !node.asyncFactory || node.text === ' ';
}
/*  */


function isAsyncPlaceholder(node) {
  return node.isComment && node.asyncFactory;
}
/*  */


function normalizeScopedSlots(slots, normalSlots, prevSlots) {
  var res;
  var hasNormalSlots = Object.keys(normalSlots).length > 0;
  var isStable = slots ? !!slots.$stable : !hasNormalSlots;
  var key = slots && slots.$key;

  if (!slots) {
    res = {};
  } else if (slots._normalized) {
    // fast path 1: child component re-render only, parent did not change
    return slots._normalized;
  } else if (isStable && prevSlots && prevSlots !== emptyObject && key === prevSlots.$key && !hasNormalSlots && !prevSlots.$hasNormal) {
    // fast path 2: stable scoped slots w/ no normal slots to proxy,
    // only need to normalize once
    return prevSlots;
  } else {
    res = {};

    for (var key$1 in slots) {
      if (slots[key$1] && key$1[0] !== '$') {
        res[key$1] = normalizeScopedSlot(normalSlots, key$1, slots[key$1]);
      }
    }
  } // expose normal slots on scopedSlots


  for (var key$2 in normalSlots) {
    if (!(key$2 in res)) {
      res[key$2] = proxyNormalSlot(normalSlots, key$2);
    }
  } // avoriaz seems to mock a non-extensible $scopedSlots object
  // and when that is passed down this would cause an error


  if (slots && Object.isExtensible(slots)) {
    slots._normalized = res;
  }

  def(res, '$stable', isStable);
  def(res, '$key', key);
  def(res, '$hasNormal', hasNormalSlots);
  return res;
}

function normalizeScopedSlot(normalSlots, key, fn) {
  var normalized = function () {
    var res = arguments.length ? fn.apply(null, arguments) : fn({});
    res = res && typeof res === 'object' && !Array.isArray(res) ? [res] // single vnode
    : normalizeChildren(res);
    var vnode = res && res[0];
    return res && (!vnode || res.length === 1 && vnode.isComment && !isAsyncPlaceholder(vnode) // #9658, #10391
    ) ? undefined : res;
  }; // this is a slot using the new v-slot syntax without scope. although it is
  // compiled as a scoped slot, render fn users would expect it to be present
  // on this.$slots because the usage is semantically a normal slot.


  if (fn.proxy) {
    Object.defineProperty(normalSlots, key, {
      get: normalized,
      enumerable: true,
      configurable: true
    });
  }

  return normalized;
}

function proxyNormalSlot(slots, key) {
  return function () {
    return slots[key];
  };
}
/*  */

/**
 * Runtime helper for rendering v-for lists.
 */


function renderList(val, render) {
  var ret, i, l, keys, key;

  if (Array.isArray(val) || typeof val === 'string') {
    ret = new Array(val.length);

    for (i = 0, l = val.length; i < l; i++) {
      ret[i] = render(val[i], i);
    }
  } else if (typeof val === 'number') {
    ret = new Array(val);

    for (i = 0; i < val; i++) {
      ret[i] = render(i + 1, i);
    }
  } else if (isObject(val)) {
    if (hasSymbol && val[Symbol.iterator]) {
      ret = [];
      var iterator = val[Symbol.iterator]();
      var result = iterator.next();

      while (!result.done) {
        ret.push(render(result.value, ret.length));
        result = iterator.next();
      }
    } else {
      keys = Object.keys(val);
      ret = new Array(keys.length);

      for (i = 0, l = keys.length; i < l; i++) {
        key = keys[i];
        ret[i] = render(val[key], key, i);
      }
    }
  }

  if (!isDef(ret)) {
    ret = [];
  }

  ret._isVList = true;
  return ret;
}
/*  */

/**
 * Runtime helper for rendering <slot>
 */


function renderSlot(name, fallbackRender, props, bindObject) {
  var scopedSlotFn = this.$scopedSlots[name];
  var nodes;

  if (scopedSlotFn) {
    // scoped slot
    props = props || {};

    if (bindObject) {
      if ( true && !isObject(bindObject)) {
        warn('slot v-bind without argument expects an Object', this);
      }

      props = extend(extend({}, bindObject), props);
    }

    nodes = scopedSlotFn(props) || (typeof fallbackRender === 'function' ? fallbackRender() : fallbackRender);
  } else {
    nodes = this.$slots[name] || (typeof fallbackRender === 'function' ? fallbackRender() : fallbackRender);
  }

  var target = props && props.slot;

  if (target) {
    return this.$createElement('template', {
      slot: target
    }, nodes);
  } else {
    return nodes;
  }
}
/*  */

/**
 * Runtime helper for resolving filters
 */


function resolveFilter(id) {
  return resolveAsset(this.$options, 'filters', id, true) || identity;
}
/*  */


function isKeyNotMatch(expect, actual) {
  if (Array.isArray(expect)) {
    return expect.indexOf(actual) === -1;
  } else {
    return expect !== actual;
  }
}
/**
 * Runtime helper for checking keyCodes from config.
 * exposed as Vue.prototype._k
 * passing in eventKeyName as last argument separately for backwards compat
 */


function checkKeyCodes(eventKeyCode, key, builtInKeyCode, eventKeyName, builtInKeyName) {
  var mappedKeyCode = config.keyCodes[key] || builtInKeyCode;

  if (builtInKeyName && eventKeyName && !config.keyCodes[key]) {
    return isKeyNotMatch(builtInKeyName, eventKeyName);
  } else if (mappedKeyCode) {
    return isKeyNotMatch(mappedKeyCode, eventKeyCode);
  } else if (eventKeyName) {
    return hyphenate(eventKeyName) !== key;
  }

  return eventKeyCode === undefined;
}
/*  */

/**
 * Runtime helper for merging v-bind="object" into a VNode's data.
 */


function bindObjectProps(data, tag, value, asProp, isSync) {
  if (value) {
    if (!isObject(value)) {
       true && warn('v-bind without argument expects an Object or Array value', this);
    } else {
      if (Array.isArray(value)) {
        value = toObject(value);
      }

      var hash;

      var loop = function (key) {
        if (key === 'class' || key === 'style' || isReservedAttribute(key)) {
          hash = data;
        } else {
          var type = data.attrs && data.attrs.type;
          hash = asProp || config.mustUseProp(tag, type, key) ? data.domProps || (data.domProps = {}) : data.attrs || (data.attrs = {});
        }

        var camelizedKey = camelize(key);
        var hyphenatedKey = hyphenate(key);

        if (!(camelizedKey in hash) && !(hyphenatedKey in hash)) {
          hash[key] = value[key];

          if (isSync) {
            var on = data.on || (data.on = {});

            on["update:" + key] = function ($event) {
              value[key] = $event;
            };
          }
        }
      };

      for (var key in value) loop(key);
    }
  }

  return data;
}
/*  */

/**
 * Runtime helper for rendering static trees.
 */


function renderStatic(index, isInFor) {
  var cached = this._staticTrees || (this._staticTrees = []);
  var tree = cached[index]; // if has already-rendered static tree and not inside v-for,
  // we can reuse the same tree.

  if (tree && !isInFor) {
    return tree;
  } // otherwise, render a fresh tree.


  tree = cached[index] = this.$options.staticRenderFns[index].call(this._renderProxy, null, this // for render fns generated for functional component templates
  );
  markStatic(tree, "__static__" + index, false);
  return tree;
}
/**
 * Runtime helper for v-once.
 * Effectively it means marking the node as static with a unique key.
 */


function markOnce(tree, index, key) {
  markStatic(tree, "__once__" + index + (key ? "_" + key : ""), true);
  return tree;
}

function markStatic(tree, key, isOnce) {
  if (Array.isArray(tree)) {
    for (var i = 0; i < tree.length; i++) {
      if (tree[i] && typeof tree[i] !== 'string') {
        markStaticNode(tree[i], key + "_" + i, isOnce);
      }
    }
  } else {
    markStaticNode(tree, key, isOnce);
  }
}

function markStaticNode(node, key, isOnce) {
  node.isStatic = true;
  node.key = key;
  node.isOnce = isOnce;
}
/*  */


function bindObjectListeners(data, value) {
  if (value) {
    if (!isPlainObject(value)) {
       true && warn('v-on without argument expects an Object value', this);
    } else {
      var on = data.on = data.on ? extend({}, data.on) : {};

      for (var key in value) {
        var existing = on[key];
        var ours = value[key];
        on[key] = existing ? [].concat(existing, ours) : ours;
      }
    }
  }

  return data;
}
/*  */


function resolveScopedSlots(fns, // see flow/vnode
res, // the following are added in 2.6
hasDynamicKeys, contentHashKey) {
  res = res || {
    $stable: !hasDynamicKeys
  };

  for (var i = 0; i < fns.length; i++) {
    var slot = fns[i];

    if (Array.isArray(slot)) {
      resolveScopedSlots(slot, res, hasDynamicKeys);
    } else if (slot) {
      // marker for reverse proxying v-slot without scope on this.$slots
      if (slot.proxy) {
        slot.fn.proxy = true;
      }

      res[slot.key] = slot.fn;
    }
  }

  if (contentHashKey) {
    res.$key = contentHashKey;
  }

  return res;
}
/*  */


function bindDynamicKeys(baseObj, values) {
  for (var i = 0; i < values.length; i += 2) {
    var key = values[i];

    if (typeof key === 'string' && key) {
      baseObj[values[i]] = values[i + 1];
    } else if ( true && key !== '' && key !== null) {
      // null is a special value for explicitly removing a binding
      warn("Invalid value for dynamic directive argument (expected string or null): " + key, this);
    }
  }

  return baseObj;
} // helper to dynamically append modifier runtime markers to event names.
// ensure only append when value is already string, otherwise it will be cast
// to string and cause the type check to miss.


function prependModifier(value, symbol) {
  return typeof value === 'string' ? symbol + value : value;
}
/*  */


function installRenderHelpers(target) {
  target._o = markOnce;
  target._n = toNumber;
  target._s = toString;
  target._l = renderList;
  target._t = renderSlot;
  target._q = looseEqual;
  target._i = looseIndexOf;
  target._m = renderStatic;
  target._f = resolveFilter;
  target._k = checkKeyCodes;
  target._b = bindObjectProps;
  target._v = createTextVNode;
  target._e = createEmptyVNode;
  target._u = resolveScopedSlots;
  target._g = bindObjectListeners;
  target._d = bindDynamicKeys;
  target._p = prependModifier;
}
/*  */


function FunctionalRenderContext(data, props, children, parent, Ctor) {
  var this$1 = this;
  var options = Ctor.options; // ensure the createElement function in functional components
  // gets a unique context - this is necessary for correct named slot check

  var contextVm;

  if (hasOwn(parent, '_uid')) {
    contextVm = Object.create(parent); // $flow-disable-line

    contextVm._original = parent;
  } else {
    // the context vm passed in is a functional context as well.
    // in this case we want to make sure we are able to get a hold to the
    // real context instance.
    contextVm = parent; // $flow-disable-line

    parent = parent._original;
  }

  var isCompiled = isTrue(options._compiled);
  var needNormalization = !isCompiled;
  this.data = data;
  this.props = props;
  this.children = children;
  this.parent = parent;
  this.listeners = data.on || emptyObject;
  this.injections = resolveInject(options.inject, parent);

  this.slots = function () {
    if (!this$1.$slots) {
      normalizeScopedSlots(data.scopedSlots, this$1.$slots = resolveSlots(children, parent));
    }

    return this$1.$slots;
  };

  Object.defineProperty(this, 'scopedSlots', {
    enumerable: true,
    get: function get() {
      return normalizeScopedSlots(data.scopedSlots, this.slots());
    }
  }); // support for compiled functional template

  if (isCompiled) {
    // exposing $options for renderStatic()
    this.$options = options; // pre-resolve slots for renderSlot()

    this.$slots = this.slots();
    this.$scopedSlots = normalizeScopedSlots(data.scopedSlots, this.$slots);
  }

  if (options._scopeId) {
    this._c = function (a, b, c, d) {
      var vnode = createElement(contextVm, a, b, c, d, needNormalization);

      if (vnode && !Array.isArray(vnode)) {
        vnode.fnScopeId = options._scopeId;
        vnode.fnContext = parent;
      }

      return vnode;
    };
  } else {
    this._c = function (a, b, c, d) {
      return createElement(contextVm, a, b, c, d, needNormalization);
    };
  }
}

installRenderHelpers(FunctionalRenderContext.prototype);

function createFunctionalComponent(Ctor, propsData, data, contextVm, children) {
  var options = Ctor.options;
  var props = {};
  var propOptions = options.props;

  if (isDef(propOptions)) {
    for (var key in propOptions) {
      props[key] = validateProp(key, propOptions, propsData || emptyObject);
    }
  } else {
    if (isDef(data.attrs)) {
      mergeProps(props, data.attrs);
    }

    if (isDef(data.props)) {
      mergeProps(props, data.props);
    }
  }

  var renderContext = new FunctionalRenderContext(data, props, children, contextVm, Ctor);
  var vnode = options.render.call(null, renderContext._c, renderContext);

  if (vnode instanceof VNode) {
    return cloneAndMarkFunctionalResult(vnode, data, renderContext.parent, options, renderContext);
  } else if (Array.isArray(vnode)) {
    var vnodes = normalizeChildren(vnode) || [];
    var res = new Array(vnodes.length);

    for (var i = 0; i < vnodes.length; i++) {
      res[i] = cloneAndMarkFunctionalResult(vnodes[i], data, renderContext.parent, options, renderContext);
    }

    return res;
  }
}

function cloneAndMarkFunctionalResult(vnode, data, contextVm, options, renderContext) {
  // #7817 clone node before setting fnContext, otherwise if the node is reused
  // (e.g. it was from a cached normal slot) the fnContext causes named slots
  // that should not be matched to match.
  var clone = cloneVNode(vnode);
  clone.fnContext = contextVm;
  clone.fnOptions = options;

  if (true) {
    (clone.devtoolsMeta = clone.devtoolsMeta || {}).renderContext = renderContext;
  }

  if (data.slot) {
    (clone.data || (clone.data = {})).slot = data.slot;
  }

  return clone;
}

function mergeProps(to, from) {
  for (var key in from) {
    to[camelize(key)] = from[key];
  }
}
/*  */

/*  */

/*  */

/*  */
// inline hooks to be invoked on component VNodes during patch


var componentVNodeHooks = {
  init: function init(vnode, hydrating) {
    if (vnode.componentInstance && !vnode.componentInstance._isDestroyed && vnode.data.keepAlive) {
      // kept-alive components, treat as a patch
      var mountedNode = vnode; // work around flow

      componentVNodeHooks.prepatch(mountedNode, mountedNode);
    } else {
      var child = vnode.componentInstance = createComponentInstanceForVnode(vnode, activeInstance);
      child.$mount(hydrating ? vnode.elm : undefined, hydrating);
    }
  },
  prepatch: function prepatch(oldVnode, vnode) {
    var options = vnode.componentOptions;
    var child = vnode.componentInstance = oldVnode.componentInstance;
    updateChildComponent(child, options.propsData, // updated props
    options.listeners, // updated listeners
    vnode, // new parent vnode
    options.children // new children
    );
  },
  insert: function insert(vnode) {
    var context = vnode.context;
    var componentInstance = vnode.componentInstance;

    if (!componentInstance._isMounted) {
      componentInstance._isMounted = true;
      callHook(componentInstance, 'mounted');
    }

    if (vnode.data.keepAlive) {
      if (context._isMounted) {
        // vue-router#1212
        // During updates, a kept-alive component's child components may
        // change, so directly walking the tree here may call activated hooks
        // on incorrect children. Instead we push them into a queue which will
        // be processed after the whole patch process ended.
        queueActivatedComponent(componentInstance);
      } else {
        activateChildComponent(componentInstance, true
        /* direct */
        );
      }
    }
  },
  destroy: function destroy(vnode) {
    var componentInstance = vnode.componentInstance;

    if (!componentInstance._isDestroyed) {
      if (!vnode.data.keepAlive) {
        componentInstance.$destroy();
      } else {
        deactivateChildComponent(componentInstance, true
        /* direct */
        );
      }
    }
  }
};
var hooksToMerge = Object.keys(componentVNodeHooks);

function createComponent(Ctor, data, context, children, tag) {
  if (isUndef(Ctor)) {
    return;
  }

  var baseCtor = context.$options._base; // plain options object: turn it into a constructor

  if (isObject(Ctor)) {
    Ctor = baseCtor.extend(Ctor);
  } // if at this stage it's not a constructor or an async component factory,
  // reject.


  if (typeof Ctor !== 'function') {
    if (true) {
      warn("Invalid Component definition: " + String(Ctor), context);
    }

    return;
  } // async component


  var asyncFactory;

  if (isUndef(Ctor.cid)) {
    asyncFactory = Ctor;
    Ctor = resolveAsyncComponent(asyncFactory, baseCtor);

    if (Ctor === undefined) {
      // return a placeholder node for async component, which is rendered
      // as a comment node but preserves all the raw information for the node.
      // the information will be used for async server-rendering and hydration.
      return createAsyncPlaceholder(asyncFactory, data, context, children, tag);
    }
  }

  data = data || {}; // resolve constructor options in case global mixins are applied after
  // component constructor creation

  resolveConstructorOptions(Ctor); // transform component v-model data into props & events

  if (isDef(data.model)) {
    transformModel(Ctor.options, data);
  } // extract props


  var propsData = extractPropsFromVNodeData(data, Ctor, tag); // functional component

  if (isTrue(Ctor.options.functional)) {
    return createFunctionalComponent(Ctor, propsData, data, context, children);
  } // extract listeners, since these needs to be treated as
  // child component listeners instead of DOM listeners


  var listeners = data.on; // replace with listeners with .native modifier
  // so it gets processed during parent component patch.

  data.on = data.nativeOn;

  if (isTrue(Ctor.options.abstract)) {
    // abstract components do not keep anything
    // other than props & listeners & slot
    // work around flow
    var slot = data.slot;
    data = {};

    if (slot) {
      data.slot = slot;
    }
  } // install component management hooks onto the placeholder node


  installComponentHooks(data); // return a placeholder vnode

  var name = Ctor.options.name || tag;
  var vnode = new VNode("vue-component-" + Ctor.cid + (name ? "-" + name : ''), data, undefined, undefined, undefined, context, {
    Ctor: Ctor,
    propsData: propsData,
    listeners: listeners,
    tag: tag,
    children: children
  }, asyncFactory);
  return vnode;
}

function createComponentInstanceForVnode( // we know it's MountedComponentVNode but flow doesn't
vnode, // activeInstance in lifecycle state
parent) {
  var options = {
    _isComponent: true,
    _parentVnode: vnode,
    parent: parent
  }; // check inline-template render functions

  var inlineTemplate = vnode.data.inlineTemplate;

  if (isDef(inlineTemplate)) {
    options.render = inlineTemplate.render;
    options.staticRenderFns = inlineTemplate.staticRenderFns;
  }

  return new vnode.componentOptions.Ctor(options);
}

function installComponentHooks(data) {
  var hooks = data.hook || (data.hook = {});

  for (var i = 0; i < hooksToMerge.length; i++) {
    var key = hooksToMerge[i];
    var existing = hooks[key];
    var toMerge = componentVNodeHooks[key];

    if (existing !== toMerge && !(existing && existing._merged)) {
      hooks[key] = existing ? mergeHook$1(toMerge, existing) : toMerge;
    }
  }
}

function mergeHook$1(f1, f2) {
  var merged = function (a, b) {
    // flow complains about extra args which is why we use any
    f1(a, b);
    f2(a, b);
  };

  merged._merged = true;
  return merged;
} // transform component v-model info (value and callback) into
// prop and event handler respectively.


function transformModel(options, data) {
  var prop = options.model && options.model.prop || 'value';
  var event = options.model && options.model.event || 'input';
  (data.attrs || (data.attrs = {}))[prop] = data.model.value;
  var on = data.on || (data.on = {});
  var existing = on[event];
  var callback = data.model.callback;

  if (isDef(existing)) {
    if (Array.isArray(existing) ? existing.indexOf(callback) === -1 : existing !== callback) {
      on[event] = [callback].concat(existing);
    }
  } else {
    on[event] = callback;
  }
}
/*  */


var SIMPLE_NORMALIZE = 1;
var ALWAYS_NORMALIZE = 2; // wrapper function for providing a more flexible interface
// without getting yelled at by flow

function createElement(context, tag, data, children, normalizationType, alwaysNormalize) {
  if (Array.isArray(data) || isPrimitive(data)) {
    normalizationType = children;
    children = data;
    data = undefined;
  }

  if (isTrue(alwaysNormalize)) {
    normalizationType = ALWAYS_NORMALIZE;
  }

  return _createElement(context, tag, data, children, normalizationType);
}

function _createElement(context, tag, data, children, normalizationType) {
  if (isDef(data) && isDef(data.__ob__)) {
     true && warn("Avoid using observed data object as vnode data: " + JSON.stringify(data) + "\n" + 'Always create fresh vnode data objects in each render!', context);
    return createEmptyVNode();
  } // object syntax in v-bind


  if (isDef(data) && isDef(data.is)) {
    tag = data.is;
  }

  if (!tag) {
    // in case of component :is set to falsy value
    return createEmptyVNode();
  } // warn against non-primitive key


  if ( true && isDef(data) && isDef(data.key) && !isPrimitive(data.key)) {
    {
      warn('Avoid using non-primitive value as key, ' + 'use string/number value instead.', context);
    }
  } // support single function children as default scoped slot


  if (Array.isArray(children) && typeof children[0] === 'function') {
    data = data || {};
    data.scopedSlots = {
      default: children[0]
    };
    children.length = 0;
  }

  if (normalizationType === ALWAYS_NORMALIZE) {
    children = normalizeChildren(children);
  } else if (normalizationType === SIMPLE_NORMALIZE) {
    children = simpleNormalizeChildren(children);
  }

  var vnode, ns;

  if (typeof tag === 'string') {
    var Ctor;
    ns = context.$vnode && context.$vnode.ns || config.getTagNamespace(tag);

    if (config.isReservedTag(tag)) {
      // platform built-in elements
      if ( true && isDef(data) && isDef(data.nativeOn) && data.tag !== 'component') {
        warn("The .native modifier for v-on is only valid on components but it was used on <" + tag + ">.", context);
      }

      vnode = new VNode(config.parsePlatformTagName(tag), data, children, undefined, undefined, context);
    } else if ((!data || !data.pre) && isDef(Ctor = resolveAsset(context.$options, 'components', tag))) {
      // component
      vnode = createComponent(Ctor, data, context, children, tag);
    } else {
      // unknown or unlisted namespaced elements
      // check at runtime because it may get assigned a namespace when its
      // parent normalizes children
      vnode = new VNode(tag, data, children, undefined, undefined, context);
    }
  } else {
    // direct component options / constructor
    vnode = createComponent(tag, data, context, children);
  }

  if (Array.isArray(vnode)) {
    return vnode;
  } else if (isDef(vnode)) {
    if (isDef(ns)) {
      applyNS(vnode, ns);
    }

    if (isDef(data)) {
      registerDeepBindings(data);
    }

    return vnode;
  } else {
    return createEmptyVNode();
  }
}

function applyNS(vnode, ns, force) {
  vnode.ns = ns;

  if (vnode.tag === 'foreignObject') {
    // use default namespace inside foreignObject
    ns = undefined;
    force = true;
  }

  if (isDef(vnode.children)) {
    for (var i = 0, l = vnode.children.length; i < l; i++) {
      var child = vnode.children[i];

      if (isDef(child.tag) && (isUndef(child.ns) || isTrue(force) && child.tag !== 'svg')) {
        applyNS(child, ns, force);
      }
    }
  }
} // ref #5318
// necessary to ensure parent re-render when deep bindings like :style and
// :class are used on slot nodes


function registerDeepBindings(data) {
  if (isObject(data.style)) {
    traverse(data.style);
  }

  if (isObject(data.class)) {
    traverse(data.class);
  }
}
/*  */


function initRender(vm) {
  vm._vnode = null; // the root of the child tree

  vm._staticTrees = null; // v-once cached trees

  var options = vm.$options;
  var parentVnode = vm.$vnode = options._parentVnode; // the placeholder node in parent tree

  var renderContext = parentVnode && parentVnode.context;
  vm.$slots = resolveSlots(options._renderChildren, renderContext);
  vm.$scopedSlots = emptyObject; // bind the createElement fn to this instance
  // so that we get proper render context inside it.
  // args order: tag, data, children, normalizationType, alwaysNormalize
  // internal version is used by render functions compiled from templates

  vm._c = function (a, b, c, d) {
    return createElement(vm, a, b, c, d, false);
  }; // normalization is always applied for the public version, used in
  // user-written render functions.


  vm.$createElement = function (a, b, c, d) {
    return createElement(vm, a, b, c, d, true);
  }; // $attrs & $listeners are exposed for easier HOC creation.
  // they need to be reactive so that HOCs using them are always updated


  var parentData = parentVnode && parentVnode.data;
  /* istanbul ignore else */

  if (true) {
    defineReactive$$1(vm, '$attrs', parentData && parentData.attrs || emptyObject, function () {
      !isUpdatingChildComponent && warn("$attrs is readonly.", vm);
    }, true);
    defineReactive$$1(vm, '$listeners', options._parentListeners || emptyObject, function () {
      !isUpdatingChildComponent && warn("$listeners is readonly.", vm);
    }, true);
  } else {}
}

var currentRenderingInstance = null;

function renderMixin(Vue) {
  // install runtime convenience helpers
  installRenderHelpers(Vue.prototype);

  Vue.prototype.$nextTick = function (fn) {
    return nextTick(fn, this);
  };

  Vue.prototype._render = function () {
    var vm = this;
    var ref = vm.$options;
    var render = ref.render;
    var _parentVnode = ref._parentVnode;

    if (_parentVnode) {
      vm.$scopedSlots = normalizeScopedSlots(_parentVnode.data.scopedSlots, vm.$slots, vm.$scopedSlots);
    } // set parent vnode. this allows render functions to have access
    // to the data on the placeholder node.


    vm.$vnode = _parentVnode; // render self

    var vnode;

    try {
      // There's no need to maintain a stack because all render fns are called
      // separately from one another. Nested component's render fns are called
      // when parent component is patched.
      currentRenderingInstance = vm;
      vnode = render.call(vm._renderProxy, vm.$createElement);
    } catch (e) {
      handleError(e, vm, "render"); // return error render result,
      // or previous vnode to prevent render error causing blank component

      /* istanbul ignore else */

      if ( true && vm.$options.renderError) {
        try {
          vnode = vm.$options.renderError.call(vm._renderProxy, vm.$createElement, e);
        } catch (e) {
          handleError(e, vm, "renderError");
          vnode = vm._vnode;
        }
      } else {
        vnode = vm._vnode;
      }
    } finally {
      currentRenderingInstance = null;
    } // if the returned array contains only a single node, allow it


    if (Array.isArray(vnode) && vnode.length === 1) {
      vnode = vnode[0];
    } // return empty vnode in case the render function errored out


    if (!(vnode instanceof VNode)) {
      if ( true && Array.isArray(vnode)) {
        warn('Multiple root nodes returned from render function. Render function ' + 'should return a single root node.', vm);
      }

      vnode = createEmptyVNode();
    } // set parent


    vnode.parent = _parentVnode;
    return vnode;
  };
}
/*  */


function ensureCtor(comp, base) {
  if (comp.__esModule || hasSymbol && comp[Symbol.toStringTag] === 'Module') {
    comp = comp.default;
  }

  return isObject(comp) ? base.extend(comp) : comp;
}

function createAsyncPlaceholder(factory, data, context, children, tag) {
  var node = createEmptyVNode();
  node.asyncFactory = factory;
  node.asyncMeta = {
    data: data,
    context: context,
    children: children,
    tag: tag
  };
  return node;
}

function resolveAsyncComponent(factory, baseCtor) {
  if (isTrue(factory.error) && isDef(factory.errorComp)) {
    return factory.errorComp;
  }

  if (isDef(factory.resolved)) {
    return factory.resolved;
  }

  var owner = currentRenderingInstance;

  if (owner && isDef(factory.owners) && factory.owners.indexOf(owner) === -1) {
    // already pending
    factory.owners.push(owner);
  }

  if (isTrue(factory.loading) && isDef(factory.loadingComp)) {
    return factory.loadingComp;
  }

  if (owner && !isDef(factory.owners)) {
    var owners = factory.owners = [owner];
    var sync = true;
    var timerLoading = null;
    var timerTimeout = null;
    owner.$on('hook:destroyed', function () {
      return remove(owners, owner);
    });

    var forceRender = function (renderCompleted) {
      for (var i = 0, l = owners.length; i < l; i++) {
        owners[i].$forceUpdate();
      }

      if (renderCompleted) {
        owners.length = 0;

        if (timerLoading !== null) {
          clearTimeout(timerLoading);
          timerLoading = null;
        }

        if (timerTimeout !== null) {
          clearTimeout(timerTimeout);
          timerTimeout = null;
        }
      }
    };

    var resolve = once(function (res) {
      // cache resolved
      factory.resolved = ensureCtor(res, baseCtor); // invoke callbacks only if this is not a synchronous resolve
      // (async resolves are shimmed as synchronous during SSR)

      if (!sync) {
        forceRender(true);
      } else {
        owners.length = 0;
      }
    });
    var reject = once(function (reason) {
       true && warn("Failed to resolve async component: " + String(factory) + (reason ? "\nReason: " + reason : ''));

      if (isDef(factory.errorComp)) {
        factory.error = true;
        forceRender(true);
      }
    });
    var res = factory(resolve, reject);

    if (isObject(res)) {
      if (isPromise(res)) {
        // () => Promise
        if (isUndef(factory.resolved)) {
          res.then(resolve, reject);
        }
      } else if (isPromise(res.component)) {
        res.component.then(resolve, reject);

        if (isDef(res.error)) {
          factory.errorComp = ensureCtor(res.error, baseCtor);
        }

        if (isDef(res.loading)) {
          factory.loadingComp = ensureCtor(res.loading, baseCtor);

          if (res.delay === 0) {
            factory.loading = true;
          } else {
            timerLoading = setTimeout(function () {
              timerLoading = null;

              if (isUndef(factory.resolved) && isUndef(factory.error)) {
                factory.loading = true;
                forceRender(false);
              }
            }, res.delay || 200);
          }
        }

        if (isDef(res.timeout)) {
          timerTimeout = setTimeout(function () {
            timerTimeout = null;

            if (isUndef(factory.resolved)) {
              reject( true ? "timeout (" + res.timeout + "ms)" : undefined);
            }
          }, res.timeout);
        }
      }
    }

    sync = false; // return in case resolved synchronously

    return factory.loading ? factory.loadingComp : factory.resolved;
  }
}
/*  */


function getFirstComponentChild(children) {
  if (Array.isArray(children)) {
    for (var i = 0; i < children.length; i++) {
      var c = children[i];

      if (isDef(c) && (isDef(c.componentOptions) || isAsyncPlaceholder(c))) {
        return c;
      }
    }
  }
}
/*  */

/*  */


function initEvents(vm) {
  vm._events = Object.create(null);
  vm._hasHookEvent = false; // init parent attached events

  var listeners = vm.$options._parentListeners;

  if (listeners) {
    updateComponentListeners(vm, listeners);
  }
}

var target;

function add(event, fn) {
  target.$on(event, fn);
}

function remove$1(event, fn) {
  target.$off(event, fn);
}

function createOnceHandler(event, fn) {
  var _target = target;
  return function onceHandler() {
    var res = fn.apply(null, arguments);

    if (res !== null) {
      _target.$off(event, onceHandler);
    }
  };
}

function updateComponentListeners(vm, listeners, oldListeners) {
  target = vm;
  updateListeners(listeners, oldListeners || {}, add, remove$1, createOnceHandler, vm);
  target = undefined;
}

function eventsMixin(Vue) {
  var hookRE = /^hook:/;

  Vue.prototype.$on = function (event, fn) {
    var vm = this;

    if (Array.isArray(event)) {
      for (var i = 0, l = event.length; i < l; i++) {
        vm.$on(event[i], fn);
      }
    } else {
      (vm._events[event] || (vm._events[event] = [])).push(fn); // optimize hook:event cost by using a boolean flag marked at registration
      // instead of a hash lookup

      if (hookRE.test(event)) {
        vm._hasHookEvent = true;
      }
    }

    return vm;
  };

  Vue.prototype.$once = function (event, fn) {
    var vm = this;

    function on() {
      vm.$off(event, on);
      fn.apply(vm, arguments);
    }

    on.fn = fn;
    vm.$on(event, on);
    return vm;
  };

  Vue.prototype.$off = function (event, fn) {
    var vm = this; // all

    if (!arguments.length) {
      vm._events = Object.create(null);
      return vm;
    } // array of events


    if (Array.isArray(event)) {
      for (var i$1 = 0, l = event.length; i$1 < l; i$1++) {
        vm.$off(event[i$1], fn);
      }

      return vm;
    } // specific event


    var cbs = vm._events[event];

    if (!cbs) {
      return vm;
    }

    if (!fn) {
      vm._events[event] = null;
      return vm;
    } // specific handler


    var cb;
    var i = cbs.length;

    while (i--) {
      cb = cbs[i];

      if (cb === fn || cb.fn === fn) {
        cbs.splice(i, 1);
        break;
      }
    }

    return vm;
  };

  Vue.prototype.$emit = function (event) {
    var vm = this;

    if (true) {
      var lowerCaseEvent = event.toLowerCase();

      if (lowerCaseEvent !== event && vm._events[lowerCaseEvent]) {
        tip("Event \"" + lowerCaseEvent + "\" is emitted in component " + formatComponentName(vm) + " but the handler is registered for \"" + event + "\". " + "Note that HTML attributes are case-insensitive and you cannot use " + "v-on to listen to camelCase events when using in-DOM templates. " + "You should probably use \"" + hyphenate(event) + "\" instead of \"" + event + "\".");
      }
    }

    var cbs = vm._events[event];

    if (cbs) {
      cbs = cbs.length > 1 ? toArray(cbs) : cbs;
      var args = toArray(arguments, 1);
      var info = "event handler for \"" + event + "\"";

      for (var i = 0, l = cbs.length; i < l; i++) {
        invokeWithErrorHandling(cbs[i], vm, args, vm, info);
      }
    }

    return vm;
  };
}
/*  */


var activeInstance = null;
var isUpdatingChildComponent = false;

function setActiveInstance(vm) {
  var prevActiveInstance = activeInstance;
  activeInstance = vm;
  return function () {
    activeInstance = prevActiveInstance;
  };
}

function initLifecycle(vm) {
  var options = vm.$options; // locate first non-abstract parent

  var parent = options.parent;

  if (parent && !options.abstract) {
    while (parent.$options.abstract && parent.$parent) {
      parent = parent.$parent;
    }

    parent.$children.push(vm);
  }

  vm.$parent = parent;
  vm.$root = parent ? parent.$root : vm;
  vm.$children = [];
  vm.$refs = {};
  vm._watcher = null;
  vm._inactive = null;
  vm._directInactive = false;
  vm._isMounted = false;
  vm._isDestroyed = false;
  vm._isBeingDestroyed = false;
}

function lifecycleMixin(Vue) {
  Vue.prototype._update = function (vnode, hydrating) {
    var vm = this;
    var prevEl = vm.$el;
    var prevVnode = vm._vnode;
    var restoreActiveInstance = setActiveInstance(vm);
    vm._vnode = vnode; // Vue.prototype.__patch__ is injected in entry points
    // based on the rendering backend used.

    if (!prevVnode) {
      // initial render
      vm.$el = vm.__patch__(vm.$el, vnode, hydrating, false
      /* removeOnly */
      );
    } else {
      // updates
      vm.$el = vm.__patch__(prevVnode, vnode);
    }

    restoreActiveInstance(); // update __vue__ reference

    if (prevEl) {
      prevEl.__vue__ = null;
    }

    if (vm.$el) {
      vm.$el.__vue__ = vm;
    } // if parent is an HOC, update its $el as well


    if (vm.$vnode && vm.$parent && vm.$vnode === vm.$parent._vnode) {
      vm.$parent.$el = vm.$el;
    } // updated hook is called by the scheduler to ensure that children are
    // updated in a parent's updated hook.

  };

  Vue.prototype.$forceUpdate = function () {
    var vm = this;

    if (vm._watcher) {
      vm._watcher.update();
    }
  };

  Vue.prototype.$destroy = function () {
    var vm = this;

    if (vm._isBeingDestroyed) {
      return;
    }

    callHook(vm, 'beforeDestroy');
    vm._isBeingDestroyed = true; // remove self from parent

    var parent = vm.$parent;

    if (parent && !parent._isBeingDestroyed && !vm.$options.abstract) {
      remove(parent.$children, vm);
    } // teardown watchers


    if (vm._watcher) {
      vm._watcher.teardown();
    }

    var i = vm._watchers.length;

    while (i--) {
      vm._watchers[i].teardown();
    } // remove reference from data ob
    // frozen object may not have observer.


    if (vm._data.__ob__) {
      vm._data.__ob__.vmCount--;
    } // call the last hook...


    vm._isDestroyed = true; // invoke destroy hooks on current rendered tree

    vm.__patch__(vm._vnode, null); // fire destroyed hook


    callHook(vm, 'destroyed'); // turn off all instance listeners.

    vm.$off(); // remove __vue__ reference

    if (vm.$el) {
      vm.$el.__vue__ = null;
    } // release circular reference (#6759)


    if (vm.$vnode) {
      vm.$vnode.parent = null;
    }
  };
}

function mountComponent(vm, el, hydrating) {
  vm.$el = el;

  if (!vm.$options.render) {
    vm.$options.render = createEmptyVNode;

    if (true) {
      /* istanbul ignore if */
      if (vm.$options.template && vm.$options.template.charAt(0) !== '#' || vm.$options.el || el) {
        warn('You are using the runtime-only build of Vue where the template ' + 'compiler is not available. Either pre-compile the templates into ' + 'render functions, or use the compiler-included build.', vm);
      } else {
        warn('Failed to mount component: template or render function not defined.', vm);
      }
    }
  }

  callHook(vm, 'beforeMount');
  var updateComponent;
  /* istanbul ignore if */

  if ( true && config.performance && mark) {
    updateComponent = function () {
      var name = vm._name;
      var id = vm._uid;
      var startTag = "vue-perf-start:" + id;
      var endTag = "vue-perf-end:" + id;
      mark(startTag);

      var vnode = vm._render();

      mark(endTag);
      measure("vue " + name + " render", startTag, endTag);
      mark(startTag);

      vm._update(vnode, hydrating);

      mark(endTag);
      measure("vue " + name + " patch", startTag, endTag);
    };
  } else {
    updateComponent = function () {
      vm._update(vm._render(), hydrating);
    };
  } // we set this to vm._watcher inside the watcher's constructor
  // since the watcher's initial patch may call $forceUpdate (e.g. inside child
  // component's mounted hook), which relies on vm._watcher being already defined


  new Watcher(vm, updateComponent, noop, {
    before: function before() {
      if (vm._isMounted && !vm._isDestroyed) {
        callHook(vm, 'beforeUpdate');
      }
    }
  }, true
  /* isRenderWatcher */
  );
  hydrating = false; // manually mounted instance, call mounted on self
  // mounted is called for render-created child components in its inserted hook

  if (vm.$vnode == null) {
    vm._isMounted = true;
    callHook(vm, 'mounted');
  }

  return vm;
}

function updateChildComponent(vm, propsData, listeners, parentVnode, renderChildren) {
  if (true) {
    isUpdatingChildComponent = true;
  } // determine whether component has slot children
  // we need to do this before overwriting $options._renderChildren.
  // check if there are dynamic scopedSlots (hand-written or compiled but with
  // dynamic slot names). Static scoped slots compiled from template has the
  // "$stable" marker.


  var newScopedSlots = parentVnode.data.scopedSlots;
  var oldScopedSlots = vm.$scopedSlots;
  var hasDynamicScopedSlot = !!(newScopedSlots && !newScopedSlots.$stable || oldScopedSlots !== emptyObject && !oldScopedSlots.$stable || newScopedSlots && vm.$scopedSlots.$key !== newScopedSlots.$key || !newScopedSlots && vm.$scopedSlots.$key); // Any static slot children from the parent may have changed during parent's
  // update. Dynamic scoped slots may also have changed. In such cases, a forced
  // update is necessary to ensure correctness.

  var needsForceUpdate = !!(renderChildren || // has new static slots
  vm.$options._renderChildren || // has old static slots
  hasDynamicScopedSlot);
  vm.$options._parentVnode = parentVnode;
  vm.$vnode = parentVnode; // update vm's placeholder node without re-render

  if (vm._vnode) {
    // update child tree's parent
    vm._vnode.parent = parentVnode;
  }

  vm.$options._renderChildren = renderChildren; // update $attrs and $listeners hash
  // these are also reactive so they may trigger child update if the child
  // used them during render

  vm.$attrs = parentVnode.data.attrs || emptyObject;
  vm.$listeners = listeners || emptyObject; // update props

  if (propsData && vm.$options.props) {
    toggleObserving(false);
    var props = vm._props;
    var propKeys = vm.$options._propKeys || [];

    for (var i = 0; i < propKeys.length; i++) {
      var key = propKeys[i];
      var propOptions = vm.$options.props; // wtf flow?

      props[key] = validateProp(key, propOptions, propsData, vm);
    }

    toggleObserving(true); // keep a copy of raw propsData

    vm.$options.propsData = propsData;
  } // update listeners


  listeners = listeners || emptyObject;
  var oldListeners = vm.$options._parentListeners;
  vm.$options._parentListeners = listeners;
  updateComponentListeners(vm, listeners, oldListeners); // resolve slots + force update if has children

  if (needsForceUpdate) {
    vm.$slots = resolveSlots(renderChildren, parentVnode.context);
    vm.$forceUpdate();
  }

  if (true) {
    isUpdatingChildComponent = false;
  }
}

function isInInactiveTree(vm) {
  while (vm && (vm = vm.$parent)) {
    if (vm._inactive) {
      return true;
    }
  }

  return false;
}

function activateChildComponent(vm, direct) {
  if (direct) {
    vm._directInactive = false;

    if (isInInactiveTree(vm)) {
      return;
    }
  } else if (vm._directInactive) {
    return;
  }

  if (vm._inactive || vm._inactive === null) {
    vm._inactive = false;

    for (var i = 0; i < vm.$children.length; i++) {
      activateChildComponent(vm.$children[i]);
    }

    callHook(vm, 'activated');
  }
}

function deactivateChildComponent(vm, direct) {
  if (direct) {
    vm._directInactive = true;

    if (isInInactiveTree(vm)) {
      return;
    }
  }

  if (!vm._inactive) {
    vm._inactive = true;

    for (var i = 0; i < vm.$children.length; i++) {
      deactivateChildComponent(vm.$children[i]);
    }

    callHook(vm, 'deactivated');
  }
}

function callHook(vm, hook) {
  // #7573 disable dep collection when invoking lifecycle hooks
  pushTarget();
  var handlers = vm.$options[hook];
  var info = hook + " hook";

  if (handlers) {
    for (var i = 0, j = handlers.length; i < j; i++) {
      invokeWithErrorHandling(handlers[i], vm, null, vm, info);
    }
  }

  if (vm._hasHookEvent) {
    vm.$emit('hook:' + hook);
  }

  popTarget();
}
/*  */


var MAX_UPDATE_COUNT = 100;
var queue = [];
var activatedChildren = [];
var has = {};
var circular = {};
var waiting = false;
var flushing = false;
var index = 0;
/**
 * Reset the scheduler's state.
 */

function resetSchedulerState() {
  index = queue.length = activatedChildren.length = 0;
  has = {};

  if (true) {
    circular = {};
  }

  waiting = flushing = false;
} // Async edge case #6566 requires saving the timestamp when event listeners are
// attached. However, calling performance.now() has a perf overhead especially
// if the page has thousands of event listeners. Instead, we take a timestamp
// every time the scheduler flushes and use that for all event listeners
// attached during that flush.


var currentFlushTimestamp = 0; // Async edge case fix requires storing an event listener's attach timestamp.

var getNow = Date.now; // Determine what event timestamp the browser is using. Annoyingly, the
// timestamp can either be hi-res (relative to page load) or low-res
// (relative to UNIX epoch), so in order to compare time we have to use the
// same timestamp type when saving the flush timestamp.
// All IE versions use low-res event timestamps, and have problematic clock
// implementations (#9632)

if (inBrowser && !isIE) {
  var performance = window.performance;

  if (performance && typeof performance.now === 'function' && getNow() > document.createEvent('Event').timeStamp) {
    // if the event timestamp, although evaluated AFTER the Date.now(), is
    // smaller than it, it means the event is using a hi-res timestamp,
    // and we need to use the hi-res version for event listener timestamps as
    // well.
    getNow = function () {
      return performance.now();
    };
  }
}
/**
 * Flush both queues and run the watchers.
 */


function flushSchedulerQueue() {
  currentFlushTimestamp = getNow();
  flushing = true;
  var watcher, id; // Sort queue before flush.
  // This ensures that:
  // 1. Components are updated from parent to child. (because parent is always
  //    created before the child)
  // 2. A component's user watchers are run before its render watcher (because
  //    user watchers are created before the render watcher)
  // 3. If a component is destroyed during a parent component's watcher run,
  //    its watchers can be skipped.

  queue.sort(function (a, b) {
    return a.id - b.id;
  }); // do not cache length because more watchers might be pushed
  // as we run existing watchers

  for (index = 0; index < queue.length; index++) {
    watcher = queue[index];

    if (watcher.before) {
      watcher.before();
    }

    id = watcher.id;
    has[id] = null;
    watcher.run(); // in dev build, check and stop circular updates.

    if ( true && has[id] != null) {
      circular[id] = (circular[id] || 0) + 1;

      if (circular[id] > MAX_UPDATE_COUNT) {
        warn('You may have an infinite update loop ' + (watcher.user ? "in watcher with expression \"" + watcher.expression + "\"" : "in a component render function."), watcher.vm);
        break;
      }
    }
  } // keep copies of post queues before resetting state


  var activatedQueue = activatedChildren.slice();
  var updatedQueue = queue.slice();
  resetSchedulerState(); // call component updated and activated hooks

  callActivatedHooks(activatedQueue);
  callUpdatedHooks(updatedQueue); // devtool hook

  /* istanbul ignore if */

  if (devtools && config.devtools) {
    devtools.emit('flush');
  }
}

function callUpdatedHooks(queue) {
  var i = queue.length;

  while (i--) {
    var watcher = queue[i];
    var vm = watcher.vm;

    if (vm._watcher === watcher && vm._isMounted && !vm._isDestroyed) {
      callHook(vm, 'updated');
    }
  }
}
/**
 * Queue a kept-alive component that was activated during patch.
 * The queue will be processed after the entire tree has been patched.
 */


function queueActivatedComponent(vm) {
  // setting _inactive to false here so that a render function can
  // rely on checking whether it's in an inactive tree (e.g. router-view)
  vm._inactive = false;
  activatedChildren.push(vm);
}

function callActivatedHooks(queue) {
  for (var i = 0; i < queue.length; i++) {
    queue[i]._inactive = true;
    activateChildComponent(queue[i], true
    /* true */
    );
  }
}
/**
 * Push a watcher into the watcher queue.
 * Jobs with duplicate IDs will be skipped unless it's
 * pushed when the queue is being flushed.
 */


function queueWatcher(watcher) {
  var id = watcher.id;

  if (has[id] == null) {
    has[id] = true;

    if (!flushing) {
      queue.push(watcher);
    } else {
      // if already flushing, splice the watcher based on its id
      // if already past its id, it will be run next immediately.
      var i = queue.length - 1;

      while (i > index && queue[i].id > watcher.id) {
        i--;
      }

      queue.splice(i + 1, 0, watcher);
    } // queue the flush


    if (!waiting) {
      waiting = true;

      if ( true && !config.async) {
        flushSchedulerQueue();
        return;
      }

      nextTick(flushSchedulerQueue);
    }
  }
}
/*  */


var uid$2 = 0;
/**
 * A watcher parses an expression, collects dependencies,
 * and fires callback when the expression value changes.
 * This is used for both the $watch() api and directives.
 */

var Watcher = function Watcher(vm, expOrFn, cb, options, isRenderWatcher) {
  this.vm = vm;

  if (isRenderWatcher) {
    vm._watcher = this;
  }

  vm._watchers.push(this); // options


  if (options) {
    this.deep = !!options.deep;
    this.user = !!options.user;
    this.lazy = !!options.lazy;
    this.sync = !!options.sync;
    this.before = options.before;
  } else {
    this.deep = this.user = this.lazy = this.sync = false;
  }

  this.cb = cb;
  this.id = ++uid$2; // uid for batching

  this.active = true;
  this.dirty = this.lazy; // for lazy watchers

  this.deps = [];
  this.newDeps = [];
  this.depIds = new _Set();
  this.newDepIds = new _Set();
  this.expression =  true ? expOrFn.toString() : undefined; // parse expression for getter

  if (typeof expOrFn === 'function') {
    this.getter = expOrFn;
  } else {
    this.getter = parsePath(expOrFn);

    if (!this.getter) {
      this.getter = noop;
       true && warn("Failed watching path: \"" + expOrFn + "\" " + 'Watcher only accepts simple dot-delimited paths. ' + 'For full control, use a function instead.', vm);
    }
  }

  this.value = this.lazy ? undefined : this.get();
};
/**
 * Evaluate the getter, and re-collect dependencies.
 */


Watcher.prototype.get = function get() {
  pushTarget(this);
  var value;
  var vm = this.vm;

  try {
    value = this.getter.call(vm, vm);
  } catch (e) {
    if (this.user) {
      handleError(e, vm, "getter for watcher \"" + this.expression + "\"");
    } else {
      throw e;
    }
  } finally {
    // "touch" every property so they are all tracked as
    // dependencies for deep watching
    if (this.deep) {
      traverse(value);
    }

    popTarget();
    this.cleanupDeps();
  }

  return value;
};
/**
 * Add a dependency to this directive.
 */


Watcher.prototype.addDep = function addDep(dep) {
  var id = dep.id;

  if (!this.newDepIds.has(id)) {
    this.newDepIds.add(id);
    this.newDeps.push(dep);

    if (!this.depIds.has(id)) {
      dep.addSub(this);
    }
  }
};
/**
 * Clean up for dependency collection.
 */


Watcher.prototype.cleanupDeps = function cleanupDeps() {
  var i = this.deps.length;

  while (i--) {
    var dep = this.deps[i];

    if (!this.newDepIds.has(dep.id)) {
      dep.removeSub(this);
    }
  }

  var tmp = this.depIds;
  this.depIds = this.newDepIds;
  this.newDepIds = tmp;
  this.newDepIds.clear();
  tmp = this.deps;
  this.deps = this.newDeps;
  this.newDeps = tmp;
  this.newDeps.length = 0;
};
/**
 * Subscriber interface.
 * Will be called when a dependency changes.
 */


Watcher.prototype.update = function update() {
  /* istanbul ignore else */
  if (this.lazy) {
    this.dirty = true;
  } else if (this.sync) {
    this.run();
  } else {
    queueWatcher(this);
  }
};
/**
 * Scheduler job interface.
 * Will be called by the scheduler.
 */


Watcher.prototype.run = function run() {
  if (this.active) {
    var value = this.get();

    if (value !== this.value || // Deep watchers and watchers on Object/Arrays should fire even
    // when the value is the same, because the value may
    // have mutated.
    isObject(value) || this.deep) {
      // set new value
      var oldValue = this.value;
      this.value = value;

      if (this.user) {
        var info = "callback for watcher \"" + this.expression + "\"";
        invokeWithErrorHandling(this.cb, this.vm, [value, oldValue], this.vm, info);
      } else {
        this.cb.call(this.vm, value, oldValue);
      }
    }
  }
};
/**
 * Evaluate the value of the watcher.
 * This only gets called for lazy watchers.
 */


Watcher.prototype.evaluate = function evaluate() {
  this.value = this.get();
  this.dirty = false;
};
/**
 * Depend on all deps collected by this watcher.
 */


Watcher.prototype.depend = function depend() {
  var i = this.deps.length;

  while (i--) {
    this.deps[i].depend();
  }
};
/**
 * Remove self from all dependencies' subscriber list.
 */


Watcher.prototype.teardown = function teardown() {
  if (this.active) {
    // remove self from vm's watcher list
    // this is a somewhat expensive operation so we skip it
    // if the vm is being destroyed.
    if (!this.vm._isBeingDestroyed) {
      remove(this.vm._watchers, this);
    }

    var i = this.deps.length;

    while (i--) {
      this.deps[i].removeSub(this);
    }

    this.active = false;
  }
};
/*  */


var sharedPropertyDefinition = {
  enumerable: true,
  configurable: true,
  get: noop,
  set: noop
};

function proxy(target, sourceKey, key) {
  sharedPropertyDefinition.get = function proxyGetter() {
    return this[sourceKey][key];
  };

  sharedPropertyDefinition.set = function proxySetter(val) {
    this[sourceKey][key] = val;
  };

  Object.defineProperty(target, key, sharedPropertyDefinition);
}

function initState(vm) {
  vm._watchers = [];
  var opts = vm.$options;

  if (opts.props) {
    initProps(vm, opts.props);
  }

  if (opts.methods) {
    initMethods(vm, opts.methods);
  }

  if (opts.data) {
    initData(vm);
  } else {
    observe(vm._data = {}, true
    /* asRootData */
    );
  }

  if (opts.computed) {
    initComputed(vm, opts.computed);
  }

  if (opts.watch && opts.watch !== nativeWatch) {
    initWatch(vm, opts.watch);
  }
}

function initProps(vm, propsOptions) {
  var propsData = vm.$options.propsData || {};
  var props = vm._props = {}; // cache prop keys so that future props updates can iterate using Array
  // instead of dynamic object key enumeration.

  var keys = vm.$options._propKeys = [];
  var isRoot = !vm.$parent; // root instance props should be converted

  if (!isRoot) {
    toggleObserving(false);
  }

  var loop = function (key) {
    keys.push(key);
    var value = validateProp(key, propsOptions, propsData, vm);
    /* istanbul ignore else */

    if (true) {
      var hyphenatedKey = hyphenate(key);

      if (isReservedAttribute(hyphenatedKey) || config.isReservedAttr(hyphenatedKey)) {
        warn("\"" + hyphenatedKey + "\" is a reserved attribute and cannot be used as component prop.", vm);
      }

      defineReactive$$1(props, key, value, function () {
        if (!isRoot && !isUpdatingChildComponent) {
          warn("Avoid mutating a prop directly since the value will be " + "overwritten whenever the parent component re-renders. " + "Instead, use a data or computed property based on the prop's " + "value. Prop being mutated: \"" + key + "\"", vm);
        }
      });
    } else {} // static props are already proxied on the component's prototype
    // during Vue.extend(). We only need to proxy props defined at
    // instantiation here.


    if (!(key in vm)) {
      proxy(vm, "_props", key);
    }
  };

  for (var key in propsOptions) loop(key);

  toggleObserving(true);
}

function initData(vm) {
  var data = vm.$options.data;
  data = vm._data = typeof data === 'function' ? getData(data, vm) : data || {};

  if (!isPlainObject(data)) {
    data = {};
     true && warn('data functions should return an object:\n' + 'https://vuejs.org/v2/guide/components.html#data-Must-Be-a-Function', vm);
  } // proxy data on instance


  var keys = Object.keys(data);
  var props = vm.$options.props;
  var methods = vm.$options.methods;
  var i = keys.length;

  while (i--) {
    var key = keys[i];

    if (true) {
      if (methods && hasOwn(methods, key)) {
        warn("Method \"" + key + "\" has already been defined as a data property.", vm);
      }
    }

    if (props && hasOwn(props, key)) {
       true && warn("The data property \"" + key + "\" is already declared as a prop. " + "Use prop default value instead.", vm);
    } else if (!isReserved(key)) {
      proxy(vm, "_data", key);
    }
  } // observe data


  observe(data, true
  /* asRootData */
  );
}

function getData(data, vm) {
  // #7573 disable dep collection when invoking data getters
  pushTarget();

  try {
    return data.call(vm, vm);
  } catch (e) {
    handleError(e, vm, "data()");
    return {};
  } finally {
    popTarget();
  }
}

var computedWatcherOptions = {
  lazy: true
};

function initComputed(vm, computed) {
  // $flow-disable-line
  var watchers = vm._computedWatchers = Object.create(null); // computed properties are just getters during SSR

  var isSSR = isServerRendering();

  for (var key in computed) {
    var userDef = computed[key];
    var getter = typeof userDef === 'function' ? userDef : userDef.get;

    if ( true && getter == null) {
      warn("Getter is missing for computed property \"" + key + "\".", vm);
    }

    if (!isSSR) {
      // create internal watcher for the computed property.
      watchers[key] = new Watcher(vm, getter || noop, noop, computedWatcherOptions);
    } // component-defined computed properties are already defined on the
    // component prototype. We only need to define computed properties defined
    // at instantiation here.


    if (!(key in vm)) {
      defineComputed(vm, key, userDef);
    } else if (true) {
      if (key in vm.$data) {
        warn("The computed property \"" + key + "\" is already defined in data.", vm);
      } else if (vm.$options.props && key in vm.$options.props) {
        warn("The computed property \"" + key + "\" is already defined as a prop.", vm);
      } else if (vm.$options.methods && key in vm.$options.methods) {
        warn("The computed property \"" + key + "\" is already defined as a method.", vm);
      }
    }
  }
}

function defineComputed(target, key, userDef) {
  var shouldCache = !isServerRendering();

  if (typeof userDef === 'function') {
    sharedPropertyDefinition.get = shouldCache ? createComputedGetter(key) : createGetterInvoker(userDef);
    sharedPropertyDefinition.set = noop;
  } else {
    sharedPropertyDefinition.get = userDef.get ? shouldCache && userDef.cache !== false ? createComputedGetter(key) : createGetterInvoker(userDef.get) : noop;
    sharedPropertyDefinition.set = userDef.set || noop;
  }

  if ( true && sharedPropertyDefinition.set === noop) {
    sharedPropertyDefinition.set = function () {
      warn("Computed property \"" + key + "\" was assigned to but it has no setter.", this);
    };
  }

  Object.defineProperty(target, key, sharedPropertyDefinition);
}

function createComputedGetter(key) {
  return function computedGetter() {
    var watcher = this._computedWatchers && this._computedWatchers[key];

    if (watcher) {
      if (watcher.dirty) {
        watcher.evaluate();
      }

      if (Dep.target) {
        watcher.depend();
      }

      return watcher.value;
    }
  };
}

function createGetterInvoker(fn) {
  return function computedGetter() {
    return fn.call(this, this);
  };
}

function initMethods(vm, methods) {
  var props = vm.$options.props;

  for (var key in methods) {
    if (true) {
      if (typeof methods[key] !== 'function') {
        warn("Method \"" + key + "\" has type \"" + typeof methods[key] + "\" in the component definition. " + "Did you reference the function correctly?", vm);
      }

      if (props && hasOwn(props, key)) {
        warn("Method \"" + key + "\" has already been defined as a prop.", vm);
      }

      if (key in vm && isReserved(key)) {
        warn("Method \"" + key + "\" conflicts with an existing Vue instance method. " + "Avoid defining component methods that start with _ or $.");
      }
    }

    vm[key] = typeof methods[key] !== 'function' ? noop : bind(methods[key], vm);
  }
}

function initWatch(vm, watch) {
  for (var key in watch) {
    var handler = watch[key];

    if (Array.isArray(handler)) {
      for (var i = 0; i < handler.length; i++) {
        createWatcher(vm, key, handler[i]);
      }
    } else {
      createWatcher(vm, key, handler);
    }
  }
}

function createWatcher(vm, expOrFn, handler, options) {
  if (isPlainObject(handler)) {
    options = handler;
    handler = handler.handler;
  }

  if (typeof handler === 'string') {
    handler = vm[handler];
  }

  return vm.$watch(expOrFn, handler, options);
}

function stateMixin(Vue) {
  // flow somehow has problems with directly declared definition object
  // when using Object.defineProperty, so we have to procedurally build up
  // the object here.
  var dataDef = {};

  dataDef.get = function () {
    return this._data;
  };

  var propsDef = {};

  propsDef.get = function () {
    return this._props;
  };

  if (true) {
    dataDef.set = function () {
      warn('Avoid replacing instance root $data. ' + 'Use nested data properties instead.', this);
    };

    propsDef.set = function () {
      warn("$props is readonly.", this);
    };
  }

  Object.defineProperty(Vue.prototype, '$data', dataDef);
  Object.defineProperty(Vue.prototype, '$props', propsDef);
  Vue.prototype.$set = set;
  Vue.prototype.$delete = del;

  Vue.prototype.$watch = function (expOrFn, cb, options) {
    var vm = this;

    if (isPlainObject(cb)) {
      return createWatcher(vm, expOrFn, cb, options);
    }

    options = options || {};
    options.user = true;
    var watcher = new Watcher(vm, expOrFn, cb, options);

    if (options.immediate) {
      var info = "callback for immediate watcher \"" + watcher.expression + "\"";
      pushTarget();
      invokeWithErrorHandling(cb, vm, [watcher.value], vm, info);
      popTarget();
    }

    return function unwatchFn() {
      watcher.teardown();
    };
  };
}
/*  */


var uid$3 = 0;

function initMixin(Vue) {
  Vue.prototype._init = function (options) {
    var vm = this; // a uid

    vm._uid = uid$3++;
    var startTag, endTag;
    /* istanbul ignore if */

    if ( true && config.performance && mark) {
      startTag = "vue-perf-start:" + vm._uid;
      endTag = "vue-perf-end:" + vm._uid;
      mark(startTag);
    } // a flag to avoid this being observed


    vm._isVue = true; // merge options

    if (options && options._isComponent) {
      // optimize internal component instantiation
      // since dynamic options merging is pretty slow, and none of the
      // internal component options needs special treatment.
      initInternalComponent(vm, options);
    } else {
      vm.$options = mergeOptions(resolveConstructorOptions(vm.constructor), options || {}, vm);
    }
    /* istanbul ignore else */


    if (true) {
      initProxy(vm);
    } else {} // expose real self


    vm._self = vm;
    initLifecycle(vm);
    initEvents(vm);
    initRender(vm);
    callHook(vm, 'beforeCreate');
    initInjections(vm); // resolve injections before data/props

    initState(vm);
    initProvide(vm); // resolve provide after data/props

    callHook(vm, 'created');
    /* istanbul ignore if */

    if ( true && config.performance && mark) {
      vm._name = formatComponentName(vm, false);
      mark(endTag);
      measure("vue " + vm._name + " init", startTag, endTag);
    }

    if (vm.$options.el) {
      vm.$mount(vm.$options.el);
    }
  };
}

function initInternalComponent(vm, options) {
  var opts = vm.$options = Object.create(vm.constructor.options); // doing this because it's faster than dynamic enumeration.

  var parentVnode = options._parentVnode;
  opts.parent = options.parent;
  opts._parentVnode = parentVnode;
  var vnodeComponentOptions = parentVnode.componentOptions;
  opts.propsData = vnodeComponentOptions.propsData;
  opts._parentListeners = vnodeComponentOptions.listeners;
  opts._renderChildren = vnodeComponentOptions.children;
  opts._componentTag = vnodeComponentOptions.tag;

  if (options.render) {
    opts.render = options.render;
    opts.staticRenderFns = options.staticRenderFns;
  }
}

function resolveConstructorOptions(Ctor) {
  var options = Ctor.options;

  if (Ctor.super) {
    var superOptions = resolveConstructorOptions(Ctor.super);
    var cachedSuperOptions = Ctor.superOptions;

    if (superOptions !== cachedSuperOptions) {
      // super option changed,
      // need to resolve new options.
      Ctor.superOptions = superOptions; // check if there are any late-modified/attached options (#4976)

      var modifiedOptions = resolveModifiedOptions(Ctor); // update base extend options

      if (modifiedOptions) {
        extend(Ctor.extendOptions, modifiedOptions);
      }

      options = Ctor.options = mergeOptions(superOptions, Ctor.extendOptions);

      if (options.name) {
        options.components[options.name] = Ctor;
      }
    }
  }

  return options;
}

function resolveModifiedOptions(Ctor) {
  var modified;
  var latest = Ctor.options;
  var sealed = Ctor.sealedOptions;

  for (var key in latest) {
    if (latest[key] !== sealed[key]) {
      if (!modified) {
        modified = {};
      }

      modified[key] = latest[key];
    }
  }

  return modified;
}

function Vue(options) {
  if ( true && !(this instanceof Vue)) {
    warn('Vue is a constructor and should be called with the `new` keyword');
  }

  this._init(options);
}

initMixin(Vue);
stateMixin(Vue);
eventsMixin(Vue);
lifecycleMixin(Vue);
renderMixin(Vue);
/*  */

function initUse(Vue) {
  Vue.use = function (plugin) {
    var installedPlugins = this._installedPlugins || (this._installedPlugins = []);

    if (installedPlugins.indexOf(plugin) > -1) {
      return this;
    } // additional parameters


    var args = toArray(arguments, 1);
    args.unshift(this);

    if (typeof plugin.install === 'function') {
      plugin.install.apply(plugin, args);
    } else if (typeof plugin === 'function') {
      plugin.apply(null, args);
    }

    installedPlugins.push(plugin);
    return this;
  };
}
/*  */


function initMixin$1(Vue) {
  Vue.mixin = function (mixin) {
    this.options = mergeOptions(this.options, mixin);
    return this;
  };
}
/*  */


function initExtend(Vue) {
  /**
   * Each instance constructor, including Vue, has a unique
   * cid. This enables us to create wrapped "child
   * constructors" for prototypal inheritance and cache them.
   */
  Vue.cid = 0;
  var cid = 1;
  /**
   * Class inheritance
   */

  Vue.extend = function (extendOptions) {
    extendOptions = extendOptions || {};
    var Super = this;
    var SuperId = Super.cid;
    var cachedCtors = extendOptions._Ctor || (extendOptions._Ctor = {});

    if (cachedCtors[SuperId]) {
      return cachedCtors[SuperId];
    }

    var name = extendOptions.name || Super.options.name;

    if ( true && name) {
      validateComponentName(name);
    }

    var Sub = function VueComponent(options) {
      this._init(options);
    };

    Sub.prototype = Object.create(Super.prototype);
    Sub.prototype.constructor = Sub;
    Sub.cid = cid++;
    Sub.options = mergeOptions(Super.options, extendOptions);
    Sub['super'] = Super; // For props and computed properties, we define the proxy getters on
    // the Vue instances at extension time, on the extended prototype. This
    // avoids Object.defineProperty calls for each instance created.

    if (Sub.options.props) {
      initProps$1(Sub);
    }

    if (Sub.options.computed) {
      initComputed$1(Sub);
    } // allow further extension/mixin/plugin usage


    Sub.extend = Super.extend;
    Sub.mixin = Super.mixin;
    Sub.use = Super.use; // create asset registers, so extended classes
    // can have their private assets too.

    ASSET_TYPES.forEach(function (type) {
      Sub[type] = Super[type];
    }); // enable recursive self-lookup

    if (name) {
      Sub.options.components[name] = Sub;
    } // keep a reference to the super options at extension time.
    // later at instantiation we can check if Super's options have
    // been updated.


    Sub.superOptions = Super.options;
    Sub.extendOptions = extendOptions;
    Sub.sealedOptions = extend({}, Sub.options); // cache constructor

    cachedCtors[SuperId] = Sub;
    return Sub;
  };
}

function initProps$1(Comp) {
  var props = Comp.options.props;

  for (var key in props) {
    proxy(Comp.prototype, "_props", key);
  }
}

function initComputed$1(Comp) {
  var computed = Comp.options.computed;

  for (var key in computed) {
    defineComputed(Comp.prototype, key, computed[key]);
  }
}
/*  */


function initAssetRegisters(Vue) {
  /**
   * Create asset registration methods.
   */
  ASSET_TYPES.forEach(function (type) {
    Vue[type] = function (id, definition) {
      if (!definition) {
        return this.options[type + 's'][id];
      } else {
        /* istanbul ignore if */
        if ( true && type === 'component') {
          validateComponentName(id);
        }

        if (type === 'component' && isPlainObject(definition)) {
          definition.name = definition.name || id;
          definition = this.options._base.extend(definition);
        }

        if (type === 'directive' && typeof definition === 'function') {
          definition = {
            bind: definition,
            update: definition
          };
        }

        this.options[type + 's'][id] = definition;
        return definition;
      }
    };
  });
}
/*  */


function getComponentName(opts) {
  return opts && (opts.Ctor.options.name || opts.tag);
}

function matches(pattern, name) {
  if (Array.isArray(pattern)) {
    return pattern.indexOf(name) > -1;
  } else if (typeof pattern === 'string') {
    return pattern.split(',').indexOf(name) > -1;
  } else if (isRegExp(pattern)) {
    return pattern.test(name);
  }
  /* istanbul ignore next */


  return false;
}

function pruneCache(keepAliveInstance, filter) {
  var cache = keepAliveInstance.cache;
  var keys = keepAliveInstance.keys;
  var _vnode = keepAliveInstance._vnode;

  for (var key in cache) {
    var entry = cache[key];

    if (entry) {
      var name = entry.name;

      if (name && !filter(name)) {
        pruneCacheEntry(cache, key, keys, _vnode);
      }
    }
  }
}

function pruneCacheEntry(cache, key, keys, current) {
  var entry = cache[key];

  if (entry && (!current || entry.tag !== current.tag)) {
    entry.componentInstance.$destroy();
  }

  cache[key] = null;
  remove(keys, key);
}

var patternTypes = [String, RegExp, Array];
var KeepAlive = {
  name: 'keep-alive',
  abstract: true,
  props: {
    include: patternTypes,
    exclude: patternTypes,
    max: [String, Number]
  },
  methods: {
    cacheVNode: function cacheVNode() {
      var ref = this;
      var cache = ref.cache;
      var keys = ref.keys;
      var vnodeToCache = ref.vnodeToCache;
      var keyToCache = ref.keyToCache;

      if (vnodeToCache) {
        var tag = vnodeToCache.tag;
        var componentInstance = vnodeToCache.componentInstance;
        var componentOptions = vnodeToCache.componentOptions;
        cache[keyToCache] = {
          name: getComponentName(componentOptions),
          tag: tag,
          componentInstance: componentInstance
        };
        keys.push(keyToCache); // prune oldest entry

        if (this.max && keys.length > parseInt(this.max)) {
          pruneCacheEntry(cache, keys[0], keys, this._vnode);
        }

        this.vnodeToCache = null;
      }
    }
  },
  created: function created() {
    this.cache = Object.create(null);
    this.keys = [];
  },
  destroyed: function destroyed() {
    for (var key in this.cache) {
      pruneCacheEntry(this.cache, key, this.keys);
    }
  },
  mounted: function mounted() {
    var this$1 = this;
    this.cacheVNode();
    this.$watch('include', function (val) {
      pruneCache(this$1, function (name) {
        return matches(val, name);
      });
    });
    this.$watch('exclude', function (val) {
      pruneCache(this$1, function (name) {
        return !matches(val, name);
      });
    });
  },
  updated: function updated() {
    this.cacheVNode();
  },
  render: function render() {
    var slot = this.$slots.default;
    var vnode = getFirstComponentChild(slot);
    var componentOptions = vnode && vnode.componentOptions;

    if (componentOptions) {
      // check pattern
      var name = getComponentName(componentOptions);
      var ref = this;
      var include = ref.include;
      var exclude = ref.exclude;

      if ( // not included
      include && (!name || !matches(include, name)) || // excluded
      exclude && name && matches(exclude, name)) {
        return vnode;
      }

      var ref$1 = this;
      var cache = ref$1.cache;
      var keys = ref$1.keys;
      var key = vnode.key == null // same constructor may get registered as different local components
      // so cid alone is not enough (#3269)
      ? componentOptions.Ctor.cid + (componentOptions.tag ? "::" + componentOptions.tag : '') : vnode.key;

      if (cache[key]) {
        vnode.componentInstance = cache[key].componentInstance; // make current key freshest

        remove(keys, key);
        keys.push(key);
      } else {
        // delay setting the cache until update
        this.vnodeToCache = vnode;
        this.keyToCache = key;
      }

      vnode.data.keepAlive = true;
    }

    return vnode || slot && slot[0];
  }
};
var builtInComponents = {
  KeepAlive: KeepAlive
};
/*  */

function initGlobalAPI(Vue) {
  // config
  var configDef = {};

  configDef.get = function () {
    return config;
  };

  if (true) {
    configDef.set = function () {
      warn('Do not replace the Vue.config object, set individual fields instead.');
    };
  }

  Object.defineProperty(Vue, 'config', configDef); // exposed util methods.
  // NOTE: these are not considered part of the public API - avoid relying on
  // them unless you are aware of the risk.

  Vue.util = {
    warn: warn,
    extend: extend,
    mergeOptions: mergeOptions,
    defineReactive: defineReactive$$1
  };
  Vue.set = set;
  Vue.delete = del;
  Vue.nextTick = nextTick; // 2.6 explicit observable API

  Vue.observable = function (obj) {
    observe(obj);
    return obj;
  };

  Vue.options = Object.create(null);
  ASSET_TYPES.forEach(function (type) {
    Vue.options[type + 's'] = Object.create(null);
  }); // this is used to identify the "base" constructor to extend all plain-object
  // components with in Weex's multi-instance scenarios.

  Vue.options._base = Vue;
  extend(Vue.options.components, builtInComponents);
  initUse(Vue);
  initMixin$1(Vue);
  initExtend(Vue);
  initAssetRegisters(Vue);
}

initGlobalAPI(Vue);
Object.defineProperty(Vue.prototype, '$isServer', {
  get: isServerRendering
});
Object.defineProperty(Vue.prototype, '$ssrContext', {
  get: function get() {
    /* istanbul ignore next */
    return this.$vnode && this.$vnode.ssrContext;
  }
}); // expose FunctionalRenderContext for ssr runtime helper installation

Object.defineProperty(Vue, 'FunctionalRenderContext', {
  value: FunctionalRenderContext
});
Vue.version = '2.6.14';
/*  */
// these are reserved for web because they are directly compiled away
// during template compilation

var isReservedAttr = makeMap('style,class'); // attributes that should be using props for binding

var acceptValue = makeMap('input,textarea,option,select,progress');

var mustUseProp = function (tag, type, attr) {
  return attr === 'value' && acceptValue(tag) && type !== 'button' || attr === 'selected' && tag === 'option' || attr === 'checked' && tag === 'input' || attr === 'muted' && tag === 'video';
};

var isEnumeratedAttr = makeMap('contenteditable,draggable,spellcheck');
var isValidContentEditableValue = makeMap('events,caret,typing,plaintext-only');

var convertEnumeratedValue = function (key, value) {
  return isFalsyAttrValue(value) || value === 'false' ? 'false' // allow arbitrary string value for contenteditable
  : key === 'contenteditable' && isValidContentEditableValue(value) ? value : 'true';
};

var isBooleanAttr = makeMap('allowfullscreen,async,autofocus,autoplay,checked,compact,controls,declare,' + 'default,defaultchecked,defaultmuted,defaultselected,defer,disabled,' + 'enabled,formnovalidate,hidden,indeterminate,inert,ismap,itemscope,loop,multiple,' + 'muted,nohref,noresize,noshade,novalidate,nowrap,open,pauseonexit,readonly,' + 'required,reversed,scoped,seamless,selected,sortable,' + 'truespeed,typemustmatch,visible');
var xlinkNS = 'http://www.w3.org/1999/xlink';

var isXlink = function (name) {
  return name.charAt(5) === ':' && name.slice(0, 5) === 'xlink';
};

var getXlinkProp = function (name) {
  return isXlink(name) ? name.slice(6, name.length) : '';
};

var isFalsyAttrValue = function (val) {
  return val == null || val === false;
};
/*  */


function genClassForVnode(vnode) {
  var data = vnode.data;
  var parentNode = vnode;
  var childNode = vnode;

  while (isDef(childNode.componentInstance)) {
    childNode = childNode.componentInstance._vnode;

    if (childNode && childNode.data) {
      data = mergeClassData(childNode.data, data);
    }
  }

  while (isDef(parentNode = parentNode.parent)) {
    if (parentNode && parentNode.data) {
      data = mergeClassData(data, parentNode.data);
    }
  }

  return renderClass(data.staticClass, data.class);
}

function mergeClassData(child, parent) {
  return {
    staticClass: concat(child.staticClass, parent.staticClass),
    class: isDef(child.class) ? [child.class, parent.class] : parent.class
  };
}

function renderClass(staticClass, dynamicClass) {
  if (isDef(staticClass) || isDef(dynamicClass)) {
    return concat(staticClass, stringifyClass(dynamicClass));
  }
  /* istanbul ignore next */


  return '';
}

function concat(a, b) {
  return a ? b ? a + ' ' + b : a : b || '';
}

function stringifyClass(value) {
  if (Array.isArray(value)) {
    return stringifyArray(value);
  }

  if (isObject(value)) {
    return stringifyObject(value);
  }

  if (typeof value === 'string') {
    return value;
  }
  /* istanbul ignore next */


  return '';
}

function stringifyArray(value) {
  var res = '';
  var stringified;

  for (var i = 0, l = value.length; i < l; i++) {
    if (isDef(stringified = stringifyClass(value[i])) && stringified !== '') {
      if (res) {
        res += ' ';
      }

      res += stringified;
    }
  }

  return res;
}

function stringifyObject(value) {
  var res = '';

  for (var key in value) {
    if (value[key]) {
      if (res) {
        res += ' ';
      }

      res += key;
    }
  }

  return res;
}
/*  */


var namespaceMap = {
  svg: 'http://www.w3.org/2000/svg',
  math: 'http://www.w3.org/1998/Math/MathML'
};
var isHTMLTag = makeMap('html,body,base,head,link,meta,style,title,' + 'address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,' + 'div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,' + 'a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,' + 's,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,' + 'embed,object,param,source,canvas,script,noscript,del,ins,' + 'caption,col,colgroup,table,thead,tbody,td,th,tr,' + 'button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,' + 'output,progress,select,textarea,' + 'details,dialog,menu,menuitem,summary,' + 'content,element,shadow,template,blockquote,iframe,tfoot'); // this map is intentionally selective, only covering SVG elements that may
// contain child elements.

var isSVG = makeMap('svg,animate,circle,clippath,cursor,defs,desc,ellipse,filter,font-face,' + 'foreignobject,g,glyph,image,line,marker,mask,missing-glyph,path,pattern,' + 'polygon,polyline,rect,switch,symbol,text,textpath,tspan,use,view', true);

var isReservedTag = function (tag) {
  return isHTMLTag(tag) || isSVG(tag);
};

function getTagNamespace(tag) {
  if (isSVG(tag)) {
    return 'svg';
  } // basic support for MathML
  // note it doesn't support other MathML elements being component roots


  if (tag === 'math') {
    return 'math';
  }
}

var unknownElementCache = Object.create(null);

function isUnknownElement(tag) {
  /* istanbul ignore if */
  if (!inBrowser) {
    return true;
  }

  if (isReservedTag(tag)) {
    return false;
  }

  tag = tag.toLowerCase();
  /* istanbul ignore if */

  if (unknownElementCache[tag] != null) {
    return unknownElementCache[tag];
  }

  var el = document.createElement(tag);

  if (tag.indexOf('-') > -1) {
    // http://stackoverflow.com/a/28210364/1070244
    return unknownElementCache[tag] = el.constructor === window.HTMLUnknownElement || el.constructor === window.HTMLElement;
  } else {
    return unknownElementCache[tag] = /HTMLUnknownElement/.test(el.toString());
  }
}

var isTextInputType = makeMap('text,number,password,search,email,tel,url');
/*  */

/**
 * Query an element selector if it's not an element already.
 */

function query(el) {
  if (typeof el === 'string') {
    var selected = document.querySelector(el);

    if (!selected) {
       true && warn('Cannot find element: ' + el);
      return document.createElement('div');
    }

    return selected;
  } else {
    return el;
  }
}
/*  */


function createElement$1(tagName, vnode) {
  var elm = document.createElement(tagName);

  if (tagName !== 'select') {
    return elm;
  } // false or null will remove the attribute but undefined will not


  if (vnode.data && vnode.data.attrs && vnode.data.attrs.multiple !== undefined) {
    elm.setAttribute('multiple', 'multiple');
  }

  return elm;
}

function createElementNS(namespace, tagName) {
  return document.createElementNS(namespaceMap[namespace], tagName);
}

function createTextNode(text) {
  return document.createTextNode(text);
}

function createComment(text) {
  return document.createComment(text);
}

function insertBefore(parentNode, newNode, referenceNode) {
  parentNode.insertBefore(newNode, referenceNode);
}

function removeChild(node, child) {
  node.removeChild(child);
}

function appendChild(node, child) {
  node.appendChild(child);
}

function parentNode(node) {
  return node.parentNode;
}

function nextSibling(node) {
  return node.nextSibling;
}

function tagName(node) {
  return node.tagName;
}

function setTextContent(node, text) {
  node.textContent = text;
}

function setStyleScope(node, scopeId) {
  node.setAttribute(scopeId, '');
}

var nodeOps = /*#__PURE__*/Object.freeze({
  createElement: createElement$1,
  createElementNS: createElementNS,
  createTextNode: createTextNode,
  createComment: createComment,
  insertBefore: insertBefore,
  removeChild: removeChild,
  appendChild: appendChild,
  parentNode: parentNode,
  nextSibling: nextSibling,
  tagName: tagName,
  setTextContent: setTextContent,
  setStyleScope: setStyleScope
});
/*  */

var ref = {
  create: function create(_, vnode) {
    registerRef(vnode);
  },
  update: function update(oldVnode, vnode) {
    if (oldVnode.data.ref !== vnode.data.ref) {
      registerRef(oldVnode, true);
      registerRef(vnode);
    }
  },
  destroy: function destroy(vnode) {
    registerRef(vnode, true);
  }
};

function registerRef(vnode, isRemoval) {
  var key = vnode.data.ref;

  if (!isDef(key)) {
    return;
  }

  var vm = vnode.context;
  var ref = vnode.componentInstance || vnode.elm;
  var refs = vm.$refs;

  if (isRemoval) {
    if (Array.isArray(refs[key])) {
      remove(refs[key], ref);
    } else if (refs[key] === ref) {
      refs[key] = undefined;
    }
  } else {
    if (vnode.data.refInFor) {
      if (!Array.isArray(refs[key])) {
        refs[key] = [ref];
      } else if (refs[key].indexOf(ref) < 0) {
        // $flow-disable-line
        refs[key].push(ref);
      }
    } else {
      refs[key] = ref;
    }
  }
}
/**
 * Virtual DOM patching algorithm based on Snabbdom by
 * Simon Friis Vindum (@paldepind)
 * Licensed under the MIT License
 * https://github.com/paldepind/snabbdom/blob/master/LICENSE
 *
 * modified by Evan You (@yyx990803)
 *
 * Not type-checking this because this file is perf-critical and the cost
 * of making flow understand it is not worth it.
 */


var emptyNode = new VNode('', {}, []);
var hooks = ['create', 'activate', 'update', 'remove', 'destroy'];

function sameVnode(a, b) {
  return a.key === b.key && a.asyncFactory === b.asyncFactory && (a.tag === b.tag && a.isComment === b.isComment && isDef(a.data) === isDef(b.data) && sameInputType(a, b) || isTrue(a.isAsyncPlaceholder) && isUndef(b.asyncFactory.error));
}

function sameInputType(a, b) {
  if (a.tag !== 'input') {
    return true;
  }

  var i;
  var typeA = isDef(i = a.data) && isDef(i = i.attrs) && i.type;
  var typeB = isDef(i = b.data) && isDef(i = i.attrs) && i.type;
  return typeA === typeB || isTextInputType(typeA) && isTextInputType(typeB);
}

function createKeyToOldIdx(children, beginIdx, endIdx) {
  var i, key;
  var map = {};

  for (i = beginIdx; i <= endIdx; ++i) {
    key = children[i].key;

    if (isDef(key)) {
      map[key] = i;
    }
  }

  return map;
}

function createPatchFunction(backend) {
  var i, j;
  var cbs = {};
  var modules = backend.modules;
  var nodeOps = backend.nodeOps;

  for (i = 0; i < hooks.length; ++i) {
    cbs[hooks[i]] = [];

    for (j = 0; j < modules.length; ++j) {
      if (isDef(modules[j][hooks[i]])) {
        cbs[hooks[i]].push(modules[j][hooks[i]]);
      }
    }
  }

  function emptyNodeAt(elm) {
    return new VNode(nodeOps.tagName(elm).toLowerCase(), {}, [], undefined, elm);
  }

  function createRmCb(childElm, listeners) {
    function remove$$1() {
      if (--remove$$1.listeners === 0) {
        removeNode(childElm);
      }
    }

    remove$$1.listeners = listeners;
    return remove$$1;
  }

  function removeNode(el) {
    var parent = nodeOps.parentNode(el); // element may have already been removed due to v-html / v-text

    if (isDef(parent)) {
      nodeOps.removeChild(parent, el);
    }
  }

  function isUnknownElement$$1(vnode, inVPre) {
    return !inVPre && !vnode.ns && !(config.ignoredElements.length && config.ignoredElements.some(function (ignore) {
      return isRegExp(ignore) ? ignore.test(vnode.tag) : ignore === vnode.tag;
    })) && config.isUnknownElement(vnode.tag);
  }

  var creatingElmInVPre = 0;

  function createElm(vnode, insertedVnodeQueue, parentElm, refElm, nested, ownerArray, index) {
    if (isDef(vnode.elm) && isDef(ownerArray)) {
      // This vnode was used in a previous render!
      // now it's used as a new node, overwriting its elm would cause
      // potential patch errors down the road when it's used as an insertion
      // reference node. Instead, we clone the node on-demand before creating
      // associated DOM element for it.
      vnode = ownerArray[index] = cloneVNode(vnode);
    }

    vnode.isRootInsert = !nested; // for transition enter check

    if (createComponent(vnode, insertedVnodeQueue, parentElm, refElm)) {
      return;
    }

    var data = vnode.data;
    var children = vnode.children;
    var tag = vnode.tag;

    if (isDef(tag)) {
      if (true) {
        if (data && data.pre) {
          creatingElmInVPre++;
        }

        if (isUnknownElement$$1(vnode, creatingElmInVPre)) {
          warn('Unknown custom element: <' + tag + '> - did you ' + 'register the component correctly? For recursive components, ' + 'make sure to provide the "name" option.', vnode.context);
        }
      }

      vnode.elm = vnode.ns ? nodeOps.createElementNS(vnode.ns, tag) : nodeOps.createElement(tag, vnode);
      setScope(vnode);
      /* istanbul ignore if */

      {
        createChildren(vnode, children, insertedVnodeQueue);

        if (isDef(data)) {
          invokeCreateHooks(vnode, insertedVnodeQueue);
        }

        insert(parentElm, vnode.elm, refElm);
      }

      if ( true && data && data.pre) {
        creatingElmInVPre--;
      }
    } else if (isTrue(vnode.isComment)) {
      vnode.elm = nodeOps.createComment(vnode.text);
      insert(parentElm, vnode.elm, refElm);
    } else {
      vnode.elm = nodeOps.createTextNode(vnode.text);
      insert(parentElm, vnode.elm, refElm);
    }
  }

  function createComponent(vnode, insertedVnodeQueue, parentElm, refElm) {
    var i = vnode.data;

    if (isDef(i)) {
      var isReactivated = isDef(vnode.componentInstance) && i.keepAlive;

      if (isDef(i = i.hook) && isDef(i = i.init)) {
        i(vnode, false
        /* hydrating */
        );
      } // after calling the init hook, if the vnode is a child component
      // it should've created a child instance and mounted it. the child
      // component also has set the placeholder vnode's elm.
      // in that case we can just return the element and be done.


      if (isDef(vnode.componentInstance)) {
        initComponent(vnode, insertedVnodeQueue);
        insert(parentElm, vnode.elm, refElm);

        if (isTrue(isReactivated)) {
          reactivateComponent(vnode, insertedVnodeQueue, parentElm, refElm);
        }

        return true;
      }
    }
  }

  function initComponent(vnode, insertedVnodeQueue) {
    if (isDef(vnode.data.pendingInsert)) {
      insertedVnodeQueue.push.apply(insertedVnodeQueue, vnode.data.pendingInsert);
      vnode.data.pendingInsert = null;
    }

    vnode.elm = vnode.componentInstance.$el;

    if (isPatchable(vnode)) {
      invokeCreateHooks(vnode, insertedVnodeQueue);
      setScope(vnode);
    } else {
      // empty component root.
      // skip all element-related modules except for ref (#3455)
      registerRef(vnode); // make sure to invoke the insert hook

      insertedVnodeQueue.push(vnode);
    }
  }

  function reactivateComponent(vnode, insertedVnodeQueue, parentElm, refElm) {
    var i; // hack for #4339: a reactivated component with inner transition
    // does not trigger because the inner node's created hooks are not called
    // again. It's not ideal to involve module-specific logic in here but
    // there doesn't seem to be a better way to do it.

    var innerNode = vnode;

    while (innerNode.componentInstance) {
      innerNode = innerNode.componentInstance._vnode;

      if (isDef(i = innerNode.data) && isDef(i = i.transition)) {
        for (i = 0; i < cbs.activate.length; ++i) {
          cbs.activate[i](emptyNode, innerNode);
        }

        insertedVnodeQueue.push(innerNode);
        break;
      }
    } // unlike a newly created component,
    // a reactivated keep-alive component doesn't insert itself


    insert(parentElm, vnode.elm, refElm);
  }

  function insert(parent, elm, ref$$1) {
    if (isDef(parent)) {
      if (isDef(ref$$1)) {
        if (nodeOps.parentNode(ref$$1) === parent) {
          nodeOps.insertBefore(parent, elm, ref$$1);
        }
      } else {
        nodeOps.appendChild(parent, elm);
      }
    }
  }

  function createChildren(vnode, children, insertedVnodeQueue) {
    if (Array.isArray(children)) {
      if (true) {
        checkDuplicateKeys(children);
      }

      for (var i = 0; i < children.length; ++i) {
        createElm(children[i], insertedVnodeQueue, vnode.elm, null, true, children, i);
      }
    } else if (isPrimitive(vnode.text)) {
      nodeOps.appendChild(vnode.elm, nodeOps.createTextNode(String(vnode.text)));
    }
  }

  function isPatchable(vnode) {
    while (vnode.componentInstance) {
      vnode = vnode.componentInstance._vnode;
    }

    return isDef(vnode.tag);
  }

  function invokeCreateHooks(vnode, insertedVnodeQueue) {
    for (var i$1 = 0; i$1 < cbs.create.length; ++i$1) {
      cbs.create[i$1](emptyNode, vnode);
    }

    i = vnode.data.hook; // Reuse variable

    if (isDef(i)) {
      if (isDef(i.create)) {
        i.create(emptyNode, vnode);
      }

      if (isDef(i.insert)) {
        insertedVnodeQueue.push(vnode);
      }
    }
  } // set scope id attribute for scoped CSS.
  // this is implemented as a special case to avoid the overhead
  // of going through the normal attribute patching process.


  function setScope(vnode) {
    var i;

    if (isDef(i = vnode.fnScopeId)) {
      nodeOps.setStyleScope(vnode.elm, i);
    } else {
      var ancestor = vnode;

      while (ancestor) {
        if (isDef(i = ancestor.context) && isDef(i = i.$options._scopeId)) {
          nodeOps.setStyleScope(vnode.elm, i);
        }

        ancestor = ancestor.parent;
      }
    } // for slot content they should also get the scopeId from the host instance.


    if (isDef(i = activeInstance) && i !== vnode.context && i !== vnode.fnContext && isDef(i = i.$options._scopeId)) {
      nodeOps.setStyleScope(vnode.elm, i);
    }
  }

  function addVnodes(parentElm, refElm, vnodes, startIdx, endIdx, insertedVnodeQueue) {
    for (; startIdx <= endIdx; ++startIdx) {
      createElm(vnodes[startIdx], insertedVnodeQueue, parentElm, refElm, false, vnodes, startIdx);
    }
  }

  function invokeDestroyHook(vnode) {
    var i, j;
    var data = vnode.data;

    if (isDef(data)) {
      if (isDef(i = data.hook) && isDef(i = i.destroy)) {
        i(vnode);
      }

      for (i = 0; i < cbs.destroy.length; ++i) {
        cbs.destroy[i](vnode);
      }
    }

    if (isDef(i = vnode.children)) {
      for (j = 0; j < vnode.children.length; ++j) {
        invokeDestroyHook(vnode.children[j]);
      }
    }
  }

  function removeVnodes(vnodes, startIdx, endIdx) {
    for (; startIdx <= endIdx; ++startIdx) {
      var ch = vnodes[startIdx];

      if (isDef(ch)) {
        if (isDef(ch.tag)) {
          removeAndInvokeRemoveHook(ch);
          invokeDestroyHook(ch);
        } else {
          // Text node
          removeNode(ch.elm);
        }
      }
    }
  }

  function removeAndInvokeRemoveHook(vnode, rm) {
    if (isDef(rm) || isDef(vnode.data)) {
      var i;
      var listeners = cbs.remove.length + 1;

      if (isDef(rm)) {
        // we have a recursively passed down rm callback
        // increase the listeners count
        rm.listeners += listeners;
      } else {
        // directly removing
        rm = createRmCb(vnode.elm, listeners);
      } // recursively invoke hooks on child component root node


      if (isDef(i = vnode.componentInstance) && isDef(i = i._vnode) && isDef(i.data)) {
        removeAndInvokeRemoveHook(i, rm);
      }

      for (i = 0; i < cbs.remove.length; ++i) {
        cbs.remove[i](vnode, rm);
      }

      if (isDef(i = vnode.data.hook) && isDef(i = i.remove)) {
        i(vnode, rm);
      } else {
        rm();
      }
    } else {
      removeNode(vnode.elm);
    }
  }

  function updateChildren(parentElm, oldCh, newCh, insertedVnodeQueue, removeOnly) {
    var oldStartIdx = 0;
    var newStartIdx = 0;
    var oldEndIdx = oldCh.length - 1;
    var oldStartVnode = oldCh[0];
    var oldEndVnode = oldCh[oldEndIdx];
    var newEndIdx = newCh.length - 1;
    var newStartVnode = newCh[0];
    var newEndVnode = newCh[newEndIdx];
    var oldKeyToIdx, idxInOld, vnodeToMove, refElm; // removeOnly is a special flag used only by <transition-group>
    // to ensure removed elements stay in correct relative positions
    // during leaving transitions

    var canMove = !removeOnly;

    if (true) {
      checkDuplicateKeys(newCh);
    }

    while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {
      if (isUndef(oldStartVnode)) {
        oldStartVnode = oldCh[++oldStartIdx]; // Vnode has been moved left
      } else if (isUndef(oldEndVnode)) {
        oldEndVnode = oldCh[--oldEndIdx];
      } else if (sameVnode(oldStartVnode, newStartVnode)) {
        patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue, newCh, newStartIdx);
        oldStartVnode = oldCh[++oldStartIdx];
        newStartVnode = newCh[++newStartIdx];
      } else if (sameVnode(oldEndVnode, newEndVnode)) {
        patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue, newCh, newEndIdx);
        oldEndVnode = oldCh[--oldEndIdx];
        newEndVnode = newCh[--newEndIdx];
      } else if (sameVnode(oldStartVnode, newEndVnode)) {
        // Vnode moved right
        patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue, newCh, newEndIdx);
        canMove && nodeOps.insertBefore(parentElm, oldStartVnode.elm, nodeOps.nextSibling(oldEndVnode.elm));
        oldStartVnode = oldCh[++oldStartIdx];
        newEndVnode = newCh[--newEndIdx];
      } else if (sameVnode(oldEndVnode, newStartVnode)) {
        // Vnode moved left
        patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue, newCh, newStartIdx);
        canMove && nodeOps.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm);
        oldEndVnode = oldCh[--oldEndIdx];
        newStartVnode = newCh[++newStartIdx];
      } else {
        if (isUndef(oldKeyToIdx)) {
          oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx);
        }

        idxInOld = isDef(newStartVnode.key) ? oldKeyToIdx[newStartVnode.key] : findIdxInOld(newStartVnode, oldCh, oldStartIdx, oldEndIdx);

        if (isUndef(idxInOld)) {
          // New element
          createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, false, newCh, newStartIdx);
        } else {
          vnodeToMove = oldCh[idxInOld];

          if (sameVnode(vnodeToMove, newStartVnode)) {
            patchVnode(vnodeToMove, newStartVnode, insertedVnodeQueue, newCh, newStartIdx);
            oldCh[idxInOld] = undefined;
            canMove && nodeOps.insertBefore(parentElm, vnodeToMove.elm, oldStartVnode.elm);
          } else {
            // same key but different element. treat as new element
            createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, false, newCh, newStartIdx);
          }
        }

        newStartVnode = newCh[++newStartIdx];
      }
    }

    if (oldStartIdx > oldEndIdx) {
      refElm = isUndef(newCh[newEndIdx + 1]) ? null : newCh[newEndIdx + 1].elm;
      addVnodes(parentElm, refElm, newCh, newStartIdx, newEndIdx, insertedVnodeQueue);
    } else if (newStartIdx > newEndIdx) {
      removeVnodes(oldCh, oldStartIdx, oldEndIdx);
    }
  }

  function checkDuplicateKeys(children) {
    var seenKeys = {};

    for (var i = 0; i < children.length; i++) {
      var vnode = children[i];
      var key = vnode.key;

      if (isDef(key)) {
        if (seenKeys[key]) {
          warn("Duplicate keys detected: '" + key + "'. This may cause an update error.", vnode.context);
        } else {
          seenKeys[key] = true;
        }
      }
    }
  }

  function findIdxInOld(node, oldCh, start, end) {
    for (var i = start; i < end; i++) {
      var c = oldCh[i];

      if (isDef(c) && sameVnode(node, c)) {
        return i;
      }
    }
  }

  function patchVnode(oldVnode, vnode, insertedVnodeQueue, ownerArray, index, removeOnly) {
    if (oldVnode === vnode) {
      return;
    }

    if (isDef(vnode.elm) && isDef(ownerArray)) {
      // clone reused vnode
      vnode = ownerArray[index] = cloneVNode(vnode);
    }

    var elm = vnode.elm = oldVnode.elm;

    if (isTrue(oldVnode.isAsyncPlaceholder)) {
      if (isDef(vnode.asyncFactory.resolved)) {
        hydrate(oldVnode.elm, vnode, insertedVnodeQueue);
      } else {
        vnode.isAsyncPlaceholder = true;
      }

      return;
    } // reuse element for static trees.
    // note we only do this if the vnode is cloned -
    // if the new node is not cloned it means the render functions have been
    // reset by the hot-reload-api and we need to do a proper re-render.


    if (isTrue(vnode.isStatic) && isTrue(oldVnode.isStatic) && vnode.key === oldVnode.key && (isTrue(vnode.isCloned) || isTrue(vnode.isOnce))) {
      vnode.componentInstance = oldVnode.componentInstance;
      return;
    }

    var i;
    var data = vnode.data;

    if (isDef(data) && isDef(i = data.hook) && isDef(i = i.prepatch)) {
      i(oldVnode, vnode);
    }

    var oldCh = oldVnode.children;
    var ch = vnode.children;

    if (isDef(data) && isPatchable(vnode)) {
      for (i = 0; i < cbs.update.length; ++i) {
        cbs.update[i](oldVnode, vnode);
      }

      if (isDef(i = data.hook) && isDef(i = i.update)) {
        i(oldVnode, vnode);
      }
    }

    if (isUndef(vnode.text)) {
      if (isDef(oldCh) && isDef(ch)) {
        if (oldCh !== ch) {
          updateChildren(elm, oldCh, ch, insertedVnodeQueue, removeOnly);
        }
      } else if (isDef(ch)) {
        if (true) {
          checkDuplicateKeys(ch);
        }

        if (isDef(oldVnode.text)) {
          nodeOps.setTextContent(elm, '');
        }

        addVnodes(elm, null, ch, 0, ch.length - 1, insertedVnodeQueue);
      } else if (isDef(oldCh)) {
        removeVnodes(oldCh, 0, oldCh.length - 1);
      } else if (isDef(oldVnode.text)) {
        nodeOps.setTextContent(elm, '');
      }
    } else if (oldVnode.text !== vnode.text) {
      nodeOps.setTextContent(elm, vnode.text);
    }

    if (isDef(data)) {
      if (isDef(i = data.hook) && isDef(i = i.postpatch)) {
        i(oldVnode, vnode);
      }
    }
  }

  function invokeInsertHook(vnode, queue, initial) {
    // delay insert hooks for component root nodes, invoke them after the
    // element is really inserted
    if (isTrue(initial) && isDef(vnode.parent)) {
      vnode.parent.data.pendingInsert = queue;
    } else {
      for (var i = 0; i < queue.length; ++i) {
        queue[i].data.hook.insert(queue[i]);
      }
    }
  }

  var hydrationBailed = false; // list of modules that can skip create hook during hydration because they
  // are already rendered on the client or has no need for initialization
  // Note: style is excluded because it relies on initial clone for future
  // deep updates (#7063).

  var isRenderedModule = makeMap('attrs,class,staticClass,staticStyle,key'); // Note: this is a browser-only function so we can assume elms are DOM nodes.

  function hydrate(elm, vnode, insertedVnodeQueue, inVPre) {
    var i;
    var tag = vnode.tag;
    var data = vnode.data;
    var children = vnode.children;
    inVPre = inVPre || data && data.pre;
    vnode.elm = elm;

    if (isTrue(vnode.isComment) && isDef(vnode.asyncFactory)) {
      vnode.isAsyncPlaceholder = true;
      return true;
    } // assert node match


    if (true) {
      if (!assertNodeMatch(elm, vnode, inVPre)) {
        return false;
      }
    }

    if (isDef(data)) {
      if (isDef(i = data.hook) && isDef(i = i.init)) {
        i(vnode, true
        /* hydrating */
        );
      }

      if (isDef(i = vnode.componentInstance)) {
        // child component. it should have hydrated its own tree.
        initComponent(vnode, insertedVnodeQueue);
        return true;
      }
    }

    if (isDef(tag)) {
      if (isDef(children)) {
        // empty element, allow client to pick up and populate children
        if (!elm.hasChildNodes()) {
          createChildren(vnode, children, insertedVnodeQueue);
        } else {
          // v-html and domProps: innerHTML
          if (isDef(i = data) && isDef(i = i.domProps) && isDef(i = i.innerHTML)) {
            if (i !== elm.innerHTML) {
              /* istanbul ignore if */
              if ( true && typeof console !== 'undefined' && !hydrationBailed) {
                hydrationBailed = true;
                console.warn('Parent: ', elm);
                console.warn('server innerHTML: ', i);
                console.warn('client innerHTML: ', elm.innerHTML);
              }

              return false;
            }
          } else {
            // iterate and compare children lists
            var childrenMatch = true;
            var childNode = elm.firstChild;

            for (var i$1 = 0; i$1 < children.length; i$1++) {
              if (!childNode || !hydrate(childNode, children[i$1], insertedVnodeQueue, inVPre)) {
                childrenMatch = false;
                break;
              }

              childNode = childNode.nextSibling;
            } // if childNode is not null, it means the actual childNodes list is
            // longer than the virtual children list.


            if (!childrenMatch || childNode) {
              /* istanbul ignore if */
              if ( true && typeof console !== 'undefined' && !hydrationBailed) {
                hydrationBailed = true;
                console.warn('Parent: ', elm);
                console.warn('Mismatching childNodes vs. VNodes: ', elm.childNodes, children);
              }

              return false;
            }
          }
        }
      }

      if (isDef(data)) {
        var fullInvoke = false;

        for (var key in data) {
          if (!isRenderedModule(key)) {
            fullInvoke = true;
            invokeCreateHooks(vnode, insertedVnodeQueue);
            break;
          }
        }

        if (!fullInvoke && data['class']) {
          // ensure collecting deps for deep class bindings for future updates
          traverse(data['class']);
        }
      }
    } else if (elm.data !== vnode.text) {
      elm.data = vnode.text;
    }

    return true;
  }

  function assertNodeMatch(node, vnode, inVPre) {
    if (isDef(vnode.tag)) {
      return vnode.tag.indexOf('vue-component') === 0 || !isUnknownElement$$1(vnode, inVPre) && vnode.tag.toLowerCase() === (node.tagName && node.tagName.toLowerCase());
    } else {
      return node.nodeType === (vnode.isComment ? 8 : 3);
    }
  }

  return function patch(oldVnode, vnode, hydrating, removeOnly) {
    if (isUndef(vnode)) {
      if (isDef(oldVnode)) {
        invokeDestroyHook(oldVnode);
      }

      return;
    }

    var isInitialPatch = false;
    var insertedVnodeQueue = [];

    if (isUndef(oldVnode)) {
      // empty mount (likely as component), create new root element
      isInitialPatch = true;
      createElm(vnode, insertedVnodeQueue);
    } else {
      var isRealElement = isDef(oldVnode.nodeType);

      if (!isRealElement && sameVnode(oldVnode, vnode)) {
        // patch existing root node
        patchVnode(oldVnode, vnode, insertedVnodeQueue, null, null, removeOnly);
      } else {
        if (isRealElement) {
          // mounting to a real element
          // check if this is server-rendered content and if we can perform
          // a successful hydration.
          if (oldVnode.nodeType === 1 && oldVnode.hasAttribute(SSR_ATTR)) {
            oldVnode.removeAttribute(SSR_ATTR);
            hydrating = true;
          }

          if (isTrue(hydrating)) {
            if (hydrate(oldVnode, vnode, insertedVnodeQueue)) {
              invokeInsertHook(vnode, insertedVnodeQueue, true);
              return oldVnode;
            } else if (true) {
              warn('The client-side rendered virtual DOM tree is not matching ' + 'server-rendered content. This is likely caused by incorrect ' + 'HTML markup, for example nesting block-level elements inside ' + '<p>, or missing <tbody>. Bailing hydration and performing ' + 'full client-side render.');
            }
          } // either not server-rendered, or hydration failed.
          // create an empty node and replace it


          oldVnode = emptyNodeAt(oldVnode);
        } // replacing existing element


        var oldElm = oldVnode.elm;
        var parentElm = nodeOps.parentNode(oldElm); // create new node

        createElm(vnode, insertedVnodeQueue, // extremely rare edge case: do not insert if old element is in a
        // leaving transition. Only happens when combining transition +
        // keep-alive + HOCs. (#4590)
        oldElm._leaveCb ? null : parentElm, nodeOps.nextSibling(oldElm)); // update parent placeholder node element, recursively

        if (isDef(vnode.parent)) {
          var ancestor = vnode.parent;
          var patchable = isPatchable(vnode);

          while (ancestor) {
            for (var i = 0; i < cbs.destroy.length; ++i) {
              cbs.destroy[i](ancestor);
            }

            ancestor.elm = vnode.elm;

            if (patchable) {
              for (var i$1 = 0; i$1 < cbs.create.length; ++i$1) {
                cbs.create[i$1](emptyNode, ancestor);
              } // #6513
              // invoke insert hooks that may have been merged by create hooks.
              // e.g. for directives that uses the "inserted" hook.


              var insert = ancestor.data.hook.insert;

              if (insert.merged) {
                // start at index 1 to avoid re-invoking component mounted hook
                for (var i$2 = 1; i$2 < insert.fns.length; i$2++) {
                  insert.fns[i$2]();
                }
              }
            } else {
              registerRef(ancestor);
            }

            ancestor = ancestor.parent;
          }
        } // destroy old node


        if (isDef(parentElm)) {
          removeVnodes([oldVnode], 0, 0);
        } else if (isDef(oldVnode.tag)) {
          invokeDestroyHook(oldVnode);
        }
      }
    }

    invokeInsertHook(vnode, insertedVnodeQueue, isInitialPatch);
    return vnode.elm;
  };
}
/*  */


var directives = {
  create: updateDirectives,
  update: updateDirectives,
  destroy: function unbindDirectives(vnode) {
    updateDirectives(vnode, emptyNode);
  }
};

function updateDirectives(oldVnode, vnode) {
  if (oldVnode.data.directives || vnode.data.directives) {
    _update(oldVnode, vnode);
  }
}

function _update(oldVnode, vnode) {
  var isCreate = oldVnode === emptyNode;
  var isDestroy = vnode === emptyNode;
  var oldDirs = normalizeDirectives$1(oldVnode.data.directives, oldVnode.context);
  var newDirs = normalizeDirectives$1(vnode.data.directives, vnode.context);
  var dirsWithInsert = [];
  var dirsWithPostpatch = [];
  var key, oldDir, dir;

  for (key in newDirs) {
    oldDir = oldDirs[key];
    dir = newDirs[key];

    if (!oldDir) {
      // new directive, bind
      callHook$1(dir, 'bind', vnode, oldVnode);

      if (dir.def && dir.def.inserted) {
        dirsWithInsert.push(dir);
      }
    } else {
      // existing directive, update
      dir.oldValue = oldDir.value;
      dir.oldArg = oldDir.arg;
      callHook$1(dir, 'update', vnode, oldVnode);

      if (dir.def && dir.def.componentUpdated) {
        dirsWithPostpatch.push(dir);
      }
    }
  }

  if (dirsWithInsert.length) {
    var callInsert = function () {
      for (var i = 0; i < dirsWithInsert.length; i++) {
        callHook$1(dirsWithInsert[i], 'inserted', vnode, oldVnode);
      }
    };

    if (isCreate) {
      mergeVNodeHook(vnode, 'insert', callInsert);
    } else {
      callInsert();
    }
  }

  if (dirsWithPostpatch.length) {
    mergeVNodeHook(vnode, 'postpatch', function () {
      for (var i = 0; i < dirsWithPostpatch.length; i++) {
        callHook$1(dirsWithPostpatch[i], 'componentUpdated', vnode, oldVnode);
      }
    });
  }

  if (!isCreate) {
    for (key in oldDirs) {
      if (!newDirs[key]) {
        // no longer present, unbind
        callHook$1(oldDirs[key], 'unbind', oldVnode, oldVnode, isDestroy);
      }
    }
  }
}

var emptyModifiers = Object.create(null);

function normalizeDirectives$1(dirs, vm) {
  var res = Object.create(null);

  if (!dirs) {
    // $flow-disable-line
    return res;
  }

  var i, dir;

  for (i = 0; i < dirs.length; i++) {
    dir = dirs[i];

    if (!dir.modifiers) {
      // $flow-disable-line
      dir.modifiers = emptyModifiers;
    }

    res[getRawDirName(dir)] = dir;
    dir.def = resolveAsset(vm.$options, 'directives', dir.name, true);
  } // $flow-disable-line


  return res;
}

function getRawDirName(dir) {
  return dir.rawName || dir.name + "." + Object.keys(dir.modifiers || {}).join('.');
}

function callHook$1(dir, hook, vnode, oldVnode, isDestroy) {
  var fn = dir.def && dir.def[hook];

  if (fn) {
    try {
      fn(vnode.elm, dir, vnode, oldVnode, isDestroy);
    } catch (e) {
      handleError(e, vnode.context, "directive " + dir.name + " " + hook + " hook");
    }
  }
}

var baseModules = [ref, directives];
/*  */

function updateAttrs(oldVnode, vnode) {
  var opts = vnode.componentOptions;

  if (isDef(opts) && opts.Ctor.options.inheritAttrs === false) {
    return;
  }

  if (isUndef(oldVnode.data.attrs) && isUndef(vnode.data.attrs)) {
    return;
  }

  var key, cur, old;
  var elm = vnode.elm;
  var oldAttrs = oldVnode.data.attrs || {};
  var attrs = vnode.data.attrs || {}; // clone observed objects, as the user probably wants to mutate it

  if (isDef(attrs.__ob__)) {
    attrs = vnode.data.attrs = extend({}, attrs);
  }

  for (key in attrs) {
    cur = attrs[key];
    old = oldAttrs[key];

    if (old !== cur) {
      setAttr(elm, key, cur, vnode.data.pre);
    }
  } // #4391: in IE9, setting type can reset value for input[type=radio]
  // #6666: IE/Edge forces progress value down to 1 before setting a max

  /* istanbul ignore if */


  if ((isIE || isEdge) && attrs.value !== oldAttrs.value) {
    setAttr(elm, 'value', attrs.value);
  }

  for (key in oldAttrs) {
    if (isUndef(attrs[key])) {
      if (isXlink(key)) {
        elm.removeAttributeNS(xlinkNS, getXlinkProp(key));
      } else if (!isEnumeratedAttr(key)) {
        elm.removeAttribute(key);
      }
    }
  }
}

function setAttr(el, key, value, isInPre) {
  if (isInPre || el.tagName.indexOf('-') > -1) {
    baseSetAttr(el, key, value);
  } else if (isBooleanAttr(key)) {
    // set attribute for blank value
    // e.g. <option disabled>Select one</option>
    if (isFalsyAttrValue(value)) {
      el.removeAttribute(key);
    } else {
      // technically allowfullscreen is a boolean attribute for <iframe>,
      // but Flash expects a value of "true" when used on <embed> tag
      value = key === 'allowfullscreen' && el.tagName === 'EMBED' ? 'true' : key;
      el.setAttribute(key, value);
    }
  } else if (isEnumeratedAttr(key)) {
    el.setAttribute(key, convertEnumeratedValue(key, value));
  } else if (isXlink(key)) {
    if (isFalsyAttrValue(value)) {
      el.removeAttributeNS(xlinkNS, getXlinkProp(key));
    } else {
      el.setAttributeNS(xlinkNS, key, value);
    }
  } else {
    baseSetAttr(el, key, value);
  }
}

function baseSetAttr(el, key, value) {
  if (isFalsyAttrValue(value)) {
    el.removeAttribute(key);
  } else {
    // #7138: IE10 & 11 fires input event when setting placeholder on
    // <textarea>... block the first input event and remove the blocker
    // immediately.

    /* istanbul ignore if */
    if (isIE && !isIE9 && el.tagName === 'TEXTAREA' && key === 'placeholder' && value !== '' && !el.__ieph) {
      var blocker = function (e) {
        e.stopImmediatePropagation();
        el.removeEventListener('input', blocker);
      };

      el.addEventListener('input', blocker); // $flow-disable-line

      el.__ieph = true;
      /* IE placeholder patched */
    }

    el.setAttribute(key, value);
  }
}

var attrs = {
  create: updateAttrs,
  update: updateAttrs
};
/*  */

function updateClass(oldVnode, vnode) {
  var el = vnode.elm;
  var data = vnode.data;
  var oldData = oldVnode.data;

  if (isUndef(data.staticClass) && isUndef(data.class) && (isUndef(oldData) || isUndef(oldData.staticClass) && isUndef(oldData.class))) {
    return;
  }

  var cls = genClassForVnode(vnode); // handle transition classes

  var transitionClass = el._transitionClasses;

  if (isDef(transitionClass)) {
    cls = concat(cls, stringifyClass(transitionClass));
  } // set the class


  if (cls !== el._prevClass) {
    el.setAttribute('class', cls);
    el._prevClass = cls;
  }
}

var klass = {
  create: updateClass,
  update: updateClass
};
/*  */

/*  */

/*  */

/*  */
// in some cases, the event used has to be determined at runtime
// so we used some reserved tokens during compile.

var RANGE_TOKEN = '__r';
var CHECKBOX_RADIO_TOKEN = '__c';
/*  */
// normalize v-model event tokens that can only be determined at runtime.
// it's important to place the event as the first in the array because
// the whole point is ensuring the v-model callback gets called before
// user-attached handlers.

function normalizeEvents(on) {
  /* istanbul ignore if */
  if (isDef(on[RANGE_TOKEN])) {
    // IE input[type=range] only supports `change` event
    var event = isIE ? 'change' : 'input';
    on[event] = [].concat(on[RANGE_TOKEN], on[event] || []);
    delete on[RANGE_TOKEN];
  } // This was originally intended to fix #4521 but no longer necessary
  // after 2.5. Keeping it for backwards compat with generated code from < 2.4

  /* istanbul ignore if */


  if (isDef(on[CHECKBOX_RADIO_TOKEN])) {
    on.change = [].concat(on[CHECKBOX_RADIO_TOKEN], on.change || []);
    delete on[CHECKBOX_RADIO_TOKEN];
  }
}

var target$1;

function createOnceHandler$1(event, handler, capture) {
  var _target = target$1; // save current target element in closure

  return function onceHandler() {
    var res = handler.apply(null, arguments);

    if (res !== null) {
      remove$2(event, onceHandler, capture, _target);
    }
  };
} // #9446: Firefox <= 53 (in particular, ESR 52) has incorrect Event.timeStamp
// implementation and does not fire microtasks in between event propagation, so
// safe to exclude.


var useMicrotaskFix = isUsingMicroTask && !(isFF && Number(isFF[1]) <= 53);

function add$1(name, handler, capture, passive) {
  // async edge case #6566: inner click event triggers patch, event handler
  // attached to outer element during patch, and triggered again. This
  // happens because browsers fire microtask ticks between event propagation.
  // the solution is simple: we save the timestamp when a handler is attached,
  // and the handler would only fire if the event passed to it was fired
  // AFTER it was attached.
  if (useMicrotaskFix) {
    var attachedTimestamp = currentFlushTimestamp;
    var original = handler;

    handler = original._wrapper = function (e) {
      if ( // no bubbling, should always fire.
      // this is just a safety net in case event.timeStamp is unreliable in
      // certain weird environments...
      e.target === e.currentTarget || // event is fired after handler attachment
      e.timeStamp >= attachedTimestamp || // bail for environments that have buggy event.timeStamp implementations
      // #9462 iOS 9 bug: event.timeStamp is 0 after history.pushState
      // #9681 QtWebEngine event.timeStamp is negative value
      e.timeStamp <= 0 || // #9448 bail if event is fired in another document in a multi-page
      // electron/nw.js app, since event.timeStamp will be using a different
      // starting reference
      e.target.ownerDocument !== document) {
        return original.apply(this, arguments);
      }
    };
  }

  target$1.addEventListener(name, handler, supportsPassive ? {
    capture: capture,
    passive: passive
  } : capture);
}

function remove$2(name, handler, capture, _target) {
  (_target || target$1).removeEventListener(name, handler._wrapper || handler, capture);
}

function updateDOMListeners(oldVnode, vnode) {
  if (isUndef(oldVnode.data.on) && isUndef(vnode.data.on)) {
    return;
  }

  var on = vnode.data.on || {};
  var oldOn = oldVnode.data.on || {};
  target$1 = vnode.elm;
  normalizeEvents(on);
  updateListeners(on, oldOn, add$1, remove$2, createOnceHandler$1, vnode.context);
  target$1 = undefined;
}

var events = {
  create: updateDOMListeners,
  update: updateDOMListeners
};
/*  */

var svgContainer;

function updateDOMProps(oldVnode, vnode) {
  if (isUndef(oldVnode.data.domProps) && isUndef(vnode.data.domProps)) {
    return;
  }

  var key, cur;
  var elm = vnode.elm;
  var oldProps = oldVnode.data.domProps || {};
  var props = vnode.data.domProps || {}; // clone observed objects, as the user probably wants to mutate it

  if (isDef(props.__ob__)) {
    props = vnode.data.domProps = extend({}, props);
  }

  for (key in oldProps) {
    if (!(key in props)) {
      elm[key] = '';
    }
  }

  for (key in props) {
    cur = props[key]; // ignore children if the node has textContent or innerHTML,
    // as these will throw away existing DOM nodes and cause removal errors
    // on subsequent patches (#3360)

    if (key === 'textContent' || key === 'innerHTML') {
      if (vnode.children) {
        vnode.children.length = 0;
      }

      if (cur === oldProps[key]) {
        continue;
      } // #6601 work around Chrome version <= 55 bug where single textNode
      // replaced by innerHTML/textContent retains its parentNode property


      if (elm.childNodes.length === 1) {
        elm.removeChild(elm.childNodes[0]);
      }
    }

    if (key === 'value' && elm.tagName !== 'PROGRESS') {
      // store value as _value as well since
      // non-string values will be stringified
      elm._value = cur; // avoid resetting cursor position when value is the same

      var strCur = isUndef(cur) ? '' : String(cur);

      if (shouldUpdateValue(elm, strCur)) {
        elm.value = strCur;
      }
    } else if (key === 'innerHTML' && isSVG(elm.tagName) && isUndef(elm.innerHTML)) {
      // IE doesn't support innerHTML for SVG elements
      svgContainer = svgContainer || document.createElement('div');
      svgContainer.innerHTML = "<svg>" + cur + "</svg>";
      var svg = svgContainer.firstChild;

      while (elm.firstChild) {
        elm.removeChild(elm.firstChild);
      }

      while (svg.firstChild) {
        elm.appendChild(svg.firstChild);
      }
    } else if ( // skip the update if old and new VDOM state is the same.
    // `value` is handled separately because the DOM value may be temporarily
    // out of sync with VDOM state due to focus, composition and modifiers.
    // This  #4521 by skipping the unnecessary `checked` update.
    cur !== oldProps[key]) {
      // some property updates can throw
      // e.g. `value` on <progress> w/ non-finite value
      try {
        elm[key] = cur;
      } catch (e) {}
    }
  }
} // check platforms/web/util/attrs.js acceptValue


function shouldUpdateValue(elm, checkVal) {
  return !elm.composing && (elm.tagName === 'OPTION' || isNotInFocusAndDirty(elm, checkVal) || isDirtyWithModifiers(elm, checkVal));
}

function isNotInFocusAndDirty(elm, checkVal) {
  // return true when textbox (.number and .trim) loses focus and its value is
  // not equal to the updated value
  var notInFocus = true; // #6157
  // work around IE bug when accessing document.activeElement in an iframe

  try {
    notInFocus = document.activeElement !== elm;
  } catch (e) {}

  return notInFocus && elm.value !== checkVal;
}

function isDirtyWithModifiers(elm, newVal) {
  var value = elm.value;
  var modifiers = elm._vModifiers; // injected by v-model runtime

  if (isDef(modifiers)) {
    if (modifiers.number) {
      return toNumber(value) !== toNumber(newVal);
    }

    if (modifiers.trim) {
      return value.trim() !== newVal.trim();
    }
  }

  return value !== newVal;
}

var domProps = {
  create: updateDOMProps,
  update: updateDOMProps
};
/*  */

var parseStyleText = cached(function (cssText) {
  var res = {};
  var listDelimiter = /;(?![^(]*\))/g;
  var propertyDelimiter = /:(.+)/;
  cssText.split(listDelimiter).forEach(function (item) {
    if (item) {
      var tmp = item.split(propertyDelimiter);
      tmp.length > 1 && (res[tmp[0].trim()] = tmp[1].trim());
    }
  });
  return res;
}); // merge static and dynamic style data on the same vnode

function normalizeStyleData(data) {
  var style = normalizeStyleBinding(data.style); // static style is pre-processed into an object during compilation
  // and is always a fresh object, so it's safe to merge into it

  return data.staticStyle ? extend(data.staticStyle, style) : style;
} // normalize possible array / string values into Object


function normalizeStyleBinding(bindingStyle) {
  if (Array.isArray(bindingStyle)) {
    return toObject(bindingStyle);
  }

  if (typeof bindingStyle === 'string') {
    return parseStyleText(bindingStyle);
  }

  return bindingStyle;
}
/**
 * parent component style should be after child's
 * so that parent component's style could override it
 */


function getStyle(vnode, checkChild) {
  var res = {};
  var styleData;

  if (checkChild) {
    var childNode = vnode;

    while (childNode.componentInstance) {
      childNode = childNode.componentInstance._vnode;

      if (childNode && childNode.data && (styleData = normalizeStyleData(childNode.data))) {
        extend(res, styleData);
      }
    }
  }

  if (styleData = normalizeStyleData(vnode.data)) {
    extend(res, styleData);
  }

  var parentNode = vnode;

  while (parentNode = parentNode.parent) {
    if (parentNode.data && (styleData = normalizeStyleData(parentNode.data))) {
      extend(res, styleData);
    }
  }

  return res;
}
/*  */


var cssVarRE = /^--/;
var importantRE = /\s*!important$/;

var setProp = function (el, name, val) {
  /* istanbul ignore if */
  if (cssVarRE.test(name)) {
    el.style.setProperty(name, val);
  } else if (importantRE.test(val)) {
    el.style.setProperty(hyphenate(name), val.replace(importantRE, ''), 'important');
  } else {
    var normalizedName = normalize(name);

    if (Array.isArray(val)) {
      // Support values array created by autoprefixer, e.g.
      // {display: ["-webkit-box", "-ms-flexbox", "flex"]}
      // Set them one by one, and the browser will only set those it can recognize
      for (var i = 0, len = val.length; i < len; i++) {
        el.style[normalizedName] = val[i];
      }
    } else {
      el.style[normalizedName] = val;
    }
  }
};

var vendorNames = ['Webkit', 'Moz', 'ms'];
var emptyStyle;
var normalize = cached(function (prop) {
  emptyStyle = emptyStyle || document.createElement('div').style;
  prop = camelize(prop);

  if (prop !== 'filter' && prop in emptyStyle) {
    return prop;
  }

  var capName = prop.charAt(0).toUpperCase() + prop.slice(1);

  for (var i = 0; i < vendorNames.length; i++) {
    var name = vendorNames[i] + capName;

    if (name in emptyStyle) {
      return name;
    }
  }
});

function updateStyle(oldVnode, vnode) {
  var data = vnode.data;
  var oldData = oldVnode.data;

  if (isUndef(data.staticStyle) && isUndef(data.style) && isUndef(oldData.staticStyle) && isUndef(oldData.style)) {
    return;
  }

  var cur, name;
  var el = vnode.elm;
  var oldStaticStyle = oldData.staticStyle;
  var oldStyleBinding = oldData.normalizedStyle || oldData.style || {}; // if static style exists, stylebinding already merged into it when doing normalizeStyleData

  var oldStyle = oldStaticStyle || oldStyleBinding;
  var style = normalizeStyleBinding(vnode.data.style) || {}; // store normalized style under a different key for next diff
  // make sure to clone it if it's reactive, since the user likely wants
  // to mutate it.

  vnode.data.normalizedStyle = isDef(style.__ob__) ? extend({}, style) : style;
  var newStyle = getStyle(vnode, true);

  for (name in oldStyle) {
    if (isUndef(newStyle[name])) {
      setProp(el, name, '');
    }
  }

  for (name in newStyle) {
    cur = newStyle[name];

    if (cur !== oldStyle[name]) {
      // ie9 setting to null has no effect, must use empty string
      setProp(el, name, cur == null ? '' : cur);
    }
  }
}

var style = {
  create: updateStyle,
  update: updateStyle
};
/*  */

var whitespaceRE = /\s+/;
/**
 * Add class with compatibility for SVG since classList is not supported on
 * SVG elements in IE
 */

function addClass(el, cls) {
  /* istanbul ignore if */
  if (!cls || !(cls = cls.trim())) {
    return;
  }
  /* istanbul ignore else */


  if (el.classList) {
    if (cls.indexOf(' ') > -1) {
      cls.split(whitespaceRE).forEach(function (c) {
        return el.classList.add(c);
      });
    } else {
      el.classList.add(cls);
    }
  } else {
    var cur = " " + (el.getAttribute('class') || '') + " ";

    if (cur.indexOf(' ' + cls + ' ') < 0) {
      el.setAttribute('class', (cur + cls).trim());
    }
  }
}
/**
 * Remove class with compatibility for SVG since classList is not supported on
 * SVG elements in IE
 */


function removeClass(el, cls) {
  /* istanbul ignore if */
  if (!cls || !(cls = cls.trim())) {
    return;
  }
  /* istanbul ignore else */


  if (el.classList) {
    if (cls.indexOf(' ') > -1) {
      cls.split(whitespaceRE).forEach(function (c) {
        return el.classList.remove(c);
      });
    } else {
      el.classList.remove(cls);
    }

    if (!el.classList.length) {
      el.removeAttribute('class');
    }
  } else {
    var cur = " " + (el.getAttribute('class') || '') + " ";
    var tar = ' ' + cls + ' ';

    while (cur.indexOf(tar) >= 0) {
      cur = cur.replace(tar, ' ');
    }

    cur = cur.trim();

    if (cur) {
      el.setAttribute('class', cur);
    } else {
      el.removeAttribute('class');
    }
  }
}
/*  */


function resolveTransition(def$$1) {
  if (!def$$1) {
    return;
  }
  /* istanbul ignore else */


  if (typeof def$$1 === 'object') {
    var res = {};

    if (def$$1.css !== false) {
      extend(res, autoCssTransition(def$$1.name || 'v'));
    }

    extend(res, def$$1);
    return res;
  } else if (typeof def$$1 === 'string') {
    return autoCssTransition(def$$1);
  }
}

var autoCssTransition = cached(function (name) {
  return {
    enterClass: name + "-enter",
    enterToClass: name + "-enter-to",
    enterActiveClass: name + "-enter-active",
    leaveClass: name + "-leave",
    leaveToClass: name + "-leave-to",
    leaveActiveClass: name + "-leave-active"
  };
});
var hasTransition = inBrowser && !isIE9;
var TRANSITION = 'transition';
var ANIMATION = 'animation'; // Transition property/event sniffing

var transitionProp = 'transition';
var transitionEndEvent = 'transitionend';
var animationProp = 'animation';
var animationEndEvent = 'animationend';

if (hasTransition) {
  /* istanbul ignore if */
  if (window.ontransitionend === undefined && window.onwebkittransitionend !== undefined) {
    transitionProp = 'WebkitTransition';
    transitionEndEvent = 'webkitTransitionEnd';
  }

  if (window.onanimationend === undefined && window.onwebkitanimationend !== undefined) {
    animationProp = 'WebkitAnimation';
    animationEndEvent = 'webkitAnimationEnd';
  }
} // binding to window is necessary to make hot reload work in IE in strict mode


var raf = inBrowser ? window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : setTimeout :
/* istanbul ignore next */
function (fn) {
  return fn();
};

function nextFrame(fn) {
  raf(function () {
    raf(fn);
  });
}

function addTransitionClass(el, cls) {
  var transitionClasses = el._transitionClasses || (el._transitionClasses = []);

  if (transitionClasses.indexOf(cls) < 0) {
    transitionClasses.push(cls);
    addClass(el, cls);
  }
}

function removeTransitionClass(el, cls) {
  if (el._transitionClasses) {
    remove(el._transitionClasses, cls);
  }

  removeClass(el, cls);
}

function whenTransitionEnds(el, expectedType, cb) {
  var ref = getTransitionInfo(el, expectedType);
  var type = ref.type;
  var timeout = ref.timeout;
  var propCount = ref.propCount;

  if (!type) {
    return cb();
  }

  var event = type === TRANSITION ? transitionEndEvent : animationEndEvent;
  var ended = 0;

  var end = function () {
    el.removeEventListener(event, onEnd);
    cb();
  };

  var onEnd = function (e) {
    if (e.target === el) {
      if (++ended >= propCount) {
        end();
      }
    }
  };

  setTimeout(function () {
    if (ended < propCount) {
      end();
    }
  }, timeout + 1);
  el.addEventListener(event, onEnd);
}

var transformRE = /\b(transform|all)(,|$)/;

function getTransitionInfo(el, expectedType) {
  var styles = window.getComputedStyle(el); // JSDOM may return undefined for transition properties

  var transitionDelays = (styles[transitionProp + 'Delay'] || '').split(', ');
  var transitionDurations = (styles[transitionProp + 'Duration'] || '').split(', ');
  var transitionTimeout = getTimeout(transitionDelays, transitionDurations);
  var animationDelays = (styles[animationProp + 'Delay'] || '').split(', ');
  var animationDurations = (styles[animationProp + 'Duration'] || '').split(', ');
  var animationTimeout = getTimeout(animationDelays, animationDurations);
  var type;
  var timeout = 0;
  var propCount = 0;
  /* istanbul ignore if */

  if (expectedType === TRANSITION) {
    if (transitionTimeout > 0) {
      type = TRANSITION;
      timeout = transitionTimeout;
      propCount = transitionDurations.length;
    }
  } else if (expectedType === ANIMATION) {
    if (animationTimeout > 0) {
      type = ANIMATION;
      timeout = animationTimeout;
      propCount = animationDurations.length;
    }
  } else {
    timeout = Math.max(transitionTimeout, animationTimeout);
    type = timeout > 0 ? transitionTimeout > animationTimeout ? TRANSITION : ANIMATION : null;
    propCount = type ? type === TRANSITION ? transitionDurations.length : animationDurations.length : 0;
  }

  var hasTransform = type === TRANSITION && transformRE.test(styles[transitionProp + 'Property']);
  return {
    type: type,
    timeout: timeout,
    propCount: propCount,
    hasTransform: hasTransform
  };
}

function getTimeout(delays, durations) {
  /* istanbul ignore next */
  while (delays.length < durations.length) {
    delays = delays.concat(delays);
  }

  return Math.max.apply(null, durations.map(function (d, i) {
    return toMs(d) + toMs(delays[i]);
  }));
} // Old versions of Chromium (below 61.0.3163.100) formats floating pointer numbers
// in a locale-dependent way, using a comma instead of a dot.
// If comma is not replaced with a dot, the input will be rounded down (i.e. acting
// as a floor function) causing unexpected behaviors


function toMs(s) {
  return Number(s.slice(0, -1).replace(',', '.')) * 1000;
}
/*  */


function enter(vnode, toggleDisplay) {
  var el = vnode.elm; // call leave callback now

  if (isDef(el._leaveCb)) {
    el._leaveCb.cancelled = true;

    el._leaveCb();
  }

  var data = resolveTransition(vnode.data.transition);

  if (isUndef(data)) {
    return;
  }
  /* istanbul ignore if */


  if (isDef(el._enterCb) || el.nodeType !== 1) {
    return;
  }

  var css = data.css;
  var type = data.type;
  var enterClass = data.enterClass;
  var enterToClass = data.enterToClass;
  var enterActiveClass = data.enterActiveClass;
  var appearClass = data.appearClass;
  var appearToClass = data.appearToClass;
  var appearActiveClass = data.appearActiveClass;
  var beforeEnter = data.beforeEnter;
  var enter = data.enter;
  var afterEnter = data.afterEnter;
  var enterCancelled = data.enterCancelled;
  var beforeAppear = data.beforeAppear;
  var appear = data.appear;
  var afterAppear = data.afterAppear;
  var appearCancelled = data.appearCancelled;
  var duration = data.duration; // activeInstance will always be the <transition> component managing this
  // transition. One edge case to check is when the <transition> is placed
  // as the root node of a child component. In that case we need to check
  // <transition>'s parent for appear check.

  var context = activeInstance;
  var transitionNode = activeInstance.$vnode;

  while (transitionNode && transitionNode.parent) {
    context = transitionNode.context;
    transitionNode = transitionNode.parent;
  }

  var isAppear = !context._isMounted || !vnode.isRootInsert;

  if (isAppear && !appear && appear !== '') {
    return;
  }

  var startClass = isAppear && appearClass ? appearClass : enterClass;
  var activeClass = isAppear && appearActiveClass ? appearActiveClass : enterActiveClass;
  var toClass = isAppear && appearToClass ? appearToClass : enterToClass;
  var beforeEnterHook = isAppear ? beforeAppear || beforeEnter : beforeEnter;
  var enterHook = isAppear ? typeof appear === 'function' ? appear : enter : enter;
  var afterEnterHook = isAppear ? afterAppear || afterEnter : afterEnter;
  var enterCancelledHook = isAppear ? appearCancelled || enterCancelled : enterCancelled;
  var explicitEnterDuration = toNumber(isObject(duration) ? duration.enter : duration);

  if ( true && explicitEnterDuration != null) {
    checkDuration(explicitEnterDuration, 'enter', vnode);
  }

  var expectsCSS = css !== false && !isIE9;
  var userWantsControl = getHookArgumentsLength(enterHook);
  var cb = el._enterCb = once(function () {
    if (expectsCSS) {
      removeTransitionClass(el, toClass);
      removeTransitionClass(el, activeClass);
    }

    if (cb.cancelled) {
      if (expectsCSS) {
        removeTransitionClass(el, startClass);
      }

      enterCancelledHook && enterCancelledHook(el);
    } else {
      afterEnterHook && afterEnterHook(el);
    }

    el._enterCb = null;
  });

  if (!vnode.data.show) {
    // remove pending leave element on enter by injecting an insert hook
    mergeVNodeHook(vnode, 'insert', function () {
      var parent = el.parentNode;
      var pendingNode = parent && parent._pending && parent._pending[vnode.key];

      if (pendingNode && pendingNode.tag === vnode.tag && pendingNode.elm._leaveCb) {
        pendingNode.elm._leaveCb();
      }

      enterHook && enterHook(el, cb);
    });
  } // start enter transition


  beforeEnterHook && beforeEnterHook(el);

  if (expectsCSS) {
    addTransitionClass(el, startClass);
    addTransitionClass(el, activeClass);
    nextFrame(function () {
      removeTransitionClass(el, startClass);

      if (!cb.cancelled) {
        addTransitionClass(el, toClass);

        if (!userWantsControl) {
          if (isValidDuration(explicitEnterDuration)) {
            setTimeout(cb, explicitEnterDuration);
          } else {
            whenTransitionEnds(el, type, cb);
          }
        }
      }
    });
  }

  if (vnode.data.show) {
    toggleDisplay && toggleDisplay();
    enterHook && enterHook(el, cb);
  }

  if (!expectsCSS && !userWantsControl) {
    cb();
  }
}

function leave(vnode, rm) {
  var el = vnode.elm; // call enter callback now

  if (isDef(el._enterCb)) {
    el._enterCb.cancelled = true;

    el._enterCb();
  }

  var data = resolveTransition(vnode.data.transition);

  if (isUndef(data) || el.nodeType !== 1) {
    return rm();
  }
  /* istanbul ignore if */


  if (isDef(el._leaveCb)) {
    return;
  }

  var css = data.css;
  var type = data.type;
  var leaveClass = data.leaveClass;
  var leaveToClass = data.leaveToClass;
  var leaveActiveClass = data.leaveActiveClass;
  var beforeLeave = data.beforeLeave;
  var leave = data.leave;
  var afterLeave = data.afterLeave;
  var leaveCancelled = data.leaveCancelled;
  var delayLeave = data.delayLeave;
  var duration = data.duration;
  var expectsCSS = css !== false && !isIE9;
  var userWantsControl = getHookArgumentsLength(leave);
  var explicitLeaveDuration = toNumber(isObject(duration) ? duration.leave : duration);

  if ( true && isDef(explicitLeaveDuration)) {
    checkDuration(explicitLeaveDuration, 'leave', vnode);
  }

  var cb = el._leaveCb = once(function () {
    if (el.parentNode && el.parentNode._pending) {
      el.parentNode._pending[vnode.key] = null;
    }

    if (expectsCSS) {
      removeTransitionClass(el, leaveToClass);
      removeTransitionClass(el, leaveActiveClass);
    }

    if (cb.cancelled) {
      if (expectsCSS) {
        removeTransitionClass(el, leaveClass);
      }

      leaveCancelled && leaveCancelled(el);
    } else {
      rm();
      afterLeave && afterLeave(el);
    }

    el._leaveCb = null;
  });

  if (delayLeave) {
    delayLeave(performLeave);
  } else {
    performLeave();
  }

  function performLeave() {
    // the delayed leave may have already been cancelled
    if (cb.cancelled) {
      return;
    } // record leaving element


    if (!vnode.data.show && el.parentNode) {
      (el.parentNode._pending || (el.parentNode._pending = {}))[vnode.key] = vnode;
    }

    beforeLeave && beforeLeave(el);

    if (expectsCSS) {
      addTransitionClass(el, leaveClass);
      addTransitionClass(el, leaveActiveClass);
      nextFrame(function () {
        removeTransitionClass(el, leaveClass);

        if (!cb.cancelled) {
          addTransitionClass(el, leaveToClass);

          if (!userWantsControl) {
            if (isValidDuration(explicitLeaveDuration)) {
              setTimeout(cb, explicitLeaveDuration);
            } else {
              whenTransitionEnds(el, type, cb);
            }
          }
        }
      });
    }

    leave && leave(el, cb);

    if (!expectsCSS && !userWantsControl) {
      cb();
    }
  }
} // only used in dev mode


function checkDuration(val, name, vnode) {
  if (typeof val !== 'number') {
    warn("<transition> explicit " + name + " duration is not a valid number - " + "got " + JSON.stringify(val) + ".", vnode.context);
  } else if (isNaN(val)) {
    warn("<transition> explicit " + name + " duration is NaN - " + 'the duration expression might be incorrect.', vnode.context);
  }
}

function isValidDuration(val) {
  return typeof val === 'number' && !isNaN(val);
}
/**
 * Normalize a transition hook's argument length. The hook may be:
 * - a merged hook (invoker) with the original in .fns
 * - a wrapped component method (check ._length)
 * - a plain function (.length)
 */


function getHookArgumentsLength(fn) {
  if (isUndef(fn)) {
    return false;
  }

  var invokerFns = fn.fns;

  if (isDef(invokerFns)) {
    // invoker
    return getHookArgumentsLength(Array.isArray(invokerFns) ? invokerFns[0] : invokerFns);
  } else {
    return (fn._length || fn.length) > 1;
  }
}

function _enter(_, vnode) {
  if (vnode.data.show !== true) {
    enter(vnode);
  }
}

var transition = inBrowser ? {
  create: _enter,
  activate: _enter,
  remove: function remove$$1(vnode, rm) {
    /* istanbul ignore else */
    if (vnode.data.show !== true) {
      leave(vnode, rm);
    } else {
      rm();
    }
  }
} : {};
var platformModules = [attrs, klass, events, domProps, style, transition];
/*  */
// the directive module should be applied last, after all
// built-in modules have been applied.

var modules = platformModules.concat(baseModules);
var patch = createPatchFunction({
  nodeOps: nodeOps,
  modules: modules
});
/**
 * Not type checking this file because flow doesn't like attaching
 * properties to Elements.
 */

/* istanbul ignore if */

if (isIE9) {
  // http://www.matts411.com/post/internet-explorer-9-oninput/
  document.addEventListener('selectionchange', function () {
    var el = document.activeElement;

    if (el && el.vmodel) {
      trigger(el, 'input');
    }
  });
}

var directive = {
  inserted: function inserted(el, binding, vnode, oldVnode) {
    if (vnode.tag === 'select') {
      // #6903
      if (oldVnode.elm && !oldVnode.elm._vOptions) {
        mergeVNodeHook(vnode, 'postpatch', function () {
          directive.componentUpdated(el, binding, vnode);
        });
      } else {
        setSelected(el, binding, vnode.context);
      }

      el._vOptions = [].map.call(el.options, getValue);
    } else if (vnode.tag === 'textarea' || isTextInputType(el.type)) {
      el._vModifiers = binding.modifiers;

      if (!binding.modifiers.lazy) {
        el.addEventListener('compositionstart', onCompositionStart);
        el.addEventListener('compositionend', onCompositionEnd); // Safari < 10.2 & UIWebView doesn't fire compositionend when
        // switching focus before confirming composition choice
        // this also fixes the issue where some browsers e.g. iOS Chrome
        // fires "change" instead of "input" on autocomplete.

        el.addEventListener('change', onCompositionEnd);
        /* istanbul ignore if */

        if (isIE9) {
          el.vmodel = true;
        }
      }
    }
  },
  componentUpdated: function componentUpdated(el, binding, vnode) {
    if (vnode.tag === 'select') {
      setSelected(el, binding, vnode.context); // in case the options rendered by v-for have changed,
      // it's possible that the value is out-of-sync with the rendered options.
      // detect such cases and filter out values that no longer has a matching
      // option in the DOM.

      var prevOptions = el._vOptions;
      var curOptions = el._vOptions = [].map.call(el.options, getValue);

      if (curOptions.some(function (o, i) {
        return !looseEqual(o, prevOptions[i]);
      })) {
        // trigger change event if
        // no matching option found for at least one value
        var needReset = el.multiple ? binding.value.some(function (v) {
          return hasNoMatchingOption(v, curOptions);
        }) : binding.value !== binding.oldValue && hasNoMatchingOption(binding.value, curOptions);

        if (needReset) {
          trigger(el, 'change');
        }
      }
    }
  }
};

function setSelected(el, binding, vm) {
  actuallySetSelected(el, binding, vm);
  /* istanbul ignore if */

  if (isIE || isEdge) {
    setTimeout(function () {
      actuallySetSelected(el, binding, vm);
    }, 0);
  }
}

function actuallySetSelected(el, binding, vm) {
  var value = binding.value;
  var isMultiple = el.multiple;

  if (isMultiple && !Array.isArray(value)) {
     true && warn("<select multiple v-model=\"" + binding.expression + "\"> " + "expects an Array value for its binding, but got " + Object.prototype.toString.call(value).slice(8, -1), vm);
    return;
  }

  var selected, option;

  for (var i = 0, l = el.options.length; i < l; i++) {
    option = el.options[i];

    if (isMultiple) {
      selected = looseIndexOf(value, getValue(option)) > -1;

      if (option.selected !== selected) {
        option.selected = selected;
      }
    } else {
      if (looseEqual(getValue(option), value)) {
        if (el.selectedIndex !== i) {
          el.selectedIndex = i;
        }

        return;
      }
    }
  }

  if (!isMultiple) {
    el.selectedIndex = -1;
  }
}

function hasNoMatchingOption(value, options) {
  return options.every(function (o) {
    return !looseEqual(o, value);
  });
}

function getValue(option) {
  return '_value' in option ? option._value : option.value;
}

function onCompositionStart(e) {
  e.target.composing = true;
}

function onCompositionEnd(e) {
  // prevent triggering an input event for no reason
  if (!e.target.composing) {
    return;
  }

  e.target.composing = false;
  trigger(e.target, 'input');
}

function trigger(el, type) {
  var e = document.createEvent('HTMLEvents');
  e.initEvent(type, true, true);
  el.dispatchEvent(e);
}
/*  */
// recursively search for possible transition defined inside the component root


function locateNode(vnode) {
  return vnode.componentInstance && (!vnode.data || !vnode.data.transition) ? locateNode(vnode.componentInstance._vnode) : vnode;
}

var show = {
  bind: function bind(el, ref, vnode) {
    var value = ref.value;
    vnode = locateNode(vnode);
    var transition$$1 = vnode.data && vnode.data.transition;
    var originalDisplay = el.__vOriginalDisplay = el.style.display === 'none' ? '' : el.style.display;

    if (value && transition$$1) {
      vnode.data.show = true;
      enter(vnode, function () {
        el.style.display = originalDisplay;
      });
    } else {
      el.style.display = value ? originalDisplay : 'none';
    }
  },
  update: function update(el, ref, vnode) {
    var value = ref.value;
    var oldValue = ref.oldValue;
    /* istanbul ignore if */

    if (!value === !oldValue) {
      return;
    }

    vnode = locateNode(vnode);
    var transition$$1 = vnode.data && vnode.data.transition;

    if (transition$$1) {
      vnode.data.show = true;

      if (value) {
        enter(vnode, function () {
          el.style.display = el.__vOriginalDisplay;
        });
      } else {
        leave(vnode, function () {
          el.style.display = 'none';
        });
      }
    } else {
      el.style.display = value ? el.__vOriginalDisplay : 'none';
    }
  },
  unbind: function unbind(el, binding, vnode, oldVnode, isDestroy) {
    if (!isDestroy) {
      el.style.display = el.__vOriginalDisplay;
    }
  }
};
var platformDirectives = {
  model: directive,
  show: show
};
/*  */

var transitionProps = {
  name: String,
  appear: Boolean,
  css: Boolean,
  mode: String,
  type: String,
  enterClass: String,
  leaveClass: String,
  enterToClass: String,
  leaveToClass: String,
  enterActiveClass: String,
  leaveActiveClass: String,
  appearClass: String,
  appearActiveClass: String,
  appearToClass: String,
  duration: [Number, String, Object]
}; // in case the child is also an abstract component, e.g. <keep-alive>
// we want to recursively retrieve the real component to be rendered

function getRealChild(vnode) {
  var compOptions = vnode && vnode.componentOptions;

  if (compOptions && compOptions.Ctor.options.abstract) {
    return getRealChild(getFirstComponentChild(compOptions.children));
  } else {
    return vnode;
  }
}

function extractTransitionData(comp) {
  var data = {};
  var options = comp.$options; // props

  for (var key in options.propsData) {
    data[key] = comp[key];
  } // events.
  // extract listeners and pass them directly to the transition methods


  var listeners = options._parentListeners;

  for (var key$1 in listeners) {
    data[camelize(key$1)] = listeners[key$1];
  }

  return data;
}

function placeholder(h, rawChild) {
  if (/\d-keep-alive$/.test(rawChild.tag)) {
    return h('keep-alive', {
      props: rawChild.componentOptions.propsData
    });
  }
}

function hasParentTransition(vnode) {
  while (vnode = vnode.parent) {
    if (vnode.data.transition) {
      return true;
    }
  }
}

function isSameChild(child, oldChild) {
  return oldChild.key === child.key && oldChild.tag === child.tag;
}

var isNotTextNode = function (c) {
  return c.tag || isAsyncPlaceholder(c);
};

var isVShowDirective = function (d) {
  return d.name === 'show';
};

var Transition = {
  name: 'transition',
  props: transitionProps,
  abstract: true,
  render: function render(h) {
    var this$1 = this;
    var children = this.$slots.default;

    if (!children) {
      return;
    } // filter out text nodes (possible whitespaces)


    children = children.filter(isNotTextNode);
    /* istanbul ignore if */

    if (!children.length) {
      return;
    } // warn multiple elements


    if ( true && children.length > 1) {
      warn('<transition> can only be used on a single element. Use ' + '<transition-group> for lists.', this.$parent);
    }

    var mode = this.mode; // warn invalid mode

    if ( true && mode && mode !== 'in-out' && mode !== 'out-in') {
      warn('invalid <transition> mode: ' + mode, this.$parent);
    }

    var rawChild = children[0]; // if this is a component root node and the component's
    // parent container node also has transition, skip.

    if (hasParentTransition(this.$vnode)) {
      return rawChild;
    } // apply transition data to child
    // use getRealChild() to ignore abstract components e.g. keep-alive


    var child = getRealChild(rawChild);
    /* istanbul ignore if */

    if (!child) {
      return rawChild;
    }

    if (this._leaving) {
      return placeholder(h, rawChild);
    } // ensure a key that is unique to the vnode type and to this transition
    // component instance. This key will be used to remove pending leaving nodes
    // during entering.


    var id = "__transition-" + this._uid + "-";
    child.key = child.key == null ? child.isComment ? id + 'comment' : id + child.tag : isPrimitive(child.key) ? String(child.key).indexOf(id) === 0 ? child.key : id + child.key : child.key;
    var data = (child.data || (child.data = {})).transition = extractTransitionData(this);
    var oldRawChild = this._vnode;
    var oldChild = getRealChild(oldRawChild); // mark v-show
    // so that the transition module can hand over the control to the directive

    if (child.data.directives && child.data.directives.some(isVShowDirective)) {
      child.data.show = true;
    }

    if (oldChild && oldChild.data && !isSameChild(child, oldChild) && !isAsyncPlaceholder(oldChild) && // #6687 component root is a comment node
    !(oldChild.componentInstance && oldChild.componentInstance._vnode.isComment)) {
      // replace old child transition data with fresh one
      // important for dynamic transitions!
      var oldData = oldChild.data.transition = extend({}, data); // handle transition mode

      if (mode === 'out-in') {
        // return placeholder node and queue update when leave finishes
        this._leaving = true;
        mergeVNodeHook(oldData, 'afterLeave', function () {
          this$1._leaving = false;
          this$1.$forceUpdate();
        });
        return placeholder(h, rawChild);
      } else if (mode === 'in-out') {
        if (isAsyncPlaceholder(child)) {
          return oldRawChild;
        }

        var delayedLeave;

        var performLeave = function () {
          delayedLeave();
        };

        mergeVNodeHook(data, 'afterEnter', performLeave);
        mergeVNodeHook(data, 'enterCancelled', performLeave);
        mergeVNodeHook(oldData, 'delayLeave', function (leave) {
          delayedLeave = leave;
        });
      }
    }

    return rawChild;
  }
};
/*  */

var props = extend({
  tag: String,
  moveClass: String
}, transitionProps);
delete props.mode;
var TransitionGroup = {
  props: props,
  beforeMount: function beforeMount() {
    var this$1 = this;
    var update = this._update;

    this._update = function (vnode, hydrating) {
      var restoreActiveInstance = setActiveInstance(this$1); // force removing pass

      this$1.__patch__(this$1._vnode, this$1.kept, false, // hydrating
      true // removeOnly (!important, avoids unnecessary moves)
      );

      this$1._vnode = this$1.kept;
      restoreActiveInstance();
      update.call(this$1, vnode, hydrating);
    };
  },
  render: function render(h) {
    var tag = this.tag || this.$vnode.data.tag || 'span';
    var map = Object.create(null);
    var prevChildren = this.prevChildren = this.children;
    var rawChildren = this.$slots.default || [];
    var children = this.children = [];
    var transitionData = extractTransitionData(this);

    for (var i = 0; i < rawChildren.length; i++) {
      var c = rawChildren[i];

      if (c.tag) {
        if (c.key != null && String(c.key).indexOf('__vlist') !== 0) {
          children.push(c);
          map[c.key] = c;
          (c.data || (c.data = {})).transition = transitionData;
        } else if (true) {
          var opts = c.componentOptions;
          var name = opts ? opts.Ctor.options.name || opts.tag || '' : c.tag;
          warn("<transition-group> children must be keyed: <" + name + ">");
        }
      }
    }

    if (prevChildren) {
      var kept = [];
      var removed = [];

      for (var i$1 = 0; i$1 < prevChildren.length; i$1++) {
        var c$1 = prevChildren[i$1];
        c$1.data.transition = transitionData;
        c$1.data.pos = c$1.elm.getBoundingClientRect();

        if (map[c$1.key]) {
          kept.push(c$1);
        } else {
          removed.push(c$1);
        }
      }

      this.kept = h(tag, null, kept);
      this.removed = removed;
    }

    return h(tag, null, children);
  },
  updated: function updated() {
    var children = this.prevChildren;
    var moveClass = this.moveClass || (this.name || 'v') + '-move';

    if (!children.length || !this.hasMove(children[0].elm, moveClass)) {
      return;
    } // we divide the work into three loops to avoid mixing DOM reads and writes
    // in each iteration - which helps prevent layout thrashing.


    children.forEach(callPendingCbs);
    children.forEach(recordPosition);
    children.forEach(applyTranslation); // force reflow to put everything in position
    // assign to this to avoid being removed in tree-shaking
    // $flow-disable-line

    this._reflow = document.body.offsetHeight;
    children.forEach(function (c) {
      if (c.data.moved) {
        var el = c.elm;
        var s = el.style;
        addTransitionClass(el, moveClass);
        s.transform = s.WebkitTransform = s.transitionDuration = '';
        el.addEventListener(transitionEndEvent, el._moveCb = function cb(e) {
          if (e && e.target !== el) {
            return;
          }

          if (!e || /transform$/.test(e.propertyName)) {
            el.removeEventListener(transitionEndEvent, cb);
            el._moveCb = null;
            removeTransitionClass(el, moveClass);
          }
        });
      }
    });
  },
  methods: {
    hasMove: function hasMove(el, moveClass) {
      /* istanbul ignore if */
      if (!hasTransition) {
        return false;
      }
      /* istanbul ignore if */


      if (this._hasMove) {
        return this._hasMove;
      } // Detect whether an element with the move class applied has
      // CSS transitions. Since the element may be inside an entering
      // transition at this very moment, we make a clone of it and remove
      // all other transition classes applied to ensure only the move class
      // is applied.


      var clone = el.cloneNode();

      if (el._transitionClasses) {
        el._transitionClasses.forEach(function (cls) {
          removeClass(clone, cls);
        });
      }

      addClass(clone, moveClass);
      clone.style.display = 'none';
      this.$el.appendChild(clone);
      var info = getTransitionInfo(clone);
      this.$el.removeChild(clone);
      return this._hasMove = info.hasTransform;
    }
  }
};

function callPendingCbs(c) {
  /* istanbul ignore if */
  if (c.elm._moveCb) {
    c.elm._moveCb();
  }
  /* istanbul ignore if */


  if (c.elm._enterCb) {
    c.elm._enterCb();
  }
}

function recordPosition(c) {
  c.data.newPos = c.elm.getBoundingClientRect();
}

function applyTranslation(c) {
  var oldPos = c.data.pos;
  var newPos = c.data.newPos;
  var dx = oldPos.left - newPos.left;
  var dy = oldPos.top - newPos.top;

  if (dx || dy) {
    c.data.moved = true;
    var s = c.elm.style;
    s.transform = s.WebkitTransform = "translate(" + dx + "px," + dy + "px)";
    s.transitionDuration = '0s';
  }
}

var platformComponents = {
  Transition: Transition,
  TransitionGroup: TransitionGroup
};
/*  */
// install platform specific utils

Vue.config.mustUseProp = mustUseProp;
Vue.config.isReservedTag = isReservedTag;
Vue.config.isReservedAttr = isReservedAttr;
Vue.config.getTagNamespace = getTagNamespace;
Vue.config.isUnknownElement = isUnknownElement; // install platform runtime directives & components

extend(Vue.options.directives, platformDirectives);
extend(Vue.options.components, platformComponents); // install platform patch function

Vue.prototype.__patch__ = inBrowser ? patch : noop; // public mount method

Vue.prototype.$mount = function (el, hydrating) {
  el = el && inBrowser ? query(el) : undefined;
  return mountComponent(this, el, hydrating);
}; // devtools global hook

/* istanbul ignore next */


if (inBrowser) {
  setTimeout(function () {
    if (config.devtools) {
      if (devtools) {
        devtools.emit('init', Vue);
      } else if (true) {
        console[console.info ? 'info' : 'log']('Download the Vue Devtools extension for a better development experience:\n' + 'https://github.com/vuejs/vue-devtools');
      }
    }

    if ( true && config.productionTip !== false && typeof console !== 'undefined') {
      console[console.info ? 'info' : 'log']("You are running Vue in development mode.\n" + "Make sure to turn on production mode when deploying for production.\n" + "See more tips at https://vuejs.org/guide/deployment.html");
    }
  }, 0);
}
/*  */


/* harmony default export */ __webpack_exports__["default"] = (Vue);
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js"), __webpack_require__(/*! ./../../timers-browserify/main.js */ "./node_modules/timers-browserify/main.js").setImmediate))

/***/ }),

/***/ "./node_modules/vuedraggable/dist/vuedraggable.umd.js":
/*!************************************************************!*\
  !*** ./node_modules/vuedraggable/dist/vuedraggable.umd.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

(function webpackUniversalModuleDefinition(root, factory) {
  if (true) module.exports = factory(__webpack_require__(/*! sortablejs */ "./node_modules/sortablejs/modular/sortable.esm.js"));else {}
})(typeof self !== 'undefined' ? self : this, function (__WEBPACK_EXTERNAL_MODULE_a352__) {
  return (
    /******/
    function (modules) {
      // webpackBootstrap

      /******/
      // The module cache

      /******/
      var installedModules = {};
      /******/

      /******/
      // The require function

      /******/

      function __webpack_require__(moduleId) {
        /******/

        /******/
        // Check if module is in cache

        /******/
        if (installedModules[moduleId]) {
          /******/
          return installedModules[moduleId].exports;
          /******/
        }
        /******/
        // Create a new module (and put it into the cache)

        /******/


        var module = installedModules[moduleId] = {
          /******/
          i: moduleId,

          /******/
          l: false,

          /******/
          exports: {}
          /******/

        };
        /******/

        /******/
        // Execute the module function

        /******/

        modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
        /******/

        /******/
        // Flag the module as loaded

        /******/

        module.l = true;
        /******/

        /******/
        // Return the exports of the module

        /******/

        return module.exports;
        /******/
      }
      /******/

      /******/

      /******/
      // expose the modules object (__webpack_modules__)

      /******/


      __webpack_require__.m = modules;
      /******/

      /******/
      // expose the module cache

      /******/

      __webpack_require__.c = installedModules;
      /******/

      /******/
      // define getter function for harmony exports

      /******/

      __webpack_require__.d = function (exports, name, getter) {
        /******/
        if (!__webpack_require__.o(exports, name)) {
          /******/
          Object.defineProperty(exports, name, {
            enumerable: true,
            get: getter
          });
          /******/
        }
        /******/

      };
      /******/

      /******/
      // define __esModule on exports

      /******/


      __webpack_require__.r = function (exports) {
        /******/
        if (typeof Symbol !== 'undefined' && Symbol.toStringTag) {
          /******/
          Object.defineProperty(exports, Symbol.toStringTag, {
            value: 'Module'
          });
          /******/
        }
        /******/


        Object.defineProperty(exports, '__esModule', {
          value: true
        });
        /******/
      };
      /******/

      /******/
      // create a fake namespace object

      /******/
      // mode & 1: value is a module id, require it

      /******/
      // mode & 2: merge all properties of value into the ns

      /******/
      // mode & 4: return value when already ns object

      /******/
      // mode & 8|1: behave like require

      /******/


      __webpack_require__.t = function (value, mode) {
        /******/
        if (mode & 1) value = __webpack_require__(value);
        /******/

        if (mode & 8) return value;
        /******/

        if (mode & 4 && typeof value === 'object' && value && value.__esModule) return value;
        /******/

        var ns = Object.create(null);
        /******/

        __webpack_require__.r(ns);
        /******/


        Object.defineProperty(ns, 'default', {
          enumerable: true,
          value: value
        });
        /******/

        if (mode & 2 && typeof value != 'string') for (var key in value) __webpack_require__.d(ns, key, function (key) {
          return value[key];
        }.bind(null, key));
        /******/

        return ns;
        /******/
      };
      /******/

      /******/
      // getDefaultExport function for compatibility with non-harmony modules

      /******/


      __webpack_require__.n = function (module) {
        /******/
        var getter = module && module.__esModule ?
        /******/
        function getDefault() {
          return module['default'];
        } :
        /******/
        function getModuleExports() {
          return module;
        };
        /******/

        __webpack_require__.d(getter, 'a', getter);
        /******/


        return getter;
        /******/
      };
      /******/

      /******/
      // Object.prototype.hasOwnProperty.call

      /******/


      __webpack_require__.o = function (object, property) {
        return Object.prototype.hasOwnProperty.call(object, property);
      };
      /******/

      /******/
      // __webpack_public_path__

      /******/


      __webpack_require__.p = "";
      /******/

      /******/

      /******/
      // Load entry module and return exports

      /******/

      return __webpack_require__(__webpack_require__.s = "fb15");
      /******/
    }
    /************************************************************************/

    /******/
    ({
      /***/
      "01f9":
      /***/
      function (module, exports, __webpack_require__) {
        "use strict";

        var LIBRARY = __webpack_require__("2d00");

        var $export = __webpack_require__("5ca1");

        var redefine = __webpack_require__("2aba");

        var hide = __webpack_require__("32e9");

        var Iterators = __webpack_require__("84f2");

        var $iterCreate = __webpack_require__("41a0");

        var setToStringTag = __webpack_require__("7f20");

        var getPrototypeOf = __webpack_require__("38fd");

        var ITERATOR = __webpack_require__("2b4c")('iterator');

        var BUGGY = !([].keys && 'next' in [].keys()); // Safari has buggy iterators w/o `next`

        var FF_ITERATOR = '@@iterator';
        var KEYS = 'keys';
        var VALUES = 'values';

        var returnThis = function () {
          return this;
        };

        module.exports = function (Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED) {
          $iterCreate(Constructor, NAME, next);

          var getMethod = function (kind) {
            if (!BUGGY && kind in proto) return proto[kind];

            switch (kind) {
              case KEYS:
                return function keys() {
                  return new Constructor(this, kind);
                };

              case VALUES:
                return function values() {
                  return new Constructor(this, kind);
                };
            }

            return function entries() {
              return new Constructor(this, kind);
            };
          };

          var TAG = NAME + ' Iterator';
          var DEF_VALUES = DEFAULT == VALUES;
          var VALUES_BUG = false;
          var proto = Base.prototype;
          var $native = proto[ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT];
          var $default = $native || getMethod(DEFAULT);
          var $entries = DEFAULT ? !DEF_VALUES ? $default : getMethod('entries') : undefined;
          var $anyNative = NAME == 'Array' ? proto.entries || $native : $native;
          var methods, key, IteratorPrototype; // Fix native

          if ($anyNative) {
            IteratorPrototype = getPrototypeOf($anyNative.call(new Base()));

            if (IteratorPrototype !== Object.prototype && IteratorPrototype.next) {
              // Set @@toStringTag to native iterators
              setToStringTag(IteratorPrototype, TAG, true); // fix for some old engines

              if (!LIBRARY && typeof IteratorPrototype[ITERATOR] != 'function') hide(IteratorPrototype, ITERATOR, returnThis);
            }
          } // fix Array#{values, @@iterator}.name in V8 / FF


          if (DEF_VALUES && $native && $native.name !== VALUES) {
            VALUES_BUG = true;

            $default = function values() {
              return $native.call(this);
            };
          } // Define iterator


          if ((!LIBRARY || FORCED) && (BUGGY || VALUES_BUG || !proto[ITERATOR])) {
            hide(proto, ITERATOR, $default);
          } // Plug for library


          Iterators[NAME] = $default;
          Iterators[TAG] = returnThis;

          if (DEFAULT) {
            methods = {
              values: DEF_VALUES ? $default : getMethod(VALUES),
              keys: IS_SET ? $default : getMethod(KEYS),
              entries: $entries
            };
            if (FORCED) for (key in methods) {
              if (!(key in proto)) redefine(proto, key, methods[key]);
            } else $export($export.P + $export.F * (BUGGY || VALUES_BUG), NAME, methods);
          }

          return methods;
        };
        /***/

      },

      /***/
      "02f4":
      /***/
      function (module, exports, __webpack_require__) {
        var toInteger = __webpack_require__("4588");

        var defined = __webpack_require__("be13"); // true  -> String#at
        // false -> String#codePointAt


        module.exports = function (TO_STRING) {
          return function (that, pos) {
            var s = String(defined(that));
            var i = toInteger(pos);
            var l = s.length;
            var a, b;
            if (i < 0 || i >= l) return TO_STRING ? '' : undefined;
            a = s.charCodeAt(i);
            return a < 0xd800 || a > 0xdbff || i + 1 === l || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff ? TO_STRING ? s.charAt(i) : a : TO_STRING ? s.slice(i, i + 2) : (a - 0xd800 << 10) + (b - 0xdc00) + 0x10000;
          };
        };
        /***/

      },

      /***/
      "0390":
      /***/
      function (module, exports, __webpack_require__) {
        "use strict";

        var at = __webpack_require__("02f4")(true); // `AdvanceStringIndex` abstract operation
        // https://tc39.github.io/ecma262/#sec-advancestringindex


        module.exports = function (S, index, unicode) {
          return index + (unicode ? at(S, index).length : 1);
        };
        /***/

      },

      /***/
      "0bfb":
      /***/
      function (module, exports, __webpack_require__) {
        "use strict"; // 21.2.5.3 get RegExp.prototype.flags

        var anObject = __webpack_require__("cb7c");

        module.exports = function () {
          var that = anObject(this);
          var result = '';
          if (that.global) result += 'g';
          if (that.ignoreCase) result += 'i';
          if (that.multiline) result += 'm';
          if (that.unicode) result += 'u';
          if (that.sticky) result += 'y';
          return result;
        };
        /***/

      },

      /***/
      "0d58":
      /***/
      function (module, exports, __webpack_require__) {
        // 19.1.2.14 / 15.2.3.14 Object.keys(O)
        var $keys = __webpack_require__("ce10");

        var enumBugKeys = __webpack_require__("e11e");

        module.exports = Object.keys || function keys(O) {
          return $keys(O, enumBugKeys);
        };
        /***/

      },

      /***/
      "1495":
      /***/
      function (module, exports, __webpack_require__) {
        var dP = __webpack_require__("86cc");

        var anObject = __webpack_require__("cb7c");

        var getKeys = __webpack_require__("0d58");

        module.exports = __webpack_require__("9e1e") ? Object.defineProperties : function defineProperties(O, Properties) {
          anObject(O);
          var keys = getKeys(Properties);
          var length = keys.length;
          var i = 0;
          var P;

          while (length > i) dP.f(O, P = keys[i++], Properties[P]);

          return O;
        };
        /***/
      },

      /***/
      "214f":
      /***/
      function (module, exports, __webpack_require__) {
        "use strict";

        __webpack_require__("b0c5");

        var redefine = __webpack_require__("2aba");

        var hide = __webpack_require__("32e9");

        var fails = __webpack_require__("79e5");

        var defined = __webpack_require__("be13");

        var wks = __webpack_require__("2b4c");

        var regexpExec = __webpack_require__("520a");

        var SPECIES = wks('species');
        var REPLACE_SUPPORTS_NAMED_GROUPS = !fails(function () {
          // #replace needs built-in support for named groups.
          // #match works fine because it just return the exec results, even if it has
          // a "grops" property.
          var re = /./;

          re.exec = function () {
            var result = [];
            result.groups = {
              a: '7'
            };
            return result;
          };

          return ''.replace(re, '$<a>') !== '7';
        });

        var SPLIT_WORKS_WITH_OVERWRITTEN_EXEC = function () {
          // Chrome 51 has a buggy "split" implementation when RegExp#exec !== nativeExec
          var re = /(?:)/;
          var originalExec = re.exec;

          re.exec = function () {
            return originalExec.apply(this, arguments);
          };

          var result = 'ab'.split(re);
          return result.length === 2 && result[0] === 'a' && result[1] === 'b';
        }();

        module.exports = function (KEY, length, exec) {
          var SYMBOL = wks(KEY);
          var DELEGATES_TO_SYMBOL = !fails(function () {
            // String methods call symbol-named RegEp methods
            var O = {};

            O[SYMBOL] = function () {
              return 7;
            };

            return ''[KEY](O) != 7;
          });
          var DELEGATES_TO_EXEC = DELEGATES_TO_SYMBOL ? !fails(function () {
            // Symbol-named RegExp methods call .exec
            var execCalled = false;
            var re = /a/;

            re.exec = function () {
              execCalled = true;
              return null;
            };

            if (KEY === 'split') {
              // RegExp[@@split] doesn't call the regex's exec method, but first creates
              // a new one. We need to return the patched regex when creating the new one.
              re.constructor = {};

              re.constructor[SPECIES] = function () {
                return re;
              };
            }

            re[SYMBOL]('');
            return !execCalled;
          }) : undefined;

          if (!DELEGATES_TO_SYMBOL || !DELEGATES_TO_EXEC || KEY === 'replace' && !REPLACE_SUPPORTS_NAMED_GROUPS || KEY === 'split' && !SPLIT_WORKS_WITH_OVERWRITTEN_EXEC) {
            var nativeRegExpMethod = /./[SYMBOL];
            var fns = exec(defined, SYMBOL, ''[KEY], function maybeCallNative(nativeMethod, regexp, str, arg2, forceStringMethod) {
              if (regexp.exec === regexpExec) {
                if (DELEGATES_TO_SYMBOL && !forceStringMethod) {
                  // The native String method already delegates to @@method (this
                  // polyfilled function), leasing to infinite recursion.
                  // We avoid it by directly calling the native @@method method.
                  return {
                    done: true,
                    value: nativeRegExpMethod.call(regexp, str, arg2)
                  };
                }

                return {
                  done: true,
                  value: nativeMethod.call(str, regexp, arg2)
                };
              }

              return {
                done: false
              };
            });
            var strfn = fns[0];
            var rxfn = fns[1];
            redefine(String.prototype, KEY, strfn);
            hide(RegExp.prototype, SYMBOL, length == 2 // 21.2.5.8 RegExp.prototype[@@replace](string, replaceValue)
            // 21.2.5.11 RegExp.prototype[@@split](string, limit)
            ? function (string, arg) {
              return rxfn.call(string, this, arg);
            } // 21.2.5.6 RegExp.prototype[@@match](string)
            // 21.2.5.9 RegExp.prototype[@@search](string)
            : function (string) {
              return rxfn.call(string, this);
            });
          }
        };
        /***/

      },

      /***/
      "230e":
      /***/
      function (module, exports, __webpack_require__) {
        var isObject = __webpack_require__("d3f4");

        var document = __webpack_require__("7726").document; // typeof document.createElement is 'object' in old IE


        var is = isObject(document) && isObject(document.createElement);

        module.exports = function (it) {
          return is ? document.createElement(it) : {};
        };
        /***/

      },

      /***/
      "23c6":
      /***/
      function (module, exports, __webpack_require__) {
        // getting tag from 19.1.3.6 Object.prototype.toString()
        var cof = __webpack_require__("2d95");

        var TAG = __webpack_require__("2b4c")('toStringTag'); // ES3 wrong here


        var ARG = cof(function () {
          return arguments;
        }()) == 'Arguments'; // fallback for IE11 Script Access Denied error

        var tryGet = function (it, key) {
          try {
            return it[key];
          } catch (e) {
            /* empty */
          }
        };

        module.exports = function (it) {
          var O, T, B;
          return it === undefined ? 'Undefined' : it === null ? 'Null' // @@toStringTag case
          : typeof (T = tryGet(O = Object(it), TAG)) == 'string' ? T // builtinTag case
          : ARG ? cof(O) // ES3 arguments fallback
          : (B = cof(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : B;
        };
        /***/

      },

      /***/
      "2621":
      /***/
      function (module, exports) {
        exports.f = Object.getOwnPropertySymbols;
        /***/
      },

      /***/
      "2aba":
      /***/
      function (module, exports, __webpack_require__) {
        var global = __webpack_require__("7726");

        var hide = __webpack_require__("32e9");

        var has = __webpack_require__("69a8");

        var SRC = __webpack_require__("ca5a")('src');

        var $toString = __webpack_require__("fa5b");

        var TO_STRING = 'toString';
        var TPL = ('' + $toString).split(TO_STRING);

        __webpack_require__("8378").inspectSource = function (it) {
          return $toString.call(it);
        };

        (module.exports = function (O, key, val, safe) {
          var isFunction = typeof val == 'function';
          if (isFunction) has(val, 'name') || hide(val, 'name', key);
          if (O[key] === val) return;
          if (isFunction) has(val, SRC) || hide(val, SRC, O[key] ? '' + O[key] : TPL.join(String(key)));

          if (O === global) {
            O[key] = val;
          } else if (!safe) {
            delete O[key];
            hide(O, key, val);
          } else if (O[key]) {
            O[key] = val;
          } else {
            hide(O, key, val);
          } // add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative

        })(Function.prototype, TO_STRING, function toString() {
          return typeof this == 'function' && this[SRC] || $toString.call(this);
        });
        /***/
      },

      /***/
      "2aeb":
      /***/
      function (module, exports, __webpack_require__) {
        // 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
        var anObject = __webpack_require__("cb7c");

        var dPs = __webpack_require__("1495");

        var enumBugKeys = __webpack_require__("e11e");

        var IE_PROTO = __webpack_require__("613b")('IE_PROTO');

        var Empty = function () {
          /* empty */
        };

        var PROTOTYPE = 'prototype'; // Create object with fake `null` prototype: use iframe Object with cleared prototype

        var createDict = function () {
          // Thrash, waste and sodomy: IE GC bug
          var iframe = __webpack_require__("230e")('iframe');

          var i = enumBugKeys.length;
          var lt = '<';
          var gt = '>';
          var iframeDocument;
          iframe.style.display = 'none';

          __webpack_require__("fab2").appendChild(iframe);

          iframe.src = 'javascript:'; // eslint-disable-line no-script-url
          // createDict = iframe.contentWindow.Object;
          // html.removeChild(iframe);

          iframeDocument = iframe.contentWindow.document;
          iframeDocument.open();
          iframeDocument.write(lt + 'script' + gt + 'document.F=Object' + lt + '/script' + gt);
          iframeDocument.close();
          createDict = iframeDocument.F;

          while (i--) delete createDict[PROTOTYPE][enumBugKeys[i]];

          return createDict();
        };

        module.exports = Object.create || function create(O, Properties) {
          var result;

          if (O !== null) {
            Empty[PROTOTYPE] = anObject(O);
            result = new Empty();
            Empty[PROTOTYPE] = null; // add "__proto__" for Object.getPrototypeOf polyfill

            result[IE_PROTO] = O;
          } else result = createDict();

          return Properties === undefined ? result : dPs(result, Properties);
        };
        /***/

      },

      /***/
      "2b4c":
      /***/
      function (module, exports, __webpack_require__) {
        var store = __webpack_require__("5537")('wks');

        var uid = __webpack_require__("ca5a");

        var Symbol = __webpack_require__("7726").Symbol;

        var USE_SYMBOL = typeof Symbol == 'function';

        var $exports = module.exports = function (name) {
          return store[name] || (store[name] = USE_SYMBOL && Symbol[name] || (USE_SYMBOL ? Symbol : uid)('Symbol.' + name));
        };

        $exports.store = store;
        /***/
      },

      /***/
      "2d00":
      /***/
      function (module, exports) {
        module.exports = false;
        /***/
      },

      /***/
      "2d95":
      /***/
      function (module, exports) {
        var toString = {}.toString;

        module.exports = function (it) {
          return toString.call(it).slice(8, -1);
        };
        /***/

      },

      /***/
      "2fdb":
      /***/
      function (module, exports, __webpack_require__) {
        "use strict"; // 21.1.3.7 String.prototype.includes(searchString, position = 0)

        var $export = __webpack_require__("5ca1");

        var context = __webpack_require__("d2c8");

        var INCLUDES = 'includes';
        $export($export.P + $export.F * __webpack_require__("5147")(INCLUDES), 'String', {
          includes: function includes(searchString
          /* , position = 0 */
          ) {
            return !!~context(this, searchString, INCLUDES).indexOf(searchString, arguments.length > 1 ? arguments[1] : undefined);
          }
        });
        /***/
      },

      /***/
      "32e9":
      /***/
      function (module, exports, __webpack_require__) {
        var dP = __webpack_require__("86cc");

        var createDesc = __webpack_require__("4630");

        module.exports = __webpack_require__("9e1e") ? function (object, key, value) {
          return dP.f(object, key, createDesc(1, value));
        } : function (object, key, value) {
          object[key] = value;
          return object;
        };
        /***/
      },

      /***/
      "38fd":
      /***/
      function (module, exports, __webpack_require__) {
        // 19.1.2.9 / 15.2.3.2 Object.getPrototypeOf(O)
        var has = __webpack_require__("69a8");

        var toObject = __webpack_require__("4bf8");

        var IE_PROTO = __webpack_require__("613b")('IE_PROTO');

        var ObjectProto = Object.prototype;

        module.exports = Object.getPrototypeOf || function (O) {
          O = toObject(O);
          if (has(O, IE_PROTO)) return O[IE_PROTO];

          if (typeof O.constructor == 'function' && O instanceof O.constructor) {
            return O.constructor.prototype;
          }

          return O instanceof Object ? ObjectProto : null;
        };
        /***/

      },

      /***/
      "41a0":
      /***/
      function (module, exports, __webpack_require__) {
        "use strict";

        var create = __webpack_require__("2aeb");

        var descriptor = __webpack_require__("4630");

        var setToStringTag = __webpack_require__("7f20");

        var IteratorPrototype = {}; // 25.1.2.1.1 %IteratorPrototype%[@@iterator]()

        __webpack_require__("32e9")(IteratorPrototype, __webpack_require__("2b4c")('iterator'), function () {
          return this;
        });

        module.exports = function (Constructor, NAME, next) {
          Constructor.prototype = create(IteratorPrototype, {
            next: descriptor(1, next)
          });
          setToStringTag(Constructor, NAME + ' Iterator');
        };
        /***/

      },

      /***/
      "456d":
      /***/
      function (module, exports, __webpack_require__) {
        // 19.1.2.14 Object.keys(O)
        var toObject = __webpack_require__("4bf8");

        var $keys = __webpack_require__("0d58");

        __webpack_require__("5eda")('keys', function () {
          return function keys(it) {
            return $keys(toObject(it));
          };
        });
        /***/

      },

      /***/
      "4588":
      /***/
      function (module, exports) {
        // 7.1.4 ToInteger
        var ceil = Math.ceil;
        var floor = Math.floor;

        module.exports = function (it) {
          return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);
        };
        /***/

      },

      /***/
      "4630":
      /***/
      function (module, exports) {
        module.exports = function (bitmap, value) {
          return {
            enumerable: !(bitmap & 1),
            configurable: !(bitmap & 2),
            writable: !(bitmap & 4),
            value: value
          };
        };
        /***/

      },

      /***/
      "4bf8":
      /***/
      function (module, exports, __webpack_require__) {
        // 7.1.13 ToObject(argument)
        var defined = __webpack_require__("be13");

        module.exports = function (it) {
          return Object(defined(it));
        };
        /***/

      },

      /***/
      "5147":
      /***/
      function (module, exports, __webpack_require__) {
        var MATCH = __webpack_require__("2b4c")('match');

        module.exports = function (KEY) {
          var re = /./;

          try {
            '/./'[KEY](re);
          } catch (e) {
            try {
              re[MATCH] = false;
              return !'/./'[KEY](re);
            } catch (f) {
              /* empty */
            }
          }

          return true;
        };
        /***/

      },

      /***/
      "520a":
      /***/
      function (module, exports, __webpack_require__) {
        "use strict";

        var regexpFlags = __webpack_require__("0bfb");

        var nativeExec = RegExp.prototype.exec; // This always refers to the native implementation, because the
        // String#replace polyfill uses ./fix-regexp-well-known-symbol-logic.js,
        // which loads this file before patching the method.

        var nativeReplace = String.prototype.replace;
        var patchedExec = nativeExec;
        var LAST_INDEX = 'lastIndex';

        var UPDATES_LAST_INDEX_WRONG = function () {
          var re1 = /a/,
              re2 = /b*/g;
          nativeExec.call(re1, 'a');
          nativeExec.call(re2, 'a');
          return re1[LAST_INDEX] !== 0 || re2[LAST_INDEX] !== 0;
        }(); // nonparticipating capturing group, copied from es5-shim's String#split patch.


        var NPCG_INCLUDED = /()??/.exec('')[1] !== undefined;
        var PATCH = UPDATES_LAST_INDEX_WRONG || NPCG_INCLUDED;

        if (PATCH) {
          patchedExec = function exec(str) {
            var re = this;
            var lastIndex, reCopy, match, i;

            if (NPCG_INCLUDED) {
              reCopy = new RegExp('^' + re.source + '$(?!\\s)', regexpFlags.call(re));
            }

            if (UPDATES_LAST_INDEX_WRONG) lastIndex = re[LAST_INDEX];
            match = nativeExec.call(re, str);

            if (UPDATES_LAST_INDEX_WRONG && match) {
              re[LAST_INDEX] = re.global ? match.index + match[0].length : lastIndex;
            }

            if (NPCG_INCLUDED && match && match.length > 1) {
              // Fix browsers whose `exec` methods don't consistently return `undefined`
              // for NPCG, like IE8. NOTE: This doesn' work for /(.?)?/
              // eslint-disable-next-line no-loop-func
              nativeReplace.call(match[0], reCopy, function () {
                for (i = 1; i < arguments.length - 2; i++) {
                  if (arguments[i] === undefined) match[i] = undefined;
                }
              });
            }

            return match;
          };
        }

        module.exports = patchedExec;
        /***/
      },

      /***/
      "52a7":
      /***/
      function (module, exports) {
        exports.f = {}.propertyIsEnumerable;
        /***/
      },

      /***/
      "5537":
      /***/
      function (module, exports, __webpack_require__) {
        var core = __webpack_require__("8378");

        var global = __webpack_require__("7726");

        var SHARED = '__core-js_shared__';
        var store = global[SHARED] || (global[SHARED] = {});
        (module.exports = function (key, value) {
          return store[key] || (store[key] = value !== undefined ? value : {});
        })('versions', []).push({
          version: core.version,
          mode: __webpack_require__("2d00") ? 'pure' : 'global',
          copyright: 'Â© 2019 Denis Pushkarev (zloirock.ru)'
        });
        /***/
      },

      /***/
      "5ca1":
      /***/
      function (module, exports, __webpack_require__) {
        var global = __webpack_require__("7726");

        var core = __webpack_require__("8378");

        var hide = __webpack_require__("32e9");

        var redefine = __webpack_require__("2aba");

        var ctx = __webpack_require__("9b43");

        var PROTOTYPE = 'prototype';

        var $export = function (type, name, source) {
          var IS_FORCED = type & $export.F;
          var IS_GLOBAL = type & $export.G;
          var IS_STATIC = type & $export.S;
          var IS_PROTO = type & $export.P;
          var IS_BIND = type & $export.B;
          var target = IS_GLOBAL ? global : IS_STATIC ? global[name] || (global[name] = {}) : (global[name] || {})[PROTOTYPE];
          var exports = IS_GLOBAL ? core : core[name] || (core[name] = {});
          var expProto = exports[PROTOTYPE] || (exports[PROTOTYPE] = {});
          var key, own, out, exp;
          if (IS_GLOBAL) source = name;

          for (key in source) {
            // contains in native
            own = !IS_FORCED && target && target[key] !== undefined; // export native or passed

            out = (own ? target : source)[key]; // bind timers to global for call from export context

            exp = IS_BIND && own ? ctx(out, global) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out; // extend global

            if (target) redefine(target, key, out, type & $export.U); // export

            if (exports[key] != out) hide(exports, key, exp);
            if (IS_PROTO && expProto[key] != out) expProto[key] = out;
          }
        };

        global.core = core; // type bitmap

        $export.F = 1; // forced

        $export.G = 2; // global

        $export.S = 4; // static

        $export.P = 8; // proto

        $export.B = 16; // bind

        $export.W = 32; // wrap

        $export.U = 64; // safe

        $export.R = 128; // real proto method for `library`

        module.exports = $export;
        /***/
      },

      /***/
      "5eda":
      /***/
      function (module, exports, __webpack_require__) {
        // most Object methods by ES6 should accept primitives
        var $export = __webpack_require__("5ca1");

        var core = __webpack_require__("8378");

        var fails = __webpack_require__("79e5");

        module.exports = function (KEY, exec) {
          var fn = (core.Object || {})[KEY] || Object[KEY];
          var exp = {};
          exp[KEY] = exec(fn);
          $export($export.S + $export.F * fails(function () {
            fn(1);
          }), 'Object', exp);
        };
        /***/

      },

      /***/
      "5f1b":
      /***/
      function (module, exports, __webpack_require__) {
        "use strict";

        var classof = __webpack_require__("23c6");

        var builtinExec = RegExp.prototype.exec; // `RegExpExec` abstract operation
        // https://tc39.github.io/ecma262/#sec-regexpexec

        module.exports = function (R, S) {
          var exec = R.exec;

          if (typeof exec === 'function') {
            var result = exec.call(R, S);

            if (typeof result !== 'object') {
              throw new TypeError('RegExp exec method returned something other than an Object or null');
            }

            return result;
          }

          if (classof(R) !== 'RegExp') {
            throw new TypeError('RegExp#exec called on incompatible receiver');
          }

          return builtinExec.call(R, S);
        };
        /***/

      },

      /***/
      "613b":
      /***/
      function (module, exports, __webpack_require__) {
        var shared = __webpack_require__("5537")('keys');

        var uid = __webpack_require__("ca5a");

        module.exports = function (key) {
          return shared[key] || (shared[key] = uid(key));
        };
        /***/

      },

      /***/
      "626a":
      /***/
      function (module, exports, __webpack_require__) {
        // fallback for non-array-like ES3 and non-enumerable old V8 strings
        var cof = __webpack_require__("2d95"); // eslint-disable-next-line no-prototype-builtins


        module.exports = Object('z').propertyIsEnumerable(0) ? Object : function (it) {
          return cof(it) == 'String' ? it.split('') : Object(it);
        };
        /***/
      },

      /***/
      "6762":
      /***/
      function (module, exports, __webpack_require__) {
        "use strict"; // https://github.com/tc39/Array.prototype.includes

        var $export = __webpack_require__("5ca1");

        var $includes = __webpack_require__("c366")(true);

        $export($export.P, 'Array', {
          includes: function includes(el
          /* , fromIndex = 0 */
          ) {
            return $includes(this, el, arguments.length > 1 ? arguments[1] : undefined);
          }
        });

        __webpack_require__("9c6c")('includes');
        /***/

      },

      /***/
      "6821":
      /***/
      function (module, exports, __webpack_require__) {
        // to indexed object, toObject with fallback for non-array-like ES3 strings
        var IObject = __webpack_require__("626a");

        var defined = __webpack_require__("be13");

        module.exports = function (it) {
          return IObject(defined(it));
        };
        /***/

      },

      /***/
      "69a8":
      /***/
      function (module, exports) {
        var hasOwnProperty = {}.hasOwnProperty;

        module.exports = function (it, key) {
          return hasOwnProperty.call(it, key);
        };
        /***/

      },

      /***/
      "6a99":
      /***/
      function (module, exports, __webpack_require__) {
        // 7.1.1 ToPrimitive(input [, PreferredType])
        var isObject = __webpack_require__("d3f4"); // instead of the ES6 spec version, we didn't implement @@toPrimitive case
        // and the second argument - flag - preferred type is a string


        module.exports = function (it, S) {
          if (!isObject(it)) return it;
          var fn, val;
          if (S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;
          if (typeof (fn = it.valueOf) == 'function' && !isObject(val = fn.call(it))) return val;
          if (!S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;
          throw TypeError("Can't convert object to primitive value");
        };
        /***/

      },

      /***/
      "7333":
      /***/
      function (module, exports, __webpack_require__) {
        "use strict"; // 19.1.2.1 Object.assign(target, source, ...)

        var getKeys = __webpack_require__("0d58");

        var gOPS = __webpack_require__("2621");

        var pIE = __webpack_require__("52a7");

        var toObject = __webpack_require__("4bf8");

        var IObject = __webpack_require__("626a");

        var $assign = Object.assign; // should work with symbols and should have deterministic property order (V8 bug)

        module.exports = !$assign || __webpack_require__("79e5")(function () {
          var A = {};
          var B = {}; // eslint-disable-next-line no-undef

          var S = Symbol();
          var K = 'abcdefghijklmnopqrst';
          A[S] = 7;
          K.split('').forEach(function (k) {
            B[k] = k;
          });
          return $assign({}, A)[S] != 7 || Object.keys($assign({}, B)).join('') != K;
        }) ? function assign(target, source) {
          // eslint-disable-line no-unused-vars
          var T = toObject(target);
          var aLen = arguments.length;
          var index = 1;
          var getSymbols = gOPS.f;
          var isEnum = pIE.f;

          while (aLen > index) {
            var S = IObject(arguments[index++]);
            var keys = getSymbols ? getKeys(S).concat(getSymbols(S)) : getKeys(S);
            var length = keys.length;
            var j = 0;
            var key;

            while (length > j) if (isEnum.call(S, key = keys[j++])) T[key] = S[key];
          }

          return T;
        } : $assign;
        /***/
      },

      /***/
      "7726":
      /***/
      function (module, exports) {
        // https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
        var global = module.exports = typeof window != 'undefined' && window.Math == Math ? window : typeof self != 'undefined' && self.Math == Math ? self // eslint-disable-next-line no-new-func
        : Function('return this')();
        if (typeof __g == 'number') __g = global; // eslint-disable-line no-undef

        /***/
      },

      /***/
      "77f1":
      /***/
      function (module, exports, __webpack_require__) {
        var toInteger = __webpack_require__("4588");

        var max = Math.max;
        var min = Math.min;

        module.exports = function (index, length) {
          index = toInteger(index);
          return index < 0 ? max(index + length, 0) : min(index, length);
        };
        /***/

      },

      /***/
      "79e5":
      /***/
      function (module, exports) {
        module.exports = function (exec) {
          try {
            return !!exec();
          } catch (e) {
            return true;
          }
        };
        /***/

      },

      /***/
      "7f20":
      /***/
      function (module, exports, __webpack_require__) {
        var def = __webpack_require__("86cc").f;

        var has = __webpack_require__("69a8");

        var TAG = __webpack_require__("2b4c")('toStringTag');

        module.exports = function (it, tag, stat) {
          if (it && !has(it = stat ? it : it.prototype, TAG)) def(it, TAG, {
            configurable: true,
            value: tag
          });
        };
        /***/

      },

      /***/
      "8378":
      /***/
      function (module, exports) {
        var core = module.exports = {
          version: '2.6.5'
        };
        if (typeof __e == 'number') __e = core; // eslint-disable-line no-undef

        /***/
      },

      /***/
      "84f2":
      /***/
      function (module, exports) {
        module.exports = {};
        /***/
      },

      /***/
      "86cc":
      /***/
      function (module, exports, __webpack_require__) {
        var anObject = __webpack_require__("cb7c");

        var IE8_DOM_DEFINE = __webpack_require__("c69a");

        var toPrimitive = __webpack_require__("6a99");

        var dP = Object.defineProperty;
        exports.f = __webpack_require__("9e1e") ? Object.defineProperty : function defineProperty(O, P, Attributes) {
          anObject(O);
          P = toPrimitive(P, true);
          anObject(Attributes);
          if (IE8_DOM_DEFINE) try {
            return dP(O, P, Attributes);
          } catch (e) {
            /* empty */
          }
          if ('get' in Attributes || 'set' in Attributes) throw TypeError('Accessors not supported!');
          if ('value' in Attributes) O[P] = Attributes.value;
          return O;
        };
        /***/
      },

      /***/
      "9b43":
      /***/
      function (module, exports, __webpack_require__) {
        // optional / simple context binding
        var aFunction = __webpack_require__("d8e8");

        module.exports = function (fn, that, length) {
          aFunction(fn);
          if (that === undefined) return fn;

          switch (length) {
            case 1:
              return function (a) {
                return fn.call(that, a);
              };

            case 2:
              return function (a, b) {
                return fn.call(that, a, b);
              };

            case 3:
              return function (a, b, c) {
                return fn.call(that, a, b, c);
              };
          }

          return function
            /* ...args */
          () {
            return fn.apply(that, arguments);
          };
        };
        /***/

      },

      /***/
      "9c6c":
      /***/
      function (module, exports, __webpack_require__) {
        // 22.1.3.31 Array.prototype[@@unscopables]
        var UNSCOPABLES = __webpack_require__("2b4c")('unscopables');

        var ArrayProto = Array.prototype;
        if (ArrayProto[UNSCOPABLES] == undefined) __webpack_require__("32e9")(ArrayProto, UNSCOPABLES, {});

        module.exports = function (key) {
          ArrayProto[UNSCOPABLES][key] = true;
        };
        /***/

      },

      /***/
      "9def":
      /***/
      function (module, exports, __webpack_require__) {
        // 7.1.15 ToLength
        var toInteger = __webpack_require__("4588");

        var min = Math.min;

        module.exports = function (it) {
          return it > 0 ? min(toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991
        };
        /***/

      },

      /***/
      "9e1e":
      /***/
      function (module, exports, __webpack_require__) {
        // Thank's IE8 for his funny defineProperty
        module.exports = !__webpack_require__("79e5")(function () {
          return Object.defineProperty({}, 'a', {
            get: function () {
              return 7;
            }
          }).a != 7;
        });
        /***/
      },

      /***/
      "a352":
      /***/
      function (module, exports) {
        module.exports = __WEBPACK_EXTERNAL_MODULE_a352__;
        /***/
      },

      /***/
      "a481":
      /***/
      function (module, exports, __webpack_require__) {
        "use strict";

        var anObject = __webpack_require__("cb7c");

        var toObject = __webpack_require__("4bf8");

        var toLength = __webpack_require__("9def");

        var toInteger = __webpack_require__("4588");

        var advanceStringIndex = __webpack_require__("0390");

        var regExpExec = __webpack_require__("5f1b");

        var max = Math.max;
        var min = Math.min;
        var floor = Math.floor;
        var SUBSTITUTION_SYMBOLS = /\$([$&`']|\d\d?|<[^>]*>)/g;
        var SUBSTITUTION_SYMBOLS_NO_NAMED = /\$([$&`']|\d\d?)/g;

        var maybeToString = function (it) {
          return it === undefined ? it : String(it);
        }; // @@replace logic


        __webpack_require__("214f")('replace', 2, function (defined, REPLACE, $replace, maybeCallNative) {
          return [// `String.prototype.replace` method
          // https://tc39.github.io/ecma262/#sec-string.prototype.replace
          function replace(searchValue, replaceValue) {
            var O = defined(this);
            var fn = searchValue == undefined ? undefined : searchValue[REPLACE];
            return fn !== undefined ? fn.call(searchValue, O, replaceValue) : $replace.call(String(O), searchValue, replaceValue);
          }, // `RegExp.prototype[@@replace]` method
          // https://tc39.github.io/ecma262/#sec-regexp.prototype-@@replace
          function (regexp, replaceValue) {
            var res = maybeCallNative($replace, regexp, this, replaceValue);
            if (res.done) return res.value;
            var rx = anObject(regexp);
            var S = String(this);
            var functionalReplace = typeof replaceValue === 'function';
            if (!functionalReplace) replaceValue = String(replaceValue);
            var global = rx.global;

            if (global) {
              var fullUnicode = rx.unicode;
              rx.lastIndex = 0;
            }

            var results = [];

            while (true) {
              var result = regExpExec(rx, S);
              if (result === null) break;
              results.push(result);
              if (!global) break;
              var matchStr = String(result[0]);
              if (matchStr === '') rx.lastIndex = advanceStringIndex(S, toLength(rx.lastIndex), fullUnicode);
            }

            var accumulatedResult = '';
            var nextSourcePosition = 0;

            for (var i = 0; i < results.length; i++) {
              result = results[i];
              var matched = String(result[0]);
              var position = max(min(toInteger(result.index), S.length), 0);
              var captures = []; // NOTE: This is equivalent to
              //   captures = result.slice(1).map(maybeToString)
              // but for some reason `nativeSlice.call(result, 1, result.length)` (called in
              // the slice polyfill when slicing native arrays) "doesn't work" in safari 9 and
              // causes a crash (https://pastebin.com/N21QzeQA) when trying to debug it.

              for (var j = 1; j < result.length; j++) captures.push(maybeToString(result[j]));

              var namedCaptures = result.groups;

              if (functionalReplace) {
                var replacerArgs = [matched].concat(captures, position, S);
                if (namedCaptures !== undefined) replacerArgs.push(namedCaptures);
                var replacement = String(replaceValue.apply(undefined, replacerArgs));
              } else {
                replacement = getSubstitution(matched, S, position, captures, namedCaptures, replaceValue);
              }

              if (position >= nextSourcePosition) {
                accumulatedResult += S.slice(nextSourcePosition, position) + replacement;
                nextSourcePosition = position + matched.length;
              }
            }

            return accumulatedResult + S.slice(nextSourcePosition);
          }]; // https://tc39.github.io/ecma262/#sec-getsubstitution

          function getSubstitution(matched, str, position, captures, namedCaptures, replacement) {
            var tailPos = position + matched.length;
            var m = captures.length;
            var symbols = SUBSTITUTION_SYMBOLS_NO_NAMED;

            if (namedCaptures !== undefined) {
              namedCaptures = toObject(namedCaptures);
              symbols = SUBSTITUTION_SYMBOLS;
            }

            return $replace.call(replacement, symbols, function (match, ch) {
              var capture;

              switch (ch.charAt(0)) {
                case '$':
                  return '$';

                case '&':
                  return matched;

                case '`':
                  return str.slice(0, position);

                case "'":
                  return str.slice(tailPos);

                case '<':
                  capture = namedCaptures[ch.slice(1, -1)];
                  break;

                default:
                  // \d\d?
                  var n = +ch;
                  if (n === 0) return match;

                  if (n > m) {
                    var f = floor(n / 10);
                    if (f === 0) return match;
                    if (f <= m) return captures[f - 1] === undefined ? ch.charAt(1) : captures[f - 1] + ch.charAt(1);
                    return match;
                  }

                  capture = captures[n - 1];
              }

              return capture === undefined ? '' : capture;
            });
          }
        });
        /***/

      },

      /***/
      "aae3":
      /***/
      function (module, exports, __webpack_require__) {
        // 7.2.8 IsRegExp(argument)
        var isObject = __webpack_require__("d3f4");

        var cof = __webpack_require__("2d95");

        var MATCH = __webpack_require__("2b4c")('match');

        module.exports = function (it) {
          var isRegExp;
          return isObject(it) && ((isRegExp = it[MATCH]) !== undefined ? !!isRegExp : cof(it) == 'RegExp');
        };
        /***/

      },

      /***/
      "ac6a":
      /***/
      function (module, exports, __webpack_require__) {
        var $iterators = __webpack_require__("cadf");

        var getKeys = __webpack_require__("0d58");

        var redefine = __webpack_require__("2aba");

        var global = __webpack_require__("7726");

        var hide = __webpack_require__("32e9");

        var Iterators = __webpack_require__("84f2");

        var wks = __webpack_require__("2b4c");

        var ITERATOR = wks('iterator');
        var TO_STRING_TAG = wks('toStringTag');
        var ArrayValues = Iterators.Array;
        var DOMIterables = {
          CSSRuleList: true,
          // TODO: Not spec compliant, should be false.
          CSSStyleDeclaration: false,
          CSSValueList: false,
          ClientRectList: false,
          DOMRectList: false,
          DOMStringList: false,
          DOMTokenList: true,
          DataTransferItemList: false,
          FileList: false,
          HTMLAllCollection: false,
          HTMLCollection: false,
          HTMLFormElement: false,
          HTMLSelectElement: false,
          MediaList: true,
          // TODO: Not spec compliant, should be false.
          MimeTypeArray: false,
          NamedNodeMap: false,
          NodeList: true,
          PaintRequestList: false,
          Plugin: false,
          PluginArray: false,
          SVGLengthList: false,
          SVGNumberList: false,
          SVGPathSegList: false,
          SVGPointList: false,
          SVGStringList: false,
          SVGTransformList: false,
          SourceBufferList: false,
          StyleSheetList: true,
          // TODO: Not spec compliant, should be false.
          TextTrackCueList: false,
          TextTrackList: false,
          TouchList: false
        };

        for (var collections = getKeys(DOMIterables), i = 0; i < collections.length; i++) {
          var NAME = collections[i];
          var explicit = DOMIterables[NAME];
          var Collection = global[NAME];
          var proto = Collection && Collection.prototype;
          var key;

          if (proto) {
            if (!proto[ITERATOR]) hide(proto, ITERATOR, ArrayValues);
            if (!proto[TO_STRING_TAG]) hide(proto, TO_STRING_TAG, NAME);
            Iterators[NAME] = ArrayValues;
            if (explicit) for (key in $iterators) if (!proto[key]) redefine(proto, key, $iterators[key], true);
          }
        }
        /***/

      },

      /***/
      "b0c5":
      /***/
      function (module, exports, __webpack_require__) {
        "use strict";

        var regexpExec = __webpack_require__("520a");

        __webpack_require__("5ca1")({
          target: 'RegExp',
          proto: true,
          forced: regexpExec !== /./.exec
        }, {
          exec: regexpExec
        });
        /***/

      },

      /***/
      "be13":
      /***/
      function (module, exports) {
        // 7.2.1 RequireObjectCoercible(argument)
        module.exports = function (it) {
          if (it == undefined) throw TypeError("Can't call method on  " + it);
          return it;
        };
        /***/

      },

      /***/
      "c366":
      /***/
      function (module, exports, __webpack_require__) {
        // false -> Array#indexOf
        // true  -> Array#includes
        var toIObject = __webpack_require__("6821");

        var toLength = __webpack_require__("9def");

        var toAbsoluteIndex = __webpack_require__("77f1");

        module.exports = function (IS_INCLUDES) {
          return function ($this, el, fromIndex) {
            var O = toIObject($this);
            var length = toLength(O.length);
            var index = toAbsoluteIndex(fromIndex, length);
            var value; // Array#includes uses SameValueZero equality algorithm
            // eslint-disable-next-line no-self-compare

            if (IS_INCLUDES && el != el) while (length > index) {
              value = O[index++]; // eslint-disable-next-line no-self-compare

              if (value != value) return true; // Array#indexOf ignores holes, Array#includes - not
            } else for (; length > index; index++) if (IS_INCLUDES || index in O) {
              if (O[index] === el) return IS_INCLUDES || index || 0;
            }
            return !IS_INCLUDES && -1;
          };
        };
        /***/

      },

      /***/
      "c649":
      /***/
      function (module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* WEBPACK VAR INJECTION */

        (function (global) {
          /* harmony export (binding) */
          __webpack_require__.d(__webpack_exports__, "c", function () {
            return insertNodeAt;
          });
          /* harmony export (binding) */


          __webpack_require__.d(__webpack_exports__, "a", function () {
            return camelize;
          });
          /* harmony export (binding) */


          __webpack_require__.d(__webpack_exports__, "b", function () {
            return console;
          });
          /* harmony export (binding) */


          __webpack_require__.d(__webpack_exports__, "d", function () {
            return removeNode;
          });
          /* harmony import */


          var core_js_modules_es6_regexp_replace__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("a481");
          /* harmony import */


          var core_js_modules_es6_regexp_replace__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es6_regexp_replace__WEBPACK_IMPORTED_MODULE_0__);

          function getConsole() {
            if (typeof window !== "undefined") {
              return window.console;
            }

            return global.console;
          }

          var console = getConsole();

          function cached(fn) {
            var cache = Object.create(null);
            return function cachedFn(str) {
              var hit = cache[str];
              return hit || (cache[str] = fn(str));
            };
          }

          var regex = /-(\w)/g;
          var camelize = cached(function (str) {
            return str.replace(regex, function (_, c) {
              return c ? c.toUpperCase() : "";
            });
          });

          function removeNode(node) {
            if (node.parentElement !== null) {
              node.parentElement.removeChild(node);
            }
          }

          function insertNodeAt(fatherNode, node, position) {
            var refNode = position === 0 ? fatherNode.children[0] : fatherNode.children[position - 1].nextSibling;
            fatherNode.insertBefore(node, refNode);
          }
          /* WEBPACK VAR INJECTION */

        }).call(this, __webpack_require__("c8ba"));
        /***/
      },

      /***/
      "c69a":
      /***/
      function (module, exports, __webpack_require__) {
        module.exports = !__webpack_require__("9e1e") && !__webpack_require__("79e5")(function () {
          return Object.defineProperty(__webpack_require__("230e")('div'), 'a', {
            get: function () {
              return 7;
            }
          }).a != 7;
        });
        /***/
      },

      /***/
      "c8ba":
      /***/
      function (module, exports) {
        var g; // This works in non-strict mode

        g = function () {
          return this;
        }();

        try {
          // This works if eval is allowed (see CSP)
          g = g || new Function("return this")();
        } catch (e) {
          // This works if the window reference is available
          if (typeof window === "object") g = window;
        } // g can still be undefined, but nothing to do about it...
        // We return undefined, instead of nothing here, so it's
        // easier to handle this case. if(!global) { ...}


        module.exports = g;
        /***/
      },

      /***/
      "ca5a":
      /***/
      function (module, exports) {
        var id = 0;
        var px = Math.random();

        module.exports = function (key) {
          return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));
        };
        /***/

      },

      /***/
      "cadf":
      /***/
      function (module, exports, __webpack_require__) {
        "use strict";

        var addToUnscopables = __webpack_require__("9c6c");

        var step = __webpack_require__("d53b");

        var Iterators = __webpack_require__("84f2");

        var toIObject = __webpack_require__("6821"); // 22.1.3.4 Array.prototype.entries()
        // 22.1.3.13 Array.prototype.keys()
        // 22.1.3.29 Array.prototype.values()
        // 22.1.3.30 Array.prototype[@@iterator]()


        module.exports = __webpack_require__("01f9")(Array, 'Array', function (iterated, kind) {
          this._t = toIObject(iterated); // target

          this._i = 0; // next index

          this._k = kind; // kind
          // 22.1.5.2.1 %ArrayIteratorPrototype%.next()
        }, function () {
          var O = this._t;
          var kind = this._k;
          var index = this._i++;

          if (!O || index >= O.length) {
            this._t = undefined;
            return step(1);
          }

          if (kind == 'keys') return step(0, index);
          if (kind == 'values') return step(0, O[index]);
          return step(0, [index, O[index]]);
        }, 'values'); // argumentsList[@@iterator] is %ArrayProto_values% (9.4.4.6, 9.4.4.7)

        Iterators.Arguments = Iterators.Array;
        addToUnscopables('keys');
        addToUnscopables('values');
        addToUnscopables('entries');
        /***/
      },

      /***/
      "cb7c":
      /***/
      function (module, exports, __webpack_require__) {
        var isObject = __webpack_require__("d3f4");

        module.exports = function (it) {
          if (!isObject(it)) throw TypeError(it + ' is not an object!');
          return it;
        };
        /***/

      },

      /***/
      "ce10":
      /***/
      function (module, exports, __webpack_require__) {
        var has = __webpack_require__("69a8");

        var toIObject = __webpack_require__("6821");

        var arrayIndexOf = __webpack_require__("c366")(false);

        var IE_PROTO = __webpack_require__("613b")('IE_PROTO');

        module.exports = function (object, names) {
          var O = toIObject(object);
          var i = 0;
          var result = [];
          var key;

          for (key in O) if (key != IE_PROTO) has(O, key) && result.push(key); // Don't enum bug & hidden keys


          while (names.length > i) if (has(O, key = names[i++])) {
            ~arrayIndexOf(result, key) || result.push(key);
          }

          return result;
        };
        /***/

      },

      /***/
      "d2c8":
      /***/
      function (module, exports, __webpack_require__) {
        // helper for String#{startsWith, endsWith, includes}
        var isRegExp = __webpack_require__("aae3");

        var defined = __webpack_require__("be13");

        module.exports = function (that, searchString, NAME) {
          if (isRegExp(searchString)) throw TypeError('String#' + NAME + " doesn't accept regex!");
          return String(defined(that));
        };
        /***/

      },

      /***/
      "d3f4":
      /***/
      function (module, exports) {
        module.exports = function (it) {
          return typeof it === 'object' ? it !== null : typeof it === 'function';
        };
        /***/

      },

      /***/
      "d53b":
      /***/
      function (module, exports) {
        module.exports = function (done, value) {
          return {
            value: value,
            done: !!done
          };
        };
        /***/

      },

      /***/
      "d8e8":
      /***/
      function (module, exports) {
        module.exports = function (it) {
          if (typeof it != 'function') throw TypeError(it + ' is not a function!');
          return it;
        };
        /***/

      },

      /***/
      "e11e":
      /***/
      function (module, exports) {
        // IE 8- don't enum bug keys
        module.exports = 'constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf'.split(',');
        /***/
      },

      /***/
      "f559":
      /***/
      function (module, exports, __webpack_require__) {
        "use strict"; // 21.1.3.18 String.prototype.startsWith(searchString [, position ])

        var $export = __webpack_require__("5ca1");

        var toLength = __webpack_require__("9def");

        var context = __webpack_require__("d2c8");

        var STARTS_WITH = 'startsWith';
        var $startsWith = ''[STARTS_WITH];
        $export($export.P + $export.F * __webpack_require__("5147")(STARTS_WITH), 'String', {
          startsWith: function startsWith(searchString
          /* , position = 0 */
          ) {
            var that = context(this, searchString, STARTS_WITH);
            var index = toLength(Math.min(arguments.length > 1 ? arguments[1] : undefined, that.length));
            var search = String(searchString);
            return $startsWith ? $startsWith.call(that, search, index) : that.slice(index, index + search.length) === search;
          }
        });
        /***/
      },

      /***/
      "f6fd":
      /***/
      function (module, exports) {
        // document.currentScript polyfill by Adam Miller
        // MIT license
        (function (document) {
          var currentScript = "currentScript",
              scripts = document.getElementsByTagName('script'); // Live NodeList collection
          // If browser needs currentScript polyfill, add get currentScript() to the document object

          if (!(currentScript in document)) {
            Object.defineProperty(document, currentScript, {
              get: function () {
                // IE 6-10 supports script readyState
                // IE 10+ support stack trace
                try {
                  throw new Error();
                } catch (err) {
                  // Find the second match for the "at" string to get file src url from stack.
                  // Specifically works with the format of stack traces in IE.
                  var i,
                      res = (/.*at [^\(]*\((.*):.+:.+\)$/ig.exec(err.stack) || [false])[1]; // For all scripts on the page, if src matches or if ready state is interactive, return the script tag

                  for (i in scripts) {
                    if (scripts[i].src == res || scripts[i].readyState == "interactive") {
                      return scripts[i];
                    }
                  } // If no match, return null


                  return null;
                }
              }
            });
          }
        })(document);
        /***/

      },

      /***/
      "f751":
      /***/
      function (module, exports, __webpack_require__) {
        // 19.1.3.1 Object.assign(target, source)
        var $export = __webpack_require__("5ca1");

        $export($export.S + $export.F, 'Object', {
          assign: __webpack_require__("7333")
        });
        /***/
      },

      /***/
      "fa5b":
      /***/
      function (module, exports, __webpack_require__) {
        module.exports = __webpack_require__("5537")('native-function-to-string', Function.toString);
        /***/
      },

      /***/
      "fab2":
      /***/
      function (module, exports, __webpack_require__) {
        var document = __webpack_require__("7726").document;

        module.exports = document && document.documentElement;
        /***/
      },

      /***/
      "fb15":
      /***/
      function (module, __webpack_exports__, __webpack_require__) {
        "use strict"; // ESM COMPAT FLAG

        __webpack_require__.r(__webpack_exports__); // CONCATENATED MODULE: ./node_modules/@vue/cli-service/lib/commands/build/setPublicPath.js
        // This file is imported into lib/wc client bundles.


        if (typeof window !== 'undefined') {
          if (true) {
            __webpack_require__("f6fd");
          }

          var setPublicPath_i;

          if ((setPublicPath_i = window.document.currentScript) && (setPublicPath_i = setPublicPath_i.src.match(/(.+\/)[^/]+\.js(\?.*)?$/))) {
            __webpack_require__.p = setPublicPath_i[1]; // eslint-disable-line
          }
        } // Indicate to webpack that this file can be concatenated

        /* harmony default export */


        var setPublicPath = null; // EXTERNAL MODULE: ./node_modules/core-js/modules/es6.object.assign.js

        var es6_object_assign = __webpack_require__("f751"); // EXTERNAL MODULE: ./node_modules/core-js/modules/es6.string.starts-with.js


        var es6_string_starts_with = __webpack_require__("f559"); // EXTERNAL MODULE: ./node_modules/core-js/modules/web.dom.iterable.js


        var web_dom_iterable = __webpack_require__("ac6a"); // EXTERNAL MODULE: ./node_modules/core-js/modules/es6.array.iterator.js


        var es6_array_iterator = __webpack_require__("cadf"); // EXTERNAL MODULE: ./node_modules/core-js/modules/es6.object.keys.js


        var es6_object_keys = __webpack_require__("456d"); // CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/arrayWithHoles.js


        function _arrayWithHoles(arr) {
          if (Array.isArray(arr)) return arr;
        } // CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/iterableToArrayLimit.js


        function _iterableToArrayLimit(arr, i) {
          if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return;
          var _arr = [];
          var _n = true;
          var _d = false;
          var _e = undefined;

          try {
            for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
              _arr.push(_s.value);

              if (i && _arr.length === i) break;
            }
          } catch (err) {
            _d = true;
            _e = err;
          } finally {
            try {
              if (!_n && _i["return"] != null) _i["return"]();
            } finally {
              if (_d) throw _e;
            }
          }

          return _arr;
        } // CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/arrayLikeToArray.js


        function _arrayLikeToArray(arr, len) {
          if (len == null || len > arr.length) len = arr.length;

          for (var i = 0, arr2 = new Array(len); i < len; i++) {
            arr2[i] = arr[i];
          }

          return arr2;
        } // CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/unsupportedIterableToArray.js


        function _unsupportedIterableToArray(o, minLen) {
          if (!o) return;
          if (typeof o === "string") return _arrayLikeToArray(o, minLen);
          var n = Object.prototype.toString.call(o).slice(8, -1);
          if (n === "Object" && o.constructor) n = o.constructor.name;
          if (n === "Map" || n === "Set") return Array.from(o);
          if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
        } // CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/nonIterableRest.js


        function _nonIterableRest() {
          throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
        } // CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/slicedToArray.js


        function _slicedToArray(arr, i) {
          return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
        } // EXTERNAL MODULE: ./node_modules/core-js/modules/es7.array.includes.js


        var es7_array_includes = __webpack_require__("6762"); // EXTERNAL MODULE: ./node_modules/core-js/modules/es6.string.includes.js


        var es6_string_includes = __webpack_require__("2fdb"); // CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/arrayWithoutHoles.js


        function _arrayWithoutHoles(arr) {
          if (Array.isArray(arr)) return _arrayLikeToArray(arr);
        } // CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/iterableToArray.js


        function _iterableToArray(iter) {
          if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter);
        } // CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/nonIterableSpread.js


        function _nonIterableSpread() {
          throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
        } // CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/toConsumableArray.js


        function _toConsumableArray(arr) {
          return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
        } // EXTERNAL MODULE: external {"commonjs":"sortablejs","commonjs2":"sortablejs","amd":"sortablejs","root":"Sortable"}


        var external_commonjs_sortablejs_commonjs2_sortablejs_amd_sortablejs_root_Sortable_ = __webpack_require__("a352");

        var external_commonjs_sortablejs_commonjs2_sortablejs_amd_sortablejs_root_Sortable_default = /*#__PURE__*/__webpack_require__.n(external_commonjs_sortablejs_commonjs2_sortablejs_amd_sortablejs_root_Sortable_); // EXTERNAL MODULE: ./src/util/helper.js


        var helper = __webpack_require__("c649"); // CONCATENATED MODULE: ./src/vuedraggable.js


        function buildAttribute(object, propName, value) {
          if (value === undefined) {
            return object;
          }

          object = object || {};
          object[propName] = value;
          return object;
        }

        function computeVmIndex(vnodes, element) {
          return vnodes.map(function (elt) {
            return elt.elm;
          }).indexOf(element);
        }

        function _computeIndexes(slots, children, isTransition, footerOffset) {
          if (!slots) {
            return [];
          }

          var elmFromNodes = slots.map(function (elt) {
            return elt.elm;
          });
          var footerIndex = children.length - footerOffset;

          var rawIndexes = _toConsumableArray(children).map(function (elt, idx) {
            return idx >= footerIndex ? elmFromNodes.length : elmFromNodes.indexOf(elt);
          });

          return isTransition ? rawIndexes.filter(function (ind) {
            return ind !== -1;
          }) : rawIndexes;
        }

        function emit(evtName, evtData) {
          var _this = this;

          this.$nextTick(function () {
            return _this.$emit(evtName.toLowerCase(), evtData);
          });
        }

        function delegateAndEmit(evtName) {
          var _this2 = this;

          return function (evtData) {
            if (_this2.realList !== null) {
              _this2["onDrag" + evtName](evtData);
            }

            emit.call(_this2, evtName, evtData);
          };
        }

        function isTransitionName(name) {
          return ["transition-group", "TransitionGroup"].includes(name);
        }

        function vuedraggable_isTransition(slots) {
          if (!slots || slots.length !== 1) {
            return false;
          }

          var _slots = _slicedToArray(slots, 1),
              componentOptions = _slots[0].componentOptions;

          if (!componentOptions) {
            return false;
          }

          return isTransitionName(componentOptions.tag);
        }

        function getSlot(slot, scopedSlot, key) {
          return slot[key] || (scopedSlot[key] ? scopedSlot[key]() : undefined);
        }

        function computeChildrenAndOffsets(children, slot, scopedSlot) {
          var headerOffset = 0;
          var footerOffset = 0;
          var header = getSlot(slot, scopedSlot, "header");

          if (header) {
            headerOffset = header.length;
            children = children ? [].concat(_toConsumableArray(header), _toConsumableArray(children)) : _toConsumableArray(header);
          }

          var footer = getSlot(slot, scopedSlot, "footer");

          if (footer) {
            footerOffset = footer.length;
            children = children ? [].concat(_toConsumableArray(children), _toConsumableArray(footer)) : _toConsumableArray(footer);
          }

          return {
            children: children,
            headerOffset: headerOffset,
            footerOffset: footerOffset
          };
        }

        function getComponentAttributes($attrs, componentData) {
          var attributes = null;

          var update = function update(name, value) {
            attributes = buildAttribute(attributes, name, value);
          };

          var attrs = Object.keys($attrs).filter(function (key) {
            return key === "id" || key.startsWith("data-");
          }).reduce(function (res, key) {
            res[key] = $attrs[key];
            return res;
          }, {});
          update("attrs", attrs);

          if (!componentData) {
            return attributes;
          }

          var on = componentData.on,
              props = componentData.props,
              componentDataAttrs = componentData.attrs;
          update("on", on);
          update("props", props);
          Object.assign(attributes.attrs, componentDataAttrs);
          return attributes;
        }

        var eventsListened = ["Start", "Add", "Remove", "Update", "End"];
        var eventsToEmit = ["Choose", "Unchoose", "Sort", "Filter", "Clone"];
        var readonlyProperties = ["Move"].concat(eventsListened, eventsToEmit).map(function (evt) {
          return "on" + evt;
        });
        var draggingElement = null;
        var props = {
          options: Object,
          list: {
            type: Array,
            required: false,
            default: null
          },
          value: {
            type: Array,
            required: false,
            default: null
          },
          noTransitionOnDrag: {
            type: Boolean,
            default: false
          },
          clone: {
            type: Function,
            default: function _default(original) {
              return original;
            }
          },
          element: {
            type: String,
            default: "div"
          },
          tag: {
            type: String,
            default: null
          },
          move: {
            type: Function,
            default: null
          },
          componentData: {
            type: Object,
            required: false,
            default: null
          }
        };
        var draggableComponent = {
          name: "draggable",
          inheritAttrs: false,
          props: props,
          data: function data() {
            return {
              transitionMode: false,
              noneFunctionalComponentMode: false
            };
          },
          render: function render(h) {
            var slots = this.$slots.default;
            this.transitionMode = vuedraggable_isTransition(slots);

            var _computeChildrenAndOf = computeChildrenAndOffsets(slots, this.$slots, this.$scopedSlots),
                children = _computeChildrenAndOf.children,
                headerOffset = _computeChildrenAndOf.headerOffset,
                footerOffset = _computeChildrenAndOf.footerOffset;

            this.headerOffset = headerOffset;
            this.footerOffset = footerOffset;
            var attributes = getComponentAttributes(this.$attrs, this.componentData);
            return h(this.getTag(), attributes, children);
          },
          created: function created() {
            if (this.list !== null && this.value !== null) {
              helper["b"
              /* console */
              ].error("Value and list props are mutually exclusive! Please set one or another.");
            }

            if (this.element !== "div") {
              helper["b"
              /* console */
              ].warn("Element props is deprecated please use tag props instead. See https://github.com/SortableJS/Vue.Draggable/blob/master/documentation/migrate.md#element-props");
            }

            if (this.options !== undefined) {
              helper["b"
              /* console */
              ].warn("Options props is deprecated, add sortable options directly as vue.draggable item, or use v-bind. See https://github.com/SortableJS/Vue.Draggable/blob/master/documentation/migrate.md#options-props");
            }
          },
          mounted: function mounted() {
            var _this3 = this;

            this.noneFunctionalComponentMode = this.getTag().toLowerCase() !== this.$el.nodeName.toLowerCase() && !this.getIsFunctional();

            if (this.noneFunctionalComponentMode && this.transitionMode) {
              throw new Error("Transition-group inside component is not supported. Please alter tag value or remove transition-group. Current tag value: ".concat(this.getTag()));
            }

            var optionsAdded = {};
            eventsListened.forEach(function (elt) {
              optionsAdded["on" + elt] = delegateAndEmit.call(_this3, elt);
            });
            eventsToEmit.forEach(function (elt) {
              optionsAdded["on" + elt] = emit.bind(_this3, elt);
            });
            var attributes = Object.keys(this.$attrs).reduce(function (res, key) {
              res[Object(helper["a"
              /* camelize */
              ])(key)] = _this3.$attrs[key];
              return res;
            }, {});
            var options = Object.assign({}, this.options, attributes, optionsAdded, {
              onMove: function onMove(evt, originalEvent) {
                return _this3.onDragMove(evt, originalEvent);
              }
            });
            !("draggable" in options) && (options.draggable = ">*");
            this._sortable = new external_commonjs_sortablejs_commonjs2_sortablejs_amd_sortablejs_root_Sortable_default.a(this.rootContainer, options);
            this.computeIndexes();
          },
          beforeDestroy: function beforeDestroy() {
            if (this._sortable !== undefined) this._sortable.destroy();
          },
          computed: {
            rootContainer: function rootContainer() {
              return this.transitionMode ? this.$el.children[0] : this.$el;
            },
            realList: function realList() {
              return this.list ? this.list : this.value;
            }
          },
          watch: {
            options: {
              handler: function handler(newOptionValue) {
                this.updateOptions(newOptionValue);
              },
              deep: true
            },
            $attrs: {
              handler: function handler(newOptionValue) {
                this.updateOptions(newOptionValue);
              },
              deep: true
            },
            realList: function realList() {
              this.computeIndexes();
            }
          },
          methods: {
            getIsFunctional: function getIsFunctional() {
              var fnOptions = this._vnode.fnOptions;
              return fnOptions && fnOptions.functional;
            },
            getTag: function getTag() {
              return this.tag || this.element;
            },
            updateOptions: function updateOptions(newOptionValue) {
              for (var property in newOptionValue) {
                var value = Object(helper["a"
                /* camelize */
                ])(property);

                if (readonlyProperties.indexOf(value) === -1) {
                  this._sortable.option(value, newOptionValue[property]);
                }
              }
            },
            getChildrenNodes: function getChildrenNodes() {
              if (this.noneFunctionalComponentMode) {
                return this.$children[0].$slots.default;
              }

              var rawNodes = this.$slots.default;
              return this.transitionMode ? rawNodes[0].child.$slots.default : rawNodes;
            },
            computeIndexes: function computeIndexes() {
              var _this4 = this;

              this.$nextTick(function () {
                _this4.visibleIndexes = _computeIndexes(_this4.getChildrenNodes(), _this4.rootContainer.children, _this4.transitionMode, _this4.footerOffset);
              });
            },
            getUnderlyingVm: function getUnderlyingVm(htmlElt) {
              var index = computeVmIndex(this.getChildrenNodes() || [], htmlElt);

              if (index === -1) {
                //Edge case during move callback: related element might be
                //an element different from collection
                return null;
              }

              var element = this.realList[index];
              return {
                index: index,
                element: element
              };
            },
            getUnderlyingPotencialDraggableComponent: function getUnderlyingPotencialDraggableComponent(_ref) {
              var vue = _ref.__vue__;

              if (!vue || !vue.$options || !isTransitionName(vue.$options._componentTag)) {
                if (!("realList" in vue) && vue.$children.length === 1 && "realList" in vue.$children[0]) return vue.$children[0];
                return vue;
              }

              return vue.$parent;
            },
            emitChanges: function emitChanges(evt) {
              var _this5 = this;

              this.$nextTick(function () {
                _this5.$emit("change", evt);
              });
            },
            alterList: function alterList(onList) {
              if (this.list) {
                onList(this.list);
                return;
              }

              var newList = _toConsumableArray(this.value);

              onList(newList);
              this.$emit("input", newList);
            },
            spliceList: function spliceList() {
              var _arguments = arguments;

              var spliceList = function spliceList(list) {
                return list.splice.apply(list, _toConsumableArray(_arguments));
              };

              this.alterList(spliceList);
            },
            updatePosition: function updatePosition(oldIndex, newIndex) {
              var updatePosition = function updatePosition(list) {
                return list.splice(newIndex, 0, list.splice(oldIndex, 1)[0]);
              };

              this.alterList(updatePosition);
            },
            getRelatedContextFromMoveEvent: function getRelatedContextFromMoveEvent(_ref2) {
              var to = _ref2.to,
                  related = _ref2.related;
              var component = this.getUnderlyingPotencialDraggableComponent(to);

              if (!component) {
                return {
                  component: component
                };
              }

              var list = component.realList;
              var context = {
                list: list,
                component: component
              };

              if (to !== related && list && component.getUnderlyingVm) {
                var destination = component.getUnderlyingVm(related);

                if (destination) {
                  return Object.assign(destination, context);
                }
              }

              return context;
            },
            getVmIndex: function getVmIndex(domIndex) {
              var indexes = this.visibleIndexes;
              var numberIndexes = indexes.length;
              return domIndex > numberIndexes - 1 ? numberIndexes : indexes[domIndex];
            },
            getComponent: function getComponent() {
              return this.$slots.default[0].componentInstance;
            },
            resetTransitionData: function resetTransitionData(index) {
              if (!this.noTransitionOnDrag || !this.transitionMode) {
                return;
              }

              var nodes = this.getChildrenNodes();
              nodes[index].data = null;
              var transitionContainer = this.getComponent();
              transitionContainer.children = [];
              transitionContainer.kept = undefined;
            },
            onDragStart: function onDragStart(evt) {
              this.context = this.getUnderlyingVm(evt.item);
              evt.item._underlying_vm_ = this.clone(this.context.element);
              draggingElement = evt.item;
            },
            onDragAdd: function onDragAdd(evt) {
              var element = evt.item._underlying_vm_;

              if (element === undefined) {
                return;
              }

              Object(helper["d"
              /* removeNode */
              ])(evt.item);
              var newIndex = this.getVmIndex(evt.newIndex);
              this.spliceList(newIndex, 0, element);
              this.computeIndexes();
              var added = {
                element: element,
                newIndex: newIndex
              };
              this.emitChanges({
                added: added
              });
            },
            onDragRemove: function onDragRemove(evt) {
              Object(helper["c"
              /* insertNodeAt */
              ])(this.rootContainer, evt.item, evt.oldIndex);

              if (evt.pullMode === "clone") {
                Object(helper["d"
                /* removeNode */
                ])(evt.clone);
                return;
              }

              var oldIndex = this.context.index;
              this.spliceList(oldIndex, 1);
              var removed = {
                element: this.context.element,
                oldIndex: oldIndex
              };
              this.resetTransitionData(oldIndex);
              this.emitChanges({
                removed: removed
              });
            },
            onDragUpdate: function onDragUpdate(evt) {
              Object(helper["d"
              /* removeNode */
              ])(evt.item);
              Object(helper["c"
              /* insertNodeAt */
              ])(evt.from, evt.item, evt.oldIndex);
              var oldIndex = this.context.index;
              var newIndex = this.getVmIndex(evt.newIndex);
              this.updatePosition(oldIndex, newIndex);
              var moved = {
                element: this.context.element,
                oldIndex: oldIndex,
                newIndex: newIndex
              };
              this.emitChanges({
                moved: moved
              });
            },
            updateProperty: function updateProperty(evt, propertyName) {
              evt.hasOwnProperty(propertyName) && (evt[propertyName] += this.headerOffset);
            },
            computeFutureIndex: function computeFutureIndex(relatedContext, evt) {
              if (!relatedContext.element) {
                return 0;
              }

              var domChildren = _toConsumableArray(evt.to.children).filter(function (el) {
                return el.style["display"] !== "none";
              });

              var currentDOMIndex = domChildren.indexOf(evt.related);
              var currentIndex = relatedContext.component.getVmIndex(currentDOMIndex);
              var draggedInList = domChildren.indexOf(draggingElement) !== -1;
              return draggedInList || !evt.willInsertAfter ? currentIndex : currentIndex + 1;
            },
            onDragMove: function onDragMove(evt, originalEvent) {
              var onMove = this.move;

              if (!onMove || !this.realList) {
                return true;
              }

              var relatedContext = this.getRelatedContextFromMoveEvent(evt);
              var draggedContext = this.context;
              var futureIndex = this.computeFutureIndex(relatedContext, evt);
              Object.assign(draggedContext, {
                futureIndex: futureIndex
              });
              var sendEvt = Object.assign({}, evt, {
                relatedContext: relatedContext,
                draggedContext: draggedContext
              });
              return onMove(sendEvt, originalEvent);
            },
            onDragEnd: function onDragEnd() {
              this.computeIndexes();
              draggingElement = null;
            }
          }
        };

        if (typeof window !== "undefined" && "Vue" in window) {
          window.Vue.component("draggable", draggableComponent);
        }
        /* harmony default export */


        var vuedraggable = draggableComponent; // CONCATENATED MODULE: ./node_modules/@vue/cli-service/lib/commands/build/entry-lib.js

        /* harmony default export */

        var entry_lib = __webpack_exports__["default"] = vuedraggable;
        /***/
      }
      /******/

    })["default"]
  );
});

/***/ }),

/***/ "./node_modules/webpack/buildin/global.js":
/*!***********************************!*\
  !*** (webpack)/buildin/global.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

var g; // This works in non-strict mode

g = function () {
  return this;
}();

try {
  // This works if eval is allowed (see CSP)
  g = g || new Function("return this")();
} catch (e) {
  // This works if the window reference is available
  if (typeof window === "object") g = window;
} // g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}


module.exports = g;

/***/ }),

/***/ "./src/components/main/main.scss?vue&type=style&index=0&lang=scss&":
/*!*************************************************************************!*\
  !*** ./src/components/main/main.scss?vue&type=style&index=0&lang=scss& ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _node_modules_style_loader_dist_cjs_js_node_modules_css_loader_dist_cjs_js_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_sass_loader_dist_cjs_js_main_scss_vue_type_style_index_0_lang_scss___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../../../node_modules/style-loader/dist/cjs.js!../../../node_modules/css-loader/dist/cjs.js!../../../node_modules/vue-loader/lib/loaders/stylePostLoader.js!../../../node_modules/sass-loader/dist/cjs.js!./main.scss?vue&type=style&index=0&lang=scss& */ "./node_modules/style-loader/dist/cjs.js!./node_modules/css-loader/dist/cjs.js!./node_modules/vue-loader/lib/loaders/stylePostLoader.js!./node_modules/sass-loader/dist/cjs.js!./src/components/main/main.scss?vue&type=style&index=0&lang=scss&");
/* harmony import */ var _node_modules_style_loader_dist_cjs_js_node_modules_css_loader_dist_cjs_js_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_sass_loader_dist_cjs_js_main_scss_vue_type_style_index_0_lang_scss___WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_cjs_js_node_modules_css_loader_dist_cjs_js_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_sass_loader_dist_cjs_js_main_scss_vue_type_style_index_0_lang_scss___WEBPACK_IMPORTED_MODULE_0__);
/* harmony reexport (unknown) */ for(var __WEBPACK_IMPORT_KEY__ in _node_modules_style_loader_dist_cjs_js_node_modules_css_loader_dist_cjs_js_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_sass_loader_dist_cjs_js_main_scss_vue_type_style_index_0_lang_scss___WEBPACK_IMPORTED_MODULE_0__) if(["default"].indexOf(__WEBPACK_IMPORT_KEY__) < 0) (function(key) { __webpack_require__.d(__webpack_exports__, key, function() { return _node_modules_style_loader_dist_cjs_js_node_modules_css_loader_dist_cjs_js_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_sass_loader_dist_cjs_js_main_scss_vue_type_style_index_0_lang_scss___WEBPACK_IMPORTED_MODULE_0__[key]; }) }(__WEBPACK_IMPORT_KEY__));


/***/ }),

/***/ "./src/components/main/main.vue":
/*!**************************************!*\
  !*** ./src/components/main/main.vue ***!
  \**************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _main_vue_vue_type_template_id_5e2104ef___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./main.vue?vue&type=template&id=5e2104ef& */ "./src/components/main/main.vue?vue&type=template&id=5e2104ef&");
/* harmony import */ var _main_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./main.vue?vue&type=script&lang=js& */ "./src/components/main/main.vue?vue&type=script&lang=js&");
/* empty/unused harmony star reexport *//* harmony import */ var _main_scss_vue_type_style_index_0_lang_scss___WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./main.scss?vue&type=style&index=0&lang=scss& */ "./src/components/main/main.scss?vue&type=style&index=0&lang=scss&");
/* harmony import */ var _node_modules_vue_loader_lib_runtime_componentNormalizer_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../node_modules/vue-loader/lib/runtime/componentNormalizer.js */ "./node_modules/vue-loader/lib/runtime/componentNormalizer.js");






/* normalize component */

var component = Object(_node_modules_vue_loader_lib_runtime_componentNormalizer_js__WEBPACK_IMPORTED_MODULE_3__["default"])(
  _main_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_1__["default"],
  _main_vue_vue_type_template_id_5e2104ef___WEBPACK_IMPORTED_MODULE_0__["render"],
  _main_vue_vue_type_template_id_5e2104ef___WEBPACK_IMPORTED_MODULE_0__["staticRenderFns"],
  false,
  null,
  null,
  null
  
)

/* hot reload */
if (false) { var api; }
component.options.__file = "src/components/main/main.vue"
/* harmony default export */ __webpack_exports__["default"] = (component.exports);

/***/ }),

/***/ "./src/components/main/main.vue?vue&type=script&lang=js&":
/*!***************************************************************!*\
  !*** ./src/components/main/main.vue?vue&type=script&lang=js& ***!
  \***************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _node_modules_babel_loader_lib_index_js_node_modules_vue_loader_lib_index_js_vue_loader_options_main_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../../../node_modules/babel-loader/lib!../../../node_modules/vue-loader/lib??vue-loader-options!./main.vue?vue&type=script&lang=js& */ "./node_modules/babel-loader/lib/index.js!./node_modules/vue-loader/lib/index.js?!./src/components/main/main.vue?vue&type=script&lang=js&");
/* empty/unused harmony star reexport */ /* harmony default export */ __webpack_exports__["default"] = (_node_modules_babel_loader_lib_index_js_node_modules_vue_loader_lib_index_js_vue_loader_options_main_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_0__["default"]); 

/***/ }),

/***/ "./src/components/main/main.vue?vue&type=template&id=5e2104ef&":
/*!*********************************************************************!*\
  !*** ./src/components/main/main.vue?vue&type=template&id=5e2104ef& ***!
  \*********************************************************************/
/*! exports provided: render, staticRenderFns */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _node_modules_vue_loader_lib_loaders_templateLoader_js_vue_loader_options_node_modules_vue_loader_lib_index_js_vue_loader_options_main_vue_vue_type_template_id_5e2104ef___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../../../node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!../../../node_modules/vue-loader/lib??vue-loader-options!./main.vue?vue&type=template&id=5e2104ef& */ "./node_modules/vue-loader/lib/loaders/templateLoader.js?!./node_modules/vue-loader/lib/index.js?!./src/components/main/main.vue?vue&type=template&id=5e2104ef&");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "render", function() { return _node_modules_vue_loader_lib_loaders_templateLoader_js_vue_loader_options_node_modules_vue_loader_lib_index_js_vue_loader_options_main_vue_vue_type_template_id_5e2104ef___WEBPACK_IMPORTED_MODULE_0__["render"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "staticRenderFns", function() { return _node_modules_vue_loader_lib_loaders_templateLoader_js_vue_loader_options_node_modules_vue_loader_lib_index_js_vue_loader_options_main_vue_vue_type_template_id_5e2104ef___WEBPACK_IMPORTED_MODULE_0__["staticRenderFns"]; });



/***/ }),

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vue */ "./node_modules/vue/dist/vue.runtime.esm.js");
/* harmony import */ var _components_main_main_vue__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./components/main/main.vue */ "./src/components/main/main.vue");


new vue__WEBPACK_IMPORTED_MODULE_0__["default"]({
  el: '#root',
  render: function render(h) {
    return h(_components_main_main_vue__WEBPACK_IMPORTED_MODULE_1__["default"]);
  }
});

/***/ })

/******/ });
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAiLCJ3ZWJwYWNrOi8vL3NyYy9jb21wb25lbnRzL21haW4vbWFpbi52dWUiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbXBvbmVudHMvbWFpbi9tYWluLnNjc3MiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9ydW50aW1lL2FwaS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcHJvY2Vzcy9icm93c2VyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zZXRpbW1lZGlhdGUvc2V0SW1tZWRpYXRlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zb3J0YWJsZWpzL21vZHVsYXIvc29ydGFibGUuZXNtLmpzIiwid2VicGFjazovLy8uL3NyYy9jb21wb25lbnRzL21haW4vbWFpbi5zY3NzP2QxMDMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9kaXN0L3J1bnRpbWUvaW5qZWN0U3R5bGVzSW50b1N0eWxlVGFnLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy90aW1lcnMtYnJvd3NlcmlmeS9tYWluLmpzIiwid2VicGFjazovLy8uL3NyYy9jb21wb25lbnRzL21haW4vbWFpbi52dWU/OGI1YSIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvcnVudGltZS9jb21wb25lbnROb3JtYWxpemVyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy92dWUvZGlzdC92dWUucnVudGltZS5lc20uanMiLCJ3ZWJwYWNrOi8vL3Z1ZWRyYWdnYWJsZS93ZWJwYWNrL3VuaXZlcnNhbE1vZHVsZURlZmluaXRpb24iLCJ3ZWJwYWNrOi8vL3Z1ZWRyYWdnYWJsZS93ZWJwYWNrL2Jvb3RzdHJhcCIsIndlYnBhY2s6Ly8vdnVlZHJhZ2dhYmxlL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2l0ZXItZGVmaW5lLmpzIiwid2VicGFjazovLy92dWVkcmFnZ2FibGUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fc3RyaW5nLWF0LmpzIiwid2VicGFjazovLy92dWVkcmFnZ2FibGUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fYWR2YW5jZS1zdHJpbmctaW5kZXguanMiLCJ3ZWJwYWNrOi8vL3Z1ZWRyYWdnYWJsZS9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19mbGFncy5qcyIsIndlYnBhY2s6Ly8vdnVlZHJhZ2dhYmxlL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX29iamVjdC1rZXlzLmpzIiwid2VicGFjazovLy92dWVkcmFnZ2FibGUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LWRwcy5qcyIsIndlYnBhY2s6Ly8vdnVlZHJhZ2dhYmxlL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2ZpeC1yZS13a3MuanMiLCJ3ZWJwYWNrOi8vL3Z1ZWRyYWdnYWJsZS9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19kb20tY3JlYXRlLmpzIiwid2VicGFjazovLy92dWVkcmFnZ2FibGUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fY2xhc3NvZi5qcyIsIndlYnBhY2s6Ly8vdnVlZHJhZ2dhYmxlL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX29iamVjdC1nb3BzLmpzIiwid2VicGFjazovLy92dWVkcmFnZ2FibGUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fcmVkZWZpbmUuanMiLCJ3ZWJwYWNrOi8vL3Z1ZWRyYWdnYWJsZS9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19vYmplY3QtY3JlYXRlLmpzIiwid2VicGFjazovLy92dWVkcmFnZ2FibGUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fd2tzLmpzIiwid2VicGFjazovLy92dWVkcmFnZ2FibGUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fbGlicmFyeS5qcyIsIndlYnBhY2s6Ly8vdnVlZHJhZ2dhYmxlL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2NvZi5qcyIsIndlYnBhY2s6Ly8vdnVlZHJhZ2dhYmxlL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnN0cmluZy5pbmNsdWRlcy5qcyIsIndlYnBhY2s6Ly8vdnVlZHJhZ2dhYmxlL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2hpZGUuanMiLCJ3ZWJwYWNrOi8vL3Z1ZWRyYWdnYWJsZS9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19vYmplY3QtZ3BvLmpzIiwid2VicGFjazovLy92dWVkcmFnZ2FibGUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9faXRlci1jcmVhdGUuanMiLCJ3ZWJwYWNrOi8vL3Z1ZWRyYWdnYWJsZS9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5vYmplY3Qua2V5cy5qcyIsIndlYnBhY2s6Ly8vdnVlZHJhZ2dhYmxlL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3RvLWludGVnZXIuanMiLCJ3ZWJwYWNrOi8vL3Z1ZWRyYWdnYWJsZS9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19wcm9wZXJ0eS1kZXNjLmpzIiwid2VicGFjazovLy92dWVkcmFnZ2FibGUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fdG8tb2JqZWN0LmpzIiwid2VicGFjazovLy92dWVkcmFnZ2FibGUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fZmFpbHMtaXMtcmVnZXhwLmpzIiwid2VicGFjazovLy92dWVkcmFnZ2FibGUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fcmVnZXhwLWV4ZWMuanMiLCJ3ZWJwYWNrOi8vL3Z1ZWRyYWdnYWJsZS9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19vYmplY3QtcGllLmpzIiwid2VicGFjazovLy92dWVkcmFnZ2FibGUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fc2hhcmVkLmpzIiwid2VicGFjazovLy92dWVkcmFnZ2FibGUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fZXhwb3J0LmpzIiwid2VicGFjazovLy92dWVkcmFnZ2FibGUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LXNhcC5qcyIsIndlYnBhY2s6Ly8vdnVlZHJhZ2dhYmxlL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3JlZ2V4cC1leGVjLWFic3RyYWN0LmpzIiwid2VicGFjazovLy92dWVkcmFnZ2FibGUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fc2hhcmVkLWtleS5qcyIsIndlYnBhY2s6Ly8vdnVlZHJhZ2dhYmxlL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2lvYmplY3QuanMiLCJ3ZWJwYWNrOi8vL3Z1ZWRyYWdnYWJsZS9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy5hcnJheS5pbmNsdWRlcy5qcyIsIndlYnBhY2s6Ly8vdnVlZHJhZ2dhYmxlL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3RvLWlvYmplY3QuanMiLCJ3ZWJwYWNrOi8vL3Z1ZWRyYWdnYWJsZS9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19oYXMuanMiLCJ3ZWJwYWNrOi8vL3Z1ZWRyYWdnYWJsZS9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL190by1wcmltaXRpdmUuanMiLCJ3ZWJwYWNrOi8vL3Z1ZWRyYWdnYWJsZS9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19vYmplY3QtYXNzaWduLmpzIiwid2VicGFjazovLy92dWVkcmFnZ2FibGUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fZ2xvYmFsLmpzIiwid2VicGFjazovLy92dWVkcmFnZ2FibGUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fdG8tYWJzb2x1dGUtaW5kZXguanMiLCJ3ZWJwYWNrOi8vL3Z1ZWRyYWdnYWJsZS9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19mYWlscy5qcyIsIndlYnBhY2s6Ly8vdnVlZHJhZ2dhYmxlL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3NldC10by1zdHJpbmctdGFnLmpzIiwid2VicGFjazovLy92dWVkcmFnZ2FibGUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fY29yZS5qcyIsIndlYnBhY2s6Ly8vdnVlZHJhZ2dhYmxlL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2l0ZXJhdG9ycy5qcyIsIndlYnBhY2s6Ly8vdnVlZHJhZ2dhYmxlL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX29iamVjdC1kcC5qcyIsIndlYnBhY2s6Ly8vdnVlZHJhZ2dhYmxlL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2N0eC5qcyIsIndlYnBhY2s6Ly8vdnVlZHJhZ2dhYmxlL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2FkZC10by11bnNjb3BhYmxlcy5qcyIsIndlYnBhY2s6Ly8vdnVlZHJhZ2dhYmxlL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3RvLWxlbmd0aC5qcyIsIndlYnBhY2s6Ly8vdnVlZHJhZ2dhYmxlL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2Rlc2NyaXB0b3JzLmpzIiwid2VicGFjazovLy92dWVkcmFnZ2FibGUvZXh0ZXJuYWwge1wiY29tbW9uanNcIjpcInNvcnRhYmxlanNcIixcImNvbW1vbmpzMlwiOlwic29ydGFibGVqc1wiLFwiYW1kXCI6XCJzb3J0YWJsZWpzXCIsXCJyb290XCI6XCJTb3J0YWJsZVwifSIsIndlYnBhY2s6Ly8vdnVlZHJhZ2dhYmxlL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnJlZ2V4cC5yZXBsYWNlLmpzIiwid2VicGFjazovLy92dWVkcmFnZ2FibGUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9faXMtcmVnZXhwLmpzIiwid2VicGFjazovLy92dWVkcmFnZ2FibGUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy93ZWIuZG9tLml0ZXJhYmxlLmpzIiwid2VicGFjazovLy92dWVkcmFnZ2FibGUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYucmVnZXhwLmV4ZWMuanMiLCJ3ZWJwYWNrOi8vL3Z1ZWRyYWdnYWJsZS9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19kZWZpbmVkLmpzIiwid2VicGFjazovLy92dWVkcmFnZ2FibGUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fYXJyYXktaW5jbHVkZXMuanMiLCJ3ZWJwYWNrOi8vL3Z1ZWRyYWdnYWJsZS9zcmMvdXRpbC9oZWxwZXIuanMiLCJ3ZWJwYWNrOi8vL3Z1ZWRyYWdnYWJsZS9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19pZTgtZG9tLWRlZmluZS5qcyIsIndlYnBhY2s6Ly8vdnVlZHJhZ2dhYmxlLyh3ZWJwYWNrKS9idWlsZGluL2dsb2JhbC5qcyIsIndlYnBhY2s6Ly8vdnVlZHJhZ2dhYmxlL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3VpZC5qcyIsIndlYnBhY2s6Ly8vdnVlZHJhZ2dhYmxlL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LmFycmF5Lml0ZXJhdG9yLmpzIiwid2VicGFjazovLy92dWVkcmFnZ2FibGUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fYW4tb2JqZWN0LmpzIiwid2VicGFjazovLy92dWVkcmFnZ2FibGUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LWtleXMtaW50ZXJuYWwuanMiLCJ3ZWJwYWNrOi8vL3Z1ZWRyYWdnYWJsZS9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19zdHJpbmctY29udGV4dC5qcyIsIndlYnBhY2s6Ly8vdnVlZHJhZ2dhYmxlL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2lzLW9iamVjdC5qcyIsIndlYnBhY2s6Ly8vdnVlZHJhZ2dhYmxlL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2l0ZXItc3RlcC5qcyIsIndlYnBhY2s6Ly8vdnVlZHJhZ2dhYmxlL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2EtZnVuY3Rpb24uanMiLCJ3ZWJwYWNrOi8vL3Z1ZWRyYWdnYWJsZS9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19lbnVtLWJ1Zy1rZXlzLmpzIiwid2VicGFjazovLy92dWVkcmFnZ2FibGUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuc3RyaW5nLnN0YXJ0cy13aXRoLmpzIiwid2VicGFjazovLy92dWVkcmFnZ2FibGUvbm9kZV9tb2R1bGVzL2N1cnJlbnQtc2NyaXB0LXBvbHlmaWxsL2N1cnJlbnRTY3JpcHQuanMiLCJ3ZWJwYWNrOi8vL3Z1ZWRyYWdnYWJsZS9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5vYmplY3QuYXNzaWduLmpzIiwid2VicGFjazovLy92dWVkcmFnZ2FibGUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fZnVuY3Rpb24tdG8tc3RyaW5nLmpzIiwid2VicGFjazovLy92dWVkcmFnZ2FibGUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9faHRtbC5qcyIsIndlYnBhY2s6Ly8vdnVlZHJhZ2dhYmxlL25vZGVfbW9kdWxlcy9AdnVlL2NsaS1zZXJ2aWNlL2xpYi9jb21tYW5kcy9idWlsZC9zZXRQdWJsaWNQYXRoLmpzIiwid2VicGFjazovLy92dWVkcmFnZ2FibGUvbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2FycmF5V2l0aEhvbGVzLmpzIiwid2VicGFjazovLy92dWVkcmFnZ2FibGUvbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2l0ZXJhYmxlVG9BcnJheUxpbWl0LmpzIiwid2VicGFjazovLy92dWVkcmFnZ2FibGUvbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2FycmF5TGlrZVRvQXJyYXkuanMiLCJ3ZWJwYWNrOi8vL3Z1ZWRyYWdnYWJsZS9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkuanMiLCJ3ZWJwYWNrOi8vL3Z1ZWRyYWdnYWJsZS9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vbm9uSXRlcmFibGVSZXN0LmpzIiwid2VicGFjazovLy92dWVkcmFnZ2FibGUvbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL3NsaWNlZFRvQXJyYXkuanMiLCJ3ZWJwYWNrOi8vL3Z1ZWRyYWdnYWJsZS9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vYXJyYXlXaXRob3V0SG9sZXMuanMiLCJ3ZWJwYWNrOi8vL3Z1ZWRyYWdnYWJsZS9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vaXRlcmFibGVUb0FycmF5LmpzIiwid2VicGFjazovLy92dWVkcmFnZ2FibGUvbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL25vbkl0ZXJhYmxlU3ByZWFkLmpzIiwid2VicGFjazovLy92dWVkcmFnZ2FibGUvbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL3RvQ29uc3VtYWJsZUFycmF5LmpzIiwid2VicGFjazovLy92dWVkcmFnZ2FibGUvc3JjL3Z1ZWRyYWdnYWJsZS5qcyIsIndlYnBhY2s6Ly8vdnVlZHJhZ2dhYmxlL25vZGVfbW9kdWxlcy9AdnVlL2NsaS1zZXJ2aWNlL2xpYi9jb21tYW5kcy9idWlsZC9lbnRyeS1saWIuanMiLCJ3ZWJwYWNrOi8vLyh3ZWJwYWNrKS9idWlsZGluL2dsb2JhbC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9tYWluL21haW4uc2Nzcz80NGY3Iiwid2VicGFjazovLy8uL3NyYy9jb21wb25lbnRzL21haW4vbWFpbi52dWUiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbXBvbmVudHMvbWFpbi9tYWluLnZ1ZT8wYjgwIiwid2VicGFjazovLy8uL3NyYy9jb21wb25lbnRzL21haW4vbWFpbi52dWU/Mjg1NyIsIndlYnBhY2s6Ly8vLi9zcmMvaW5kZXguanMiXSwibmFtZXMiOlsibmFtZSIsImRhdGEiLCJuYW1lRmlyc3QiLCJuYW1lU2Vjb25kIiwibmFtZUxhc3QiLCJhZ2UiLCJwZW9wbGVzIiwic2hvd0Zyb21Mb2NhbCIsIndhdGNoIiwibW91bnRlZCIsImNvbXBvbmVudHMiLCJkcmFnZ2FibGUiLCJtZXRob2RzIiwiYWRkTmV3Iiwic2F2ZWRBZ2UiLCJsb2NhbFN0b3JhZ2UiLCJjb25zb2xlIiwiY2xlYXJMb2NhbCIsImNsZWFySW5wdXQiLCJkZWxldGVDaGVsaWsiLCJpbmRleCIsImNyZWF0ZWQiLCJtb2R1bGUiLCJleHBvcnRzIiwidXNlU291cmNlTWFwIiwibGlzdCIsInRvU3RyaW5nIiwibWFwIiwiaXRlbSIsImNvbnRlbnQiLCJjc3NXaXRoTWFwcGluZ1RvU3RyaW5nIiwiY29uY2F0Iiwiam9pbiIsImkiLCJtb2R1bGVzIiwibWVkaWFRdWVyeSIsImRlZHVwZSIsImFscmVhZHlJbXBvcnRlZE1vZHVsZXMiLCJsZW5ndGgiLCJpZCIsIl9pIiwicHVzaCIsImNzc01hcHBpbmciLCJidG9hIiwic291cmNlTWFwcGluZyIsInRvQ29tbWVudCIsInNvdXJjZVVSTHMiLCJzb3VyY2VzIiwic291cmNlIiwic291cmNlUm9vdCIsInNvdXJjZU1hcCIsImJhc2U2NCIsInVuZXNjYXBlIiwiZW5jb2RlVVJJQ29tcG9uZW50IiwiSlNPTiIsInN0cmluZ2lmeSIsInByb2Nlc3MiLCJjYWNoZWRTZXRUaW1lb3V0IiwiY2FjaGVkQ2xlYXJUaW1lb3V0IiwiZGVmYXVsdFNldFRpbW91dCIsIkVycm9yIiwiZGVmYXVsdENsZWFyVGltZW91dCIsInNldFRpbWVvdXQiLCJlIiwiY2xlYXJUaW1lb3V0IiwicnVuVGltZW91dCIsImZ1biIsImNhbGwiLCJydW5DbGVhclRpbWVvdXQiLCJtYXJrZXIiLCJxdWV1ZSIsImRyYWluaW5nIiwiY3VycmVudFF1ZXVlIiwicXVldWVJbmRleCIsImNsZWFuVXBOZXh0VGljayIsImRyYWluUXVldWUiLCJ0aW1lb3V0IiwibGVuIiwicnVuIiwibmV4dFRpY2siLCJhcmdzIiwiQXJyYXkiLCJhcmd1bWVudHMiLCJJdGVtIiwiYXJyYXkiLCJwcm90b3R5cGUiLCJhcHBseSIsInRpdGxlIiwiYnJvd3NlciIsImVudiIsImFyZ3YiLCJ2ZXJzaW9uIiwidmVyc2lvbnMiLCJub29wIiwib24iLCJhZGRMaXN0ZW5lciIsIm9uY2UiLCJvZmYiLCJyZW1vdmVMaXN0ZW5lciIsInJlbW92ZUFsbExpc3RlbmVycyIsImVtaXQiLCJwcmVwZW5kTGlzdGVuZXIiLCJwcmVwZW5kT25jZUxpc3RlbmVyIiwibGlzdGVuZXJzIiwiYmluZGluZyIsImN3ZCIsImNoZGlyIiwiZGlyIiwidW1hc2siLCJnbG9iYWwiLCJ1bmRlZmluZWQiLCJzZXRJbW1lZGlhdGUiLCJuZXh0SGFuZGxlIiwidGFza3NCeUhhbmRsZSIsImN1cnJlbnRseVJ1bm5pbmdBVGFzayIsImRvYyIsImRvY3VtZW50IiwicmVnaXN0ZXJJbW1lZGlhdGUiLCJjYWxsYmFjayIsIkZ1bmN0aW9uIiwidGFzayIsImNsZWFySW1tZWRpYXRlIiwiaGFuZGxlIiwicnVuSWZQcmVzZW50IiwiaW5zdGFsbE5leHRUaWNrSW1wbGVtZW50YXRpb24iLCJjYW5Vc2VQb3N0TWVzc2FnZSIsInBvc3RNZXNzYWdlIiwiaW1wb3J0U2NyaXB0cyIsInBvc3RNZXNzYWdlSXNBc3luY2hyb25vdXMiLCJvbGRPbk1lc3NhZ2UiLCJvbm1lc3NhZ2UiLCJpbnN0YWxsUG9zdE1lc3NhZ2VJbXBsZW1lbnRhdGlvbiIsIm1lc3NhZ2VQcmVmaXgiLCJNYXRoIiwicmFuZG9tIiwib25HbG9iYWxNZXNzYWdlIiwiZXZlbnQiLCJpbmRleE9mIiwic2xpY2UiLCJhZGRFdmVudExpc3RlbmVyIiwiYXR0YWNoRXZlbnQiLCJpbnN0YWxsTWVzc2FnZUNoYW5uZWxJbXBsZW1lbnRhdGlvbiIsImNoYW5uZWwiLCJNZXNzYWdlQ2hhbm5lbCIsInBvcnQxIiwicG9ydDIiLCJpbnN0YWxsUmVhZHlTdGF0ZUNoYW5nZUltcGxlbWVudGF0aW9uIiwiaHRtbCIsImRvY3VtZW50RWxlbWVudCIsInNjcmlwdCIsImNyZWF0ZUVsZW1lbnQiLCJvbnJlYWR5c3RhdGVjaGFuZ2UiLCJyZW1vdmVDaGlsZCIsImFwcGVuZENoaWxkIiwiaW5zdGFsbFNldFRpbWVvdXRJbXBsZW1lbnRhdGlvbiIsImF0dGFjaFRvIiwiT2JqZWN0IiwiZ2V0UHJvdG90eXBlT2YiLCJzZWxmIiwiX3R5cGVvZiIsIm9iaiIsIlN5bWJvbCIsIml0ZXJhdG9yIiwiY29uc3RydWN0b3IiLCJfZGVmaW5lUHJvcGVydHkiLCJrZXkiLCJ2YWx1ZSIsImRlZmluZVByb3BlcnR5IiwiZW51bWVyYWJsZSIsImNvbmZpZ3VyYWJsZSIsIndyaXRhYmxlIiwiX2V4dGVuZHMiLCJhc3NpZ24iLCJ0YXJnZXQiLCJoYXNPd25Qcm9wZXJ0eSIsIl9vYmplY3RTcHJlYWQiLCJvd25LZXlzIiwia2V5cyIsImdldE93blByb3BlcnR5U3ltYm9scyIsImZpbHRlciIsInN5bSIsImdldE93blByb3BlcnR5RGVzY3JpcHRvciIsImZvckVhY2giLCJfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZSIsImV4Y2x1ZGVkIiwic291cmNlS2V5cyIsIl9vYmplY3RXaXRob3V0UHJvcGVydGllcyIsInNvdXJjZVN5bWJvbEtleXMiLCJwcm9wZXJ0eUlzRW51bWVyYWJsZSIsIl90b0NvbnN1bWFibGVBcnJheSIsImFyciIsIl9hcnJheVdpdGhvdXRIb2xlcyIsIl9pdGVyYWJsZVRvQXJyYXkiLCJfbm9uSXRlcmFibGVTcHJlYWQiLCJpc0FycmF5IiwiYXJyMiIsIml0ZXIiLCJmcm9tIiwiVHlwZUVycm9yIiwidXNlckFnZW50IiwicGF0dGVybiIsIndpbmRvdyIsIm5hdmlnYXRvciIsIm1hdGNoIiwiSUUxMU9yTGVzcyIsIkVkZ2UiLCJGaXJlRm94IiwiU2FmYXJpIiwiSU9TIiwiQ2hyb21lRm9yQW5kcm9pZCIsImNhcHR1cmVNb2RlIiwiY2FwdHVyZSIsInBhc3NpdmUiLCJlbCIsImZuIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsIm1hdGNoZXMiLCJzZWxlY3RvciIsInN1YnN0cmluZyIsIm1zTWF0Y2hlc1NlbGVjdG9yIiwid2Via2l0TWF0Y2hlc1NlbGVjdG9yIiwiXyIsImdldFBhcmVudE9ySG9zdCIsImhvc3QiLCJub2RlVHlwZSIsInBhcmVudE5vZGUiLCJjbG9zZXN0IiwiY3R4IiwiaW5jbHVkZUNUWCIsIlJfU1BBQ0UiLCJ0b2dnbGVDbGFzcyIsInN0YXRlIiwiY2xhc3NMaXN0IiwiY2xhc3NOYW1lIiwicmVwbGFjZSIsImNzcyIsInByb3AiLCJ2YWwiLCJzdHlsZSIsImRlZmF1bHRWaWV3IiwiZ2V0Q29tcHV0ZWRTdHlsZSIsImN1cnJlbnRTdHlsZSIsIm1hdHJpeCIsInNlbGZPbmx5IiwiYXBwbGllZFRyYW5zZm9ybXMiLCJ0cmFuc2Zvcm0iLCJtYXRyaXhGbiIsIkRPTU1hdHJpeCIsIldlYktpdENTU01hdHJpeCIsIkNTU01hdHJpeCIsIk1TQ1NTTWF0cml4IiwiZmluZCIsInRhZ05hbWUiLCJnZXRFbGVtZW50c0J5VGFnTmFtZSIsIm4iLCJnZXRXaW5kb3dTY3JvbGxpbmdFbGVtZW50Iiwic2Nyb2xsaW5nRWxlbWVudCIsImdldFJlY3QiLCJyZWxhdGl2ZVRvQ29udGFpbmluZ0Jsb2NrIiwicmVsYXRpdmVUb05vblN0YXRpY1BhcmVudCIsInVuZG9TY2FsZSIsImNvbnRhaW5lciIsImdldEJvdW5kaW5nQ2xpZW50UmVjdCIsImVsUmVjdCIsInRvcCIsImxlZnQiLCJib3R0b20iLCJyaWdodCIsImhlaWdodCIsIndpZHRoIiwiaW5uZXJIZWlnaHQiLCJpbm5lcldpZHRoIiwiY29udGFpbmVyUmVjdCIsInBhcnNlSW50IiwiZWxNYXRyaXgiLCJzY2FsZVgiLCJhIiwic2NhbGVZIiwiZCIsImlzU2Nyb2xsZWRQYXN0IiwiZWxTaWRlIiwicGFyZW50U2lkZSIsInBhcmVudCIsImdldFBhcmVudEF1dG9TY3JvbGxFbGVtZW50IiwiZWxTaWRlVmFsIiwicGFyZW50U2lkZVZhbCIsInZpc2libGUiLCJnZXRDaGlsZCIsImNoaWxkTnVtIiwib3B0aW9ucyIsImN1cnJlbnRDaGlsZCIsImNoaWxkcmVuIiwiZGlzcGxheSIsIlNvcnRhYmxlIiwiZ2hvc3QiLCJkcmFnZ2VkIiwibGFzdENoaWxkIiwibGFzdCIsImxhc3RFbGVtZW50Q2hpbGQiLCJwcmV2aW91c0VsZW1lbnRTaWJsaW5nIiwibm9kZU5hbWUiLCJ0b1VwcGVyQ2FzZSIsImNsb25lIiwiZ2V0UmVsYXRpdmVTY3JvbGxPZmZzZXQiLCJvZmZzZXRMZWZ0Iiwib2Zmc2V0VG9wIiwid2luU2Nyb2xsZXIiLCJzY3JvbGxMZWZ0Iiwic2Nyb2xsVG9wIiwiaW5kZXhPZk9iamVjdCIsIk51bWJlciIsImluY2x1ZGVTZWxmIiwiZWxlbSIsImdvdFNlbGYiLCJjbGllbnRXaWR0aCIsInNjcm9sbFdpZHRoIiwiY2xpZW50SGVpZ2h0Iiwic2Nyb2xsSGVpZ2h0IiwiZWxlbUNTUyIsIm92ZXJmbG93WCIsIm92ZXJmbG93WSIsImJvZHkiLCJleHRlbmQiLCJkc3QiLCJzcmMiLCJpc1JlY3RFcXVhbCIsInJlY3QxIiwicmVjdDIiLCJyb3VuZCIsIl90aHJvdHRsZVRpbWVvdXQiLCJ0aHJvdHRsZSIsIm1zIiwiX3RoaXMiLCJjYW5jZWxUaHJvdHRsZSIsInNjcm9sbEJ5IiwieCIsInkiLCJQb2x5bWVyIiwiJCIsImpRdWVyeSIsIlplcHRvIiwiZG9tIiwiY2xvbmVOb2RlIiwic2V0UmVjdCIsInJlY3QiLCJ1bnNldFJlY3QiLCJleHBhbmRvIiwiRGF0ZSIsImdldFRpbWUiLCJBbmltYXRpb25TdGF0ZU1hbmFnZXIiLCJhbmltYXRpb25TdGF0ZXMiLCJhbmltYXRpb25DYWxsYmFja0lkIiwiY2FwdHVyZUFuaW1hdGlvblN0YXRlIiwiYW5pbWF0aW9uIiwiY2hpbGQiLCJmcm9tUmVjdCIsInRoaXNBbmltYXRpb25EdXJhdGlvbiIsImNoaWxkTWF0cml4IiwiZiIsImFkZEFuaW1hdGlvblN0YXRlIiwicmVtb3ZlQW5pbWF0aW9uU3RhdGUiLCJzcGxpY2UiLCJhbmltYXRlQWxsIiwiYW5pbWF0aW5nIiwiYW5pbWF0aW9uVGltZSIsInRpbWUiLCJ0b1JlY3QiLCJwcmV2RnJvbVJlY3QiLCJwcmV2VG9SZWN0IiwiYW5pbWF0aW5nUmVjdCIsInRhcmdldE1hdHJpeCIsImNhbGN1bGF0ZVJlYWxUaW1lIiwiYW5pbWF0ZSIsIm1heCIsImFuaW1hdGlvblJlc2V0VGltZXIiLCJjdXJyZW50UmVjdCIsImR1cmF0aW9uIiwidHJhbnNsYXRlWCIsInRyYW5zbGF0ZVkiLCJhbmltYXRpbmdYIiwiYW5pbWF0aW5nWSIsInJlcGFpbnQiLCJlYXNpbmciLCJhbmltYXRlZCIsIm9mZnNldFdpZHRoIiwic3FydCIsInBvdyIsInBsdWdpbnMiLCJkZWZhdWx0cyIsImluaXRpYWxpemVCeURlZmF1bHQiLCJQbHVnaW5NYW5hZ2VyIiwibW91bnQiLCJwbHVnaW4iLCJvcHRpb24iLCJwbHVnaW5FdmVudCIsImV2ZW50TmFtZSIsInNvcnRhYmxlIiwiZXZ0IiwiZXZlbnRDYW5jZWxlZCIsImNhbmNlbCIsImV2ZW50TmFtZUdsb2JhbCIsInBsdWdpbk5hbWUiLCJpbml0aWFsaXplUGx1Z2lucyIsImluaXRpYWxpemVkIiwibW9kaWZpZWQiLCJtb2RpZnlPcHRpb24iLCJnZXRFdmVudFByb3BlcnRpZXMiLCJldmVudFByb3BlcnRpZXMiLCJtb2RpZmllZFZhbHVlIiwib3B0aW9uTGlzdGVuZXJzIiwiZGlzcGF0Y2hFdmVudCIsIl9yZWYiLCJyb290RWwiLCJ0YXJnZXRFbCIsImNsb25lRWwiLCJ0b0VsIiwiZnJvbUVsIiwib2xkSW5kZXgiLCJuZXdJbmRleCIsIm9sZERyYWdnYWJsZUluZGV4IiwibmV3RHJhZ2dhYmxlSW5kZXgiLCJvcmlnaW5hbEV2ZW50IiwicHV0U29ydGFibGUiLCJleHRyYUV2ZW50UHJvcGVydGllcyIsIm9uTmFtZSIsImNoYXJBdCIsInN1YnN0ciIsIkN1c3RvbUV2ZW50IiwiYnViYmxlcyIsImNhbmNlbGFibGUiLCJjcmVhdGVFdmVudCIsImluaXRFdmVudCIsInRvIiwicHVsbE1vZGUiLCJsYXN0UHV0TW9kZSIsImFsbEV2ZW50UHJvcGVydGllcyIsImJpbmQiLCJkcmFnRWwiLCJwYXJlbnRFbCIsImdob3N0RWwiLCJuZXh0RWwiLCJsYXN0RG93bkVsIiwiY2xvbmVIaWRkZW4iLCJkcmFnU3RhcnRlZCIsIm1vdmVkIiwiYWN0aXZlU29ydGFibGUiLCJhY3RpdmUiLCJoaWRlR2hvc3RGb3JUYXJnZXQiLCJfaGlkZUdob3N0Rm9yVGFyZ2V0IiwidW5oaWRlR2hvc3RGb3JUYXJnZXQiLCJfdW5oaWRlR2hvc3RGb3JUYXJnZXQiLCJjbG9uZU5vd0hpZGRlbiIsImNsb25lTm93U2hvd24iLCJkaXNwYXRjaFNvcnRhYmxlRXZlbnQiLCJfZGlzcGF0Y2hFdmVudCIsImluZm8iLCJhY3RpdmVHcm91cCIsImF3YWl0aW5nRHJhZ1N0YXJ0ZWQiLCJpZ25vcmVOZXh0Q2xpY2siLCJzb3J0YWJsZXMiLCJ0YXBFdnQiLCJ0b3VjaEV2dCIsImxhc3REeCIsImxhc3REeSIsInRhcERpc3RhbmNlTGVmdCIsInRhcERpc3RhbmNlVG9wIiwibGFzdFRhcmdldCIsImxhc3REaXJlY3Rpb24iLCJwYXN0Rmlyc3RJbnZlcnRUaHJlc2giLCJpc0NpcmN1bXN0YW50aWFsSW52ZXJ0IiwidGFyZ2V0TW92ZURpc3RhbmNlIiwiZ2hvc3RSZWxhdGl2ZVBhcmVudCIsImdob3N0UmVsYXRpdmVQYXJlbnRJbml0aWFsU2Nyb2xsIiwiX3NpbGVudCIsInNhdmVkSW5wdXRDaGVja2VkIiwiZG9jdW1lbnRFeGlzdHMiLCJQb3NpdGlvbkdob3N0QWJzb2x1dGVseSIsIkNTU0Zsb2F0UHJvcGVydHkiLCJzdXBwb3J0RHJhZ2dhYmxlIiwic3VwcG9ydENzc1BvaW50ZXJFdmVudHMiLCJjc3NUZXh0IiwicG9pbnRlckV2ZW50cyIsIl9kZXRlY3REaXJlY3Rpb24iLCJlbENTUyIsImVsV2lkdGgiLCJwYWRkaW5nTGVmdCIsInBhZGRpbmdSaWdodCIsImJvcmRlckxlZnRXaWR0aCIsImJvcmRlclJpZ2h0V2lkdGgiLCJjaGlsZDEiLCJjaGlsZDIiLCJmaXJzdENoaWxkQ1NTIiwic2Vjb25kQ2hpbGRDU1MiLCJmaXJzdENoaWxkV2lkdGgiLCJtYXJnaW5MZWZ0IiwibWFyZ2luUmlnaHQiLCJzZWNvbmRDaGlsZFdpZHRoIiwiZmxleERpcmVjdGlvbiIsImdyaWRUZW1wbGF0ZUNvbHVtbnMiLCJzcGxpdCIsInRvdWNoaW5nU2lkZUNoaWxkMiIsImNsZWFyIiwiX2RyYWdFbEluUm93Q29sdW1uIiwiZHJhZ1JlY3QiLCJ0YXJnZXRSZWN0IiwidmVydGljYWwiLCJkcmFnRWxTMU9wcCIsImRyYWdFbFMyT3BwIiwiZHJhZ0VsT3BwTGVuZ3RoIiwidGFyZ2V0UzFPcHAiLCJ0YXJnZXRTMk9wcCIsInRhcmdldE9wcExlbmd0aCIsIl9kZXRlY3ROZWFyZXN0RW1wdHlTb3J0YWJsZSIsInJldCIsInNvbWUiLCJ0aHJlc2hvbGQiLCJlbXB0eUluc2VydFRocmVzaG9sZCIsImluc2lkZUhvcml6b250YWxseSIsImluc2lkZVZlcnRpY2FsbHkiLCJfcHJlcGFyZUdyb3VwIiwidG9GbiIsInB1bGwiLCJzYW1lR3JvdXAiLCJncm91cCIsIm90aGVyR3JvdXAiLCJvcmlnaW5hbEdyb3VwIiwiY2hlY2tQdWxsIiwiY2hlY2tQdXQiLCJwdXQiLCJyZXZlcnRDbG9uZSIsInByZXZlbnREZWZhdWx0Iiwic3RvcFByb3BhZ2F0aW9uIiwic3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uIiwibmVhcmVzdEVtcHR5SW5zZXJ0RGV0ZWN0RXZlbnQiLCJ0b3VjaGVzIiwibmVhcmVzdCIsImNsaWVudFgiLCJjbGllbnRZIiwiX29uRHJhZ092ZXIiLCJfY2hlY2tPdXRzaWRlVGFyZ2V0RWwiLCJfaXNPdXRzaWRlVGhpc0VsIiwic29ydCIsImRpc2FibGVkIiwic3RvcmUiLCJ0ZXN0Iiwic3dhcFRocmVzaG9sZCIsImludmVydFN3YXAiLCJpbnZlcnRlZFN3YXBUaHJlc2hvbGQiLCJyZW1vdmVDbG9uZU9uSGlkZSIsImRpcmVjdGlvbiIsImdob3N0Q2xhc3MiLCJjaG9zZW5DbGFzcyIsImRyYWdDbGFzcyIsImlnbm9yZSIsInByZXZlbnRPbkZpbHRlciIsInNldERhdGEiLCJkYXRhVHJhbnNmZXIiLCJ0ZXh0Q29udGVudCIsImRyb3BCdWJibGUiLCJkcmFnb3ZlckJ1YmJsZSIsImRhdGFJZEF0dHIiLCJkZWxheSIsImRlbGF5T25Ub3VjaE9ubHkiLCJ0b3VjaFN0YXJ0VGhyZXNob2xkIiwiZGV2aWNlUGl4ZWxSYXRpbyIsImZvcmNlRmFsbGJhY2siLCJmYWxsYmFja0NsYXNzIiwiZmFsbGJhY2tPbkJvZHkiLCJmYWxsYmFja1RvbGVyYW5jZSIsImZhbGxiYWNrT2Zmc2V0Iiwic3VwcG9ydFBvaW50ZXIiLCJuYXRpdmVEcmFnZ2FibGUiLCJfb25UYXBTdGFydCIsImdldCIsImNvbnRhaW5zIiwiX2dldERpcmVjdGlvbiIsInR5cGUiLCJ0b3VjaCIsInBvaW50ZXJUeXBlIiwib3JpZ2luYWxUYXJnZXQiLCJzaGFkb3dSb290IiwicGF0aCIsImNvbXBvc2VkUGF0aCIsIl9zYXZlSW5wdXRDaGVja2VkU3RhdGUiLCJidXR0b24iLCJpc0NvbnRlbnRFZGl0YWJsZSIsImNyaXRlcmlhIiwidHJpbSIsIl9wcmVwYXJlRHJhZ1N0YXJ0Iiwib3duZXJEb2N1bWVudCIsImRyYWdTdGFydEZuIiwibmV4dFNpYmxpbmciLCJfbGFzdFgiLCJfbGFzdFkiLCJfb25Ecm9wIiwiX2Rpc2FibGVEZWxheWVkRHJhZ0V2ZW50cyIsIl90cmlnZ2VyRHJhZ1N0YXJ0IiwiX2Rpc2FibGVEcmFnZ2FibGUiLCJfZGlzYWJsZURlbGF5ZWREcmFnIiwiX2RlbGF5ZWREcmFnVG91Y2hNb3ZlSGFuZGxlciIsIl9kcmFnU3RhcnRUaW1lciIsImFicyIsImZsb29yIiwiX29uVG91Y2hNb3ZlIiwiX29uRHJhZ1N0YXJ0Iiwic2VsZWN0aW9uIiwiX25leHRUaWNrIiwiZW1wdHkiLCJnZXRTZWxlY3Rpb24iLCJyZW1vdmVBbGxSYW5nZXMiLCJlcnIiLCJfZHJhZ1N0YXJ0ZWQiLCJmYWxsYmFjayIsIl9hcHBlbmRHaG9zdCIsIl9udWxsaW5nIiwiX2VtdWxhdGVEcmFnT3ZlciIsImVsZW1lbnRGcm9tUG9pbnQiLCJpbnNlcnRlZCIsImdob3N0TWF0cml4IiwicmVsYXRpdmVTY3JvbGxPZmZzZXQiLCJkeCIsImR5IiwiYiIsImMiLCJjc3NNYXRyaXgiLCJfaGlkZUNsb25lIiwiY2xvbmVJZCIsImluc2VydEJlZm9yZSIsIl9sb29wSWQiLCJzZXRJbnRlcnZhbCIsImVmZmVjdEFsbG93ZWQiLCJfZHJhZ1N0YXJ0SWQiLCJyZXZlcnQiLCJpc093bmVyIiwiY2FuU29ydCIsImZyb21Tb3J0YWJsZSIsImNvbXBsZXRlZEZpcmVkIiwiZHJhZ092ZXJFdmVudCIsImV4dHJhIiwiYXhpcyIsImNvbXBsZXRlZCIsIm9uTW92ZSIsImFmdGVyIiwiX29uTW92ZSIsImNoYW5nZWQiLCJpbnNlcnRpb24iLCJfc2hvd0Nsb25lIiwiX2lnbm9yZVdoaWxlQW5pbWF0aW5nIiwiZWxMYXN0Q2hpbGQiLCJfZ2hvc3RJc0xhc3QiLCJ0YXJnZXRCZWZvcmVGaXJzdFN3YXAiLCJkaWZmZXJlbnRMZXZlbCIsImRpZmZlcmVudFJvd0NvbCIsInNpZGUxIiwic2Nyb2xsZWRQYXN0VG9wIiwic2Nyb2xsQmVmb3JlIiwiX2dldFN3YXBEaXJlY3Rpb24iLCJzaWJsaW5nIiwiZHJhZ0luZGV4IiwibmV4dEVsZW1lbnRTaWJsaW5nIiwibW92ZVZlY3RvciIsIl91bnNpbGVudCIsIl9vZmZNb3ZlRXZlbnRzIiwiX29mZlVwRXZlbnRzIiwiY2xlYXJJbnRlcnZhbCIsIl9jYW5jZWxOZXh0VGljayIsInNhdmUiLCJjaGVja2VkIiwiaGFuZGxlRXZlbnQiLCJfZ2xvYmFsRHJhZ092ZXIiLCJ0b0FycmF5Iiwib3JkZXIiLCJnZXRBdHRyaWJ1dGUiLCJfZ2VuZXJhdGVJZCIsIml0ZW1zIiwic2V0IiwiY2xvc2VzdCQxIiwiZGVzdHJveSIsInF1ZXJ5U2VsZWN0b3JBbGwiLCJyZW1vdmVBdHRyaWJ1dGUiLCJkcm9wRWZmZWN0Iiwid2lsbEluc2VydEFmdGVyIiwib25Nb3ZlRm4iLCJyZXRWYWwiLCJkcmFnZ2VkUmVjdCIsInJlbGF0ZWQiLCJyZWxhdGVkUmVjdCIsInNwYWNlciIsImlzTGFzdFRhcmdldCIsIm1vdXNlT25BeGlzIiwidGFyZ2V0TGVuZ3RoIiwidGFyZ2V0UzEiLCJ0YXJnZXRTMiIsImludmVydCIsIl9nZXRJbnNlcnREaXJlY3Rpb24iLCJzdHIiLCJocmVmIiwic3VtIiwiY2hhckNvZGVBdCIsInJvb3QiLCJpbnB1dHMiLCJpZHgiLCJ1dGlscyIsImlzIiwiY2FuY2VsTmV4dFRpY2siLCJkZXRlY3REaXJlY3Rpb24iLCJlbGVtZW50IiwiX2xlbiIsIl9rZXkiLCJjcmVhdGUiLCJhdXRvU2Nyb2xscyIsInNjcm9sbEVsIiwic2Nyb2xsUm9vdEVsIiwic2Nyb2xsaW5nIiwibGFzdEF1dG9TY3JvbGxYIiwibGFzdEF1dG9TY3JvbGxZIiwidG91Y2hFdnQkMSIsInBvaW50ZXJFbGVtQ2hhbmdlZEludGVydmFsIiwiQXV0b1Njcm9sbFBsdWdpbiIsIkF1dG9TY3JvbGwiLCJzY3JvbGwiLCJzY3JvbGxTZW5zaXRpdml0eSIsInNjcm9sbFNwZWVkIiwiYnViYmxlU2Nyb2xsIiwiX2hhbmRsZUF1dG9TY3JvbGwiLCJfaGFuZGxlRmFsbGJhY2tBdXRvU2Nyb2xsIiwiZHJhZ092ZXJDb21wbGV0ZWQiLCJfcmVmMiIsImRyYWdPdmVyQnViYmxlIiwiZHJvcCIsImNsZWFyUG9pbnRlckVsZW1DaGFuZ2VkSW50ZXJ2YWwiLCJjbGVhckF1dG9TY3JvbGxzIiwibnVsbGluZyIsImF1dG9TY3JvbGwiLCJvZ0VsZW1TY3JvbGxlciIsIm5ld0VsZW0iLCJwaWQiLCJpc0ZhbGxiYWNrIiwic2VucyIsInNwZWVkIiwic2Nyb2xsVGhpc0luc3RhbmNlIiwic2Nyb2xsQ3VzdG9tRm4iLCJzY3JvbGxGbiIsImxheWVyc091dCIsImN1cnJlbnRQYXJlbnQiLCJjYW5TY3JvbGxYIiwiY2FuU2Nyb2xsWSIsInNjcm9sbFBvc1giLCJzY3JvbGxQb3NZIiwidngiLCJ2eSIsImxheWVyIiwic2Nyb2xsT2Zmc2V0WSIsInNjcm9sbE9mZnNldFgiLCJ0b1NvcnRhYmxlIiwiY2hhbmdlZFRvdWNoZXMiLCJvblNwaWxsIiwiUmV2ZXJ0Iiwic3RhcnRJbmRleCIsImRyYWdTdGFydCIsIl9yZWYzIiwiUmVtb3ZlIiwiX3JlZjQiLCJwYXJlbnRTb3J0YWJsZSIsImxhc3RTd2FwRWwiLCJTd2FwUGx1Z2luIiwiU3dhcCIsInN3YXBDbGFzcyIsImRyYWdPdmVyVmFsaWQiLCJzd2FwIiwicHJldlN3YXBFbCIsInN3YXBOb2RlcyIsInN3YXBJdGVtIiwibjEiLCJuMiIsInAxIiwicDIiLCJpMSIsImkyIiwiaXNFcXVhbE5vZGUiLCJtdWx0aURyYWdFbGVtZW50cyIsIm11bHRpRHJhZ0Nsb25lcyIsImxhc3RNdWx0aURyYWdTZWxlY3QiLCJtdWx0aURyYWdTb3J0YWJsZSIsImluaXRpYWxGb2xkaW5nIiwiZm9sZGluZyIsImRyYWdFbCQxIiwiY2xvbmVzRnJvbVJlY3QiLCJjbG9uZXNIaWRkZW4iLCJNdWx0aURyYWdQbHVnaW4iLCJNdWx0aURyYWciLCJfZGVzZWxlY3RNdWx0aURyYWciLCJfY2hlY2tLZXlEb3duIiwiX2NoZWNrS2V5VXAiLCJzZWxlY3RlZENsYXNzIiwibXVsdGlEcmFnS2V5IiwibXVsdGlEcmFnRWxlbWVudCIsIm11bHRpRHJhZ0tleURvd24iLCJpc011bHRpRHJhZyIsImRlbGF5U3RhcnRHbG9iYWwiLCJkZWxheUVuZGVkIiwic2V0dXBDbG9uZSIsInNvcnRhYmxlSW5kZXgiLCJpbnNlcnRNdWx0aURyYWdDbG9uZXMiLCJzaG93Q2xvbmUiLCJoaWRlQ2xvbmUiLCJfcmVmNSIsImRyYWdTdGFydEdsb2JhbCIsIl9yZWY2IiwibXVsdGlEcmFnIiwiX3JlZjciLCJfdGhpczIiLCJyZW1vdmVNdWx0aURyYWdFbGVtZW50cyIsImRyYWdPdmVyIiwiX3JlZjgiLCJfcmVmOSIsImluc2VydE11bHRpRHJhZ0VsZW1lbnRzIiwiX3JlZjEwIiwiZHJhZ1JlY3RBYnNvbHV0ZSIsImNsb25lc0hpZGRlbkJlZm9yZSIsImRyYWdPdmVyQW5pbWF0aW9uQ2FwdHVyZSIsIl9yZWYxMSIsImRyYWdNYXRyaXgiLCJkcmFnT3ZlckFuaW1hdGlvbkNvbXBsZXRlIiwiX3JlZjEyIiwib3JpZ2luYWxFdnQiLCJzaGlmdEtleSIsImxhc3RJbmRleCIsImN1cnJlbnRJbmRleCIsIm11bHRpRHJhZ0luZGV4IiwidXBkYXRlIiwibnVsbGluZ0dsb2JhbCIsImRlc3Ryb3lHbG9iYWwiLCJzaGlmdCIsInNlbGVjdCIsImRlc2VsZWN0IiwiX3RoaXMzIiwib2xkSW5kaWNpZXMiLCJuZXdJbmRpY2llcyIsImNsb25lcyIsInRvTG93ZXJDYXNlIiwiY2xvbmVzSW5zZXJ0ZWQiLCJlbGVtZW50c0luc2VydGVkIiwic2NvcGUiLCJUaW1lb3V0IiwiY2xvc2UiLCJjbGVhckZuIiwiX2lkIiwiX2NsZWFyRm4iLCJ1bnJlZiIsInJlZiIsImVucm9sbCIsIm1zZWNzIiwiX2lkbGVUaW1lb3V0SWQiLCJfaWRsZVRpbWVvdXQiLCJ1bmVucm9sbCIsIl91bnJlZkFjdGl2ZSIsIm9uVGltZW91dCIsIl9vblRpbWVvdXQiLCJyZXF1aXJlIiwiZW1wdHlPYmplY3QiLCJmcmVlemUiLCJpc1VuZGVmIiwidiIsImlzRGVmIiwiaXNUcnVlIiwiaXNGYWxzZSIsImlzUHJpbWl0aXZlIiwiaXNPYmplY3QiLCJfdG9TdHJpbmciLCJ0b1Jhd1R5cGUiLCJpc1BsYWluT2JqZWN0IiwiaXNSZWdFeHAiLCJpc1ZhbGlkQXJyYXlJbmRleCIsInBhcnNlRmxvYXQiLCJTdHJpbmciLCJpc0Zpbml0ZSIsImlzUHJvbWlzZSIsInRoZW4iLCJjYXRjaCIsInRvTnVtYmVyIiwiaXNOYU4iLCJtYWtlTWFwIiwiZXhwZWN0c0xvd2VyQ2FzZSIsImlzQnVpbHRJblRhZyIsImlzUmVzZXJ2ZWRBdHRyaWJ1dGUiLCJyZW1vdmUiLCJoYXNPd24iLCJjYWNoZWQiLCJjYWNoZSIsImNhY2hlZEZuIiwiaGl0IiwiY2FtZWxpemVSRSIsImNhbWVsaXplIiwiY2FwaXRhbGl6ZSIsImh5cGhlbmF0ZVJFIiwiaHlwaGVuYXRlIiwicG9seWZpbGxCaW5kIiwiYm91bmRGbiIsImwiLCJfbGVuZ3RoIiwibmF0aXZlQmluZCIsInN0YXJ0IiwiX2Zyb20iLCJ0b09iamVjdCIsInJlcyIsIm5vIiwiaWRlbnRpdHkiLCJsb29zZUVxdWFsIiwiaXNPYmplY3RBIiwiaXNPYmplY3RCIiwiaXNBcnJheUEiLCJpc0FycmF5QiIsImV2ZXJ5Iiwia2V5c0EiLCJrZXlzQiIsImxvb3NlSW5kZXhPZiIsImNhbGxlZCIsIlNTUl9BVFRSIiwiQVNTRVRfVFlQRVMiLCJMSUZFQ1lDTEVfSE9PS1MiLCJjb25maWciLCJvcHRpb25NZXJnZVN0cmF0ZWdpZXMiLCJzaWxlbnQiLCJwcm9kdWN0aW9uVGlwIiwiZGV2dG9vbHMiLCJwZXJmb3JtYW5jZSIsImVycm9ySGFuZGxlciIsIndhcm5IYW5kbGVyIiwiaWdub3JlZEVsZW1lbnRzIiwia2V5Q29kZXMiLCJpc1Jlc2VydmVkVGFnIiwiaXNSZXNlcnZlZEF0dHIiLCJpc1Vua25vd25FbGVtZW50IiwiZ2V0VGFnTmFtZXNwYWNlIiwicGFyc2VQbGF0Zm9ybVRhZ05hbWUiLCJtdXN0VXNlUHJvcCIsImFzeW5jIiwiX2xpZmVjeWNsZUhvb2tzIiwidW5pY29kZVJlZ0V4cCIsImlzUmVzZXJ2ZWQiLCJkZWYiLCJiYWlsUkUiLCJSZWdFeHAiLCJwYXJzZVBhdGgiLCJzZWdtZW50cyIsImhhc1Byb3RvIiwiaW5Ccm93c2VyIiwiaW5XZWV4IiwiV1hFbnZpcm9ubWVudCIsInBsYXRmb3JtIiwid2VleFBsYXRmb3JtIiwiVUEiLCJpc0lFIiwiaXNJRTkiLCJpc0VkZ2UiLCJpc0FuZHJvaWQiLCJpc0lPUyIsImlzQ2hyb21lIiwiaXNQaGFudG9tSlMiLCJpc0ZGIiwibmF0aXZlV2F0Y2giLCJzdXBwb3J0c1Bhc3NpdmUiLCJvcHRzIiwiX2lzU2VydmVyIiwiaXNTZXJ2ZXJSZW5kZXJpbmciLCJWVUVfRU5WIiwiX19WVUVfREVWVE9PTFNfR0xPQkFMX0hPT0tfXyIsImlzTmF0aXZlIiwiQ3RvciIsImhhc1N5bWJvbCIsIlJlZmxlY3QiLCJfU2V0IiwiU2V0IiwiaGFzIiwiYWRkIiwid2FybiIsInRpcCIsImdlbmVyYXRlQ29tcG9uZW50VHJhY2UiLCJmb3JtYXRDb21wb25lbnROYW1lIiwiaGFzQ29uc29sZSIsImNsYXNzaWZ5UkUiLCJjbGFzc2lmeSIsIm1zZyIsInZtIiwidHJhY2UiLCJlcnJvciIsImluY2x1ZGVGaWxlIiwiJHJvb3QiLCJjaWQiLCJfaXNWdWUiLCIkb3B0aW9ucyIsIl9jb21wb25lbnRUYWciLCJmaWxlIiwiX19maWxlIiwicmVwZWF0IiwiJHBhcmVudCIsInRyZWUiLCJjdXJyZW50UmVjdXJzaXZlU2VxdWVuY2UiLCJ1aWQiLCJEZXAiLCJzdWJzIiwiYWRkU3ViIiwic3ViIiwicmVtb3ZlU3ViIiwiZGVwZW5kIiwiYWRkRGVwIiwibm90aWZ5IiwidGFyZ2V0U3RhY2siLCJwdXNoVGFyZ2V0IiwicG9wVGFyZ2V0IiwicG9wIiwiVk5vZGUiLCJ0YWciLCJ0ZXh0IiwiZWxtIiwiY29udGV4dCIsImNvbXBvbmVudE9wdGlvbnMiLCJhc3luY0ZhY3RvcnkiLCJucyIsImZuQ29udGV4dCIsImZuT3B0aW9ucyIsImZuU2NvcGVJZCIsImNvbXBvbmVudEluc3RhbmNlIiwicmF3IiwiaXNTdGF0aWMiLCJpc1Jvb3RJbnNlcnQiLCJpc0NvbW1lbnQiLCJpc0Nsb25lZCIsImlzT25jZSIsImFzeW5jTWV0YSIsImlzQXN5bmNQbGFjZWhvbGRlciIsInByb3RvdHlwZUFjY2Vzc29ycyIsImRlZmluZVByb3BlcnRpZXMiLCJjcmVhdGVFbXB0eVZOb2RlIiwibm9kZSIsImNyZWF0ZVRleHRWTm9kZSIsImNsb25lVk5vZGUiLCJ2bm9kZSIsImNsb25lZCIsImFycmF5UHJvdG8iLCJhcnJheU1ldGhvZHMiLCJtZXRob2RzVG9QYXRjaCIsIm1ldGhvZCIsIm9yaWdpbmFsIiwibXV0YXRvciIsInJlc3VsdCIsIm9iIiwiX19vYl9fIiwib2JzZXJ2ZUFycmF5IiwiZGVwIiwiYXJyYXlLZXlzIiwiZ2V0T3duUHJvcGVydHlOYW1lcyIsInNob3VsZE9ic2VydmUiLCJ0b2dnbGVPYnNlcnZpbmciLCJPYnNlcnZlciIsInZtQ291bnQiLCJwcm90b0F1Z21lbnQiLCJjb3B5QXVnbWVudCIsIndhbGsiLCJkZWZpbmVSZWFjdGl2ZSQkMSIsIm9ic2VydmUiLCJfX3Byb3RvX18iLCJhc1Jvb3REYXRhIiwiaXNFeHRlbnNpYmxlIiwiY3VzdG9tU2V0dGVyIiwic2hhbGxvdyIsInByb3BlcnR5IiwiZ2V0dGVyIiwic2V0dGVyIiwiY2hpbGRPYiIsInJlYWN0aXZlR2V0dGVyIiwiZGVwZW5kQXJyYXkiLCJyZWFjdGl2ZVNldHRlciIsIm5ld1ZhbCIsImRlbCIsInN0cmF0cyIsInByb3BzRGF0YSIsImRlZmF1bHRTdHJhdCIsIm1lcmdlRGF0YSIsInRvVmFsIiwiZnJvbVZhbCIsIm1lcmdlRGF0YU9yRm4iLCJwYXJlbnRWYWwiLCJjaGlsZFZhbCIsIm1lcmdlZERhdGFGbiIsIm1lcmdlZEluc3RhbmNlRGF0YUZuIiwiaW5zdGFuY2VEYXRhIiwiZGVmYXVsdERhdGEiLCJtZXJnZUhvb2siLCJkZWR1cGVIb29rcyIsImhvb2tzIiwiaG9vayIsIm1lcmdlQXNzZXRzIiwiYXNzZXJ0T2JqZWN0VHlwZSIsImtleSQxIiwicHJvcHMiLCJpbmplY3QiLCJjb21wdXRlZCIsInByb3ZpZGUiLCJjaGVja0NvbXBvbmVudHMiLCJ2YWxpZGF0ZUNvbXBvbmVudE5hbWUiLCJub3JtYWxpemVQcm9wcyIsIm5vcm1hbGl6ZUluamVjdCIsIm5vcm1hbGl6ZWQiLCJub3JtYWxpemVEaXJlY3RpdmVzIiwiZGlycyIsImRpcmVjdGl2ZXMiLCJkZWYkJDEiLCJtZXJnZU9wdGlvbnMiLCJfYmFzZSIsImV4dGVuZHMiLCJtaXhpbnMiLCJtZXJnZUZpZWxkIiwic3RyYXQiLCJyZXNvbHZlQXNzZXQiLCJ3YXJuTWlzc2luZyIsImFzc2V0cyIsImNhbWVsaXplZElkIiwiUGFzY2FsQ2FzZUlkIiwidmFsaWRhdGVQcm9wIiwicHJvcE9wdGlvbnMiLCJhYnNlbnQiLCJib29sZWFuSW5kZXgiLCJnZXRUeXBlSW5kZXgiLCJCb29sZWFuIiwic3RyaW5nSW5kZXgiLCJnZXRQcm9wRGVmYXVsdFZhbHVlIiwicHJldlNob3VsZE9ic2VydmUiLCJhc3NlcnRQcm9wIiwiZGVmYXVsdCIsIl9wcm9wcyIsImdldFR5cGUiLCJyZXF1aXJlZCIsInZhbGlkIiwiZXhwZWN0ZWRUeXBlcyIsImFzc2VydGVkVHlwZSIsImFzc2VydFR5cGUiLCJleHBlY3RlZFR5cGUiLCJoYXZlRXhwZWN0ZWRUeXBlcyIsInQiLCJnZXRJbnZhbGlkVHlwZU1lc3NhZ2UiLCJ2YWxpZGF0b3IiLCJzaW1wbGVDaGVja1JFIiwiZnVuY3Rpb25UeXBlQ2hlY2tSRSIsImlzU2FtZVR5cGUiLCJtZXNzYWdlIiwicmVjZWl2ZWRUeXBlIiwiaXNFeHBsaWNhYmxlIiwiaXNCb29sZWFuIiwic3R5bGVWYWx1ZSIsIkVYUExJQ0FCTEVfVFlQRVMiLCJoYW5kbGVFcnJvciIsImN1ciIsImVycm9yQ2FwdHVyZWQiLCJnbG9iYWxIYW5kbGVFcnJvciIsImludm9rZVdpdGhFcnJvckhhbmRsaW5nIiwiaGFuZGxlciIsIl9oYW5kbGVkIiwibG9nRXJyb3IiLCJpc1VzaW5nTWljcm9UYXNrIiwiY2FsbGJhY2tzIiwicGVuZGluZyIsImZsdXNoQ2FsbGJhY2tzIiwiY29waWVzIiwidGltZXJGdW5jIiwiUHJvbWlzZSIsInAiLCJyZXNvbHZlIiwiTXV0YXRpb25PYnNlcnZlciIsImNvdW50ZXIiLCJvYnNlcnZlciIsInRleHROb2RlIiwiY3JlYXRlVGV4dE5vZGUiLCJjaGFyYWN0ZXJEYXRhIiwiY2IiLCJfcmVzb2x2ZSIsImluaXRQcm94eSIsImFsbG93ZWRHbG9iYWxzIiwid2Fybk5vblByZXNlbnQiLCJ3YXJuUmVzZXJ2ZWRQcmVmaXgiLCJoYXNQcm94eSIsIlByb3h5IiwiaXNCdWlsdEluTW9kaWZpZXIiLCJoYXNIYW5kbGVyIiwiaXNBbGxvd2VkIiwiJGRhdGEiLCJnZXRIYW5kbGVyIiwiaGFuZGxlcnMiLCJyZW5kZXIiLCJfd2l0aFN0cmlwcGVkIiwiX3JlbmRlclByb3h5Iiwic2Vlbk9iamVjdHMiLCJ0cmF2ZXJzZSIsIl90cmF2ZXJzZSIsInNlZW4iLCJpc0EiLCJpc0Zyb3plbiIsImRlcElkIiwibWFyayIsIm1lYXN1cmUiLCJwZXJmIiwiY2xlYXJNYXJrcyIsImNsZWFyTWVhc3VyZXMiLCJzdGFydFRhZyIsImVuZFRhZyIsIm5vcm1hbGl6ZUV2ZW50Iiwib25jZSQkMSIsImNyZWF0ZUZuSW52b2tlciIsImZucyIsImludm9rZXIiLCJhcmd1bWVudHMkMSIsInVwZGF0ZUxpc3RlbmVycyIsIm9sZE9uIiwicmVtb3ZlJCQxIiwiY3JlYXRlT25jZUhhbmRsZXIiLCJvbGQiLCJwYXJhbXMiLCJtZXJnZVZOb2RlSG9vayIsImhvb2tLZXkiLCJvbGRIb29rIiwid3JhcHBlZEhvb2siLCJtZXJnZWQiLCJleHRyYWN0UHJvcHNGcm9tVk5vZGVEYXRhIiwiYXR0cnMiLCJhbHRLZXkiLCJrZXlJbkxvd2VyQ2FzZSIsImNoZWNrUHJvcCIsImhhc2giLCJwcmVzZXJ2ZSIsInNpbXBsZU5vcm1hbGl6ZUNoaWxkcmVuIiwibm9ybWFsaXplQ2hpbGRyZW4iLCJub3JtYWxpemVBcnJheUNoaWxkcmVuIiwiaXNUZXh0Tm9kZSIsIm5lc3RlZEluZGV4IiwiX2lzVkxpc3QiLCJpbml0UHJvdmlkZSIsIl9wcm92aWRlZCIsImluaXRJbmplY3Rpb25zIiwicmVzb2x2ZUluamVjdCIsInByb3ZpZGVLZXkiLCJwcm92aWRlRGVmYXVsdCIsInJlc29sdmVTbG90cyIsInNsb3RzIiwic2xvdCIsIm5hbWUkMSIsImlzV2hpdGVzcGFjZSIsIm5vcm1hbGl6ZVNjb3BlZFNsb3RzIiwibm9ybWFsU2xvdHMiLCJwcmV2U2xvdHMiLCJoYXNOb3JtYWxTbG90cyIsImlzU3RhYmxlIiwiJHN0YWJsZSIsIiRrZXkiLCJfbm9ybWFsaXplZCIsIiRoYXNOb3JtYWwiLCJub3JtYWxpemVTY29wZWRTbG90Iiwia2V5JDIiLCJwcm94eU5vcm1hbFNsb3QiLCJwcm94eSIsInJlbmRlckxpc3QiLCJuZXh0IiwiZG9uZSIsInJlbmRlclNsb3QiLCJmYWxsYmFja1JlbmRlciIsImJpbmRPYmplY3QiLCJzY29wZWRTbG90Rm4iLCIkc2NvcGVkU2xvdHMiLCJub2RlcyIsIiRzbG90cyIsIiRjcmVhdGVFbGVtZW50IiwicmVzb2x2ZUZpbHRlciIsImlzS2V5Tm90TWF0Y2giLCJleHBlY3QiLCJhY3R1YWwiLCJjaGVja0tleUNvZGVzIiwiZXZlbnRLZXlDb2RlIiwiYnVpbHRJbktleUNvZGUiLCJldmVudEtleU5hbWUiLCJidWlsdEluS2V5TmFtZSIsIm1hcHBlZEtleUNvZGUiLCJiaW5kT2JqZWN0UHJvcHMiLCJhc1Byb3AiLCJpc1N5bmMiLCJsb29wIiwiZG9tUHJvcHMiLCJjYW1lbGl6ZWRLZXkiLCJoeXBoZW5hdGVkS2V5IiwiJGV2ZW50IiwicmVuZGVyU3RhdGljIiwiaXNJbkZvciIsIl9zdGF0aWNUcmVlcyIsInN0YXRpY1JlbmRlckZucyIsIm1hcmtTdGF0aWMiLCJtYXJrT25jZSIsIm1hcmtTdGF0aWNOb2RlIiwiYmluZE9iamVjdExpc3RlbmVycyIsImV4aXN0aW5nIiwib3VycyIsInJlc29sdmVTY29wZWRTbG90cyIsImhhc0R5bmFtaWNLZXlzIiwiY29udGVudEhhc2hLZXkiLCJiaW5kRHluYW1pY0tleXMiLCJiYXNlT2JqIiwidmFsdWVzIiwicHJlcGVuZE1vZGlmaWVyIiwic3ltYm9sIiwiaW5zdGFsbFJlbmRlckhlbHBlcnMiLCJfbyIsIl9uIiwiX3MiLCJfbCIsIl90IiwiX3EiLCJfbSIsIl9mIiwiX2siLCJfYiIsIl92IiwiX2UiLCJfdSIsIl9nIiwiX2QiLCJfcCIsIkZ1bmN0aW9uYWxSZW5kZXJDb250ZXh0IiwidGhpcyQxIiwiY29udGV4dFZtIiwiX29yaWdpbmFsIiwiaXNDb21waWxlZCIsIl9jb21waWxlZCIsIm5lZWROb3JtYWxpemF0aW9uIiwiaW5qZWN0aW9ucyIsInNjb3BlZFNsb3RzIiwiX3Njb3BlSWQiLCJfYyIsImNyZWF0ZUZ1bmN0aW9uYWxDb21wb25lbnQiLCJtZXJnZVByb3BzIiwicmVuZGVyQ29udGV4dCIsImNsb25lQW5kTWFya0Z1bmN0aW9uYWxSZXN1bHQiLCJ2bm9kZXMiLCJkZXZ0b29sc01ldGEiLCJjb21wb25lbnRWTm9kZUhvb2tzIiwiaW5pdCIsImh5ZHJhdGluZyIsIl9pc0Rlc3Ryb3llZCIsImtlZXBBbGl2ZSIsIm1vdW50ZWROb2RlIiwicHJlcGF0Y2giLCJjcmVhdGVDb21wb25lbnRJbnN0YW5jZUZvclZub2RlIiwiYWN0aXZlSW5zdGFuY2UiLCIkbW91bnQiLCJvbGRWbm9kZSIsInVwZGF0ZUNoaWxkQ29tcG9uZW50IiwiaW5zZXJ0IiwiX2lzTW91bnRlZCIsImNhbGxIb29rIiwicXVldWVBY3RpdmF0ZWRDb21wb25lbnQiLCJhY3RpdmF0ZUNoaWxkQ29tcG9uZW50IiwiJGRlc3Ryb3kiLCJkZWFjdGl2YXRlQ2hpbGRDb21wb25lbnQiLCJob29rc1RvTWVyZ2UiLCJjcmVhdGVDb21wb25lbnQiLCJiYXNlQ3RvciIsInJlc29sdmVBc3luY0NvbXBvbmVudCIsImNyZWF0ZUFzeW5jUGxhY2Vob2xkZXIiLCJyZXNvbHZlQ29uc3RydWN0b3JPcHRpb25zIiwibW9kZWwiLCJ0cmFuc2Zvcm1Nb2RlbCIsImZ1bmN0aW9uYWwiLCJuYXRpdmVPbiIsImFic3RyYWN0IiwiaW5zdGFsbENvbXBvbmVudEhvb2tzIiwiX2lzQ29tcG9uZW50IiwiX3BhcmVudFZub2RlIiwiaW5saW5lVGVtcGxhdGUiLCJ0b01lcmdlIiwiX21lcmdlZCIsIm1lcmdlSG9vayQxIiwiZjEiLCJmMiIsIlNJTVBMRV9OT1JNQUxJWkUiLCJBTFdBWVNfTk9STUFMSVpFIiwibm9ybWFsaXphdGlvblR5cGUiLCJhbHdheXNOb3JtYWxpemUiLCJfY3JlYXRlRWxlbWVudCIsIiR2bm9kZSIsInByZSIsImFwcGx5TlMiLCJyZWdpc3RlckRlZXBCaW5kaW5ncyIsImZvcmNlIiwiY2xhc3MiLCJpbml0UmVuZGVyIiwiX3Zub2RlIiwicGFyZW50Vm5vZGUiLCJfcmVuZGVyQ2hpbGRyZW4iLCJwYXJlbnREYXRhIiwiaXNVcGRhdGluZ0NoaWxkQ29tcG9uZW50IiwiX3BhcmVudExpc3RlbmVycyIsImN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZSIsInJlbmRlck1peGluIiwiVnVlIiwiJG5leHRUaWNrIiwiX3JlbmRlciIsInJlbmRlckVycm9yIiwiZW5zdXJlQ3RvciIsImNvbXAiLCJiYXNlIiwiX19lc01vZHVsZSIsInRvU3RyaW5nVGFnIiwiZmFjdG9yeSIsImVycm9yQ29tcCIsInJlc29sdmVkIiwib3duZXIiLCJvd25lcnMiLCJsb2FkaW5nIiwibG9hZGluZ0NvbXAiLCJzeW5jIiwidGltZXJMb2FkaW5nIiwidGltZXJUaW1lb3V0IiwiJG9uIiwiZm9yY2VSZW5kZXIiLCJyZW5kZXJDb21wbGV0ZWQiLCIkZm9yY2VVcGRhdGUiLCJyZWplY3QiLCJyZWFzb24iLCJjb21wb25lbnQiLCJnZXRGaXJzdENvbXBvbmVudENoaWxkIiwiaW5pdEV2ZW50cyIsIl9ldmVudHMiLCJfaGFzSG9va0V2ZW50IiwidXBkYXRlQ29tcG9uZW50TGlzdGVuZXJzIiwicmVtb3ZlJDEiLCIkb2ZmIiwiX3RhcmdldCIsIm9uY2VIYW5kbGVyIiwib2xkTGlzdGVuZXJzIiwiZXZlbnRzTWl4aW4iLCJob29rUkUiLCIkb25jZSIsImkkMSIsImNicyIsIiRlbWl0IiwibG93ZXJDYXNlRXZlbnQiLCJzZXRBY3RpdmVJbnN0YW5jZSIsInByZXZBY3RpdmVJbnN0YW5jZSIsImluaXRMaWZlY3ljbGUiLCIkY2hpbGRyZW4iLCIkcmVmcyIsIl93YXRjaGVyIiwiX2luYWN0aXZlIiwiX2RpcmVjdEluYWN0aXZlIiwiX2lzQmVpbmdEZXN0cm95ZWQiLCJsaWZlY3ljbGVNaXhpbiIsIl91cGRhdGUiLCJwcmV2RWwiLCIkZWwiLCJwcmV2Vm5vZGUiLCJyZXN0b3JlQWN0aXZlSW5zdGFuY2UiLCJfX3BhdGNoX18iLCJfX3Z1ZV9fIiwidGVhcmRvd24iLCJfd2F0Y2hlcnMiLCJfZGF0YSIsIm1vdW50Q29tcG9uZW50IiwidGVtcGxhdGUiLCJ1cGRhdGVDb21wb25lbnQiLCJfbmFtZSIsIl91aWQiLCJXYXRjaGVyIiwiYmVmb3JlIiwicmVuZGVyQ2hpbGRyZW4iLCJuZXdTY29wZWRTbG90cyIsIm9sZFNjb3BlZFNsb3RzIiwiaGFzRHluYW1pY1Njb3BlZFNsb3QiLCJuZWVkc0ZvcmNlVXBkYXRlIiwiJGF0dHJzIiwiJGxpc3RlbmVycyIsInByb3BLZXlzIiwiX3Byb3BLZXlzIiwiaXNJbkluYWN0aXZlVHJlZSIsImRpcmVjdCIsImoiLCJNQVhfVVBEQVRFX0NPVU5UIiwiYWN0aXZhdGVkQ2hpbGRyZW4iLCJjaXJjdWxhciIsIndhaXRpbmciLCJmbHVzaGluZyIsInJlc2V0U2NoZWR1bGVyU3RhdGUiLCJjdXJyZW50Rmx1c2hUaW1lc3RhbXAiLCJnZXROb3ciLCJub3ciLCJ0aW1lU3RhbXAiLCJmbHVzaFNjaGVkdWxlclF1ZXVlIiwid2F0Y2hlciIsInVzZXIiLCJleHByZXNzaW9uIiwiYWN0aXZhdGVkUXVldWUiLCJ1cGRhdGVkUXVldWUiLCJjYWxsQWN0aXZhdGVkSG9va3MiLCJjYWxsVXBkYXRlZEhvb2tzIiwicXVldWVXYXRjaGVyIiwidWlkJDIiLCJleHBPckZuIiwiaXNSZW5kZXJXYXRjaGVyIiwiZGVlcCIsImxhenkiLCJkaXJ0eSIsImRlcHMiLCJuZXdEZXBzIiwiZGVwSWRzIiwibmV3RGVwSWRzIiwiY2xlYW51cERlcHMiLCJ0bXAiLCJvbGRWYWx1ZSIsImV2YWx1YXRlIiwic2hhcmVkUHJvcGVydHlEZWZpbml0aW9uIiwic291cmNlS2V5IiwicHJveHlHZXR0ZXIiLCJwcm94eVNldHRlciIsImluaXRTdGF0ZSIsImluaXRQcm9wcyIsImluaXRNZXRob2RzIiwiaW5pdERhdGEiLCJpbml0Q29tcHV0ZWQiLCJpbml0V2F0Y2giLCJwcm9wc09wdGlvbnMiLCJpc1Jvb3QiLCJnZXREYXRhIiwiY29tcHV0ZWRXYXRjaGVyT3B0aW9ucyIsIndhdGNoZXJzIiwiX2NvbXB1dGVkV2F0Y2hlcnMiLCJpc1NTUiIsInVzZXJEZWYiLCJkZWZpbmVDb21wdXRlZCIsInNob3VsZENhY2hlIiwiY3JlYXRlQ29tcHV0ZWRHZXR0ZXIiLCJjcmVhdGVHZXR0ZXJJbnZva2VyIiwiY29tcHV0ZWRHZXR0ZXIiLCJjcmVhdGVXYXRjaGVyIiwiJHdhdGNoIiwic3RhdGVNaXhpbiIsImRhdGFEZWYiLCJwcm9wc0RlZiIsIiRzZXQiLCIkZGVsZXRlIiwiaW1tZWRpYXRlIiwidW53YXRjaEZuIiwidWlkJDMiLCJpbml0TWl4aW4iLCJfaW5pdCIsImluaXRJbnRlcm5hbENvbXBvbmVudCIsIl9zZWxmIiwidm5vZGVDb21wb25lbnRPcHRpb25zIiwic3VwZXIiLCJzdXBlck9wdGlvbnMiLCJjYWNoZWRTdXBlck9wdGlvbnMiLCJtb2RpZmllZE9wdGlvbnMiLCJyZXNvbHZlTW9kaWZpZWRPcHRpb25zIiwiZXh0ZW5kT3B0aW9ucyIsImxhdGVzdCIsInNlYWxlZCIsInNlYWxlZE9wdGlvbnMiLCJpbml0VXNlIiwidXNlIiwiaW5zdGFsbGVkUGx1Z2lucyIsIl9pbnN0YWxsZWRQbHVnaW5zIiwidW5zaGlmdCIsImluc3RhbGwiLCJpbml0TWl4aW4kMSIsIm1peGluIiwiaW5pdEV4dGVuZCIsIlN1cGVyIiwiU3VwZXJJZCIsImNhY2hlZEN0b3JzIiwiX0N0b3IiLCJTdWIiLCJWdWVDb21wb25lbnQiLCJpbml0UHJvcHMkMSIsImluaXRDb21wdXRlZCQxIiwiQ29tcCIsImluaXRBc3NldFJlZ2lzdGVycyIsImRlZmluaXRpb24iLCJnZXRDb21wb25lbnROYW1lIiwicHJ1bmVDYWNoZSIsImtlZXBBbGl2ZUluc3RhbmNlIiwiZW50cnkiLCJwcnVuZUNhY2hlRW50cnkiLCJjdXJyZW50IiwicGF0dGVyblR5cGVzIiwiS2VlcEFsaXZlIiwiaW5jbHVkZSIsImV4Y2x1ZGUiLCJjYWNoZVZOb2RlIiwidm5vZGVUb0NhY2hlIiwia2V5VG9DYWNoZSIsImRlc3Ryb3llZCIsInVwZGF0ZWQiLCJyZWYkMSIsImJ1aWx0SW5Db21wb25lbnRzIiwiaW5pdEdsb2JhbEFQSSIsImNvbmZpZ0RlZiIsInV0aWwiLCJkZWZpbmVSZWFjdGl2ZSIsImRlbGV0ZSIsIm9ic2VydmFibGUiLCJzc3JDb250ZXh0IiwiYWNjZXB0VmFsdWUiLCJhdHRyIiwiaXNFbnVtZXJhdGVkQXR0ciIsImlzVmFsaWRDb250ZW50RWRpdGFibGVWYWx1ZSIsImNvbnZlcnRFbnVtZXJhdGVkVmFsdWUiLCJpc0ZhbHN5QXR0clZhbHVlIiwiaXNCb29sZWFuQXR0ciIsInhsaW5rTlMiLCJpc1hsaW5rIiwiZ2V0WGxpbmtQcm9wIiwiZ2VuQ2xhc3NGb3JWbm9kZSIsImNoaWxkTm9kZSIsIm1lcmdlQ2xhc3NEYXRhIiwicmVuZGVyQ2xhc3MiLCJzdGF0aWNDbGFzcyIsImR5bmFtaWNDbGFzcyIsInN0cmluZ2lmeUNsYXNzIiwic3RyaW5naWZ5QXJyYXkiLCJzdHJpbmdpZnlPYmplY3QiLCJzdHJpbmdpZmllZCIsIm5hbWVzcGFjZU1hcCIsInN2ZyIsIm1hdGgiLCJpc0hUTUxUYWciLCJpc1NWRyIsInVua25vd25FbGVtZW50Q2FjaGUiLCJIVE1MVW5rbm93bkVsZW1lbnQiLCJIVE1MRWxlbWVudCIsImlzVGV4dElucHV0VHlwZSIsInF1ZXJ5Iiwic2VsZWN0ZWQiLCJxdWVyeVNlbGVjdG9yIiwiY3JlYXRlRWxlbWVudCQxIiwibXVsdGlwbGUiLCJzZXRBdHRyaWJ1dGUiLCJjcmVhdGVFbGVtZW50TlMiLCJuYW1lc3BhY2UiLCJjcmVhdGVDb21tZW50IiwibmV3Tm9kZSIsInJlZmVyZW5jZU5vZGUiLCJzZXRUZXh0Q29udGVudCIsInNldFN0eWxlU2NvcGUiLCJzY29wZUlkIiwibm9kZU9wcyIsInJlZ2lzdGVyUmVmIiwiaXNSZW1vdmFsIiwicmVmcyIsInJlZkluRm9yIiwiZW1wdHlOb2RlIiwic2FtZVZub2RlIiwic2FtZUlucHV0VHlwZSIsInR5cGVBIiwidHlwZUIiLCJjcmVhdGVLZXlUb09sZElkeCIsImJlZ2luSWR4IiwiZW5kSWR4IiwiY3JlYXRlUGF0Y2hGdW5jdGlvbiIsImJhY2tlbmQiLCJlbXB0eU5vZGVBdCIsImNyZWF0ZVJtQ2IiLCJjaGlsZEVsbSIsInJlbW92ZU5vZGUiLCJpc1Vua25vd25FbGVtZW50JCQxIiwiaW5WUHJlIiwiY3JlYXRpbmdFbG1JblZQcmUiLCJjcmVhdGVFbG0iLCJpbnNlcnRlZFZub2RlUXVldWUiLCJwYXJlbnRFbG0iLCJyZWZFbG0iLCJuZXN0ZWQiLCJvd25lckFycmF5Iiwic2V0U2NvcGUiLCJjcmVhdGVDaGlsZHJlbiIsImludm9rZUNyZWF0ZUhvb2tzIiwiaXNSZWFjdGl2YXRlZCIsImluaXRDb21wb25lbnQiLCJyZWFjdGl2YXRlQ29tcG9uZW50IiwicGVuZGluZ0luc2VydCIsImlzUGF0Y2hhYmxlIiwiaW5uZXJOb2RlIiwidHJhbnNpdGlvbiIsImFjdGl2YXRlIiwicmVmJCQxIiwiY2hlY2tEdXBsaWNhdGVLZXlzIiwiYW5jZXN0b3IiLCJhZGRWbm9kZXMiLCJzdGFydElkeCIsImludm9rZURlc3Ryb3lIb29rIiwicmVtb3ZlVm5vZGVzIiwiY2giLCJyZW1vdmVBbmRJbnZva2VSZW1vdmVIb29rIiwicm0iLCJ1cGRhdGVDaGlsZHJlbiIsIm9sZENoIiwibmV3Q2giLCJyZW1vdmVPbmx5Iiwib2xkU3RhcnRJZHgiLCJuZXdTdGFydElkeCIsIm9sZEVuZElkeCIsIm9sZFN0YXJ0Vm5vZGUiLCJvbGRFbmRWbm9kZSIsIm5ld0VuZElkeCIsIm5ld1N0YXJ0Vm5vZGUiLCJuZXdFbmRWbm9kZSIsIm9sZEtleVRvSWR4IiwiaWR4SW5PbGQiLCJ2bm9kZVRvTW92ZSIsImNhbk1vdmUiLCJwYXRjaFZub2RlIiwiZmluZElkeEluT2xkIiwic2VlbktleXMiLCJlbmQiLCJoeWRyYXRlIiwicG9zdHBhdGNoIiwiaW52b2tlSW5zZXJ0SG9vayIsImluaXRpYWwiLCJoeWRyYXRpb25CYWlsZWQiLCJpc1JlbmRlcmVkTW9kdWxlIiwiYXNzZXJ0Tm9kZU1hdGNoIiwiaGFzQ2hpbGROb2RlcyIsImlubmVySFRNTCIsImNoaWxkcmVuTWF0Y2giLCJmaXJzdENoaWxkIiwiY2hpbGROb2RlcyIsImZ1bGxJbnZva2UiLCJwYXRjaCIsImlzSW5pdGlhbFBhdGNoIiwiaXNSZWFsRWxlbWVudCIsImhhc0F0dHJpYnV0ZSIsIm9sZEVsbSIsIl9sZWF2ZUNiIiwicGF0Y2hhYmxlIiwiaSQyIiwidXBkYXRlRGlyZWN0aXZlcyIsInVuYmluZERpcmVjdGl2ZXMiLCJpc0NyZWF0ZSIsImlzRGVzdHJveSIsIm9sZERpcnMiLCJub3JtYWxpemVEaXJlY3RpdmVzJDEiLCJuZXdEaXJzIiwiZGlyc1dpdGhJbnNlcnQiLCJkaXJzV2l0aFBvc3RwYXRjaCIsIm9sZERpciIsImNhbGxIb29rJDEiLCJvbGRBcmciLCJhcmciLCJjb21wb25lbnRVcGRhdGVkIiwiY2FsbEluc2VydCIsImVtcHR5TW9kaWZpZXJzIiwibW9kaWZpZXJzIiwiZ2V0UmF3RGlyTmFtZSIsInJhd05hbWUiLCJiYXNlTW9kdWxlcyIsInVwZGF0ZUF0dHJzIiwiaW5oZXJpdEF0dHJzIiwib2xkQXR0cnMiLCJzZXRBdHRyIiwicmVtb3ZlQXR0cmlidXRlTlMiLCJpc0luUHJlIiwiYmFzZVNldEF0dHIiLCJzZXRBdHRyaWJ1dGVOUyIsIl9faWVwaCIsImJsb2NrZXIiLCJ1cGRhdGVDbGFzcyIsIm9sZERhdGEiLCJjbHMiLCJ0cmFuc2l0aW9uQ2xhc3MiLCJfdHJhbnNpdGlvbkNsYXNzZXMiLCJfcHJldkNsYXNzIiwia2xhc3MiLCJSQU5HRV9UT0tFTiIsIkNIRUNLQk9YX1JBRElPX1RPS0VOIiwibm9ybWFsaXplRXZlbnRzIiwiY2hhbmdlIiwidGFyZ2V0JDEiLCJjcmVhdGVPbmNlSGFuZGxlciQxIiwicmVtb3ZlJDIiLCJ1c2VNaWNyb3Rhc2tGaXgiLCJhZGQkMSIsImF0dGFjaGVkVGltZXN0YW1wIiwiX3dyYXBwZXIiLCJjdXJyZW50VGFyZ2V0IiwidXBkYXRlRE9NTGlzdGVuZXJzIiwiZXZlbnRzIiwic3ZnQ29udGFpbmVyIiwidXBkYXRlRE9NUHJvcHMiLCJvbGRQcm9wcyIsIl92YWx1ZSIsInN0ckN1ciIsInNob3VsZFVwZGF0ZVZhbHVlIiwiY2hlY2tWYWwiLCJjb21wb3NpbmciLCJpc05vdEluRm9jdXNBbmREaXJ0eSIsImlzRGlydHlXaXRoTW9kaWZpZXJzIiwibm90SW5Gb2N1cyIsImFjdGl2ZUVsZW1lbnQiLCJfdk1vZGlmaWVycyIsIm51bWJlciIsInBhcnNlU3R5bGVUZXh0IiwibGlzdERlbGltaXRlciIsInByb3BlcnR5RGVsaW1pdGVyIiwibm9ybWFsaXplU3R5bGVEYXRhIiwibm9ybWFsaXplU3R5bGVCaW5kaW5nIiwic3RhdGljU3R5bGUiLCJiaW5kaW5nU3R5bGUiLCJnZXRTdHlsZSIsImNoZWNrQ2hpbGQiLCJzdHlsZURhdGEiLCJjc3NWYXJSRSIsImltcG9ydGFudFJFIiwic2V0UHJvcCIsInNldFByb3BlcnR5Iiwibm9ybWFsaXplZE5hbWUiLCJub3JtYWxpemUiLCJ2ZW5kb3JOYW1lcyIsImVtcHR5U3R5bGUiLCJjYXBOYW1lIiwidXBkYXRlU3R5bGUiLCJvbGRTdGF0aWNTdHlsZSIsIm9sZFN0eWxlQmluZGluZyIsIm5vcm1hbGl6ZWRTdHlsZSIsIm9sZFN0eWxlIiwibmV3U3R5bGUiLCJ3aGl0ZXNwYWNlUkUiLCJhZGRDbGFzcyIsInJlbW92ZUNsYXNzIiwidGFyIiwicmVzb2x2ZVRyYW5zaXRpb24iLCJhdXRvQ3NzVHJhbnNpdGlvbiIsImVudGVyQ2xhc3MiLCJlbnRlclRvQ2xhc3MiLCJlbnRlckFjdGl2ZUNsYXNzIiwibGVhdmVDbGFzcyIsImxlYXZlVG9DbGFzcyIsImxlYXZlQWN0aXZlQ2xhc3MiLCJoYXNUcmFuc2l0aW9uIiwiVFJBTlNJVElPTiIsIkFOSU1BVElPTiIsInRyYW5zaXRpb25Qcm9wIiwidHJhbnNpdGlvbkVuZEV2ZW50IiwiYW5pbWF0aW9uUHJvcCIsImFuaW1hdGlvbkVuZEV2ZW50Iiwib250cmFuc2l0aW9uZW5kIiwib253ZWJraXR0cmFuc2l0aW9uZW5kIiwib25hbmltYXRpb25lbmQiLCJvbndlYmtpdGFuaW1hdGlvbmVuZCIsInJhZiIsInJlcXVlc3RBbmltYXRpb25GcmFtZSIsIm5leHRGcmFtZSIsImFkZFRyYW5zaXRpb25DbGFzcyIsInRyYW5zaXRpb25DbGFzc2VzIiwicmVtb3ZlVHJhbnNpdGlvbkNsYXNzIiwid2hlblRyYW5zaXRpb25FbmRzIiwiZ2V0VHJhbnNpdGlvbkluZm8iLCJwcm9wQ291bnQiLCJlbmRlZCIsIm9uRW5kIiwidHJhbnNmb3JtUkUiLCJzdHlsZXMiLCJ0cmFuc2l0aW9uRGVsYXlzIiwidHJhbnNpdGlvbkR1cmF0aW9ucyIsInRyYW5zaXRpb25UaW1lb3V0IiwiZ2V0VGltZW91dCIsImFuaW1hdGlvbkRlbGF5cyIsImFuaW1hdGlvbkR1cmF0aW9ucyIsImFuaW1hdGlvblRpbWVvdXQiLCJoYXNUcmFuc2Zvcm0iLCJkZWxheXMiLCJkdXJhdGlvbnMiLCJ0b01zIiwicyIsImVudGVyIiwidG9nZ2xlRGlzcGxheSIsImNhbmNlbGxlZCIsIl9lbnRlckNiIiwiYXBwZWFyQ2xhc3MiLCJhcHBlYXJUb0NsYXNzIiwiYXBwZWFyQWN0aXZlQ2xhc3MiLCJiZWZvcmVFbnRlciIsImFmdGVyRW50ZXIiLCJlbnRlckNhbmNlbGxlZCIsImJlZm9yZUFwcGVhciIsImFwcGVhciIsImFmdGVyQXBwZWFyIiwiYXBwZWFyQ2FuY2VsbGVkIiwidHJhbnNpdGlvbk5vZGUiLCJpc0FwcGVhciIsInN0YXJ0Q2xhc3MiLCJhY3RpdmVDbGFzcyIsInRvQ2xhc3MiLCJiZWZvcmVFbnRlckhvb2siLCJlbnRlckhvb2siLCJhZnRlckVudGVySG9vayIsImVudGVyQ2FuY2VsbGVkSG9vayIsImV4cGxpY2l0RW50ZXJEdXJhdGlvbiIsImNoZWNrRHVyYXRpb24iLCJleHBlY3RzQ1NTIiwidXNlcldhbnRzQ29udHJvbCIsImdldEhvb2tBcmd1bWVudHNMZW5ndGgiLCJzaG93IiwicGVuZGluZ05vZGUiLCJfcGVuZGluZyIsImlzVmFsaWREdXJhdGlvbiIsImxlYXZlIiwiYmVmb3JlTGVhdmUiLCJhZnRlckxlYXZlIiwibGVhdmVDYW5jZWxsZWQiLCJkZWxheUxlYXZlIiwiZXhwbGljaXRMZWF2ZUR1cmF0aW9uIiwicGVyZm9ybUxlYXZlIiwiaW52b2tlckZucyIsIl9lbnRlciIsInBsYXRmb3JtTW9kdWxlcyIsInZtb2RlbCIsInRyaWdnZXIiLCJkaXJlY3RpdmUiLCJfdk9wdGlvbnMiLCJzZXRTZWxlY3RlZCIsImdldFZhbHVlIiwib25Db21wb3NpdGlvblN0YXJ0Iiwib25Db21wb3NpdGlvbkVuZCIsInByZXZPcHRpb25zIiwiY3VyT3B0aW9ucyIsIm8iLCJuZWVkUmVzZXQiLCJoYXNOb01hdGNoaW5nT3B0aW9uIiwiYWN0dWFsbHlTZXRTZWxlY3RlZCIsImlzTXVsdGlwbGUiLCJzZWxlY3RlZEluZGV4IiwibG9jYXRlTm9kZSIsInRyYW5zaXRpb24kJDEiLCJvcmlnaW5hbERpc3BsYXkiLCJfX3ZPcmlnaW5hbERpc3BsYXkiLCJ1bmJpbmQiLCJwbGF0Zm9ybURpcmVjdGl2ZXMiLCJ0cmFuc2l0aW9uUHJvcHMiLCJtb2RlIiwiZ2V0UmVhbENoaWxkIiwiY29tcE9wdGlvbnMiLCJleHRyYWN0VHJhbnNpdGlvbkRhdGEiLCJwbGFjZWhvbGRlciIsImgiLCJyYXdDaGlsZCIsImhhc1BhcmVudFRyYW5zaXRpb24iLCJpc1NhbWVDaGlsZCIsIm9sZENoaWxkIiwiaXNOb3RUZXh0Tm9kZSIsImlzVlNob3dEaXJlY3RpdmUiLCJUcmFuc2l0aW9uIiwiX2xlYXZpbmciLCJvbGRSYXdDaGlsZCIsImRlbGF5ZWRMZWF2ZSIsIm1vdmVDbGFzcyIsIlRyYW5zaXRpb25Hcm91cCIsImJlZm9yZU1vdW50Iiwia2VwdCIsInByZXZDaGlsZHJlbiIsInJhd0NoaWxkcmVuIiwidHJhbnNpdGlvbkRhdGEiLCJyZW1vdmVkIiwiYyQxIiwicG9zIiwiaGFzTW92ZSIsImNhbGxQZW5kaW5nQ2JzIiwicmVjb3JkUG9zaXRpb24iLCJhcHBseVRyYW5zbGF0aW9uIiwiX3JlZmxvdyIsIm9mZnNldEhlaWdodCIsIldlYmtpdFRyYW5zZm9ybSIsInRyYW5zaXRpb25EdXJhdGlvbiIsIl9tb3ZlQ2IiLCJwcm9wZXJ0eU5hbWUiLCJfaGFzTW92ZSIsIm5ld1BvcyIsIm9sZFBvcyIsInBsYXRmb3JtQ29tcG9uZW50cyIsIl9fd2VicGFja19yZXF1aXJlX18iLCIkaXRlckNyZWF0ZSIsIkl0ZXJhdG9yUHJvdG90eXBlIiwic2V0VG9TdHJpbmdUYWciLCJWQUxVRVNfQlVHIiwiJGRlZmF1bHQiLCJoaWRlIiwiSXRlcmF0b3JzIiwiZW50cmllcyIsIiRleHBvcnQiLCJUT19TVFJJTkciLCJhbk9iamVjdCIsInJlIiwiTyIsImV4ZWNDYWxsZWQiLCJLRVkiLCJkZWZpbmVkIiwiU1lNQk9MIiwicmVkZWZpbmUiLCJBUkciLCJpbnNwZWN0U291cmNlIiwiaWZyYW1lIiwiaWZyYW1lRG9jdW1lbnQiLCJjcmVhdGVEaWN0IiwiRW1wdHkiLCJVU0VfU1lNQk9MIiwiJGV4cG9ydHMiLCJJTkNMVURFUyIsImluY2x1ZGVzIiwic2VhcmNoU3RyaW5nIiwib2JqZWN0IiwiQ29uc3RydWN0b3IiLCJyZTIiLCJuYXRpdmVFeGVjIiwicGF0Y2hlZEV4ZWMiLCJyZUNvcHkiLCJuYXRpdmVSZXBsYWNlIiwiY29weXJpZ2h0IiwiUFJPVE9UWVBFIiwib3duIiwib3V0IiwiZXhwIiwiQSIsIksiLCJCIiwiUyIsIiRhc3NpZ24iLCJQIiwiYUZ1bmN0aW9uIiwiQXJyYXlQcm90byIsIlVOU0NPUEFCTEVTIiwiJHJlcGxhY2UiLCJyeCIsInJlc3VsdHMiLCJjYXB0dXJlcyIsInJlcGxhY2VtZW50IiwiYWNjdW11bGF0ZWRSZXN1bHQiLCJuZXh0U291cmNlUG9zaXRpb24iLCJuYW1lZENhcHR1cmVzIiwic3ltYm9scyIsIkNTU1J1bGVMaXN0IiwiQ1NTU3R5bGVEZWNsYXJhdGlvbiIsIkNTU1ZhbHVlTGlzdCIsIkNsaWVudFJlY3RMaXN0IiwiRE9NUmVjdExpc3QiLCJET01TdHJpbmdMaXN0IiwiRE9NVG9rZW5MaXN0IiwiRGF0YVRyYW5zZmVySXRlbUxpc3QiLCJGaWxlTGlzdCIsIkhUTUxBbGxDb2xsZWN0aW9uIiwiSFRNTENvbGxlY3Rpb24iLCJIVE1MRm9ybUVsZW1lbnQiLCJIVE1MU2VsZWN0RWxlbWVudCIsIk1lZGlhTGlzdCIsIk1pbWVUeXBlQXJyYXkiLCJOYW1lZE5vZGVNYXAiLCJOb2RlTGlzdCIsIlBhaW50UmVxdWVzdExpc3QiLCJQbHVnaW4iLCJQbHVnaW5BcnJheSIsIlNWR0xlbmd0aExpc3QiLCJTVkdOdW1iZXJMaXN0IiwiU1ZHUGF0aFNlZ0xpc3QiLCJTVkdQb2ludExpc3QiLCJTVkdTdHJpbmdMaXN0IiwiU1ZHVHJhbnNmb3JtTGlzdCIsIlNvdXJjZUJ1ZmZlckxpc3QiLCJTdHlsZVNoZWV0TGlzdCIsIlRleHRUcmFja0N1ZUxpc3QiLCJUZXh0VHJhY2tMaXN0IiwiVG91Y2hMaXN0IiwicHJvdG8iLCJmb3JjZWQiLCJleGVjIiwiZ2V0Q29uc29sZSIsInJlZ2V4IiwicGFyZW50RWxlbWVudCIsImluc2VydE5vZGVBdCIsImZhdGhlck5vZGUiLCJwb3NpdGlvbiIsInJlZk5vZGUiLCJnIiwiYWRkVG9VbnNjb3BhYmxlcyIsIlNUQVJUU19XSVRIIiwic3RhcnRzV2l0aCIsIiRzdGFydHNXaXRoIiwidGhhdCIsInNjcmlwdHMiLCJzZXRQdWJsaWNQYXRoX2kiLCJfYXJyIiwiX2FycmF5TGlrZVRvQXJyYXkiLCJfYXJyYXlXaXRoSG9sZXMiLCJfaXRlcmFibGVUb0FycmF5TGltaXQiLCJfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkiLCJfbm9uSXRlcmFibGVSZXN0IiwiYnVpbGRBdHRyaWJ1dGUiLCJwcm9wTmFtZSIsImNvbXB1dGVWbUluZGV4IiwiZWx0IiwiY29tcHV0ZUluZGV4ZXMiLCJpc1RyYW5zaXRpb24iLCJmb290ZXJPZmZzZXQiLCJlbG1Gcm9tTm9kZXMiLCJmb290ZXJJbmRleCIsInJhd0luZGV4ZXMiLCJpbmQiLCJldnROYW1lIiwiZXZ0RGF0YSIsImRlbGVnYXRlQW5kRW1pdCIsInJlYWxMaXN0IiwiaXNUcmFuc2l0aW9uTmFtZSIsImdldFNsb3QiLCJzY29wZWRTbG90IiwiY29tcHV0ZUNoaWxkcmVuQW5kT2Zmc2V0cyIsImhlYWRlck9mZnNldCIsImhlYWRlciIsImZvb3RlciIsImdldENvbXBvbmVudEF0dHJpYnV0ZXMiLCJjb21wb25lbnREYXRhIiwiYXR0cmlidXRlcyIsInJlZHVjZSIsImNvbXBvbmVudERhdGFBdHRycyIsImV2ZW50c0xpc3RlbmVkIiwiZXZlbnRzVG9FbWl0IiwicmVhZG9ubHlQcm9wZXJ0aWVzIiwiZHJhZ2dpbmdFbGVtZW50Iiwibm9UcmFuc2l0aW9uT25EcmFnIiwibW92ZSIsImRyYWdnYWJsZUNvbXBvbmVudCIsInRyYW5zaXRpb25Nb2RlIiwibm9uZUZ1bmN0aW9uYWxDb21wb25lbnRNb2RlIiwiZ2V0VGFnIiwiZ2V0SXNGdW5jdGlvbmFsIiwib3B0aW9uc0FkZGVkIiwib25EcmFnTW92ZSIsIl9zb3J0YWJsZSIsInJvb3RDb250YWluZXIiLCJiZWZvcmVEZXN0cm95IiwibmV3T3B0aW9uVmFsdWUiLCJ1cGRhdGVPcHRpb25zIiwiZ2V0Q2hpbGRyZW5Ob2RlcyIsInJhd05vZGVzIiwiX3RoaXM0IiwidmlzaWJsZUluZGV4ZXMiLCJnZXRVbmRlcmx5aW5nVm0iLCJodG1sRWx0IiwiZ2V0VW5kZXJseWluZ1BvdGVuY2lhbERyYWdnYWJsZUNvbXBvbmVudCIsInZ1ZSIsImVtaXRDaGFuZ2VzIiwiX3RoaXM1IiwiYWx0ZXJMaXN0Iiwib25MaXN0IiwibmV3TGlzdCIsInNwbGljZUxpc3QiLCJ1cGRhdGVQb3NpdGlvbiIsImdldFJlbGF0ZWRDb250ZXh0RnJvbU1vdmVFdmVudCIsImRlc3RpbmF0aW9uIiwiZ2V0Vm1JbmRleCIsImRvbUluZGV4IiwiaW5kZXhlcyIsIm51bWJlckluZGV4ZXMiLCJnZXRDb21wb25lbnQiLCJyZXNldFRyYW5zaXRpb25EYXRhIiwidHJhbnNpdGlvbkNvbnRhaW5lciIsIm9uRHJhZ1N0YXJ0IiwiX3VuZGVybHlpbmdfdm1fIiwib25EcmFnQWRkIiwiYWRkZWQiLCJvbkRyYWdSZW1vdmUiLCJvbkRyYWdVcGRhdGUiLCJ1cGRhdGVQcm9wZXJ0eSIsImNvbXB1dGVGdXR1cmVJbmRleCIsInJlbGF0ZWRDb250ZXh0IiwiZG9tQ2hpbGRyZW4iLCJjdXJyZW50RE9NSW5kZXgiLCJkcmFnZ2VkSW5MaXN0IiwiZHJhZ2dlZENvbnRleHQiLCJmdXR1cmVJbmRleCIsInNlbmRFdnQiLCJvbkRyYWdFbmQiLCJNYWluIl0sIm1hcHBpbmdzIjoiO1FBQUE7UUFDQTs7UUFFQTtRQUNBOztRQUVBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBOztRQUVBO1FBQ0E7O1FBRUE7UUFDQTs7UUFFQTtRQUNBO1FBQ0E7OztRQUdBO1FBQ0E7O1FBRUE7UUFDQTs7UUFFQTtRQUNBO1FBQ0E7UUFDQSwwQ0FBMEMsZ0NBQWdDO1FBQzFFO1FBQ0E7O1FBRUE7UUFDQTtRQUNBO1FBQ0Esd0RBQXdELGtCQUFrQjtRQUMxRTtRQUNBLGlEQUFpRCxjQUFjO1FBQy9EOztRQUVBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQSx5Q0FBeUMsaUNBQWlDO1FBQzFFLGdIQUFnSCxtQkFBbUIsRUFBRTtRQUNySTtRQUNBOztRQUVBO1FBQ0E7UUFDQTtRQUNBLDJCQUEyQiwwQkFBMEIsRUFBRTtRQUN2RCxpQ0FBaUMsZUFBZTtRQUNoRDtRQUNBO1FBQ0E7O1FBRUE7UUFDQSxzREFBc0QsK0RBQStEOztRQUVySDtRQUNBOzs7UUFHQTtRQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUN6QkE7QUFFQTtFQUNBQSxXQURBO0VBRUFDLElBRkEsa0JBRUE7SUFDQTtNQUNBQyxh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QUFDLEdBQUcxMUQsTUFBSjtBQUNoQyxDLENBRUQ7QUFDQTtBQUNBOzs7QUFFQW5MLE1BQU0sQ0FBQ0MsT0FBUCxHQUFpQjRnRSxDQUFqQixDOzs7Ozs7Ozs7Ozs7QUNuQkE7QUFBQTtBQUFBO0FBQUE7Ozs7Ozs7Ozs7Ozs7QUNBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQW1GO0FBQzNCO0FBQ0w7QUFDZTs7O0FBR2xFO0FBQzZGO0FBQzdGLGdCQUFnQiwyR0FBVTtBQUMxQixFQUFFLDBFQUFNO0FBQ1IsRUFBRSwrRUFBTTtBQUNSLEVBQUUsd0ZBQWU7QUFDakI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxJQUFJLEtBQVUsRUFBRSxZQWlCZjtBQUNEO0FBQ2UsZ0Y7Ozs7Ozs7Ozs7OztBQ3ZDZjtBQUFBO0FBQUEsd0NBQTBLLENBQWdCLHdPQUFHLEVBQUMsQzs7Ozs7Ozs7Ozs7O0FDQTlMO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7Ozs7Ozs7Ozs7OztBQ0FBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFFQSxJQUFJM3FCLDJDQUFKLENBQVE7RUFDSm5xQyxFQUFFLEVBQUUsT0FEQTtFQUVKZzlCLE1BQU0sRUFBRSxnQkFBQXN2QixDQUFDO0lBQUEsT0FBSUEsQ0FBQyxDQUFDMk8saUVBQUQsQ0FBTDtFQUFBO0FBRkwsQ0FBUixFIiwiZmlsZSI6Im1haW4uanMiLCJzb3VyY2VzQ29udGVudCI6WyIgXHQvLyBUaGUgbW9kdWxlIGNhY2hlXG4gXHR2YXIgaW5zdGFsbGVkTW9kdWxlcyA9IHt9O1xuXG4gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuXG4gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuIFx0XHRpZihpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSkge1xuIFx0XHRcdHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xuIFx0XHR9XG4gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4gXHRcdHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcbiBcdFx0XHRpOiBtb2R1bGVJZCxcbiBcdFx0XHRsOiBmYWxzZSxcbiBcdFx0XHRleHBvcnRzOiB7fVxuIFx0XHR9O1xuXG4gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuIFx0XHRtb2R1bGVzW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcblxuIFx0XHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG4gXHRcdG1vZHVsZS5sID0gdHJ1ZTtcblxuIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4gXHR9XG5cblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlIGNhY2hlXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xuXG4gXHQvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9uIGZvciBoYXJtb255IGV4cG9ydHNcbiBcdF9fd2VicGFja19yZXF1aXJlX18uZCA9IGZ1bmN0aW9uKGV4cG9ydHMsIG5hbWUsIGdldHRlcikge1xuIFx0XHRpZighX193ZWJwYWNrX3JlcXVpcmVfXy5vKGV4cG9ydHMsIG5hbWUpKSB7XG4gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIG5hbWUsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBnZXR0ZXIgfSk7XG4gXHRcdH1cbiBcdH07XG5cbiBcdC8vIGRlZmluZSBfX2VzTW9kdWxlIG9uIGV4cG9ydHNcbiBcdF9fd2VicGFja19yZXF1aXJlX18uciA9IGZ1bmN0aW9uKGV4cG9ydHMpIHtcbiBcdFx0aWYodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLnRvU3RyaW5nVGFnKSB7XG4gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFN5bWJvbC50b1N0cmluZ1RhZywgeyB2YWx1ZTogJ01vZHVsZScgfSk7XG4gXHRcdH1cbiBcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbiBcdH07XG5cbiBcdC8vIGNyZWF0ZSBhIGZha2UgbmFtZXNwYWNlIG9iamVjdFxuIFx0Ly8gbW9kZSAmIDE6IHZhbHVlIGlzIGEgbW9kdWxlIGlkLCByZXF1aXJlIGl0XG4gXHQvLyBtb2RlICYgMjogbWVyZ2UgYWxsIHByb3BlcnRpZXMgb2YgdmFsdWUgaW50byB0aGUgbnNcbiBcdC8vIG1vZGUgJiA0OiByZXR1cm4gdmFsdWUgd2hlbiBhbHJlYWR5IG5zIG9iamVjdFxuIFx0Ly8gbW9kZSAmIDh8MTogYmVoYXZlIGxpa2UgcmVxdWlyZVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy50ID0gZnVuY3Rpb24odmFsdWUsIG1vZGUpIHtcbiBcdFx0aWYobW9kZSAmIDEpIHZhbHVlID0gX193ZWJwYWNrX3JlcXVpcmVfXyh2YWx1ZSk7XG4gXHRcdGlmKG1vZGUgJiA4KSByZXR1cm4gdmFsdWU7XG4gXHRcdGlmKChtb2RlICYgNCkgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiB2YWx1ZSAmJiB2YWx1ZS5fX2VzTW9kdWxlKSByZXR1cm4gdmFsdWU7XG4gXHRcdHZhciBucyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gXHRcdF9fd2VicGFja19yZXF1aXJlX18ucihucyk7XG4gXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShucywgJ2RlZmF1bHQnLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2YWx1ZSB9KTtcbiBcdFx0aWYobW9kZSAmIDIgJiYgdHlwZW9mIHZhbHVlICE9ICdzdHJpbmcnKSBmb3IodmFyIGtleSBpbiB2YWx1ZSkgX193ZWJwYWNrX3JlcXVpcmVfXy5kKG5zLCBrZXksIGZ1bmN0aW9uKGtleSkgeyByZXR1cm4gdmFsdWVba2V5XTsgfS5iaW5kKG51bGwsIGtleSkpO1xuIFx0XHRyZXR1cm4gbnM7XG4gXHR9O1xuXG4gXHQvLyBnZXREZWZhdWx0RXhwb3J0IGZ1bmN0aW9uIGZvciBjb21wYXRpYmlsaXR5IHdpdGggbm9uLWhhcm1vbnkgbW9kdWxlc1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5uID0gZnVuY3Rpb24obW9kdWxlKSB7XG4gXHRcdHZhciBnZXR0ZXIgPSBtb2R1bGUgJiYgbW9kdWxlLl9fZXNNb2R1bGUgP1xuIFx0XHRcdGZ1bmN0aW9uIGdldERlZmF1bHQoKSB7IHJldHVybiBtb2R1bGVbJ2RlZmF1bHQnXTsgfSA6XG4gXHRcdFx0ZnVuY3Rpb24gZ2V0TW9kdWxlRXhwb3J0cygpIHsgcmV0dXJuIG1vZHVsZTsgfTtcbiBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kKGdldHRlciwgJ2EnLCBnZXR0ZXIpO1xuIFx0XHRyZXR1cm4gZ2V0dGVyO1xuIFx0fTtcblxuIFx0Ly8gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm8gPSBmdW5jdGlvbihvYmplY3QsIHByb3BlcnR5KSB7IHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSk7IH07XG5cbiBcdC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBcIlwiO1xuXG5cbiBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuIFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18oX193ZWJwYWNrX3JlcXVpcmVfXy5zID0gXCIuL3NyYy9pbmRleC5qc1wiKTtcbiIsIjx0ZW1wbGF0ZT5cbiAgPGRpdiBjbGFzcz1cIm1haW5cIj5cblxuICAgICAgPGRpdiBjbGFzcz1cInRvZG8tYXBwXCI+XG5cbiAgICAgICAgPGRpdiBjbGFzcz1cImNoZWxpay1pbnB1dFwiPlxuICAgICAgICAgICA8ZGl2PlxuICAgICAgICAgICAgICAgINCk0LDQvNC40LvQuNGPINGH0LXQu9C40LrQsDogPGlucHV0IHYtbW9kZWw9XCJuYW1lU2Vjb25kXCI+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgIDxkaXY+XG4gICAgICAgICAgICAgICAg0JjQvNGPINGH0LXQu9C40LrQsDogPGlucHV0IHYtbW9kZWw9XCJuYW1lRmlyc3RcIj5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgPGRpdj5cbiAgICAgICAgICAgICAgICDQntGC0YfQtdGB0YLQstC+INGH0LXQu9C40LrQsDogPGlucHV0IHYtbW9kZWw9XCJuYW1lTGFzdFwiPlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICA8ZGl2PlxuICAgICAgICAgICAgICAgINCS0L7Qt9GA0LDRgdGCINGH0LXQu9C40LrQsDogPGlucHV0IHYtbW9kZWw9XCJhZ2VcIj5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICA8L2Rpdj5cblxuICAgICAgICA8YnV0dG9uIHYtb246Y2xpY2s9XCJhZGROZXdcIj7QlNC+0LHQsNCy0LjRgtGMPC9idXR0b24+XG4gICAgICAgIDxidXR0b24gdi1vbjpjbGljaz1cImNsZWFySW5wdXRcIj7QntGH0LjRgdC40YLRjCDQstCy0L7QtDwvYnV0dG9uPlxuXG4gICAgICAgIDxkaXYgdi1pZj1cInNob3dGcm9tTG9jYWxcIiBjbGFzcz1cImNoZWxpay10YWJsZVwiPlxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cImNoZWxpay1pbmZvX193cmFwXCI+XG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cImNoZWxpay1pbmZvX190aXRsZVwiPtCX0LDQv9C+0LzQvdC10L3QvjwvZGl2PlxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJjaGVsaWstaW5mb19fcHJvcGVydGllcy1saXN0XCI+XG4gICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJjaGVsaWstaW5mb19fcHJvcGVydGllcy1pbmRleFwiPtCd0L7QvNC10YA6PC9kaXY+XG4gICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJjaGVsaWstaW5mb19fcHJvcGVydGllcy1uYW1lXCI+0KTQmNCeOjwvZGl2PlxuICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwiY2hlbGlrLWluZm9fX3Byb3BlcnRpZXMtYWdlXCI+0JLQvtC30YDQsNGB0YI6PC9kaXY+XG4gICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJjaGVsaWstaW5mb19fcHJvcGVydGllcy1ibGFua1wiPjwvZGl2PlxuICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgIDxkcmFnZ2FibGUgdi1tb2RlbD1cInBlb3BsZXNcIiBncm91cD1cInBlb3BsZXNcIiB0YWc9XCJkaXZcIiBnaG9zdC1jbGFzcz1cIm1vdmluZy1pdGVtXCIgY2xhc3M9XCJjaGVsaWstaW5mb19fbGlzdFwiPlxuICAgICAgXG4gICAgICAgICAgICAgICAgICAgIDxkaXYgdi1mb3I9XCIoY2hlbGlrLGluZGV4KSBpbiBwZW9wbGVzXCIgOmtleT1cImNoZWxpay5uYW1lRmlyc3RcIiBjbGFzcz1cImNoZWxpay1pbmZvX19pdGVtXCI+XG4gICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwiY2hlbGlrLWluZm9fX2l0ZW0taW5kZXhcIj57eyBpbmRleCArIDEgfX08L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJjaGVsaWstaW5mb19faXRlbS1uYW1lXCI+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPHNwYW4gdi1pZj1cImNoZWxpay5uYW1lU2Vjb25kXCI+IHt7IGNoZWxpay5uYW1lU2Vjb25kIH19PC9zcGFuPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuIHYtaWY9XCJjaGVsaWsubmFtZUZpcnN0XCI+e3sgY2hlbGlrLm5hbWVGaXJzdCB9fTwvc3Bhbj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8c3BhbiB2LWlmPVwiY2hlbGlrLm5hbWVMYXN0XCI+IHt7IGNoZWxpay5uYW1lTGFzdCB9fTwvc3Bhbj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cImNoZWxpay1pbmZvX19pdGVtLWFnZVwiPjxzcGFuIHYtaWY9XCJjaGVsaWsuc2F2ZWRBZ2VcIj57eyBjaGVsaWsuc2F2ZWRBZ2UgfX08L3NwYW4+PC9kaXY+XG4gICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwiY2hlbGlrLWluZm9fX2l0ZW0tZGVsXCI+PGJ1dHRvbiB2LW9uOmNsaWNrPVwiZGVsZXRlQ2hlbGlrKGluZGV4KVwiPlg8L2J1dHRvbj48L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgPC9kcmFnZ2FibGU+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgIDxidXR0b24gdi1vbjpjbGljaz1cImNsZWFyTG9jYWxcIj7QntGH0LjRgdGC0LjRgtGMPC9idXR0b24+XG4gICAgICAgIDwvZGl2PlxuXG4gICAgICA8L2Rpdj5cblxuICA8L2Rpdj5cbjwvdGVtcGxhdGU+XG5cbjxzdHlsZSBsYW5nPVwic2Nzc1wiIHNyYz1cIi4vbWFpbi5zY3NzXCI+PC9zdHlsZT5cblxuPHNjcmlwdD5cbiAgICBpbXBvcnQgZHJhZ2dhYmxlIGZyb20gJ3Z1ZWRyYWdnYWJsZSdcblxuICAgIGV4cG9ydCBkZWZhdWx0IHtcbiAgICAgICAgbmFtZTogJ0FwcCcsXG4gICAgICAgIGRhdGEoKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIG5hbWVGaXJzdDogJycsXG4gICAgICAgICAgICAgICAgbmFtZVNlY29uZDogJycsXG4gICAgICAgICAgICAgICAgbmFtZUxhc3Q6ICcnLFxuICAgICAgICAgICAgICAgIGFnZTogJycsXG5cbiAgICAgICAgICAgICAgICBwZW9wbGVzOiBbXSxcbiAgICAgICAgICAgICAgICBzaG93RnJvbUxvY2FsOiBmYWxzZSxcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgd2F0Y2g6IHtcbiAgICAgICAgfSxcbiAgICAgICAgbW91bnRlZDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKGxvY2FsU3RvcmFnZS5hZ2UpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNhdmVkQWdlID0gbG9jYWxTdG9yYWdlLmFnZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChsb2NhbFN0b3JhZ2UucGVvcGxlc0xvY2FsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wZW9wbGVzID0gSlNPTi5wYXJzZShsb2NhbFN0b3JhZ2UucGVvcGxlc0xvY2FsKTtcbiAgICAgICAgICAgICAgICB0aGlzLnNob3dGcm9tTG9jYWwgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBjb21wb25lbnRzOiB7XG4gICAgICAgICAgICBkcmFnZ2FibGUsXG4gICAgICAgIH0sXG4gICAgICAgIG1ldGhvZHM6IHtcbiAgICAgICAgICAgIGFkZE5ldygpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnBlb3BsZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIG5hbWVGaXJzdDogdGhpcy5uYW1lRmlyc3QsXG4gICAgICAgICAgICAgICAgICAgIG5hbWVTZWNvbmQ6IHRoaXMubmFtZVNlY29uZCxcbiAgICAgICAgICAgICAgICAgICAgbmFtZUxhc3Q6IHRoaXMubmFtZUxhc3QsXG4gICAgICAgICAgICAgICAgICAgIHNhdmVkQWdlOiB0aGlzLmFnZVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHRoaXMuc2hvd0Zyb21Mb2NhbCA9IHRydWU7XG5cbiAgICAgICAgICAgICAgICBsb2NhbFN0b3JhZ2UucGVvcGxlc0xvY2FsID0gSlNPTi5zdHJpbmdpZnkodGhpcy5wZW9wbGVzKTtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhsb2NhbFN0b3JhZ2UucGVvcGxlc0xvY2FsKTtcbiAgICAgICAgICAgICAgICAvL0pTT04ucGFyc2UobG9jYWxTdG9yYWdlLnBlb3BsZXNMb2NhbClcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjbGVhckxvY2FsKCkge1xuICAgICAgICAgICAgICAgIHRoaXMucGVvcGxlcyA9IFtdO1xuICAgICAgICAgICAgICAgIGxvY2FsU3RvcmFnZS5jbGVhcigpO1xuICAgICAgICAgICAgICAgIHRoaXMuc2hvd0Zyb21Mb2NhbCA9IGZhbHNlO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNsZWFySW5wdXQoKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5uYW1lRmlyc3QgPSB0aGlzLm5hbWVTZWNvbmQgPSB0aGlzLm5hbWVMYXN0ID0gdGhpcy5hZ2UgPSAnJztcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBkZWxldGVDaGVsaWsoaW5kZXgpIHsgICAgICBcblx0ICAgICAgICAgICAgdGhpcy5wZW9wbGVzLnNwbGljZShpbmRleCwgMSk7XG5cdCAgICAgICAgICAgIGNvbnNvbGUubG9nKHRoaXMucGVvcGxlcyk7XG5cdCAgICAgICAgICAgIGNvbnNvbGUubG9nKGluZGV4KTtcbiAgICAgICAgICAgICAgICBsb2NhbFN0b3JhZ2UucGVvcGxlc0xvY2FsID0gSlNPTi5zdHJpbmdpZnkodGhpcy5wZW9wbGVzKTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5wZW9wbGVzLmxlbmd0aCA9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2xlYXJMb2NhbCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgY3JlYXRlZCgpIHtcbiAgICAgICAgfVxuICAgIH1cbjwvc2NyaXB0PiIsIi8vIEltcG9ydHNcbnZhciBfX19DU1NfTE9BREVSX0FQSV9JTVBPUlRfX18gPSByZXF1aXJlKFwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9ydW50aW1lL2FwaS5qc1wiKTtcbmV4cG9ydHMgPSBfX19DU1NfTE9BREVSX0FQSV9JTVBPUlRfX18oZmFsc2UpO1xuZXhwb3J0cy5wdXNoKFttb2R1bGUuaWQsIFwiQGltcG9ydCB1cmwoaHR0cHM6Ly9mb250cy5nb29nbGVhcGlzLmNvbS9jc3MyP2ZhbWlseT1Tb3VyY2UrU2FucytQcm86d2dodEAyMDAmZGlzcGxheT1zd2FwKTtcIl0pO1xuLy8gTW9kdWxlXG5leHBvcnRzLnB1c2goW21vZHVsZS5pZCwgXCJib2R5IHtcXG4gIGZvbnQtZmFtaWx5OiAnU291cmNlIFNhbnMgUHJvJywgc2Fucy1zZXJpZjtcXG59XFxuLm1haW4ge1xcbiAgaGVpZ2h0OiAxMDB2aDtcXG4gIGRpc3BsYXk6IGZsZXg7XFxuICBhbGlnbi1pdGVtczogY2VudGVyO1xcbiAgYmFja2dyb3VuZC1jb2xvcjogYWxpY2VibHVlO1xcbn1cXG4udG9kby1hcHAge1xcbiAgbWF4LXdpZHRoOiA2MDBweDtcXG4gIHdpZHRoOiAxMDAlO1xcbiAgbWFyZ2luOiAwIGF1dG87XFxuICB0ZXh0LWFsaWduOiBjZW50ZXI7XFxuICBiYWNrZ3JvdW5kOiAjZDdlNWZmO1xcbiAgYm9yZGVyLXJhZGl1czogOHB4O1xcbiAgcGFkZGluZzogMTBweDtcXG4gIGJvcmRlcjogMXB4IHNvbGlkICNhMGEwYTA7XFxufVxcbi5jaGVsaWstaW5wdXQgZGl2IHtcXG4gIGRpc3BsYXk6IGZsZXg7XFxuICBmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xcbiAgZmxleC13cmFwOiB3cmFwO1xcbiAgYWxpZ24taXRlbXM6IGZsZXgtc3RhcnQ7XFxuICBtYXgtd2lkdGg6IDM4MHB4O1xcbiAgbWFyZ2luOiAwIGF1dG8gMTZweDtcXG59XFxuLmNoZWxpay1pbnB1dCBpbnB1dCB7XFxuICB3aWR0aDogLXdlYmtpdC1maWxsLWF2YWlsYWJsZTtcXG59XFxuLm1vdmluZy1pdGVtIHtcXG4gIG9wYWNpdHk6IDAuNTtcXG4gIGJhY2tncm91bmQ6ICMwMDA7XFxuICBib3JkZXI6IDFweCBzb2xpZCAjNDI5OWUxO1xcbn1cXG4uY2hlbGlrLWluZm9fX3dyYXAge1xcbiAgZGlzcGxheTogZmxleDtcXG4gIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XFxuICBiYWNrZ3JvdW5kOiBhbGljZWJsdWU7XFxuICBib3JkZXI6IDFweCBzb2xpZCAjYTBhMGEwO1xcbiAgYm9yZGVyLXJhZGl1czogMTBweDtcXG4gIG1hcmdpbjogMzJweCAwO1xcbn1cXG4uY2hlbGlrLWluZm9fX3RpdGxlIHtcXG4gIHdpZHRoOiAxMDAlO1xcbiAgYm9yZGVyLWJvdHRvbTogMXB4IHNvbGlkICNhMGEwYTA7XFxuICBoZWlnaHQ6IDMycHg7XFxuICBsaW5lLWhlaWdodDogMzBweDtcXG59XFxuLmNoZWxpay1pbmZvX19wcm9wZXJ0aWVzLWxpc3Qge1xcbiAgZGlzcGxheTogZmxleDtcXG4gIGhlaWdodDogMzBweDtcXG4gIGxpbmUtaGVpZ2h0OiAzMHB4O1xcbiAganVzdGlmeS1jb250ZW50OiBmbGV4LXN0YXJ0O1xcbiAgYWxpZ24taXRlbXM6IGNlbnRlcjtcXG59XFxuLmNoZWxpay1pbmZvX19wcm9wZXJ0aWVzLWluZGV4IHtcXG4gIHdpZHRoOiAyMCU7XFxuICBib3JkZXItcmlnaHQ6IDFweCBzb2xpZCAjYTBhMGEwO1xcbn1cXG4uY2hlbGlrLWluZm9fX3Byb3BlcnRpZXMtbmFtZSB7XFxuICB3aWR0aDogNDUlO1xcbiAgYm9yZGVyLXJpZ2h0OiAxcHggc29saWQgI2EwYTBhMDtcXG59XFxuLmNoZWxpay1pbmZvX19wcm9wZXJ0aWVzLWFnZSB7XFxuICB3aWR0aDogMjQlO1xcbiAgYm9yZGVyLXJpZ2h0OiAxcHggc29saWQgI2EwYTBhMDtcXG59XFxuLmNoZWxpay1pbmZvX19wcm9wZXJ0aWVzLWJsYW5rIHtcXG4gIHdpZHRoOiAxMSU7XFxufVxcbi5jaGVsaWstaW5mb19fbGlzdCB7XFxuICBkaXNwbGF5OiBmbGV4O1xcbiAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcXG4gIGxpbmUtaGVpZ2h0OiAzMHB4O1xcbn1cXG4uY2hlbGlrLWluZm9fX2l0ZW0ge1xcbiAgZGlzcGxheTogZmxleDtcXG4gIGp1c3RpZnktY29udGVudDogZmxleC1zdGFydDtcXG4gIGJvcmRlci10b3A6IDFweCBzb2xpZCAjYTBhMGEwO1xcbiAgbWluLWhlaWdodDogMzJweDtcXG59XFxuLmNoZWxpay1pbmZvX19pdGVtLWluZGV4IHtcXG4gIHdpZHRoOiAyMCU7XFxuICBib3JkZXItcmlnaHQ6IDFweCBzb2xpZCAjYTBhMGEwO1xcbn1cXG4uY2hlbGlrLWluZm9fX2l0ZW0tbmFtZSB7XFxuICB3aWR0aDogNDUlO1xcbiAgYm9yZGVyLXJpZ2h0OiAxcHggc29saWQgI2EwYTBhMDtcXG59XFxuLmNoZWxpay1pbmZvX19pdGVtLWFnZSB7XFxuICB3aWR0aDogMjQlO1xcbiAgYm9yZGVyLXJpZ2h0OiAxcHggc29saWQgI2EwYTBhMDtcXG59XFxuLmNoZWxpay1pbmZvX19pdGVtLWRlbCB7XFxuICB3aWR0aDogMTElO1xcbn1cXG4uY2hlbGlrLWluZm9fX2l0ZW0taW5kZXgsIC5jaGVsaWstaW5mb19faXRlbS1hZ2UsIC5jaGVsaWstaW5mb19faXRlbS1kZWwge1xcbiAgZGlzcGxheTogZmxleDtcXG4gIGp1c3RpZnktY29udGVudDogY2VudGVyO1xcbiAgYWxpZ24taXRlbXM6IGNlbnRlcjtcXG59XFxuYnV0dG9uIHtcXG4gIG1hcmdpbjogMHB4IGF1dG87XFxufVxcblwiLCBcIlwiXSk7XG4vLyBFeHBvcnRzXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHM7XG4iLCJcInVzZSBzdHJpY3RcIjtcblxuLypcbiAgTUlUIExpY2Vuc2UgaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHBcbiAgQXV0aG9yIFRvYmlhcyBLb3BwZXJzIEBzb2tyYVxuKi9cbi8vIGNzcyBiYXNlIGNvZGUsIGluamVjdGVkIGJ5IHRoZSBjc3MtbG9hZGVyXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZnVuYy1uYW1lc1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAodXNlU291cmNlTWFwKSB7XG4gIHZhciBsaXN0ID0gW107IC8vIHJldHVybiB0aGUgbGlzdCBvZiBtb2R1bGVzIGFzIGNzcyBzdHJpbmdcblxuICBsaXN0LnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMubWFwKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICB2YXIgY29udGVudCA9IGNzc1dpdGhNYXBwaW5nVG9TdHJpbmcoaXRlbSwgdXNlU291cmNlTWFwKTtcblxuICAgICAgaWYgKGl0ZW1bMl0pIHtcbiAgICAgICAgcmV0dXJuIFwiQG1lZGlhIFwiLmNvbmNhdChpdGVtWzJdLCBcIiB7XCIpLmNvbmNhdChjb250ZW50LCBcIn1cIik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBjb250ZW50O1xuICAgIH0pLmpvaW4oJycpO1xuICB9OyAvLyBpbXBvcnQgYSBsaXN0IG9mIG1vZHVsZXMgaW50byB0aGUgbGlzdFxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZnVuYy1uYW1lc1xuXG5cbiAgbGlzdC5pID0gZnVuY3Rpb24gKG1vZHVsZXMsIG1lZGlhUXVlcnksIGRlZHVwZSkge1xuICAgIGlmICh0eXBlb2YgbW9kdWxlcyA9PT0gJ3N0cmluZycpIHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICAgICAgbW9kdWxlcyA9IFtbbnVsbCwgbW9kdWxlcywgJyddXTtcbiAgICB9XG5cbiAgICB2YXIgYWxyZWFkeUltcG9ydGVkTW9kdWxlcyA9IHt9O1xuXG4gICAgaWYgKGRlZHVwZSkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBwcmVmZXItZGVzdHJ1Y3R1cmluZ1xuICAgICAgICB2YXIgaWQgPSB0aGlzW2ldWzBdO1xuXG4gICAgICAgIGlmIChpZCAhPSBudWxsKSB7XG4gICAgICAgICAgYWxyZWFkeUltcG9ydGVkTW9kdWxlc1tpZF0gPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IG1vZHVsZXMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICB2YXIgaXRlbSA9IFtdLmNvbmNhdChtb2R1bGVzW19pXSk7XG5cbiAgICAgIGlmIChkZWR1cGUgJiYgYWxyZWFkeUltcG9ydGVkTW9kdWxlc1tpdGVtWzBdXSkge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29udGludWVcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGlmIChtZWRpYVF1ZXJ5KSB7XG4gICAgICAgIGlmICghaXRlbVsyXSkge1xuICAgICAgICAgIGl0ZW1bMl0gPSBtZWRpYVF1ZXJ5O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGl0ZW1bMl0gPSBcIlwiLmNvbmNhdChtZWRpYVF1ZXJ5LCBcIiBhbmQgXCIpLmNvbmNhdChpdGVtWzJdKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBsaXN0LnB1c2goaXRlbSk7XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiBsaXN0O1xufTtcblxuZnVuY3Rpb24gY3NzV2l0aE1hcHBpbmdUb1N0cmluZyhpdGVtLCB1c2VTb3VyY2VNYXApIHtcbiAgdmFyIGNvbnRlbnQgPSBpdGVtWzFdIHx8ICcnOyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcHJlZmVyLWRlc3RydWN0dXJpbmdcblxuICB2YXIgY3NzTWFwcGluZyA9IGl0ZW1bM107XG5cbiAgaWYgKCFjc3NNYXBwaW5nKSB7XG4gICAgcmV0dXJuIGNvbnRlbnQ7XG4gIH1cblxuICBpZiAodXNlU291cmNlTWFwICYmIHR5cGVvZiBidG9hID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdmFyIHNvdXJjZU1hcHBpbmcgPSB0b0NvbW1lbnQoY3NzTWFwcGluZyk7XG4gICAgdmFyIHNvdXJjZVVSTHMgPSBjc3NNYXBwaW5nLnNvdXJjZXMubWFwKGZ1bmN0aW9uIChzb3VyY2UpIHtcbiAgICAgIHJldHVybiBcIi8qIyBzb3VyY2VVUkw9XCIuY29uY2F0KGNzc01hcHBpbmcuc291cmNlUm9vdCB8fCAnJykuY29uY2F0KHNvdXJjZSwgXCIgKi9cIik7XG4gICAgfSk7XG4gICAgcmV0dXJuIFtjb250ZW50XS5jb25jYXQoc291cmNlVVJMcykuY29uY2F0KFtzb3VyY2VNYXBwaW5nXSkuam9pbignXFxuJyk7XG4gIH1cblxuICByZXR1cm4gW2NvbnRlbnRdLmpvaW4oJ1xcbicpO1xufSAvLyBBZGFwdGVkIGZyb20gY29udmVydC1zb3VyY2UtbWFwIChNSVQpXG5cblxuZnVuY3Rpb24gdG9Db21tZW50KHNvdXJjZU1hcCkge1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW5kZWZcbiAgdmFyIGJhc2U2NCA9IGJ0b2EodW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KEpTT04uc3RyaW5naWZ5KHNvdXJjZU1hcCkpKSk7XG4gIHZhciBkYXRhID0gXCJzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtjaGFyc2V0PXV0Zi04O2Jhc2U2NCxcIi5jb25jYXQoYmFzZTY0KTtcbiAgcmV0dXJuIFwiLyojIFwiLmNvbmNhdChkYXRhLCBcIiAqL1wiKTtcbn0iLCIvLyBzaGltIGZvciB1c2luZyBwcm9jZXNzIGluIGJyb3dzZXJcbnZhciBwcm9jZXNzID0gbW9kdWxlLmV4cG9ydHMgPSB7fTtcblxuLy8gY2FjaGVkIGZyb20gd2hhdGV2ZXIgZ2xvYmFsIGlzIHByZXNlbnQgc28gdGhhdCB0ZXN0IHJ1bm5lcnMgdGhhdCBzdHViIGl0XG4vLyBkb24ndCBicmVhayB0aGluZ3MuICBCdXQgd2UgbmVlZCB0byB3cmFwIGl0IGluIGEgdHJ5IGNhdGNoIGluIGNhc2UgaXQgaXNcbi8vIHdyYXBwZWQgaW4gc3RyaWN0IG1vZGUgY29kZSB3aGljaCBkb2Vzbid0IGRlZmluZSBhbnkgZ2xvYmFscy4gIEl0J3MgaW5zaWRlIGFcbi8vIGZ1bmN0aW9uIGJlY2F1c2UgdHJ5L2NhdGNoZXMgZGVvcHRpbWl6ZSBpbiBjZXJ0YWluIGVuZ2luZXMuXG5cbnZhciBjYWNoZWRTZXRUaW1lb3V0O1xudmFyIGNhY2hlZENsZWFyVGltZW91dDtcblxuZnVuY3Rpb24gZGVmYXVsdFNldFRpbW91dCgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3NldFRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcbn1cbmZ1bmN0aW9uIGRlZmF1bHRDbGVhclRpbWVvdXQgKCkge1xuICAgIHRocm93IG5ldyBFcnJvcignY2xlYXJUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG4oZnVuY3Rpb24gKCkge1xuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2Ygc2V0VGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2YgY2xlYXJUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xuICAgIH1cbn0gKCkpXG5mdW5jdGlvbiBydW5UaW1lb3V0KGZ1bikge1xuICAgIGlmIChjYWNoZWRTZXRUaW1lb3V0ID09PSBzZXRUaW1lb3V0KSB7XG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICAgIH1cbiAgICAvLyBpZiBzZXRUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuICAgIGlmICgoY2FjaGVkU2V0VGltZW91dCA9PT0gZGVmYXVsdFNldFRpbW91dCB8fCAhY2FjaGVkU2V0VGltZW91dCkgJiYgc2V0VGltZW91dCkge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dChmdW4sIDApO1xuICAgIH0gY2F0Y2goZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwobnVsbCwgZnVuLCAwKTtcbiAgICAgICAgfSBjYXRjaChlKXtcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yXG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKHRoaXMsIGZ1biwgMCk7XG4gICAgICAgIH1cbiAgICB9XG5cblxufVxuZnVuY3Rpb24gcnVuQ2xlYXJUaW1lb3V0KG1hcmtlcikge1xuICAgIGlmIChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGNsZWFyVGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH1cbiAgICAvLyBpZiBjbGVhclRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG4gICAgaWYgKChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGRlZmF1bHRDbGVhclRpbWVvdXQgfHwgIWNhY2hlZENsZWFyVGltZW91dCkgJiYgY2xlYXJUaW1lb3V0KSB7XG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCAgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbChudWxsLCBtYXJrZXIpO1xuICAgICAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yLlxuICAgICAgICAgICAgLy8gU29tZSB2ZXJzaW9ucyBvZiBJLkUuIGhhdmUgZGlmZmVyZW50IHJ1bGVzIGZvciBjbGVhclRpbWVvdXQgdnMgc2V0VGltZW91dFxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKHRoaXMsIG1hcmtlcik7XG4gICAgICAgIH1cbiAgICB9XG5cblxuXG59XG52YXIgcXVldWUgPSBbXTtcbnZhciBkcmFpbmluZyA9IGZhbHNlO1xudmFyIGN1cnJlbnRRdWV1ZTtcbnZhciBxdWV1ZUluZGV4ID0gLTE7XG5cbmZ1bmN0aW9uIGNsZWFuVXBOZXh0VGljaygpIHtcbiAgICBpZiAoIWRyYWluaW5nIHx8ICFjdXJyZW50UXVldWUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIGlmIChjdXJyZW50UXVldWUubGVuZ3RoKSB7XG4gICAgICAgIHF1ZXVlID0gY3VycmVudFF1ZXVlLmNvbmNhdChxdWV1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgIH1cbiAgICBpZiAocXVldWUubGVuZ3RoKSB7XG4gICAgICAgIGRyYWluUXVldWUoKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGRyYWluUXVldWUoKSB7XG4gICAgaWYgKGRyYWluaW5nKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIHRpbWVvdXQgPSBydW5UaW1lb3V0KGNsZWFuVXBOZXh0VGljayk7XG4gICAgZHJhaW5pbmcgPSB0cnVlO1xuXG4gICAgdmFyIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB3aGlsZShsZW4pIHtcbiAgICAgICAgY3VycmVudFF1ZXVlID0gcXVldWU7XG4gICAgICAgIHF1ZXVlID0gW107XG4gICAgICAgIHdoaWxlICgrK3F1ZXVlSW5kZXggPCBsZW4pIHtcbiAgICAgICAgICAgIGlmIChjdXJyZW50UXVldWUpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50UXVldWVbcXVldWVJbmRleF0ucnVuKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgICAgICBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgfVxuICAgIGN1cnJlbnRRdWV1ZSA9IG51bGw7XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBydW5DbGVhclRpbWVvdXQodGltZW91dCk7XG59XG5cbnByb2Nlc3MubmV4dFRpY2sgPSBmdW5jdGlvbiAoZnVuKSB7XG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCAtIDEpO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgYXJnc1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcXVldWUucHVzaChuZXcgSXRlbShmdW4sIGFyZ3MpKTtcbiAgICBpZiAocXVldWUubGVuZ3RoID09PSAxICYmICFkcmFpbmluZykge1xuICAgICAgICBydW5UaW1lb3V0KGRyYWluUXVldWUpO1xuICAgIH1cbn07XG5cbi8vIHY4IGxpa2VzIHByZWRpY3RpYmxlIG9iamVjdHNcbmZ1bmN0aW9uIEl0ZW0oZnVuLCBhcnJheSkge1xuICAgIHRoaXMuZnVuID0gZnVuO1xuICAgIHRoaXMuYXJyYXkgPSBhcnJheTtcbn1cbkl0ZW0ucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmZ1bi5hcHBseShudWxsLCB0aGlzLmFycmF5KTtcbn07XG5wcm9jZXNzLnRpdGxlID0gJ2Jyb3dzZXInO1xucHJvY2Vzcy5icm93c2VyID0gdHJ1ZTtcbnByb2Nlc3MuZW52ID0ge307XG5wcm9jZXNzLmFyZ3YgPSBbXTtcbnByb2Nlc3MudmVyc2lvbiA9ICcnOyAvLyBlbXB0eSBzdHJpbmcgdG8gYXZvaWQgcmVnZXhwIGlzc3Vlc1xucHJvY2Vzcy52ZXJzaW9ucyA9IHt9O1xuXG5mdW5jdGlvbiBub29wKCkge31cblxucHJvY2Vzcy5vbiA9IG5vb3A7XG5wcm9jZXNzLmFkZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3Mub25jZSA9IG5vb3A7XG5wcm9jZXNzLm9mZiA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUxpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlQWxsTGlzdGVuZXJzID0gbm9vcDtcbnByb2Nlc3MuZW1pdCA9IG5vb3A7XG5wcm9jZXNzLnByZXBlbmRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnByZXBlbmRPbmNlTGlzdGVuZXIgPSBub29wO1xuXG5wcm9jZXNzLmxpc3RlbmVycyA9IGZ1bmN0aW9uIChuYW1lKSB7IHJldHVybiBbXSB9XG5cbnByb2Nlc3MuYmluZGluZyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmJpbmRpbmcgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcblxucHJvY2Vzcy5jd2QgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAnLycgfTtcbnByb2Nlc3MuY2hkaXIgPSBmdW5jdGlvbiAoZGlyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmNoZGlyIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5wcm9jZXNzLnVtYXNrID0gZnVuY3Rpb24oKSB7IHJldHVybiAwOyB9O1xuIiwiKGZ1bmN0aW9uIChnbG9iYWwsIHVuZGVmaW5lZCkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgaWYgKGdsb2JhbC5zZXRJbW1lZGlhdGUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBuZXh0SGFuZGxlID0gMTsgLy8gU3BlYyBzYXlzIGdyZWF0ZXIgdGhhbiB6ZXJvXG4gICAgdmFyIHRhc2tzQnlIYW5kbGUgPSB7fTtcbiAgICB2YXIgY3VycmVudGx5UnVubmluZ0FUYXNrID0gZmFsc2U7XG4gICAgdmFyIGRvYyA9IGdsb2JhbC5kb2N1bWVudDtcbiAgICB2YXIgcmVnaXN0ZXJJbW1lZGlhdGU7XG5cbiAgICBmdW5jdGlvbiBzZXRJbW1lZGlhdGUoY2FsbGJhY2spIHtcbiAgICAgIC8vIENhbGxiYWNrIGNhbiBlaXRoZXIgYmUgYSBmdW5jdGlvbiBvciBhIHN0cmluZ1xuICAgICAgaWYgKHR5cGVvZiBjYWxsYmFjayAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIGNhbGxiYWNrID0gbmV3IEZ1bmN0aW9uKFwiXCIgKyBjYWxsYmFjayk7XG4gICAgICB9XG4gICAgICAvLyBDb3B5IGZ1bmN0aW9uIGFyZ3VtZW50c1xuICAgICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCAtIDEpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgYXJnc1tpXSA9IGFyZ3VtZW50c1tpICsgMV07XG4gICAgICB9XG4gICAgICAvLyBTdG9yZSBhbmQgcmVnaXN0ZXIgdGhlIHRhc2tcbiAgICAgIHZhciB0YXNrID0geyBjYWxsYmFjazogY2FsbGJhY2ssIGFyZ3M6IGFyZ3MgfTtcbiAgICAgIHRhc2tzQnlIYW5kbGVbbmV4dEhhbmRsZV0gPSB0YXNrO1xuICAgICAgcmVnaXN0ZXJJbW1lZGlhdGUobmV4dEhhbmRsZSk7XG4gICAgICByZXR1cm4gbmV4dEhhbmRsZSsrO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNsZWFySW1tZWRpYXRlKGhhbmRsZSkge1xuICAgICAgICBkZWxldGUgdGFza3NCeUhhbmRsZVtoYW5kbGVdO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJ1bih0YXNrKSB7XG4gICAgICAgIHZhciBjYWxsYmFjayA9IHRhc2suY2FsbGJhY2s7XG4gICAgICAgIHZhciBhcmdzID0gdGFzay5hcmdzO1xuICAgICAgICBzd2l0Y2ggKGFyZ3MubGVuZ3RoKSB7XG4gICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgY2FsbGJhY2soYXJnc1swXSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgY2FsbGJhY2soYXJnc1swXSwgYXJnc1sxXSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgY2FsbGJhY2soYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGNhbGxiYWNrLmFwcGx5KHVuZGVmaW5lZCwgYXJncyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJ1bklmUHJlc2VudChoYW5kbGUpIHtcbiAgICAgICAgLy8gRnJvbSB0aGUgc3BlYzogXCJXYWl0IHVudGlsIGFueSBpbnZvY2F0aW9ucyBvZiB0aGlzIGFsZ29yaXRobSBzdGFydGVkIGJlZm9yZSB0aGlzIG9uZSBoYXZlIGNvbXBsZXRlZC5cIlxuICAgICAgICAvLyBTbyBpZiB3ZSdyZSBjdXJyZW50bHkgcnVubmluZyBhIHRhc2ssIHdlJ2xsIG5lZWQgdG8gZGVsYXkgdGhpcyBpbnZvY2F0aW9uLlxuICAgICAgICBpZiAoY3VycmVudGx5UnVubmluZ0FUYXNrKSB7XG4gICAgICAgICAgICAvLyBEZWxheSBieSBkb2luZyBhIHNldFRpbWVvdXQuIHNldEltbWVkaWF0ZSB3YXMgdHJpZWQgaW5zdGVhZCwgYnV0IGluIEZpcmVmb3ggNyBpdCBnZW5lcmF0ZWQgYVxuICAgICAgICAgICAgLy8gXCJ0b28gbXVjaCByZWN1cnNpb25cIiBlcnJvci5cbiAgICAgICAgICAgIHNldFRpbWVvdXQocnVuSWZQcmVzZW50LCAwLCBoYW5kbGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIHRhc2sgPSB0YXNrc0J5SGFuZGxlW2hhbmRsZV07XG4gICAgICAgICAgICBpZiAodGFzaykge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRseVJ1bm5pbmdBVGFzayA9IHRydWU7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgcnVuKHRhc2spO1xuICAgICAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgICAgICAgIGNsZWFySW1tZWRpYXRlKGhhbmRsZSk7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRseVJ1bm5pbmdBVGFzayA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGluc3RhbGxOZXh0VGlja0ltcGxlbWVudGF0aW9uKCkge1xuICAgICAgICByZWdpc3RlckltbWVkaWF0ZSA9IGZ1bmN0aW9uKGhhbmRsZSkge1xuICAgICAgICAgICAgcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbiAoKSB7IHJ1bklmUHJlc2VudChoYW5kbGUpOyB9KTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjYW5Vc2VQb3N0TWVzc2FnZSgpIHtcbiAgICAgICAgLy8gVGhlIHRlc3QgYWdhaW5zdCBgaW1wb3J0U2NyaXB0c2AgcHJldmVudHMgdGhpcyBpbXBsZW1lbnRhdGlvbiBmcm9tIGJlaW5nIGluc3RhbGxlZCBpbnNpZGUgYSB3ZWIgd29ya2VyLFxuICAgICAgICAvLyB3aGVyZSBgZ2xvYmFsLnBvc3RNZXNzYWdlYCBtZWFucyBzb21ldGhpbmcgY29tcGxldGVseSBkaWZmZXJlbnQgYW5kIGNhbid0IGJlIHVzZWQgZm9yIHRoaXMgcHVycG9zZS5cbiAgICAgICAgaWYgKGdsb2JhbC5wb3N0TWVzc2FnZSAmJiAhZ2xvYmFsLmltcG9ydFNjcmlwdHMpIHtcbiAgICAgICAgICAgIHZhciBwb3N0TWVzc2FnZUlzQXN5bmNocm9ub3VzID0gdHJ1ZTtcbiAgICAgICAgICAgIHZhciBvbGRPbk1lc3NhZ2UgPSBnbG9iYWwub25tZXNzYWdlO1xuICAgICAgICAgICAgZ2xvYmFsLm9ubWVzc2FnZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHBvc3RNZXNzYWdlSXNBc3luY2hyb25vdXMgPSBmYWxzZTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBnbG9iYWwucG9zdE1lc3NhZ2UoXCJcIiwgXCIqXCIpO1xuICAgICAgICAgICAgZ2xvYmFsLm9ubWVzc2FnZSA9IG9sZE9uTWVzc2FnZTtcbiAgICAgICAgICAgIHJldHVybiBwb3N0TWVzc2FnZUlzQXN5bmNocm9ub3VzO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5zdGFsbFBvc3RNZXNzYWdlSW1wbGVtZW50YXRpb24oKSB7XG4gICAgICAgIC8vIEluc3RhbGxzIGFuIGV2ZW50IGhhbmRsZXIgb24gYGdsb2JhbGAgZm9yIHRoZSBgbWVzc2FnZWAgZXZlbnQ6IHNlZVxuICAgICAgICAvLyAqIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL0RPTS93aW5kb3cucG9zdE1lc3NhZ2VcbiAgICAgICAgLy8gKiBodHRwOi8vd3d3LndoYXR3Zy5vcmcvc3BlY3Mvd2ViLWFwcHMvY3VycmVudC13b3JrL211bHRpcGFnZS9jb21tcy5odG1sI2Nyb3NzRG9jdW1lbnRNZXNzYWdlc1xuXG4gICAgICAgIHZhciBtZXNzYWdlUHJlZml4ID0gXCJzZXRJbW1lZGlhdGUkXCIgKyBNYXRoLnJhbmRvbSgpICsgXCIkXCI7XG4gICAgICAgIHZhciBvbkdsb2JhbE1lc3NhZ2UgPSBmdW5jdGlvbihldmVudCkge1xuICAgICAgICAgICAgaWYgKGV2ZW50LnNvdXJjZSA9PT0gZ2xvYmFsICYmXG4gICAgICAgICAgICAgICAgdHlwZW9mIGV2ZW50LmRhdGEgPT09IFwic3RyaW5nXCIgJiZcbiAgICAgICAgICAgICAgICBldmVudC5kYXRhLmluZGV4T2YobWVzc2FnZVByZWZpeCkgPT09IDApIHtcbiAgICAgICAgICAgICAgICBydW5JZlByZXNlbnQoK2V2ZW50LmRhdGEuc2xpY2UobWVzc2FnZVByZWZpeC5sZW5ndGgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICBpZiAoZ2xvYmFsLmFkZEV2ZW50TGlzdGVuZXIpIHtcbiAgICAgICAgICAgIGdsb2JhbC5hZGRFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLCBvbkdsb2JhbE1lc3NhZ2UsIGZhbHNlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGdsb2JhbC5hdHRhY2hFdmVudChcIm9ubWVzc2FnZVwiLCBvbkdsb2JhbE1lc3NhZ2UpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVnaXN0ZXJJbW1lZGlhdGUgPSBmdW5jdGlvbihoYW5kbGUpIHtcbiAgICAgICAgICAgIGdsb2JhbC5wb3N0TWVzc2FnZShtZXNzYWdlUHJlZml4ICsgaGFuZGxlLCBcIipcIik7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5zdGFsbE1lc3NhZ2VDaGFubmVsSW1wbGVtZW50YXRpb24oKSB7XG4gICAgICAgIHZhciBjaGFubmVsID0gbmV3IE1lc3NhZ2VDaGFubmVsKCk7XG4gICAgICAgIGNoYW5uZWwucG9ydDEub25tZXNzYWdlID0gZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgICAgIHZhciBoYW5kbGUgPSBldmVudC5kYXRhO1xuICAgICAgICAgICAgcnVuSWZQcmVzZW50KGhhbmRsZSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgcmVnaXN0ZXJJbW1lZGlhdGUgPSBmdW5jdGlvbihoYW5kbGUpIHtcbiAgICAgICAgICAgIGNoYW5uZWwucG9ydDIucG9zdE1lc3NhZ2UoaGFuZGxlKTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbnN0YWxsUmVhZHlTdGF0ZUNoYW5nZUltcGxlbWVudGF0aW9uKCkge1xuICAgICAgICB2YXIgaHRtbCA9IGRvYy5kb2N1bWVudEVsZW1lbnQ7XG4gICAgICAgIHJlZ2lzdGVySW1tZWRpYXRlID0gZnVuY3Rpb24oaGFuZGxlKSB7XG4gICAgICAgICAgICAvLyBDcmVhdGUgYSA8c2NyaXB0PiBlbGVtZW50OyBpdHMgcmVhZHlzdGF0ZWNoYW5nZSBldmVudCB3aWxsIGJlIGZpcmVkIGFzeW5jaHJvbm91c2x5IG9uY2UgaXQgaXMgaW5zZXJ0ZWRcbiAgICAgICAgICAgIC8vIGludG8gdGhlIGRvY3VtZW50LiBEbyBzbywgdGh1cyBxdWV1aW5nIHVwIHRoZSB0YXNrLiBSZW1lbWJlciB0byBjbGVhbiB1cCBvbmNlIGl0J3MgYmVlbiBjYWxsZWQuXG4gICAgICAgICAgICB2YXIgc2NyaXB0ID0gZG9jLmNyZWF0ZUVsZW1lbnQoXCJzY3JpcHRcIik7XG4gICAgICAgICAgICBzY3JpcHQub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJ1bklmUHJlc2VudChoYW5kbGUpO1xuICAgICAgICAgICAgICAgIHNjcmlwdC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBudWxsO1xuICAgICAgICAgICAgICAgIGh0bWwucmVtb3ZlQ2hpbGQoc2NyaXB0KTtcbiAgICAgICAgICAgICAgICBzY3JpcHQgPSBudWxsO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGh0bWwuYXBwZW5kQ2hpbGQoc2NyaXB0KTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbnN0YWxsU2V0VGltZW91dEltcGxlbWVudGF0aW9uKCkge1xuICAgICAgICByZWdpc3RlckltbWVkaWF0ZSA9IGZ1bmN0aW9uKGhhbmRsZSkge1xuICAgICAgICAgICAgc2V0VGltZW91dChydW5JZlByZXNlbnQsIDAsIGhhbmRsZSk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gSWYgc3VwcG9ydGVkLCB3ZSBzaG91bGQgYXR0YWNoIHRvIHRoZSBwcm90b3R5cGUgb2YgZ2xvYmFsLCBzaW5jZSB0aGF0IGlzIHdoZXJlIHNldFRpbWVvdXQgZXQgYWwuIGxpdmUuXG4gICAgdmFyIGF0dGFjaFRvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mICYmIE9iamVjdC5nZXRQcm90b3R5cGVPZihnbG9iYWwpO1xuICAgIGF0dGFjaFRvID0gYXR0YWNoVG8gJiYgYXR0YWNoVG8uc2V0VGltZW91dCA/IGF0dGFjaFRvIDogZ2xvYmFsO1xuXG4gICAgLy8gRG9uJ3QgZ2V0IGZvb2xlZCBieSBlLmcuIGJyb3dzZXJpZnkgZW52aXJvbm1lbnRzLlxuICAgIGlmICh7fS50b1N0cmluZy5jYWxsKGdsb2JhbC5wcm9jZXNzKSA9PT0gXCJbb2JqZWN0IHByb2Nlc3NdXCIpIHtcbiAgICAgICAgLy8gRm9yIE5vZGUuanMgYmVmb3JlIDAuOVxuICAgICAgICBpbnN0YWxsTmV4dFRpY2tJbXBsZW1lbnRhdGlvbigpO1xuXG4gICAgfSBlbHNlIGlmIChjYW5Vc2VQb3N0TWVzc2FnZSgpKSB7XG4gICAgICAgIC8vIEZvciBub24tSUUxMCBtb2Rlcm4gYnJvd3NlcnNcbiAgICAgICAgaW5zdGFsbFBvc3RNZXNzYWdlSW1wbGVtZW50YXRpb24oKTtcblxuICAgIH0gZWxzZSBpZiAoZ2xvYmFsLk1lc3NhZ2VDaGFubmVsKSB7XG4gICAgICAgIC8vIEZvciB3ZWIgd29ya2Vycywgd2hlcmUgc3VwcG9ydGVkXG4gICAgICAgIGluc3RhbGxNZXNzYWdlQ2hhbm5lbEltcGxlbWVudGF0aW9uKCk7XG5cbiAgICB9IGVsc2UgaWYgKGRvYyAmJiBcIm9ucmVhZHlzdGF0ZWNoYW5nZVwiIGluIGRvYy5jcmVhdGVFbGVtZW50KFwic2NyaXB0XCIpKSB7XG4gICAgICAgIC8vIEZvciBJRSA24oCTOFxuICAgICAgICBpbnN0YWxsUmVhZHlTdGF0ZUNoYW5nZUltcGxlbWVudGF0aW9uKCk7XG5cbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyBGb3Igb2xkZXIgYnJvd3NlcnNcbiAgICAgICAgaW5zdGFsbFNldFRpbWVvdXRJbXBsZW1lbnRhdGlvbigpO1xuICAgIH1cblxuICAgIGF0dGFjaFRvLnNldEltbWVkaWF0ZSA9IHNldEltbWVkaWF0ZTtcbiAgICBhdHRhY2hUby5jbGVhckltbWVkaWF0ZSA9IGNsZWFySW1tZWRpYXRlO1xufSh0eXBlb2Ygc2VsZiA9PT0gXCJ1bmRlZmluZWRcIiA/IHR5cGVvZiBnbG9iYWwgPT09IFwidW5kZWZpbmVkXCIgPyB0aGlzIDogZ2xvYmFsIDogc2VsZikpO1xuIiwiLyoqIVxuICogU29ydGFibGUgMS4xMC4yXG4gKiBAYXV0aG9yXHRSdWJhWGEgICA8dHJhc2hAcnViYXhhLm9yZz5cbiAqIEBhdXRob3JcdG93ZW5tICAgIDxvd2VuMjMzNTVAZ21haWwuY29tPlxuICogQGxpY2Vuc2UgTUlUXG4gKi9cbmZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7XG4gIGlmICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIikge1xuICAgIF90eXBlb2YgPSBmdW5jdGlvbiAob2JqKSB7XG4gICAgICByZXR1cm4gdHlwZW9mIG9iajtcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIF90eXBlb2YgPSBmdW5jdGlvbiAob2JqKSB7XG4gICAgICByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajtcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIF90eXBlb2Yob2JqKTtcbn1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkge1xuICBpZiAoa2V5IGluIG9iaikge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwge1xuICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgb2JqW2tleV0gPSB2YWx1ZTtcbiAgfVxuXG4gIHJldHVybiBvYmo7XG59XG5cbmZ1bmN0aW9uIF9leHRlbmRzKCkge1xuICBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkge1xuICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldO1xuXG4gICAgICBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7XG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7XG4gICAgICAgICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0YXJnZXQ7XG4gIH07XG5cbiAgcmV0dXJuIF9leHRlbmRzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQodGFyZ2V0KSB7XG4gIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXSAhPSBudWxsID8gYXJndW1lbnRzW2ldIDoge307XG4gICAgdmFyIG93bktleXMgPSBPYmplY3Qua2V5cyhzb3VyY2UpO1xuXG4gICAgaWYgKHR5cGVvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBvd25LZXlzID0gb3duS2V5cy5jb25jYXQoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhzb3VyY2UpLmZpbHRlcihmdW5jdGlvbiAoc3ltKSB7XG4gICAgICAgIHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZSwgc3ltKS5lbnVtZXJhYmxlO1xuICAgICAgfSkpO1xuICAgIH1cblxuICAgIG93bktleXMuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICBfZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHNvdXJjZVtrZXldKTtcbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiB0YXJnZXQ7XG59XG5cbmZ1bmN0aW9uIF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKHNvdXJjZSwgZXhjbHVkZWQpIHtcbiAgaWYgKHNvdXJjZSA9PSBudWxsKSByZXR1cm4ge307XG4gIHZhciB0YXJnZXQgPSB7fTtcbiAgdmFyIHNvdXJjZUtleXMgPSBPYmplY3Qua2V5cyhzb3VyY2UpO1xuICB2YXIga2V5LCBpO1xuXG4gIGZvciAoaSA9IDA7IGkgPCBzb3VyY2VLZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAga2V5ID0gc291cmNlS2V5c1tpXTtcbiAgICBpZiAoZXhjbHVkZWQuaW5kZXhPZihrZXkpID49IDApIGNvbnRpbnVlO1xuICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG4gIH1cblxuICByZXR1cm4gdGFyZ2V0O1xufVxuXG5mdW5jdGlvbiBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoc291cmNlLCBleGNsdWRlZCkge1xuICBpZiAoc291cmNlID09IG51bGwpIHJldHVybiB7fTtcblxuICB2YXIgdGFyZ2V0ID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2Uoc291cmNlLCBleGNsdWRlZCk7XG5cbiAgdmFyIGtleSwgaTtcblxuICBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykge1xuICAgIHZhciBzb3VyY2VTeW1ib2xLZXlzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhzb3VyY2UpO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IHNvdXJjZVN5bWJvbEtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGtleSA9IHNvdXJjZVN5bWJvbEtleXNbaV07XG4gICAgICBpZiAoZXhjbHVkZWQuaW5kZXhPZihrZXkpID49IDApIGNvbnRpbnVlO1xuICAgICAgaWYgKCFPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwoc291cmNlLCBrZXkpKSBjb250aW51ZTtcbiAgICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRhcmdldDtcbn1cblxuZnVuY3Rpb24gX3RvQ29uc3VtYWJsZUFycmF5KGFycikge1xuICByZXR1cm4gX2FycmF5V2l0aG91dEhvbGVzKGFycikgfHwgX2l0ZXJhYmxlVG9BcnJheShhcnIpIHx8IF9ub25JdGVyYWJsZVNwcmVhZCgpO1xufVxuXG5mdW5jdGlvbiBfYXJyYXlXaXRob3V0SG9sZXMoYXJyKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGFycikpIHtcbiAgICBmb3IgKHZhciBpID0gMCwgYXJyMiA9IG5ldyBBcnJheShhcnIubGVuZ3RoKTsgaSA8IGFyci5sZW5ndGg7IGkrKykgYXJyMltpXSA9IGFycltpXTtcblxuICAgIHJldHVybiBhcnIyO1xuICB9XG59XG5cbmZ1bmN0aW9uIF9pdGVyYWJsZVRvQXJyYXkoaXRlcikge1xuICBpZiAoU3ltYm9sLml0ZXJhdG9yIGluIE9iamVjdChpdGVyKSB8fCBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoaXRlcikgPT09IFwiW29iamVjdCBBcmd1bWVudHNdXCIpIHJldHVybiBBcnJheS5mcm9tKGl0ZXIpO1xufVxuXG5mdW5jdGlvbiBfbm9uSXRlcmFibGVTcHJlYWQoKSB7XG4gIHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gc3ByZWFkIG5vbi1pdGVyYWJsZSBpbnN0YW5jZVwiKTtcbn1cblxudmFyIHZlcnNpb24gPSBcIjEuMTAuMlwiO1xuXG5mdW5jdGlvbiB1c2VyQWdlbnQocGF0dGVybikge1xuICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93Lm5hdmlnYXRvcikge1xuICAgIHJldHVybiAhIVxuICAgIC8qQF9fUFVSRV9fKi9cbiAgICBuYXZpZ2F0b3IudXNlckFnZW50Lm1hdGNoKHBhdHRlcm4pO1xuICB9XG59XG5cbnZhciBJRTExT3JMZXNzID0gdXNlckFnZW50KC8oPzpUcmlkZW50LipydlsgOl0/MTFcXC58bXNpZXxpZW1vYmlsZXxXaW5kb3dzIFBob25lKS9pKTtcbnZhciBFZGdlID0gdXNlckFnZW50KC9FZGdlL2kpO1xudmFyIEZpcmVGb3ggPSB1c2VyQWdlbnQoL2ZpcmVmb3gvaSk7XG52YXIgU2FmYXJpID0gdXNlckFnZW50KC9zYWZhcmkvaSkgJiYgIXVzZXJBZ2VudCgvY2hyb21lL2kpICYmICF1c2VyQWdlbnQoL2FuZHJvaWQvaSk7XG52YXIgSU9TID0gdXNlckFnZW50KC9pUChhZHxvZHxob25lKS9pKTtcbnZhciBDaHJvbWVGb3JBbmRyb2lkID0gdXNlckFnZW50KC9jaHJvbWUvaSkgJiYgdXNlckFnZW50KC9hbmRyb2lkL2kpO1xuXG52YXIgY2FwdHVyZU1vZGUgPSB7XG4gIGNhcHR1cmU6IGZhbHNlLFxuICBwYXNzaXZlOiBmYWxzZVxufTtcblxuZnVuY3Rpb24gb24oZWwsIGV2ZW50LCBmbikge1xuICBlbC5hZGRFdmVudExpc3RlbmVyKGV2ZW50LCBmbiwgIUlFMTFPckxlc3MgJiYgY2FwdHVyZU1vZGUpO1xufVxuXG5mdW5jdGlvbiBvZmYoZWwsIGV2ZW50LCBmbikge1xuICBlbC5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50LCBmbiwgIUlFMTFPckxlc3MgJiYgY2FwdHVyZU1vZGUpO1xufVxuXG5mdW5jdGlvbiBtYXRjaGVzKFxuLyoqSFRNTEVsZW1lbnQqL1xuZWwsXG4vKipTdHJpbmcqL1xuc2VsZWN0b3IpIHtcbiAgaWYgKCFzZWxlY3RvcikgcmV0dXJuO1xuICBzZWxlY3RvclswXSA9PT0gJz4nICYmIChzZWxlY3RvciA9IHNlbGVjdG9yLnN1YnN0cmluZygxKSk7XG5cbiAgaWYgKGVsKSB7XG4gICAgdHJ5IHtcbiAgICAgIGlmIChlbC5tYXRjaGVzKSB7XG4gICAgICAgIHJldHVybiBlbC5tYXRjaGVzKHNlbGVjdG9yKTtcbiAgICAgIH0gZWxzZSBpZiAoZWwubXNNYXRjaGVzU2VsZWN0b3IpIHtcbiAgICAgICAgcmV0dXJuIGVsLm1zTWF0Y2hlc1NlbGVjdG9yKHNlbGVjdG9yKTtcbiAgICAgIH0gZWxzZSBpZiAoZWwud2Via2l0TWF0Y2hlc1NlbGVjdG9yKSB7XG4gICAgICAgIHJldHVybiBlbC53ZWJraXRNYXRjaGVzU2VsZWN0b3Ioc2VsZWN0b3IpO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKF8pIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGdldFBhcmVudE9ySG9zdChlbCkge1xuICByZXR1cm4gZWwuaG9zdCAmJiBlbCAhPT0gZG9jdW1lbnQgJiYgZWwuaG9zdC5ub2RlVHlwZSA/IGVsLmhvc3QgOiBlbC5wYXJlbnROb2RlO1xufVxuXG5mdW5jdGlvbiBjbG9zZXN0KFxuLyoqSFRNTEVsZW1lbnQqL1xuZWwsXG4vKipTdHJpbmcqL1xuc2VsZWN0b3IsXG4vKipIVE1MRWxlbWVudCovXG5jdHgsIGluY2x1ZGVDVFgpIHtcbiAgaWYgKGVsKSB7XG4gICAgY3R4ID0gY3R4IHx8IGRvY3VtZW50O1xuXG4gICAgZG8ge1xuICAgICAgaWYgKHNlbGVjdG9yICE9IG51bGwgJiYgKHNlbGVjdG9yWzBdID09PSAnPicgPyBlbC5wYXJlbnROb2RlID09PSBjdHggJiYgbWF0Y2hlcyhlbCwgc2VsZWN0b3IpIDogbWF0Y2hlcyhlbCwgc2VsZWN0b3IpKSB8fCBpbmNsdWRlQ1RYICYmIGVsID09PSBjdHgpIHtcbiAgICAgICAgcmV0dXJuIGVsO1xuICAgICAgfVxuXG4gICAgICBpZiAoZWwgPT09IGN0eCkgYnJlYWs7XG4gICAgICAvKiBqc2hpbnQgYm9zczp0cnVlICovXG4gICAgfSB3aGlsZSAoZWwgPSBnZXRQYXJlbnRPckhvc3QoZWwpKTtcbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuXG52YXIgUl9TUEFDRSA9IC9cXHMrL2c7XG5cbmZ1bmN0aW9uIHRvZ2dsZUNsYXNzKGVsLCBuYW1lLCBzdGF0ZSkge1xuICBpZiAoZWwgJiYgbmFtZSkge1xuICAgIGlmIChlbC5jbGFzc0xpc3QpIHtcbiAgICAgIGVsLmNsYXNzTGlzdFtzdGF0ZSA/ICdhZGQnIDogJ3JlbW92ZSddKG5hbWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgY2xhc3NOYW1lID0gKCcgJyArIGVsLmNsYXNzTmFtZSArICcgJykucmVwbGFjZShSX1NQQUNFLCAnICcpLnJlcGxhY2UoJyAnICsgbmFtZSArICcgJywgJyAnKTtcbiAgICAgIGVsLmNsYXNzTmFtZSA9IChjbGFzc05hbWUgKyAoc3RhdGUgPyAnICcgKyBuYW1lIDogJycpKS5yZXBsYWNlKFJfU1BBQ0UsICcgJyk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGNzcyhlbCwgcHJvcCwgdmFsKSB7XG4gIHZhciBzdHlsZSA9IGVsICYmIGVsLnN0eWxlO1xuXG4gIGlmIChzdHlsZSkge1xuICAgIGlmICh2YWwgPT09IHZvaWQgMCkge1xuICAgICAgaWYgKGRvY3VtZW50LmRlZmF1bHRWaWV3ICYmIGRvY3VtZW50LmRlZmF1bHRWaWV3LmdldENvbXB1dGVkU3R5bGUpIHtcbiAgICAgICAgdmFsID0gZG9jdW1lbnQuZGVmYXVsdFZpZXcuZ2V0Q29tcHV0ZWRTdHlsZShlbCwgJycpO1xuICAgICAgfSBlbHNlIGlmIChlbC5jdXJyZW50U3R5bGUpIHtcbiAgICAgICAgdmFsID0gZWwuY3VycmVudFN0eWxlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcHJvcCA9PT0gdm9pZCAwID8gdmFsIDogdmFsW3Byb3BdO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoIShwcm9wIGluIHN0eWxlKSAmJiBwcm9wLmluZGV4T2YoJ3dlYmtpdCcpID09PSAtMSkge1xuICAgICAgICBwcm9wID0gJy13ZWJraXQtJyArIHByb3A7XG4gICAgICB9XG5cbiAgICAgIHN0eWxlW3Byb3BdID0gdmFsICsgKHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnID8gJycgOiAncHgnKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gbWF0cml4KGVsLCBzZWxmT25seSkge1xuICB2YXIgYXBwbGllZFRyYW5zZm9ybXMgPSAnJztcblxuICBpZiAodHlwZW9mIGVsID09PSAnc3RyaW5nJykge1xuICAgIGFwcGxpZWRUcmFuc2Zvcm1zID0gZWw7XG4gIH0gZWxzZSB7XG4gICAgZG8ge1xuICAgICAgdmFyIHRyYW5zZm9ybSA9IGNzcyhlbCwgJ3RyYW5zZm9ybScpO1xuXG4gICAgICBpZiAodHJhbnNmb3JtICYmIHRyYW5zZm9ybSAhPT0gJ25vbmUnKSB7XG4gICAgICAgIGFwcGxpZWRUcmFuc2Zvcm1zID0gdHJhbnNmb3JtICsgJyAnICsgYXBwbGllZFRyYW5zZm9ybXM7XG4gICAgICB9XG4gICAgICAvKiBqc2hpbnQgYm9zczp0cnVlICovXG5cbiAgICB9IHdoaWxlICghc2VsZk9ubHkgJiYgKGVsID0gZWwucGFyZW50Tm9kZSkpO1xuICB9XG5cbiAgdmFyIG1hdHJpeEZuID0gd2luZG93LkRPTU1hdHJpeCB8fCB3aW5kb3cuV2ViS2l0Q1NTTWF0cml4IHx8IHdpbmRvdy5DU1NNYXRyaXggfHwgd2luZG93Lk1TQ1NTTWF0cml4O1xuICAvKmpzaGludCAtVzA1NiAqL1xuXG4gIHJldHVybiBtYXRyaXhGbiAmJiBuZXcgbWF0cml4Rm4oYXBwbGllZFRyYW5zZm9ybXMpO1xufVxuXG5mdW5jdGlvbiBmaW5kKGN0eCwgdGFnTmFtZSwgaXRlcmF0b3IpIHtcbiAgaWYgKGN0eCkge1xuICAgIHZhciBsaXN0ID0gY3R4LmdldEVsZW1lbnRzQnlUYWdOYW1lKHRhZ05hbWUpLFxuICAgICAgICBpID0gMCxcbiAgICAgICAgbiA9IGxpc3QubGVuZ3RoO1xuXG4gICAgaWYgKGl0ZXJhdG9yKSB7XG4gICAgICBmb3IgKDsgaSA8IG47IGkrKykge1xuICAgICAgICBpdGVyYXRvcihsaXN0W2ldLCBpKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbGlzdDtcbiAgfVxuXG4gIHJldHVybiBbXTtcbn1cblxuZnVuY3Rpb24gZ2V0V2luZG93U2Nyb2xsaW5nRWxlbWVudCgpIHtcbiAgdmFyIHNjcm9sbGluZ0VsZW1lbnQgPSBkb2N1bWVudC5zY3JvbGxpbmdFbGVtZW50O1xuXG4gIGlmIChzY3JvbGxpbmdFbGVtZW50KSB7XG4gICAgcmV0dXJuIHNjcm9sbGluZ0VsZW1lbnQ7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcbiAgfVxufVxuLyoqXHJcbiAqIFJldHVybnMgdGhlIFwiYm91bmRpbmcgY2xpZW50IHJlY3RcIiBvZiBnaXZlbiBlbGVtZW50XHJcbiAqIEBwYXJhbSAge0hUTUxFbGVtZW50fSBlbCAgICAgICAgICAgICAgICAgICAgICAgVGhlIGVsZW1lbnQgd2hvc2UgYm91bmRpbmdDbGllbnRSZWN0IGlzIHdhbnRlZFxyXG4gKiBAcGFyYW0gIHtbQm9vbGVhbl19IHJlbGF0aXZlVG9Db250YWluaW5nQmxvY2sgIFdoZXRoZXIgdGhlIHJlY3Qgc2hvdWxkIGJlIHJlbGF0aXZlIHRvIHRoZSBjb250YWluaW5nIGJsb2NrIG9mIChpbmNsdWRpbmcpIHRoZSBjb250YWluZXJcclxuICogQHBhcmFtICB7W0Jvb2xlYW5dfSByZWxhdGl2ZVRvTm9uU3RhdGljUGFyZW50ICBXaGV0aGVyIHRoZSByZWN0IHNob3VsZCBiZSByZWxhdGl2ZSB0byB0aGUgcmVsYXRpdmUgcGFyZW50IG9mIChpbmNsdWRpbmcpIHRoZSBjb250YWllbnJcclxuICogQHBhcmFtICB7W0Jvb2xlYW5dfSB1bmRvU2NhbGUgICAgICAgICAgICAgICAgICBXaGV0aGVyIHRoZSBjb250YWluZXIncyBzY2FsZSgpIHNob3VsZCBiZSB1bmRvbmVcclxuICogQHBhcmFtICB7W0hUTUxFbGVtZW50XX0gY29udGFpbmVyICAgICAgICAgICAgICBUaGUgcGFyZW50IHRoZSBlbGVtZW50IHdpbGwgYmUgcGxhY2VkIGluXHJcbiAqIEByZXR1cm4ge09iamVjdH0gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgVGhlIGJvdW5kaW5nQ2xpZW50UmVjdCBvZiBlbCwgd2l0aCBzcGVjaWZpZWQgYWRqdXN0bWVudHNcclxuICovXG5cblxuZnVuY3Rpb24gZ2V0UmVjdChlbCwgcmVsYXRpdmVUb0NvbnRhaW5pbmdCbG9jaywgcmVsYXRpdmVUb05vblN0YXRpY1BhcmVudCwgdW5kb1NjYWxlLCBjb250YWluZXIpIHtcbiAgaWYgKCFlbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QgJiYgZWwgIT09IHdpbmRvdykgcmV0dXJuO1xuICB2YXIgZWxSZWN0LCB0b3AsIGxlZnQsIGJvdHRvbSwgcmlnaHQsIGhlaWdodCwgd2lkdGg7XG5cbiAgaWYgKGVsICE9PSB3aW5kb3cgJiYgZWwgIT09IGdldFdpbmRvd1Njcm9sbGluZ0VsZW1lbnQoKSkge1xuICAgIGVsUmVjdCA9IGVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIHRvcCA9IGVsUmVjdC50b3A7XG4gICAgbGVmdCA9IGVsUmVjdC5sZWZ0O1xuICAgIGJvdHRvbSA9IGVsUmVjdC5ib3R0b207XG4gICAgcmlnaHQgPSBlbFJlY3QucmlnaHQ7XG4gICAgaGVpZ2h0ID0gZWxSZWN0LmhlaWdodDtcbiAgICB3aWR0aCA9IGVsUmVjdC53aWR0aDtcbiAgfSBlbHNlIHtcbiAgICB0b3AgPSAwO1xuICAgIGxlZnQgPSAwO1xuICAgIGJvdHRvbSA9IHdpbmRvdy5pbm5lckhlaWdodDtcbiAgICByaWdodCA9IHdpbmRvdy5pbm5lcldpZHRoO1xuICAgIGhlaWdodCA9IHdpbmRvdy5pbm5lckhlaWdodDtcbiAgICB3aWR0aCA9IHdpbmRvdy5pbm5lcldpZHRoO1xuICB9XG5cbiAgaWYgKChyZWxhdGl2ZVRvQ29udGFpbmluZ0Jsb2NrIHx8IHJlbGF0aXZlVG9Ob25TdGF0aWNQYXJlbnQpICYmIGVsICE9PSB3aW5kb3cpIHtcbiAgICAvLyBBZGp1c3QgZm9yIHRyYW5zbGF0ZSgpXG4gICAgY29udGFpbmVyID0gY29udGFpbmVyIHx8IGVsLnBhcmVudE5vZGU7IC8vIHNvbHZlcyAjMTEyMyAoc2VlOiBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMzc5NTM4MDYvNjA4ODMxMilcbiAgICAvLyBOb3QgbmVlZGVkIG9uIDw9IElFMTFcblxuICAgIGlmICghSUUxMU9yTGVzcykge1xuICAgICAgZG8ge1xuICAgICAgICBpZiAoY29udGFpbmVyICYmIGNvbnRhaW5lci5nZXRCb3VuZGluZ0NsaWVudFJlY3QgJiYgKGNzcyhjb250YWluZXIsICd0cmFuc2Zvcm0nKSAhPT0gJ25vbmUnIHx8IHJlbGF0aXZlVG9Ob25TdGF0aWNQYXJlbnQgJiYgY3NzKGNvbnRhaW5lciwgJ3Bvc2l0aW9uJykgIT09ICdzdGF0aWMnKSkge1xuICAgICAgICAgIHZhciBjb250YWluZXJSZWN0ID0gY29udGFpbmVyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpOyAvLyBTZXQgcmVsYXRpdmUgdG8gZWRnZXMgb2YgcGFkZGluZyBib3ggb2YgY29udGFpbmVyXG5cbiAgICAgICAgICB0b3AgLT0gY29udGFpbmVyUmVjdC50b3AgKyBwYXJzZUludChjc3MoY29udGFpbmVyLCAnYm9yZGVyLXRvcC13aWR0aCcpKTtcbiAgICAgICAgICBsZWZ0IC09IGNvbnRhaW5lclJlY3QubGVmdCArIHBhcnNlSW50KGNzcyhjb250YWluZXIsICdib3JkZXItbGVmdC13aWR0aCcpKTtcbiAgICAgICAgICBib3R0b20gPSB0b3AgKyBlbFJlY3QuaGVpZ2h0O1xuICAgICAgICAgIHJpZ2h0ID0gbGVmdCArIGVsUmVjdC53aWR0aDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICAvKiBqc2hpbnQgYm9zczp0cnVlICovXG5cbiAgICAgIH0gd2hpbGUgKGNvbnRhaW5lciA9IGNvbnRhaW5lci5wYXJlbnROb2RlKTtcbiAgICB9XG4gIH1cblxuICBpZiAodW5kb1NjYWxlICYmIGVsICE9PSB3aW5kb3cpIHtcbiAgICAvLyBBZGp1c3QgZm9yIHNjYWxlKClcbiAgICB2YXIgZWxNYXRyaXggPSBtYXRyaXgoY29udGFpbmVyIHx8IGVsKSxcbiAgICAgICAgc2NhbGVYID0gZWxNYXRyaXggJiYgZWxNYXRyaXguYSxcbiAgICAgICAgc2NhbGVZID0gZWxNYXRyaXggJiYgZWxNYXRyaXguZDtcblxuICAgIGlmIChlbE1hdHJpeCkge1xuICAgICAgdG9wIC89IHNjYWxlWTtcbiAgICAgIGxlZnQgLz0gc2NhbGVYO1xuICAgICAgd2lkdGggLz0gc2NhbGVYO1xuICAgICAgaGVpZ2h0IC89IHNjYWxlWTtcbiAgICAgIGJvdHRvbSA9IHRvcCArIGhlaWdodDtcbiAgICAgIHJpZ2h0ID0gbGVmdCArIHdpZHRoO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgdG9wOiB0b3AsXG4gICAgbGVmdDogbGVmdCxcbiAgICBib3R0b206IGJvdHRvbSxcbiAgICByaWdodDogcmlnaHQsXG4gICAgd2lkdGg6IHdpZHRoLFxuICAgIGhlaWdodDogaGVpZ2h0XG4gIH07XG59XG4vKipcclxuICogQ2hlY2tzIGlmIGEgc2lkZSBvZiBhbiBlbGVtZW50IGlzIHNjcm9sbGVkIHBhc3QgYSBzaWRlIG9mIGl0cyBwYXJlbnRzXHJcbiAqIEBwYXJhbSAge0hUTUxFbGVtZW50fSAgZWwgICAgICAgICAgIFRoZSBlbGVtZW50IHdobydzIHNpZGUgYmVpbmcgc2Nyb2xsZWQgb3V0IG9mIHZpZXcgaXMgaW4gcXVlc3Rpb25cclxuICogQHBhcmFtICB7U3RyaW5nfSAgICAgICBlbFNpZGUgICAgICAgU2lkZSBvZiB0aGUgZWxlbWVudCBpbiBxdWVzdGlvbiAoJ3RvcCcsICdsZWZ0JywgJ3JpZ2h0JywgJ2JvdHRvbScpXHJcbiAqIEBwYXJhbSAge1N0cmluZ30gICAgICAgcGFyZW50U2lkZSAgIFNpZGUgb2YgdGhlIHBhcmVudCBpbiBxdWVzdGlvbiAoJ3RvcCcsICdsZWZ0JywgJ3JpZ2h0JywgJ2JvdHRvbScpXHJcbiAqIEByZXR1cm4ge0hUTUxFbGVtZW50fSAgICAgICAgICAgICAgIFRoZSBwYXJlbnQgc2Nyb2xsIGVsZW1lbnQgdGhhdCB0aGUgZWwncyBzaWRlIGlzIHNjcm9sbGVkIHBhc3QsIG9yIG51bGwgaWYgdGhlcmUgaXMgbm8gc3VjaCBlbGVtZW50XHJcbiAqL1xuXG5cbmZ1bmN0aW9uIGlzU2Nyb2xsZWRQYXN0KGVsLCBlbFNpZGUsIHBhcmVudFNpZGUpIHtcbiAgdmFyIHBhcmVudCA9IGdldFBhcmVudEF1dG9TY3JvbGxFbGVtZW50KGVsLCB0cnVlKSxcbiAgICAgIGVsU2lkZVZhbCA9IGdldFJlY3QoZWwpW2VsU2lkZV07XG4gIC8qIGpzaGludCBib3NzOnRydWUgKi9cblxuICB3aGlsZSAocGFyZW50KSB7XG4gICAgdmFyIHBhcmVudFNpZGVWYWwgPSBnZXRSZWN0KHBhcmVudClbcGFyZW50U2lkZV0sXG4gICAgICAgIHZpc2libGUgPSB2b2lkIDA7XG5cbiAgICBpZiAocGFyZW50U2lkZSA9PT0gJ3RvcCcgfHwgcGFyZW50U2lkZSA9PT0gJ2xlZnQnKSB7XG4gICAgICB2aXNpYmxlID0gZWxTaWRlVmFsID49IHBhcmVudFNpZGVWYWw7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZpc2libGUgPSBlbFNpZGVWYWwgPD0gcGFyZW50U2lkZVZhbDtcbiAgICB9XG5cbiAgICBpZiAoIXZpc2libGUpIHJldHVybiBwYXJlbnQ7XG4gICAgaWYgKHBhcmVudCA9PT0gZ2V0V2luZG93U2Nyb2xsaW5nRWxlbWVudCgpKSBicmVhaztcbiAgICBwYXJlbnQgPSBnZXRQYXJlbnRBdXRvU2Nyb2xsRWxlbWVudChwYXJlbnQsIGZhbHNlKTtcbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cbi8qKlxyXG4gKiBHZXRzIG50aCBjaGlsZCBvZiBlbCwgaWdub3JpbmcgaGlkZGVuIGNoaWxkcmVuLCBzb3J0YWJsZSdzIGVsZW1lbnRzIChkb2VzIG5vdCBpZ25vcmUgY2xvbmUgaWYgaXQncyB2aXNpYmxlKVxyXG4gKiBhbmQgbm9uLWRyYWdnYWJsZSBlbGVtZW50c1xyXG4gKiBAcGFyYW0gIHtIVE1MRWxlbWVudH0gZWwgICAgICAgVGhlIHBhcmVudCBlbGVtZW50XHJcbiAqIEBwYXJhbSAge051bWJlcn0gY2hpbGROdW0gICAgICBUaGUgaW5kZXggb2YgdGhlIGNoaWxkXHJcbiAqIEBwYXJhbSAge09iamVjdH0gb3B0aW9ucyAgICAgICBQYXJlbnQgU29ydGFibGUncyBvcHRpb25zXHJcbiAqIEByZXR1cm4ge0hUTUxFbGVtZW50fSAgICAgICAgICBUaGUgY2hpbGQgYXQgaW5kZXggY2hpbGROdW0sIG9yIG51bGwgaWYgbm90IGZvdW5kXHJcbiAqL1xuXG5cbmZ1bmN0aW9uIGdldENoaWxkKGVsLCBjaGlsZE51bSwgb3B0aW9ucykge1xuICB2YXIgY3VycmVudENoaWxkID0gMCxcbiAgICAgIGkgPSAwLFxuICAgICAgY2hpbGRyZW4gPSBlbC5jaGlsZHJlbjtcblxuICB3aGlsZSAoaSA8IGNoaWxkcmVuLmxlbmd0aCkge1xuICAgIGlmIChjaGlsZHJlbltpXS5zdHlsZS5kaXNwbGF5ICE9PSAnbm9uZScgJiYgY2hpbGRyZW5baV0gIT09IFNvcnRhYmxlLmdob3N0ICYmIGNoaWxkcmVuW2ldICE9PSBTb3J0YWJsZS5kcmFnZ2VkICYmIGNsb3Nlc3QoY2hpbGRyZW5baV0sIG9wdGlvbnMuZHJhZ2dhYmxlLCBlbCwgZmFsc2UpKSB7XG4gICAgICBpZiAoY3VycmVudENoaWxkID09PSBjaGlsZE51bSkge1xuICAgICAgICByZXR1cm4gY2hpbGRyZW5baV07XG4gICAgICB9XG5cbiAgICAgIGN1cnJlbnRDaGlsZCsrO1xuICAgIH1cblxuICAgIGkrKztcbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuLyoqXHJcbiAqIEdldHMgdGhlIGxhc3QgY2hpbGQgaW4gdGhlIGVsLCBpZ25vcmluZyBnaG9zdEVsIG9yIGludmlzaWJsZSBlbGVtZW50cyAoY2xvbmVzKVxyXG4gKiBAcGFyYW0gIHtIVE1MRWxlbWVudH0gZWwgICAgICAgUGFyZW50IGVsZW1lbnRcclxuICogQHBhcmFtICB7c2VsZWN0b3J9IHNlbGVjdG9yICAgIEFueSBvdGhlciBlbGVtZW50cyB0aGF0IHNob3VsZCBiZSBpZ25vcmVkXHJcbiAqIEByZXR1cm4ge0hUTUxFbGVtZW50fSAgICAgICAgICBUaGUgbGFzdCBjaGlsZCwgaWdub3JpbmcgZ2hvc3RFbFxyXG4gKi9cblxuXG5mdW5jdGlvbiBsYXN0Q2hpbGQoZWwsIHNlbGVjdG9yKSB7XG4gIHZhciBsYXN0ID0gZWwubGFzdEVsZW1lbnRDaGlsZDtcblxuICB3aGlsZSAobGFzdCAmJiAobGFzdCA9PT0gU29ydGFibGUuZ2hvc3QgfHwgY3NzKGxhc3QsICdkaXNwbGF5JykgPT09ICdub25lJyB8fCBzZWxlY3RvciAmJiAhbWF0Y2hlcyhsYXN0LCBzZWxlY3RvcikpKSB7XG4gICAgbGFzdCA9IGxhc3QucHJldmlvdXNFbGVtZW50U2libGluZztcbiAgfVxuXG4gIHJldHVybiBsYXN0IHx8IG51bGw7XG59XG4vKipcclxuICogUmV0dXJucyB0aGUgaW5kZXggb2YgYW4gZWxlbWVudCB3aXRoaW4gaXRzIHBhcmVudCBmb3IgYSBzZWxlY3RlZCBzZXQgb2ZcclxuICogZWxlbWVudHNcclxuICogQHBhcmFtICB7SFRNTEVsZW1lbnR9IGVsXHJcbiAqIEBwYXJhbSAge3NlbGVjdG9yfSBzZWxlY3RvclxyXG4gKiBAcmV0dXJuIHtudW1iZXJ9XHJcbiAqL1xuXG5cbmZ1bmN0aW9uIGluZGV4KGVsLCBzZWxlY3Rvcikge1xuICB2YXIgaW5kZXggPSAwO1xuXG4gIGlmICghZWwgfHwgIWVsLnBhcmVudE5vZGUpIHtcbiAgICByZXR1cm4gLTE7XG4gIH1cbiAgLyoganNoaW50IGJvc3M6dHJ1ZSAqL1xuXG5cbiAgd2hpbGUgKGVsID0gZWwucHJldmlvdXNFbGVtZW50U2libGluZykge1xuICAgIGlmIChlbC5ub2RlTmFtZS50b1VwcGVyQ2FzZSgpICE9PSAnVEVNUExBVEUnICYmIGVsICE9PSBTb3J0YWJsZS5jbG9uZSAmJiAoIXNlbGVjdG9yIHx8IG1hdGNoZXMoZWwsIHNlbGVjdG9yKSkpIHtcbiAgICAgIGluZGV4Kys7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGluZGV4O1xufVxuLyoqXHJcbiAqIFJldHVybnMgdGhlIHNjcm9sbCBvZmZzZXQgb2YgdGhlIGdpdmVuIGVsZW1lbnQsIGFkZGVkIHdpdGggYWxsIHRoZSBzY3JvbGwgb2Zmc2V0cyBvZiBwYXJlbnQgZWxlbWVudHMuXHJcbiAqIFRoZSB2YWx1ZSBpcyByZXR1cm5lZCBpbiByZWFsIHBpeGVscy5cclxuICogQHBhcmFtICB7SFRNTEVsZW1lbnR9IGVsXHJcbiAqIEByZXR1cm4ge0FycmF5fSAgICAgICAgICAgICBPZmZzZXRzIGluIHRoZSBmb3JtYXQgb2YgW2xlZnQsIHRvcF1cclxuICovXG5cblxuZnVuY3Rpb24gZ2V0UmVsYXRpdmVTY3JvbGxPZmZzZXQoZWwpIHtcbiAgdmFyIG9mZnNldExlZnQgPSAwLFxuICAgICAgb2Zmc2V0VG9wID0gMCxcbiAgICAgIHdpblNjcm9sbGVyID0gZ2V0V2luZG93U2Nyb2xsaW5nRWxlbWVudCgpO1xuXG4gIGlmIChlbCkge1xuICAgIGRvIHtcbiAgICAgIHZhciBlbE1hdHJpeCA9IG1hdHJpeChlbCksXG4gICAgICAgICAgc2NhbGVYID0gZWxNYXRyaXguYSxcbiAgICAgICAgICBzY2FsZVkgPSBlbE1hdHJpeC5kO1xuICAgICAgb2Zmc2V0TGVmdCArPSBlbC5zY3JvbGxMZWZ0ICogc2NhbGVYO1xuICAgICAgb2Zmc2V0VG9wICs9IGVsLnNjcm9sbFRvcCAqIHNjYWxlWTtcbiAgICB9IHdoaWxlIChlbCAhPT0gd2luU2Nyb2xsZXIgJiYgKGVsID0gZWwucGFyZW50Tm9kZSkpO1xuICB9XG5cbiAgcmV0dXJuIFtvZmZzZXRMZWZ0LCBvZmZzZXRUb3BdO1xufVxuLyoqXHJcbiAqIFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBvYmplY3Qgd2l0aGluIHRoZSBnaXZlbiBhcnJheVxyXG4gKiBAcGFyYW0gIHtBcnJheX0gYXJyICAgQXJyYXkgdGhhdCBtYXkgb3IgbWF5IG5vdCBob2xkIHRoZSBvYmplY3RcclxuICogQHBhcmFtICB7T2JqZWN0fSBvYmogIEFuIG9iamVjdCB0aGF0IGhhcyBhIGtleS12YWx1ZSBwYWlyIHVuaXF1ZSB0byBhbmQgaWRlbnRpY2FsIHRvIGEga2V5LXZhbHVlIHBhaXIgaW4gdGhlIG9iamVjdCB5b3Ugd2FudCB0byBmaW5kXHJcbiAqIEByZXR1cm4ge051bWJlcn0gICAgICBUaGUgaW5kZXggb2YgdGhlIG9iamVjdCBpbiB0aGUgYXJyYXksIG9yIC0xXHJcbiAqL1xuXG5cbmZ1bmN0aW9uIGluZGV4T2ZPYmplY3QoYXJyLCBvYmopIHtcbiAgZm9yICh2YXIgaSBpbiBhcnIpIHtcbiAgICBpZiAoIWFyci5oYXNPd25Qcm9wZXJ0eShpKSkgY29udGludWU7XG5cbiAgICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgICBpZiAob2JqLmhhc093blByb3BlcnR5KGtleSkgJiYgb2JqW2tleV0gPT09IGFycltpXVtrZXldKSByZXR1cm4gTnVtYmVyKGkpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiAtMTtcbn1cblxuZnVuY3Rpb24gZ2V0UGFyZW50QXV0b1Njcm9sbEVsZW1lbnQoZWwsIGluY2x1ZGVTZWxmKSB7XG4gIC8vIHNraXAgdG8gd2luZG93XG4gIGlmICghZWwgfHwgIWVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCkgcmV0dXJuIGdldFdpbmRvd1Njcm9sbGluZ0VsZW1lbnQoKTtcbiAgdmFyIGVsZW0gPSBlbDtcbiAgdmFyIGdvdFNlbGYgPSBmYWxzZTtcblxuICBkbyB7XG4gICAgLy8gd2UgZG9uJ3QgbmVlZCB0byBnZXQgZWxlbSBjc3MgaWYgaXQgaXNuJ3QgZXZlbiBvdmVyZmxvd2luZyBpbiB0aGUgZmlyc3QgcGxhY2UgKHBlcmZvcm1hbmNlKVxuICAgIGlmIChlbGVtLmNsaWVudFdpZHRoIDwgZWxlbS5zY3JvbGxXaWR0aCB8fCBlbGVtLmNsaWVudEhlaWdodCA8IGVsZW0uc2Nyb2xsSGVpZ2h0KSB7XG4gICAgICB2YXIgZWxlbUNTUyA9IGNzcyhlbGVtKTtcblxuICAgICAgaWYgKGVsZW0uY2xpZW50V2lkdGggPCBlbGVtLnNjcm9sbFdpZHRoICYmIChlbGVtQ1NTLm92ZXJmbG93WCA9PSAnYXV0bycgfHwgZWxlbUNTUy5vdmVyZmxvd1ggPT0gJ3Njcm9sbCcpIHx8IGVsZW0uY2xpZW50SGVpZ2h0IDwgZWxlbS5zY3JvbGxIZWlnaHQgJiYgKGVsZW1DU1Mub3ZlcmZsb3dZID09ICdhdXRvJyB8fCBlbGVtQ1NTLm92ZXJmbG93WSA9PSAnc2Nyb2xsJykpIHtcbiAgICAgICAgaWYgKCFlbGVtLmdldEJvdW5kaW5nQ2xpZW50UmVjdCB8fCBlbGVtID09PSBkb2N1bWVudC5ib2R5KSByZXR1cm4gZ2V0V2luZG93U2Nyb2xsaW5nRWxlbWVudCgpO1xuICAgICAgICBpZiAoZ290U2VsZiB8fCBpbmNsdWRlU2VsZikgcmV0dXJuIGVsZW07XG4gICAgICAgIGdvdFNlbGYgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICAvKiBqc2hpbnQgYm9zczp0cnVlICovXG5cbiAgfSB3aGlsZSAoZWxlbSA9IGVsZW0ucGFyZW50Tm9kZSk7XG5cbiAgcmV0dXJuIGdldFdpbmRvd1Njcm9sbGluZ0VsZW1lbnQoKTtcbn1cblxuZnVuY3Rpb24gZXh0ZW5kKGRzdCwgc3JjKSB7XG4gIGlmIChkc3QgJiYgc3JjKSB7XG4gICAgZm9yICh2YXIga2V5IGluIHNyYykge1xuICAgICAgaWYgKHNyYy5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgIGRzdFtrZXldID0gc3JjW2tleV07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGRzdDtcbn1cblxuZnVuY3Rpb24gaXNSZWN0RXF1YWwocmVjdDEsIHJlY3QyKSB7XG4gIHJldHVybiBNYXRoLnJvdW5kKHJlY3QxLnRvcCkgPT09IE1hdGgucm91bmQocmVjdDIudG9wKSAmJiBNYXRoLnJvdW5kKHJlY3QxLmxlZnQpID09PSBNYXRoLnJvdW5kKHJlY3QyLmxlZnQpICYmIE1hdGgucm91bmQocmVjdDEuaGVpZ2h0KSA9PT0gTWF0aC5yb3VuZChyZWN0Mi5oZWlnaHQpICYmIE1hdGgucm91bmQocmVjdDEud2lkdGgpID09PSBNYXRoLnJvdW5kKHJlY3QyLndpZHRoKTtcbn1cblxudmFyIF90aHJvdHRsZVRpbWVvdXQ7XG5cbmZ1bmN0aW9uIHRocm90dGxlKGNhbGxiYWNrLCBtcykge1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIGlmICghX3Rocm90dGxlVGltZW91dCkge1xuICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudHMsXG4gICAgICAgICAgX3RoaXMgPSB0aGlzO1xuXG4gICAgICBpZiAoYXJncy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgY2FsbGJhY2suY2FsbChfdGhpcywgYXJnc1swXSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjYWxsYmFjay5hcHBseShfdGhpcywgYXJncyk7XG4gICAgICB9XG5cbiAgICAgIF90aHJvdHRsZVRpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgX3Rocm90dGxlVGltZW91dCA9IHZvaWQgMDtcbiAgICAgIH0sIG1zKTtcbiAgICB9XG4gIH07XG59XG5cbmZ1bmN0aW9uIGNhbmNlbFRocm90dGxlKCkge1xuICBjbGVhclRpbWVvdXQoX3Rocm90dGxlVGltZW91dCk7XG4gIF90aHJvdHRsZVRpbWVvdXQgPSB2b2lkIDA7XG59XG5cbmZ1bmN0aW9uIHNjcm9sbEJ5KGVsLCB4LCB5KSB7XG4gIGVsLnNjcm9sbExlZnQgKz0geDtcbiAgZWwuc2Nyb2xsVG9wICs9IHk7XG59XG5cbmZ1bmN0aW9uIGNsb25lKGVsKSB7XG4gIHZhciBQb2x5bWVyID0gd2luZG93LlBvbHltZXI7XG4gIHZhciAkID0gd2luZG93LmpRdWVyeSB8fCB3aW5kb3cuWmVwdG87XG5cbiAgaWYgKFBvbHltZXIgJiYgUG9seW1lci5kb20pIHtcbiAgICByZXR1cm4gUG9seW1lci5kb20oZWwpLmNsb25lTm9kZSh0cnVlKTtcbiAgfSBlbHNlIGlmICgkKSB7XG4gICAgcmV0dXJuICQoZWwpLmNsb25lKHRydWUpWzBdO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBlbC5jbG9uZU5vZGUodHJ1ZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gc2V0UmVjdChlbCwgcmVjdCkge1xuICBjc3MoZWwsICdwb3NpdGlvbicsICdhYnNvbHV0ZScpO1xuICBjc3MoZWwsICd0b3AnLCByZWN0LnRvcCk7XG4gIGNzcyhlbCwgJ2xlZnQnLCByZWN0LmxlZnQpO1xuICBjc3MoZWwsICd3aWR0aCcsIHJlY3Qud2lkdGgpO1xuICBjc3MoZWwsICdoZWlnaHQnLCByZWN0LmhlaWdodCk7XG59XG5cbmZ1bmN0aW9uIHVuc2V0UmVjdChlbCkge1xuICBjc3MoZWwsICdwb3NpdGlvbicsICcnKTtcbiAgY3NzKGVsLCAndG9wJywgJycpO1xuICBjc3MoZWwsICdsZWZ0JywgJycpO1xuICBjc3MoZWwsICd3aWR0aCcsICcnKTtcbiAgY3NzKGVsLCAnaGVpZ2h0JywgJycpO1xufVxuXG52YXIgZXhwYW5kbyA9ICdTb3J0YWJsZScgKyBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcblxuZnVuY3Rpb24gQW5pbWF0aW9uU3RhdGVNYW5hZ2VyKCkge1xuICB2YXIgYW5pbWF0aW9uU3RhdGVzID0gW10sXG4gICAgICBhbmltYXRpb25DYWxsYmFja0lkO1xuICByZXR1cm4ge1xuICAgIGNhcHR1cmVBbmltYXRpb25TdGF0ZTogZnVuY3Rpb24gY2FwdHVyZUFuaW1hdGlvblN0YXRlKCkge1xuICAgICAgYW5pbWF0aW9uU3RhdGVzID0gW107XG4gICAgICBpZiAoIXRoaXMub3B0aW9ucy5hbmltYXRpb24pIHJldHVybjtcbiAgICAgIHZhciBjaGlsZHJlbiA9IFtdLnNsaWNlLmNhbGwodGhpcy5lbC5jaGlsZHJlbik7XG4gICAgICBjaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgICBpZiAoY3NzKGNoaWxkLCAnZGlzcGxheScpID09PSAnbm9uZScgfHwgY2hpbGQgPT09IFNvcnRhYmxlLmdob3N0KSByZXR1cm47XG4gICAgICAgIGFuaW1hdGlvblN0YXRlcy5wdXNoKHtcbiAgICAgICAgICB0YXJnZXQ6IGNoaWxkLFxuICAgICAgICAgIHJlY3Q6IGdldFJlY3QoY2hpbGQpXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHZhciBmcm9tUmVjdCA9IF9vYmplY3RTcHJlYWQoe30sIGFuaW1hdGlvblN0YXRlc1thbmltYXRpb25TdGF0ZXMubGVuZ3RoIC0gMV0ucmVjdCk7IC8vIElmIGFuaW1hdGluZzogY29tcGVuc2F0ZSBmb3IgY3VycmVudCBhbmltYXRpb25cblxuXG4gICAgICAgIGlmIChjaGlsZC50aGlzQW5pbWF0aW9uRHVyYXRpb24pIHtcbiAgICAgICAgICB2YXIgY2hpbGRNYXRyaXggPSBtYXRyaXgoY2hpbGQsIHRydWUpO1xuXG4gICAgICAgICAgaWYgKGNoaWxkTWF0cml4KSB7XG4gICAgICAgICAgICBmcm9tUmVjdC50b3AgLT0gY2hpbGRNYXRyaXguZjtcbiAgICAgICAgICAgIGZyb21SZWN0LmxlZnQgLT0gY2hpbGRNYXRyaXguZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBjaGlsZC5mcm9tUmVjdCA9IGZyb21SZWN0O1xuICAgICAgfSk7XG4gICAgfSxcbiAgICBhZGRBbmltYXRpb25TdGF0ZTogZnVuY3Rpb24gYWRkQW5pbWF0aW9uU3RhdGUoc3RhdGUpIHtcbiAgICAgIGFuaW1hdGlvblN0YXRlcy5wdXNoKHN0YXRlKTtcbiAgICB9LFxuICAgIHJlbW92ZUFuaW1hdGlvblN0YXRlOiBmdW5jdGlvbiByZW1vdmVBbmltYXRpb25TdGF0ZSh0YXJnZXQpIHtcbiAgICAgIGFuaW1hdGlvblN0YXRlcy5zcGxpY2UoaW5kZXhPZk9iamVjdChhbmltYXRpb25TdGF0ZXMsIHtcbiAgICAgICAgdGFyZ2V0OiB0YXJnZXRcbiAgICAgIH0pLCAxKTtcbiAgICB9LFxuICAgIGFuaW1hdGVBbGw6IGZ1bmN0aW9uIGFuaW1hdGVBbGwoY2FsbGJhY2spIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgIGlmICghdGhpcy5vcHRpb25zLmFuaW1hdGlvbikge1xuICAgICAgICBjbGVhclRpbWVvdXQoYW5pbWF0aW9uQ2FsbGJhY2tJZCk7XG4gICAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgPT09ICdmdW5jdGlvbicpIGNhbGxiYWNrKCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIGFuaW1hdGluZyA9IGZhbHNlLFxuICAgICAgICAgIGFuaW1hdGlvblRpbWUgPSAwO1xuICAgICAgYW5pbWF0aW9uU3RhdGVzLmZvckVhY2goZnVuY3Rpb24gKHN0YXRlKSB7XG4gICAgICAgIHZhciB0aW1lID0gMCxcbiAgICAgICAgICAgIHRhcmdldCA9IHN0YXRlLnRhcmdldCxcbiAgICAgICAgICAgIGZyb21SZWN0ID0gdGFyZ2V0LmZyb21SZWN0LFxuICAgICAgICAgICAgdG9SZWN0ID0gZ2V0UmVjdCh0YXJnZXQpLFxuICAgICAgICAgICAgcHJldkZyb21SZWN0ID0gdGFyZ2V0LnByZXZGcm9tUmVjdCxcbiAgICAgICAgICAgIHByZXZUb1JlY3QgPSB0YXJnZXQucHJldlRvUmVjdCxcbiAgICAgICAgICAgIGFuaW1hdGluZ1JlY3QgPSBzdGF0ZS5yZWN0LFxuICAgICAgICAgICAgdGFyZ2V0TWF0cml4ID0gbWF0cml4KHRhcmdldCwgdHJ1ZSk7XG5cbiAgICAgICAgaWYgKHRhcmdldE1hdHJpeCkge1xuICAgICAgICAgIC8vIENvbXBlbnNhdGUgZm9yIGN1cnJlbnQgYW5pbWF0aW9uXG4gICAgICAgICAgdG9SZWN0LnRvcCAtPSB0YXJnZXRNYXRyaXguZjtcbiAgICAgICAgICB0b1JlY3QubGVmdCAtPSB0YXJnZXRNYXRyaXguZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRhcmdldC50b1JlY3QgPSB0b1JlY3Q7XG5cbiAgICAgICAgaWYgKHRhcmdldC50aGlzQW5pbWF0aW9uRHVyYXRpb24pIHtcbiAgICAgICAgICAvLyBDb3VsZCBhbHNvIGNoZWNrIGlmIGFuaW1hdGluZ1JlY3QgaXMgYmV0d2VlbiBmcm9tUmVjdCBhbmQgdG9SZWN0XG4gICAgICAgICAgaWYgKGlzUmVjdEVxdWFsKHByZXZGcm9tUmVjdCwgdG9SZWN0KSAmJiAhaXNSZWN0RXF1YWwoZnJvbVJlY3QsIHRvUmVjdCkgJiYgLy8gTWFrZSBzdXJlIGFuaW1hdGluZ1JlY3QgaXMgb24gbGluZSBiZXR3ZWVuIHRvUmVjdCAmIGZyb21SZWN0XG4gICAgICAgICAgKGFuaW1hdGluZ1JlY3QudG9wIC0gdG9SZWN0LnRvcCkgLyAoYW5pbWF0aW5nUmVjdC5sZWZ0IC0gdG9SZWN0LmxlZnQpID09PSAoZnJvbVJlY3QudG9wIC0gdG9SZWN0LnRvcCkgLyAoZnJvbVJlY3QubGVmdCAtIHRvUmVjdC5sZWZ0KSkge1xuICAgICAgICAgICAgLy8gSWYgcmV0dXJuaW5nIHRvIHNhbWUgcGxhY2UgYXMgc3RhcnRlZCBmcm9tIGFuaW1hdGlvbiBhbmQgb24gc2FtZSBheGlzXG4gICAgICAgICAgICB0aW1lID0gY2FsY3VsYXRlUmVhbFRpbWUoYW5pbWF0aW5nUmVjdCwgcHJldkZyb21SZWN0LCBwcmV2VG9SZWN0LCBfdGhpcy5vcHRpb25zKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gLy8gaWYgZnJvbVJlY3QgIT0gdG9SZWN0OiBhbmltYXRlXG5cblxuICAgICAgICBpZiAoIWlzUmVjdEVxdWFsKHRvUmVjdCwgZnJvbVJlY3QpKSB7XG4gICAgICAgICAgdGFyZ2V0LnByZXZGcm9tUmVjdCA9IGZyb21SZWN0O1xuICAgICAgICAgIHRhcmdldC5wcmV2VG9SZWN0ID0gdG9SZWN0O1xuXG4gICAgICAgICAgaWYgKCF0aW1lKSB7XG4gICAgICAgICAgICB0aW1lID0gX3RoaXMub3B0aW9ucy5hbmltYXRpb247XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgX3RoaXMuYW5pbWF0ZSh0YXJnZXQsIGFuaW1hdGluZ1JlY3QsIHRvUmVjdCwgdGltZSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGltZSkge1xuICAgICAgICAgIGFuaW1hdGluZyA9IHRydWU7XG4gICAgICAgICAgYW5pbWF0aW9uVGltZSA9IE1hdGgubWF4KGFuaW1hdGlvblRpbWUsIHRpbWUpO1xuICAgICAgICAgIGNsZWFyVGltZW91dCh0YXJnZXQuYW5pbWF0aW9uUmVzZXRUaW1lcik7XG4gICAgICAgICAgdGFyZ2V0LmFuaW1hdGlvblJlc2V0VGltZXIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRhcmdldC5hbmltYXRpb25UaW1lID0gMDtcbiAgICAgICAgICAgIHRhcmdldC5wcmV2RnJvbVJlY3QgPSBudWxsO1xuICAgICAgICAgICAgdGFyZ2V0LmZyb21SZWN0ID0gbnVsbDtcbiAgICAgICAgICAgIHRhcmdldC5wcmV2VG9SZWN0ID0gbnVsbDtcbiAgICAgICAgICAgIHRhcmdldC50aGlzQW5pbWF0aW9uRHVyYXRpb24gPSBudWxsO1xuICAgICAgICAgIH0sIHRpbWUpO1xuICAgICAgICAgIHRhcmdldC50aGlzQW5pbWF0aW9uRHVyYXRpb24gPSB0aW1lO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGNsZWFyVGltZW91dChhbmltYXRpb25DYWxsYmFja0lkKTtcblxuICAgICAgaWYgKCFhbmltYXRpbmcpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBjYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJykgY2FsbGJhY2soKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFuaW1hdGlvbkNhbGxiYWNrSWQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBpZiAodHlwZW9mIGNhbGxiYWNrID09PSAnZnVuY3Rpb24nKSBjYWxsYmFjaygpO1xuICAgICAgICB9LCBhbmltYXRpb25UaW1lKTtcbiAgICAgIH1cblxuICAgICAgYW5pbWF0aW9uU3RhdGVzID0gW107XG4gICAgfSxcbiAgICBhbmltYXRlOiBmdW5jdGlvbiBhbmltYXRlKHRhcmdldCwgY3VycmVudFJlY3QsIHRvUmVjdCwgZHVyYXRpb24pIHtcbiAgICAgIGlmIChkdXJhdGlvbikge1xuICAgICAgICBjc3ModGFyZ2V0LCAndHJhbnNpdGlvbicsICcnKTtcbiAgICAgICAgY3NzKHRhcmdldCwgJ3RyYW5zZm9ybScsICcnKTtcbiAgICAgICAgdmFyIGVsTWF0cml4ID0gbWF0cml4KHRoaXMuZWwpLFxuICAgICAgICAgICAgc2NhbGVYID0gZWxNYXRyaXggJiYgZWxNYXRyaXguYSxcbiAgICAgICAgICAgIHNjYWxlWSA9IGVsTWF0cml4ICYmIGVsTWF0cml4LmQsXG4gICAgICAgICAgICB0cmFuc2xhdGVYID0gKGN1cnJlbnRSZWN0LmxlZnQgLSB0b1JlY3QubGVmdCkgLyAoc2NhbGVYIHx8IDEpLFxuICAgICAgICAgICAgdHJhbnNsYXRlWSA9IChjdXJyZW50UmVjdC50b3AgLSB0b1JlY3QudG9wKSAvIChzY2FsZVkgfHwgMSk7XG4gICAgICAgIHRhcmdldC5hbmltYXRpbmdYID0gISF0cmFuc2xhdGVYO1xuICAgICAgICB0YXJnZXQuYW5pbWF0aW5nWSA9ICEhdHJhbnNsYXRlWTtcbiAgICAgICAgY3NzKHRhcmdldCwgJ3RyYW5zZm9ybScsICd0cmFuc2xhdGUzZCgnICsgdHJhbnNsYXRlWCArICdweCwnICsgdHJhbnNsYXRlWSArICdweCwwKScpO1xuICAgICAgICByZXBhaW50KHRhcmdldCk7IC8vIHJlcGFpbnRcblxuICAgICAgICBjc3ModGFyZ2V0LCAndHJhbnNpdGlvbicsICd0cmFuc2Zvcm0gJyArIGR1cmF0aW9uICsgJ21zJyArICh0aGlzLm9wdGlvbnMuZWFzaW5nID8gJyAnICsgdGhpcy5vcHRpb25zLmVhc2luZyA6ICcnKSk7XG4gICAgICAgIGNzcyh0YXJnZXQsICd0cmFuc2Zvcm0nLCAndHJhbnNsYXRlM2QoMCwwLDApJyk7XG4gICAgICAgIHR5cGVvZiB0YXJnZXQuYW5pbWF0ZWQgPT09ICdudW1iZXInICYmIGNsZWFyVGltZW91dCh0YXJnZXQuYW5pbWF0ZWQpO1xuICAgICAgICB0YXJnZXQuYW5pbWF0ZWQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBjc3ModGFyZ2V0LCAndHJhbnNpdGlvbicsICcnKTtcbiAgICAgICAgICBjc3ModGFyZ2V0LCAndHJhbnNmb3JtJywgJycpO1xuICAgICAgICAgIHRhcmdldC5hbmltYXRlZCA9IGZhbHNlO1xuICAgICAgICAgIHRhcmdldC5hbmltYXRpbmdYID0gZmFsc2U7XG4gICAgICAgICAgdGFyZ2V0LmFuaW1hdGluZ1kgPSBmYWxzZTtcbiAgICAgICAgfSwgZHVyYXRpb24pO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbn1cblxuZnVuY3Rpb24gcmVwYWludCh0YXJnZXQpIHtcbiAgcmV0dXJuIHRhcmdldC5vZmZzZXRXaWR0aDtcbn1cblxuZnVuY3Rpb24gY2FsY3VsYXRlUmVhbFRpbWUoYW5pbWF0aW5nUmVjdCwgZnJvbVJlY3QsIHRvUmVjdCwgb3B0aW9ucykge1xuICByZXR1cm4gTWF0aC5zcXJ0KE1hdGgucG93KGZyb21SZWN0LnRvcCAtIGFuaW1hdGluZ1JlY3QudG9wLCAyKSArIE1hdGgucG93KGZyb21SZWN0LmxlZnQgLSBhbmltYXRpbmdSZWN0LmxlZnQsIDIpKSAvIE1hdGguc3FydChNYXRoLnBvdyhmcm9tUmVjdC50b3AgLSB0b1JlY3QudG9wLCAyKSArIE1hdGgucG93KGZyb21SZWN0LmxlZnQgLSB0b1JlY3QubGVmdCwgMikpICogb3B0aW9ucy5hbmltYXRpb247XG59XG5cbnZhciBwbHVnaW5zID0gW107XG52YXIgZGVmYXVsdHMgPSB7XG4gIGluaXRpYWxpemVCeURlZmF1bHQ6IHRydWVcbn07XG52YXIgUGx1Z2luTWFuYWdlciA9IHtcbiAgbW91bnQ6IGZ1bmN0aW9uIG1vdW50KHBsdWdpbikge1xuICAgIC8vIFNldCBkZWZhdWx0IHN0YXRpYyBwcm9wZXJ0aWVzXG4gICAgZm9yICh2YXIgb3B0aW9uIGluIGRlZmF1bHRzKSB7XG4gICAgICBpZiAoZGVmYXVsdHMuaGFzT3duUHJvcGVydHkob3B0aW9uKSAmJiAhKG9wdGlvbiBpbiBwbHVnaW4pKSB7XG4gICAgICAgIHBsdWdpbltvcHRpb25dID0gZGVmYXVsdHNbb3B0aW9uXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBwbHVnaW5zLnB1c2gocGx1Z2luKTtcbiAgfSxcbiAgcGx1Z2luRXZlbnQ6IGZ1bmN0aW9uIHBsdWdpbkV2ZW50KGV2ZW50TmFtZSwgc29ydGFibGUsIGV2dCkge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICB0aGlzLmV2ZW50Q2FuY2VsZWQgPSBmYWxzZTtcblxuICAgIGV2dC5jYW5jZWwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBfdGhpcy5ldmVudENhbmNlbGVkID0gdHJ1ZTtcbiAgICB9O1xuXG4gICAgdmFyIGV2ZW50TmFtZUdsb2JhbCA9IGV2ZW50TmFtZSArICdHbG9iYWwnO1xuICAgIHBsdWdpbnMuZm9yRWFjaChmdW5jdGlvbiAocGx1Z2luKSB7XG4gICAgICBpZiAoIXNvcnRhYmxlW3BsdWdpbi5wbHVnaW5OYW1lXSkgcmV0dXJuOyAvLyBGaXJlIGdsb2JhbCBldmVudHMgaWYgaXQgZXhpc3RzIGluIHRoaXMgc29ydGFibGVcblxuICAgICAgaWYgKHNvcnRhYmxlW3BsdWdpbi5wbHVnaW5OYW1lXVtldmVudE5hbWVHbG9iYWxdKSB7XG4gICAgICAgIHNvcnRhYmxlW3BsdWdpbi5wbHVnaW5OYW1lXVtldmVudE5hbWVHbG9iYWxdKF9vYmplY3RTcHJlYWQoe1xuICAgICAgICAgIHNvcnRhYmxlOiBzb3J0YWJsZVxuICAgICAgICB9LCBldnQpKTtcbiAgICAgIH0gLy8gT25seSBmaXJlIHBsdWdpbiBldmVudCBpZiBwbHVnaW4gaXMgZW5hYmxlZCBpbiB0aGlzIHNvcnRhYmxlLFxuICAgICAgLy8gYW5kIHBsdWdpbiBoYXMgZXZlbnQgZGVmaW5lZFxuXG5cbiAgICAgIGlmIChzb3J0YWJsZS5vcHRpb25zW3BsdWdpbi5wbHVnaW5OYW1lXSAmJiBzb3J0YWJsZVtwbHVnaW4ucGx1Z2luTmFtZV1bZXZlbnROYW1lXSkge1xuICAgICAgICBzb3J0YWJsZVtwbHVnaW4ucGx1Z2luTmFtZV1bZXZlbnROYW1lXShfb2JqZWN0U3ByZWFkKHtcbiAgICAgICAgICBzb3J0YWJsZTogc29ydGFibGVcbiAgICAgICAgfSwgZXZ0KSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0sXG4gIGluaXRpYWxpemVQbHVnaW5zOiBmdW5jdGlvbiBpbml0aWFsaXplUGx1Z2lucyhzb3J0YWJsZSwgZWwsIGRlZmF1bHRzLCBvcHRpb25zKSB7XG4gICAgcGx1Z2lucy5mb3JFYWNoKGZ1bmN0aW9uIChwbHVnaW4pIHtcbiAgICAgIHZhciBwbHVnaW5OYW1lID0gcGx1Z2luLnBsdWdpbk5hbWU7XG4gICAgICBpZiAoIXNvcnRhYmxlLm9wdGlvbnNbcGx1Z2luTmFtZV0gJiYgIXBsdWdpbi5pbml0aWFsaXplQnlEZWZhdWx0KSByZXR1cm47XG4gICAgICB2YXIgaW5pdGlhbGl6ZWQgPSBuZXcgcGx1Z2luKHNvcnRhYmxlLCBlbCwgc29ydGFibGUub3B0aW9ucyk7XG4gICAgICBpbml0aWFsaXplZC5zb3J0YWJsZSA9IHNvcnRhYmxlO1xuICAgICAgaW5pdGlhbGl6ZWQub3B0aW9ucyA9IHNvcnRhYmxlLm9wdGlvbnM7XG4gICAgICBzb3J0YWJsZVtwbHVnaW5OYW1lXSA9IGluaXRpYWxpemVkOyAvLyBBZGQgZGVmYXVsdCBvcHRpb25zIGZyb20gcGx1Z2luXG5cbiAgICAgIF9leHRlbmRzKGRlZmF1bHRzLCBpbml0aWFsaXplZC5kZWZhdWx0cyk7XG4gICAgfSk7XG5cbiAgICBmb3IgKHZhciBvcHRpb24gaW4gc29ydGFibGUub3B0aW9ucykge1xuICAgICAgaWYgKCFzb3J0YWJsZS5vcHRpb25zLmhhc093blByb3BlcnR5KG9wdGlvbikpIGNvbnRpbnVlO1xuICAgICAgdmFyIG1vZGlmaWVkID0gdGhpcy5tb2RpZnlPcHRpb24oc29ydGFibGUsIG9wdGlvbiwgc29ydGFibGUub3B0aW9uc1tvcHRpb25dKTtcblxuICAgICAgaWYgKHR5cGVvZiBtb2RpZmllZCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgc29ydGFibGUub3B0aW9uc1tvcHRpb25dID0gbW9kaWZpZWQ7XG4gICAgICB9XG4gICAgfVxuICB9LFxuICBnZXRFdmVudFByb3BlcnRpZXM6IGZ1bmN0aW9uIGdldEV2ZW50UHJvcGVydGllcyhuYW1lLCBzb3J0YWJsZSkge1xuICAgIHZhciBldmVudFByb3BlcnRpZXMgPSB7fTtcbiAgICBwbHVnaW5zLmZvckVhY2goZnVuY3Rpb24gKHBsdWdpbikge1xuICAgICAgaWYgKHR5cGVvZiBwbHVnaW4uZXZlbnRQcm9wZXJ0aWVzICE9PSAnZnVuY3Rpb24nKSByZXR1cm47XG5cbiAgICAgIF9leHRlbmRzKGV2ZW50UHJvcGVydGllcywgcGx1Z2luLmV2ZW50UHJvcGVydGllcy5jYWxsKHNvcnRhYmxlW3BsdWdpbi5wbHVnaW5OYW1lXSwgbmFtZSkpO1xuICAgIH0pO1xuICAgIHJldHVybiBldmVudFByb3BlcnRpZXM7XG4gIH0sXG4gIG1vZGlmeU9wdGlvbjogZnVuY3Rpb24gbW9kaWZ5T3B0aW9uKHNvcnRhYmxlLCBuYW1lLCB2YWx1ZSkge1xuICAgIHZhciBtb2RpZmllZFZhbHVlO1xuICAgIHBsdWdpbnMuZm9yRWFjaChmdW5jdGlvbiAocGx1Z2luKSB7XG4gICAgICAvLyBQbHVnaW4gbXVzdCBleGlzdCBvbiB0aGUgU29ydGFibGVcbiAgICAgIGlmICghc29ydGFibGVbcGx1Z2luLnBsdWdpbk5hbWVdKSByZXR1cm47IC8vIElmIHN0YXRpYyBvcHRpb24gbGlzdGVuZXIgZXhpc3RzIGZvciB0aGlzIG9wdGlvbiwgY2FsbCBpbiB0aGUgY29udGV4dCBvZiB0aGUgU29ydGFibGUncyBpbnN0YW5jZSBvZiB0aGlzIHBsdWdpblxuXG4gICAgICBpZiAocGx1Z2luLm9wdGlvbkxpc3RlbmVycyAmJiB0eXBlb2YgcGx1Z2luLm9wdGlvbkxpc3RlbmVyc1tuYW1lXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBtb2RpZmllZFZhbHVlID0gcGx1Z2luLm9wdGlvbkxpc3RlbmVyc1tuYW1lXS5jYWxsKHNvcnRhYmxlW3BsdWdpbi5wbHVnaW5OYW1lXSwgdmFsdWUpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBtb2RpZmllZFZhbHVlO1xuICB9XG59O1xuXG5mdW5jdGlvbiBkaXNwYXRjaEV2ZW50KF9yZWYpIHtcbiAgdmFyIHNvcnRhYmxlID0gX3JlZi5zb3J0YWJsZSxcbiAgICAgIHJvb3RFbCA9IF9yZWYucm9vdEVsLFxuICAgICAgbmFtZSA9IF9yZWYubmFtZSxcbiAgICAgIHRhcmdldEVsID0gX3JlZi50YXJnZXRFbCxcbiAgICAgIGNsb25lRWwgPSBfcmVmLmNsb25lRWwsXG4gICAgICB0b0VsID0gX3JlZi50b0VsLFxuICAgICAgZnJvbUVsID0gX3JlZi5mcm9tRWwsXG4gICAgICBvbGRJbmRleCA9IF9yZWYub2xkSW5kZXgsXG4gICAgICBuZXdJbmRleCA9IF9yZWYubmV3SW5kZXgsXG4gICAgICBvbGREcmFnZ2FibGVJbmRleCA9IF9yZWYub2xkRHJhZ2dhYmxlSW5kZXgsXG4gICAgICBuZXdEcmFnZ2FibGVJbmRleCA9IF9yZWYubmV3RHJhZ2dhYmxlSW5kZXgsXG4gICAgICBvcmlnaW5hbEV2ZW50ID0gX3JlZi5vcmlnaW5hbEV2ZW50LFxuICAgICAgcHV0U29ydGFibGUgPSBfcmVmLnB1dFNvcnRhYmxlLFxuICAgICAgZXh0cmFFdmVudFByb3BlcnRpZXMgPSBfcmVmLmV4dHJhRXZlbnRQcm9wZXJ0aWVzO1xuICBzb3J0YWJsZSA9IHNvcnRhYmxlIHx8IHJvb3RFbCAmJiByb290RWxbZXhwYW5kb107XG4gIGlmICghc29ydGFibGUpIHJldHVybjtcbiAgdmFyIGV2dCxcbiAgICAgIG9wdGlvbnMgPSBzb3J0YWJsZS5vcHRpb25zLFxuICAgICAgb25OYW1lID0gJ29uJyArIG5hbWUuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBuYW1lLnN1YnN0cigxKTsgLy8gU3VwcG9ydCBmb3IgbmV3IEN1c3RvbUV2ZW50IGZlYXR1cmVcblxuICBpZiAod2luZG93LkN1c3RvbUV2ZW50ICYmICFJRTExT3JMZXNzICYmICFFZGdlKSB7XG4gICAgZXZ0ID0gbmV3IEN1c3RvbUV2ZW50KG5hbWUsIHtcbiAgICAgIGJ1YmJsZXM6IHRydWUsXG4gICAgICBjYW5jZWxhYmxlOiB0cnVlXG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgZXZ0ID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoJ0V2ZW50Jyk7XG4gICAgZXZ0LmluaXRFdmVudChuYW1lLCB0cnVlLCB0cnVlKTtcbiAgfVxuXG4gIGV2dC50byA9IHRvRWwgfHwgcm9vdEVsO1xuICBldnQuZnJvbSA9IGZyb21FbCB8fCByb290RWw7XG4gIGV2dC5pdGVtID0gdGFyZ2V0RWwgfHwgcm9vdEVsO1xuICBldnQuY2xvbmUgPSBjbG9uZUVsO1xuICBldnQub2xkSW5kZXggPSBvbGRJbmRleDtcbiAgZXZ0Lm5ld0luZGV4ID0gbmV3SW5kZXg7XG4gIGV2dC5vbGREcmFnZ2FibGVJbmRleCA9IG9sZERyYWdnYWJsZUluZGV4O1xuICBldnQubmV3RHJhZ2dhYmxlSW5kZXggPSBuZXdEcmFnZ2FibGVJbmRleDtcbiAgZXZ0Lm9yaWdpbmFsRXZlbnQgPSBvcmlnaW5hbEV2ZW50O1xuICBldnQucHVsbE1vZGUgPSBwdXRTb3J0YWJsZSA/IHB1dFNvcnRhYmxlLmxhc3RQdXRNb2RlIDogdW5kZWZpbmVkO1xuXG4gIHZhciBhbGxFdmVudFByb3BlcnRpZXMgPSBfb2JqZWN0U3ByZWFkKHt9LCBleHRyYUV2ZW50UHJvcGVydGllcywgUGx1Z2luTWFuYWdlci5nZXRFdmVudFByb3BlcnRpZXMobmFtZSwgc29ydGFibGUpKTtcblxuICBmb3IgKHZhciBvcHRpb24gaW4gYWxsRXZlbnRQcm9wZXJ0aWVzKSB7XG4gICAgZXZ0W29wdGlvbl0gPSBhbGxFdmVudFByb3BlcnRpZXNbb3B0aW9uXTtcbiAgfVxuXG4gIGlmIChyb290RWwpIHtcbiAgICByb290RWwuZGlzcGF0Y2hFdmVudChldnQpO1xuICB9XG5cbiAgaWYgKG9wdGlvbnNbb25OYW1lXSkge1xuICAgIG9wdGlvbnNbb25OYW1lXS5jYWxsKHNvcnRhYmxlLCBldnQpO1xuICB9XG59XG5cbnZhciBwbHVnaW5FdmVudCA9IGZ1bmN0aW9uIHBsdWdpbkV2ZW50KGV2ZW50TmFtZSwgc29ydGFibGUpIHtcbiAgdmFyIF9yZWYgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9LFxuICAgICAgb3JpZ2luYWxFdmVudCA9IF9yZWYuZXZ0LFxuICAgICAgZGF0YSA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhfcmVmLCBbXCJldnRcIl0pO1xuXG4gIFBsdWdpbk1hbmFnZXIucGx1Z2luRXZlbnQuYmluZChTb3J0YWJsZSkoZXZlbnROYW1lLCBzb3J0YWJsZSwgX29iamVjdFNwcmVhZCh7XG4gICAgZHJhZ0VsOiBkcmFnRWwsXG4gICAgcGFyZW50RWw6IHBhcmVudEVsLFxuICAgIGdob3N0RWw6IGdob3N0RWwsXG4gICAgcm9vdEVsOiByb290RWwsXG4gICAgbmV4dEVsOiBuZXh0RWwsXG4gICAgbGFzdERvd25FbDogbGFzdERvd25FbCxcbiAgICBjbG9uZUVsOiBjbG9uZUVsLFxuICAgIGNsb25lSGlkZGVuOiBjbG9uZUhpZGRlbixcbiAgICBkcmFnU3RhcnRlZDogbW92ZWQsXG4gICAgcHV0U29ydGFibGU6IHB1dFNvcnRhYmxlLFxuICAgIGFjdGl2ZVNvcnRhYmxlOiBTb3J0YWJsZS5hY3RpdmUsXG4gICAgb3JpZ2luYWxFdmVudDogb3JpZ2luYWxFdmVudCxcbiAgICBvbGRJbmRleDogb2xkSW5kZXgsXG4gICAgb2xkRHJhZ2dhYmxlSW5kZXg6IG9sZERyYWdnYWJsZUluZGV4LFxuICAgIG5ld0luZGV4OiBuZXdJbmRleCxcbiAgICBuZXdEcmFnZ2FibGVJbmRleDogbmV3RHJhZ2dhYmxlSW5kZXgsXG4gICAgaGlkZUdob3N0Rm9yVGFyZ2V0OiBfaGlkZUdob3N0Rm9yVGFyZ2V0LFxuICAgIHVuaGlkZUdob3N0Rm9yVGFyZ2V0OiBfdW5oaWRlR2hvc3RGb3JUYXJnZXQsXG4gICAgY2xvbmVOb3dIaWRkZW46IGZ1bmN0aW9uIGNsb25lTm93SGlkZGVuKCkge1xuICAgICAgY2xvbmVIaWRkZW4gPSB0cnVlO1xuICAgIH0sXG4gICAgY2xvbmVOb3dTaG93bjogZnVuY3Rpb24gY2xvbmVOb3dTaG93bigpIHtcbiAgICAgIGNsb25lSGlkZGVuID0gZmFsc2U7XG4gICAgfSxcbiAgICBkaXNwYXRjaFNvcnRhYmxlRXZlbnQ6IGZ1bmN0aW9uIGRpc3BhdGNoU29ydGFibGVFdmVudChuYW1lKSB7XG4gICAgICBfZGlzcGF0Y2hFdmVudCh7XG4gICAgICAgIHNvcnRhYmxlOiBzb3J0YWJsZSxcbiAgICAgICAgbmFtZTogbmFtZSxcbiAgICAgICAgb3JpZ2luYWxFdmVudDogb3JpZ2luYWxFdmVudFxuICAgICAgfSk7XG4gICAgfVxuICB9LCBkYXRhKSk7XG59O1xuXG5mdW5jdGlvbiBfZGlzcGF0Y2hFdmVudChpbmZvKSB7XG4gIGRpc3BhdGNoRXZlbnQoX29iamVjdFNwcmVhZCh7XG4gICAgcHV0U29ydGFibGU6IHB1dFNvcnRhYmxlLFxuICAgIGNsb25lRWw6IGNsb25lRWwsXG4gICAgdGFyZ2V0RWw6IGRyYWdFbCxcbiAgICByb290RWw6IHJvb3RFbCxcbiAgICBvbGRJbmRleDogb2xkSW5kZXgsXG4gICAgb2xkRHJhZ2dhYmxlSW5kZXg6IG9sZERyYWdnYWJsZUluZGV4LFxuICAgIG5ld0luZGV4OiBuZXdJbmRleCxcbiAgICBuZXdEcmFnZ2FibGVJbmRleDogbmV3RHJhZ2dhYmxlSW5kZXhcbiAgfSwgaW5mbykpO1xufVxuXG52YXIgZHJhZ0VsLFxuICAgIHBhcmVudEVsLFxuICAgIGdob3N0RWwsXG4gICAgcm9vdEVsLFxuICAgIG5leHRFbCxcbiAgICBsYXN0RG93bkVsLFxuICAgIGNsb25lRWwsXG4gICAgY2xvbmVIaWRkZW4sXG4gICAgb2xkSW5kZXgsXG4gICAgbmV3SW5kZXgsXG4gICAgb2xkRHJhZ2dhYmxlSW5kZXgsXG4gICAgbmV3RHJhZ2dhYmxlSW5kZXgsXG4gICAgYWN0aXZlR3JvdXAsXG4gICAgcHV0U29ydGFibGUsXG4gICAgYXdhaXRpbmdEcmFnU3RhcnRlZCA9IGZhbHNlLFxuICAgIGlnbm9yZU5leHRDbGljayA9IGZhbHNlLFxuICAgIHNvcnRhYmxlcyA9IFtdLFxuICAgIHRhcEV2dCxcbiAgICB0b3VjaEV2dCxcbiAgICBsYXN0RHgsXG4gICAgbGFzdER5LFxuICAgIHRhcERpc3RhbmNlTGVmdCxcbiAgICB0YXBEaXN0YW5jZVRvcCxcbiAgICBtb3ZlZCxcbiAgICBsYXN0VGFyZ2V0LFxuICAgIGxhc3REaXJlY3Rpb24sXG4gICAgcGFzdEZpcnN0SW52ZXJ0VGhyZXNoID0gZmFsc2UsXG4gICAgaXNDaXJjdW1zdGFudGlhbEludmVydCA9IGZhbHNlLFxuICAgIHRhcmdldE1vdmVEaXN0YW5jZSxcbiAgICAvLyBGb3IgcG9zaXRpb25pbmcgZ2hvc3QgYWJzb2x1dGVseVxuZ2hvc3RSZWxhdGl2ZVBhcmVudCxcbiAgICBnaG9zdFJlbGF0aXZlUGFyZW50SW5pdGlhbFNjcm9sbCA9IFtdLFxuICAgIC8vIChsZWZ0LCB0b3ApXG5fc2lsZW50ID0gZmFsc2UsXG4gICAgc2F2ZWRJbnB1dENoZWNrZWQgPSBbXTtcbi8qKiBAY29uc3QgKi9cblxudmFyIGRvY3VtZW50RXhpc3RzID0gdHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJyxcbiAgICBQb3NpdGlvbkdob3N0QWJzb2x1dGVseSA9IElPUyxcbiAgICBDU1NGbG9hdFByb3BlcnR5ID0gRWRnZSB8fCBJRTExT3JMZXNzID8gJ2Nzc0Zsb2F0JyA6ICdmbG9hdCcsXG4gICAgLy8gVGhpcyB3aWxsIG5vdCBwYXNzIGZvciBJRTksIGJlY2F1c2UgSUU5IERuRCBvbmx5IHdvcmtzIG9uIGFuY2hvcnNcbnN1cHBvcnREcmFnZ2FibGUgPSBkb2N1bWVudEV4aXN0cyAmJiAhQ2hyb21lRm9yQW5kcm9pZCAmJiAhSU9TICYmICdkcmFnZ2FibGUnIGluIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpLFxuICAgIHN1cHBvcnRDc3NQb2ludGVyRXZlbnRzID0gZnVuY3Rpb24gKCkge1xuICBpZiAoIWRvY3VtZW50RXhpc3RzKSByZXR1cm47IC8vIGZhbHNlIHdoZW4gPD0gSUUxMVxuXG4gIGlmIChJRTExT3JMZXNzKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgdmFyIGVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgneCcpO1xuICBlbC5zdHlsZS5jc3NUZXh0ID0gJ3BvaW50ZXItZXZlbnRzOmF1dG8nO1xuICByZXR1cm4gZWwuc3R5bGUucG9pbnRlckV2ZW50cyA9PT0gJ2F1dG8nO1xufSgpLFxuICAgIF9kZXRlY3REaXJlY3Rpb24gPSBmdW5jdGlvbiBfZGV0ZWN0RGlyZWN0aW9uKGVsLCBvcHRpb25zKSB7XG4gIHZhciBlbENTUyA9IGNzcyhlbCksXG4gICAgICBlbFdpZHRoID0gcGFyc2VJbnQoZWxDU1Mud2lkdGgpIC0gcGFyc2VJbnQoZWxDU1MucGFkZGluZ0xlZnQpIC0gcGFyc2VJbnQoZWxDU1MucGFkZGluZ1JpZ2h0KSAtIHBhcnNlSW50KGVsQ1NTLmJvcmRlckxlZnRXaWR0aCkgLSBwYXJzZUludChlbENTUy5ib3JkZXJSaWdodFdpZHRoKSxcbiAgICAgIGNoaWxkMSA9IGdldENoaWxkKGVsLCAwLCBvcHRpb25zKSxcbiAgICAgIGNoaWxkMiA9IGdldENoaWxkKGVsLCAxLCBvcHRpb25zKSxcbiAgICAgIGZpcnN0Q2hpbGRDU1MgPSBjaGlsZDEgJiYgY3NzKGNoaWxkMSksXG4gICAgICBzZWNvbmRDaGlsZENTUyA9IGNoaWxkMiAmJiBjc3MoY2hpbGQyKSxcbiAgICAgIGZpcnN0Q2hpbGRXaWR0aCA9IGZpcnN0Q2hpbGRDU1MgJiYgcGFyc2VJbnQoZmlyc3RDaGlsZENTUy5tYXJnaW5MZWZ0KSArIHBhcnNlSW50KGZpcnN0Q2hpbGRDU1MubWFyZ2luUmlnaHQpICsgZ2V0UmVjdChjaGlsZDEpLndpZHRoLFxuICAgICAgc2Vjb25kQ2hpbGRXaWR0aCA9IHNlY29uZENoaWxkQ1NTICYmIHBhcnNlSW50KHNlY29uZENoaWxkQ1NTLm1hcmdpbkxlZnQpICsgcGFyc2VJbnQoc2Vjb25kQ2hpbGRDU1MubWFyZ2luUmlnaHQpICsgZ2V0UmVjdChjaGlsZDIpLndpZHRoO1xuXG4gIGlmIChlbENTUy5kaXNwbGF5ID09PSAnZmxleCcpIHtcbiAgICByZXR1cm4gZWxDU1MuZmxleERpcmVjdGlvbiA9PT0gJ2NvbHVtbicgfHwgZWxDU1MuZmxleERpcmVjdGlvbiA9PT0gJ2NvbHVtbi1yZXZlcnNlJyA/ICd2ZXJ0aWNhbCcgOiAnaG9yaXpvbnRhbCc7XG4gIH1cblxuICBpZiAoZWxDU1MuZGlzcGxheSA9PT0gJ2dyaWQnKSB7XG4gICAgcmV0dXJuIGVsQ1NTLmdyaWRUZW1wbGF0ZUNvbHVtbnMuc3BsaXQoJyAnKS5sZW5ndGggPD0gMSA/ICd2ZXJ0aWNhbCcgOiAnaG9yaXpvbnRhbCc7XG4gIH1cblxuICBpZiAoY2hpbGQxICYmIGZpcnN0Q2hpbGRDU1NbXCJmbG9hdFwiXSAmJiBmaXJzdENoaWxkQ1NTW1wiZmxvYXRcIl0gIT09ICdub25lJykge1xuICAgIHZhciB0b3VjaGluZ1NpZGVDaGlsZDIgPSBmaXJzdENoaWxkQ1NTW1wiZmxvYXRcIl0gPT09ICdsZWZ0JyA/ICdsZWZ0JyA6ICdyaWdodCc7XG4gICAgcmV0dXJuIGNoaWxkMiAmJiAoc2Vjb25kQ2hpbGRDU1MuY2xlYXIgPT09ICdib3RoJyB8fCBzZWNvbmRDaGlsZENTUy5jbGVhciA9PT0gdG91Y2hpbmdTaWRlQ2hpbGQyKSA/ICd2ZXJ0aWNhbCcgOiAnaG9yaXpvbnRhbCc7XG4gIH1cblxuICByZXR1cm4gY2hpbGQxICYmIChmaXJzdENoaWxkQ1NTLmRpc3BsYXkgPT09ICdibG9jaycgfHwgZmlyc3RDaGlsZENTUy5kaXNwbGF5ID09PSAnZmxleCcgfHwgZmlyc3RDaGlsZENTUy5kaXNwbGF5ID09PSAndGFibGUnIHx8IGZpcnN0Q2hpbGRDU1MuZGlzcGxheSA9PT0gJ2dyaWQnIHx8IGZpcnN0Q2hpbGRXaWR0aCA+PSBlbFdpZHRoICYmIGVsQ1NTW0NTU0Zsb2F0UHJvcGVydHldID09PSAnbm9uZScgfHwgY2hpbGQyICYmIGVsQ1NTW0NTU0Zsb2F0UHJvcGVydHldID09PSAnbm9uZScgJiYgZmlyc3RDaGlsZFdpZHRoICsgc2Vjb25kQ2hpbGRXaWR0aCA+IGVsV2lkdGgpID8gJ3ZlcnRpY2FsJyA6ICdob3Jpem9udGFsJztcbn0sXG4gICAgX2RyYWdFbEluUm93Q29sdW1uID0gZnVuY3Rpb24gX2RyYWdFbEluUm93Q29sdW1uKGRyYWdSZWN0LCB0YXJnZXRSZWN0LCB2ZXJ0aWNhbCkge1xuICB2YXIgZHJhZ0VsUzFPcHAgPSB2ZXJ0aWNhbCA/IGRyYWdSZWN0LmxlZnQgOiBkcmFnUmVjdC50b3AsXG4gICAgICBkcmFnRWxTMk9wcCA9IHZlcnRpY2FsID8gZHJhZ1JlY3QucmlnaHQgOiBkcmFnUmVjdC5ib3R0b20sXG4gICAgICBkcmFnRWxPcHBMZW5ndGggPSB2ZXJ0aWNhbCA/IGRyYWdSZWN0LndpZHRoIDogZHJhZ1JlY3QuaGVpZ2h0LFxuICAgICAgdGFyZ2V0UzFPcHAgPSB2ZXJ0aWNhbCA/IHRhcmdldFJlY3QubGVmdCA6IHRhcmdldFJlY3QudG9wLFxuICAgICAgdGFyZ2V0UzJPcHAgPSB2ZXJ0aWNhbCA/IHRhcmdldFJlY3QucmlnaHQgOiB0YXJnZXRSZWN0LmJvdHRvbSxcbiAgICAgIHRhcmdldE9wcExlbmd0aCA9IHZlcnRpY2FsID8gdGFyZ2V0UmVjdC53aWR0aCA6IHRhcmdldFJlY3QuaGVpZ2h0O1xuICByZXR1cm4gZHJhZ0VsUzFPcHAgPT09IHRhcmdldFMxT3BwIHx8IGRyYWdFbFMyT3BwID09PSB0YXJnZXRTMk9wcCB8fCBkcmFnRWxTMU9wcCArIGRyYWdFbE9wcExlbmd0aCAvIDIgPT09IHRhcmdldFMxT3BwICsgdGFyZ2V0T3BwTGVuZ3RoIC8gMjtcbn0sXG5cbi8qKlxuICogRGV0ZWN0cyBmaXJzdCBuZWFyZXN0IGVtcHR5IHNvcnRhYmxlIHRvIFggYW5kIFkgcG9zaXRpb24gdXNpbmcgZW1wdHlJbnNlcnRUaHJlc2hvbGQuXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IHggICAgICBYIHBvc2l0aW9uXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IHkgICAgICBZIHBvc2l0aW9uXG4gKiBAcmV0dXJuIHtIVE1MRWxlbWVudH0gICBFbGVtZW50IG9mIHRoZSBmaXJzdCBmb3VuZCBuZWFyZXN0IFNvcnRhYmxlXG4gKi9cbl9kZXRlY3ROZWFyZXN0RW1wdHlTb3J0YWJsZSA9IGZ1bmN0aW9uIF9kZXRlY3ROZWFyZXN0RW1wdHlTb3J0YWJsZSh4LCB5KSB7XG4gIHZhciByZXQ7XG4gIHNvcnRhYmxlcy5zb21lKGZ1bmN0aW9uIChzb3J0YWJsZSkge1xuICAgIGlmIChsYXN0Q2hpbGQoc29ydGFibGUpKSByZXR1cm47XG4gICAgdmFyIHJlY3QgPSBnZXRSZWN0KHNvcnRhYmxlKSxcbiAgICAgICAgdGhyZXNob2xkID0gc29ydGFibGVbZXhwYW5kb10ub3B0aW9ucy5lbXB0eUluc2VydFRocmVzaG9sZCxcbiAgICAgICAgaW5zaWRlSG9yaXpvbnRhbGx5ID0geCA+PSByZWN0LmxlZnQgLSB0aHJlc2hvbGQgJiYgeCA8PSByZWN0LnJpZ2h0ICsgdGhyZXNob2xkLFxuICAgICAgICBpbnNpZGVWZXJ0aWNhbGx5ID0geSA+PSByZWN0LnRvcCAtIHRocmVzaG9sZCAmJiB5IDw9IHJlY3QuYm90dG9tICsgdGhyZXNob2xkO1xuXG4gICAgaWYgKHRocmVzaG9sZCAmJiBpbnNpZGVIb3Jpem9udGFsbHkgJiYgaW5zaWRlVmVydGljYWxseSkge1xuICAgICAgcmV0dXJuIHJldCA9IHNvcnRhYmxlO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiByZXQ7XG59LFxuICAgIF9wcmVwYXJlR3JvdXAgPSBmdW5jdGlvbiBfcHJlcGFyZUdyb3VwKG9wdGlvbnMpIHtcbiAgZnVuY3Rpb24gdG9Gbih2YWx1ZSwgcHVsbCkge1xuICAgIHJldHVybiBmdW5jdGlvbiAodG8sIGZyb20sIGRyYWdFbCwgZXZ0KSB7XG4gICAgICB2YXIgc2FtZUdyb3VwID0gdG8ub3B0aW9ucy5ncm91cC5uYW1lICYmIGZyb20ub3B0aW9ucy5ncm91cC5uYW1lICYmIHRvLm9wdGlvbnMuZ3JvdXAubmFtZSA9PT0gZnJvbS5vcHRpb25zLmdyb3VwLm5hbWU7XG5cbiAgICAgIGlmICh2YWx1ZSA9PSBudWxsICYmIChwdWxsIHx8IHNhbWVHcm91cCkpIHtcbiAgICAgICAgLy8gRGVmYXVsdCBwdWxsIHZhbHVlXG4gICAgICAgIC8vIERlZmF1bHQgcHVsbCBhbmQgcHV0IHZhbHVlIGlmIHNhbWUgZ3JvdXBcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9IGVsc2UgaWYgKHZhbHVlID09IG51bGwgfHwgdmFsdWUgPT09IGZhbHNlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH0gZWxzZSBpZiAocHVsbCAmJiB2YWx1ZSA9PT0gJ2Nsb25lJykge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4gdG9Gbih2YWx1ZSh0bywgZnJvbSwgZHJhZ0VsLCBldnQpLCBwdWxsKSh0bywgZnJvbSwgZHJhZ0VsLCBldnQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIG90aGVyR3JvdXAgPSAocHVsbCA/IHRvIDogZnJvbSkub3B0aW9ucy5ncm91cC5uYW1lO1xuICAgICAgICByZXR1cm4gdmFsdWUgPT09IHRydWUgfHwgdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyAmJiB2YWx1ZSA9PT0gb3RoZXJHcm91cCB8fCB2YWx1ZS5qb2luICYmIHZhbHVlLmluZGV4T2Yob3RoZXJHcm91cCkgPiAtMTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgdmFyIGdyb3VwID0ge307XG4gIHZhciBvcmlnaW5hbEdyb3VwID0gb3B0aW9ucy5ncm91cDtcblxuICBpZiAoIW9yaWdpbmFsR3JvdXAgfHwgX3R5cGVvZihvcmlnaW5hbEdyb3VwKSAhPSAnb2JqZWN0Jykge1xuICAgIG9yaWdpbmFsR3JvdXAgPSB7XG4gICAgICBuYW1lOiBvcmlnaW5hbEdyb3VwXG4gICAgfTtcbiAgfVxuXG4gIGdyb3VwLm5hbWUgPSBvcmlnaW5hbEdyb3VwLm5hbWU7XG4gIGdyb3VwLmNoZWNrUHVsbCA9IHRvRm4ob3JpZ2luYWxHcm91cC5wdWxsLCB0cnVlKTtcbiAgZ3JvdXAuY2hlY2tQdXQgPSB0b0ZuKG9yaWdpbmFsR3JvdXAucHV0KTtcbiAgZ3JvdXAucmV2ZXJ0Q2xvbmUgPSBvcmlnaW5hbEdyb3VwLnJldmVydENsb25lO1xuICBvcHRpb25zLmdyb3VwID0gZ3JvdXA7XG59LFxuICAgIF9oaWRlR2hvc3RGb3JUYXJnZXQgPSBmdW5jdGlvbiBfaGlkZUdob3N0Rm9yVGFyZ2V0KCkge1xuICBpZiAoIXN1cHBvcnRDc3NQb2ludGVyRXZlbnRzICYmIGdob3N0RWwpIHtcbiAgICBjc3MoZ2hvc3RFbCwgJ2Rpc3BsYXknLCAnbm9uZScpO1xuICB9XG59LFxuICAgIF91bmhpZGVHaG9zdEZvclRhcmdldCA9IGZ1bmN0aW9uIF91bmhpZGVHaG9zdEZvclRhcmdldCgpIHtcbiAgaWYgKCFzdXBwb3J0Q3NzUG9pbnRlckV2ZW50cyAmJiBnaG9zdEVsKSB7XG4gICAgY3NzKGdob3N0RWwsICdkaXNwbGF5JywgJycpO1xuICB9XG59OyAvLyAjMTE4NCBmaXggLSBQcmV2ZW50IGNsaWNrIGV2ZW50IG9uIGZhbGxiYWNrIGlmIGRyYWdnZWQgYnV0IGl0ZW0gbm90IGNoYW5nZWQgcG9zaXRpb25cblxuXG5pZiAoZG9jdW1lbnRFeGlzdHMpIHtcbiAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBmdW5jdGlvbiAoZXZ0KSB7XG4gICAgaWYgKGlnbm9yZU5leHRDbGljaykge1xuICAgICAgZXZ0LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICBldnQuc3RvcFByb3BhZ2F0aW9uICYmIGV2dC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgIGV2dC5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24gJiYgZXZ0LnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xuICAgICAgaWdub3JlTmV4dENsaWNrID0gZmFsc2U7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9LCB0cnVlKTtcbn1cblxudmFyIG5lYXJlc3RFbXB0eUluc2VydERldGVjdEV2ZW50ID0gZnVuY3Rpb24gbmVhcmVzdEVtcHR5SW5zZXJ0RGV0ZWN0RXZlbnQoZXZ0KSB7XG4gIGlmIChkcmFnRWwpIHtcbiAgICBldnQgPSBldnQudG91Y2hlcyA/IGV2dC50b3VjaGVzWzBdIDogZXZ0O1xuXG4gICAgdmFyIG5lYXJlc3QgPSBfZGV0ZWN0TmVhcmVzdEVtcHR5U29ydGFibGUoZXZ0LmNsaWVudFgsIGV2dC5jbGllbnRZKTtcblxuICAgIGlmIChuZWFyZXN0KSB7XG4gICAgICAvLyBDcmVhdGUgaW1pdGF0aW9uIGV2ZW50XG4gICAgICB2YXIgZXZlbnQgPSB7fTtcblxuICAgICAgZm9yICh2YXIgaSBpbiBldnQpIHtcbiAgICAgICAgaWYgKGV2dC5oYXNPd25Qcm9wZXJ0eShpKSkge1xuICAgICAgICAgIGV2ZW50W2ldID0gZXZ0W2ldO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGV2ZW50LnRhcmdldCA9IGV2ZW50LnJvb3RFbCA9IG5lYXJlc3Q7XG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCA9IHZvaWQgMDtcbiAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbiA9IHZvaWQgMDtcblxuICAgICAgbmVhcmVzdFtleHBhbmRvXS5fb25EcmFnT3ZlcihldmVudCk7XG4gICAgfVxuICB9XG59O1xuXG52YXIgX2NoZWNrT3V0c2lkZVRhcmdldEVsID0gZnVuY3Rpb24gX2NoZWNrT3V0c2lkZVRhcmdldEVsKGV2dCkge1xuICBpZiAoZHJhZ0VsKSB7XG4gICAgZHJhZ0VsLnBhcmVudE5vZGVbZXhwYW5kb10uX2lzT3V0c2lkZVRoaXNFbChldnQudGFyZ2V0KTtcbiAgfVxufTtcbi8qKlxuICogQGNsYXNzICBTb3J0YWJsZVxuICogQHBhcmFtICB7SFRNTEVsZW1lbnR9ICBlbFxuICogQHBhcmFtICB7T2JqZWN0fSAgICAgICBbb3B0aW9uc11cbiAqL1xuXG5cbmZ1bmN0aW9uIFNvcnRhYmxlKGVsLCBvcHRpb25zKSB7XG4gIGlmICghKGVsICYmIGVsLm5vZGVUeXBlICYmIGVsLm5vZGVUeXBlID09PSAxKSkge1xuICAgIHRocm93IFwiU29ydGFibGU6IGBlbGAgbXVzdCBiZSBhbiBIVE1MRWxlbWVudCwgbm90IFwiLmNvbmNhdCh7fS50b1N0cmluZy5jYWxsKGVsKSk7XG4gIH1cblxuICB0aGlzLmVsID0gZWw7IC8vIHJvb3QgZWxlbWVudFxuXG4gIHRoaXMub3B0aW9ucyA9IG9wdGlvbnMgPSBfZXh0ZW5kcyh7fSwgb3B0aW9ucyk7IC8vIEV4cG9ydCBpbnN0YW5jZVxuXG4gIGVsW2V4cGFuZG9dID0gdGhpcztcbiAgdmFyIGRlZmF1bHRzID0ge1xuICAgIGdyb3VwOiBudWxsLFxuICAgIHNvcnQ6IHRydWUsXG4gICAgZGlzYWJsZWQ6IGZhbHNlLFxuICAgIHN0b3JlOiBudWxsLFxuICAgIGhhbmRsZTogbnVsbCxcbiAgICBkcmFnZ2FibGU6IC9eW3VvXWwkL2kudGVzdChlbC5ub2RlTmFtZSkgPyAnPmxpJyA6ICc+KicsXG4gICAgc3dhcFRocmVzaG9sZDogMSxcbiAgICAvLyBwZXJjZW50YWdlOyAwIDw9IHggPD0gMVxuICAgIGludmVydFN3YXA6IGZhbHNlLFxuICAgIC8vIGludmVydCBhbHdheXNcbiAgICBpbnZlcnRlZFN3YXBUaHJlc2hvbGQ6IG51bGwsXG4gICAgLy8gd2lsbCBiZSBzZXQgdG8gc2FtZSBhcyBzd2FwVGhyZXNob2xkIGlmIGRlZmF1bHRcbiAgICByZW1vdmVDbG9uZU9uSGlkZTogdHJ1ZSxcbiAgICBkaXJlY3Rpb246IGZ1bmN0aW9uIGRpcmVjdGlvbigpIHtcbiAgICAgIHJldHVybiBfZGV0ZWN0RGlyZWN0aW9uKGVsLCB0aGlzLm9wdGlvbnMpO1xuICAgIH0sXG4gICAgZ2hvc3RDbGFzczogJ3NvcnRhYmxlLWdob3N0JyxcbiAgICBjaG9zZW5DbGFzczogJ3NvcnRhYmxlLWNob3NlbicsXG4gICAgZHJhZ0NsYXNzOiAnc29ydGFibGUtZHJhZycsXG4gICAgaWdub3JlOiAnYSwgaW1nJyxcbiAgICBmaWx0ZXI6IG51bGwsXG4gICAgcHJldmVudE9uRmlsdGVyOiB0cnVlLFxuICAgIGFuaW1hdGlvbjogMCxcbiAgICBlYXNpbmc6IG51bGwsXG4gICAgc2V0RGF0YTogZnVuY3Rpb24gc2V0RGF0YShkYXRhVHJhbnNmZXIsIGRyYWdFbCkge1xuICAgICAgZGF0YVRyYW5zZmVyLnNldERhdGEoJ1RleHQnLCBkcmFnRWwudGV4dENvbnRlbnQpO1xuICAgIH0sXG4gICAgZHJvcEJ1YmJsZTogZmFsc2UsXG4gICAgZHJhZ292ZXJCdWJibGU6IGZhbHNlLFxuICAgIGRhdGFJZEF0dHI6ICdkYXRhLWlkJyxcbiAgICBkZWxheTogMCxcbiAgICBkZWxheU9uVG91Y2hPbmx5OiBmYWxzZSxcbiAgICB0b3VjaFN0YXJ0VGhyZXNob2xkOiAoTnVtYmVyLnBhcnNlSW50ID8gTnVtYmVyIDogd2luZG93KS5wYXJzZUludCh3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbywgMTApIHx8IDEsXG4gICAgZm9yY2VGYWxsYmFjazogZmFsc2UsXG4gICAgZmFsbGJhY2tDbGFzczogJ3NvcnRhYmxlLWZhbGxiYWNrJyxcbiAgICBmYWxsYmFja09uQm9keTogZmFsc2UsXG4gICAgZmFsbGJhY2tUb2xlcmFuY2U6IDAsXG4gICAgZmFsbGJhY2tPZmZzZXQ6IHtcbiAgICAgIHg6IDAsXG4gICAgICB5OiAwXG4gICAgfSxcbiAgICBzdXBwb3J0UG9pbnRlcjogU29ydGFibGUuc3VwcG9ydFBvaW50ZXIgIT09IGZhbHNlICYmICdQb2ludGVyRXZlbnQnIGluIHdpbmRvdyxcbiAgICBlbXB0eUluc2VydFRocmVzaG9sZDogNVxuICB9O1xuICBQbHVnaW5NYW5hZ2VyLmluaXRpYWxpemVQbHVnaW5zKHRoaXMsIGVsLCBkZWZhdWx0cyk7IC8vIFNldCBkZWZhdWx0IG9wdGlvbnNcblxuICBmb3IgKHZhciBuYW1lIGluIGRlZmF1bHRzKSB7XG4gICAgIShuYW1lIGluIG9wdGlvbnMpICYmIChvcHRpb25zW25hbWVdID0gZGVmYXVsdHNbbmFtZV0pO1xuICB9XG5cbiAgX3ByZXBhcmVHcm91cChvcHRpb25zKTsgLy8gQmluZCBhbGwgcHJpdmF0ZSBtZXRob2RzXG5cblxuICBmb3IgKHZhciBmbiBpbiB0aGlzKSB7XG4gICAgaWYgKGZuLmNoYXJBdCgwKSA9PT0gJ18nICYmIHR5cGVvZiB0aGlzW2ZuXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhpc1tmbl0gPSB0aGlzW2ZuXS5iaW5kKHRoaXMpO1xuICAgIH1cbiAgfSAvLyBTZXR1cCBkcmFnIG1vZGVcblxuXG4gIHRoaXMubmF0aXZlRHJhZ2dhYmxlID0gb3B0aW9ucy5mb3JjZUZhbGxiYWNrID8gZmFsc2UgOiBzdXBwb3J0RHJhZ2dhYmxlO1xuXG4gIGlmICh0aGlzLm5hdGl2ZURyYWdnYWJsZSkge1xuICAgIC8vIFRvdWNoIHN0YXJ0IHRocmVzaG9sZCBjYW5ub3QgYmUgZ3JlYXRlciB0aGFuIHRoZSBuYXRpdmUgZHJhZ3N0YXJ0IHRocmVzaG9sZFxuICAgIHRoaXMub3B0aW9ucy50b3VjaFN0YXJ0VGhyZXNob2xkID0gMTtcbiAgfSAvLyBCaW5kIGV2ZW50c1xuXG5cbiAgaWYgKG9wdGlvbnMuc3VwcG9ydFBvaW50ZXIpIHtcbiAgICBvbihlbCwgJ3BvaW50ZXJkb3duJywgdGhpcy5fb25UYXBTdGFydCk7XG4gIH0gZWxzZSB7XG4gICAgb24oZWwsICdtb3VzZWRvd24nLCB0aGlzLl9vblRhcFN0YXJ0KTtcbiAgICBvbihlbCwgJ3RvdWNoc3RhcnQnLCB0aGlzLl9vblRhcFN0YXJ0KTtcbiAgfVxuXG4gIGlmICh0aGlzLm5hdGl2ZURyYWdnYWJsZSkge1xuICAgIG9uKGVsLCAnZHJhZ292ZXInLCB0aGlzKTtcbiAgICBvbihlbCwgJ2RyYWdlbnRlcicsIHRoaXMpO1xuICB9XG5cbiAgc29ydGFibGVzLnB1c2godGhpcy5lbCk7IC8vIFJlc3RvcmUgc29ydGluZ1xuXG4gIG9wdGlvbnMuc3RvcmUgJiYgb3B0aW9ucy5zdG9yZS5nZXQgJiYgdGhpcy5zb3J0KG9wdGlvbnMuc3RvcmUuZ2V0KHRoaXMpIHx8IFtdKTsgLy8gQWRkIGFuaW1hdGlvbiBzdGF0ZSBtYW5hZ2VyXG5cbiAgX2V4dGVuZHModGhpcywgQW5pbWF0aW9uU3RhdGVNYW5hZ2VyKCkpO1xufVxuXG5Tb3J0YWJsZS5wcm90b3R5cGUgPVxuLyoqIEBsZW5kcyBTb3J0YWJsZS5wcm90b3R5cGUgKi9cbntcbiAgY29uc3RydWN0b3I6IFNvcnRhYmxlLFxuICBfaXNPdXRzaWRlVGhpc0VsOiBmdW5jdGlvbiBfaXNPdXRzaWRlVGhpc0VsKHRhcmdldCkge1xuICAgIGlmICghdGhpcy5lbC5jb250YWlucyh0YXJnZXQpICYmIHRhcmdldCAhPT0gdGhpcy5lbCkge1xuICAgICAgbGFzdFRhcmdldCA9IG51bGw7XG4gICAgfVxuICB9LFxuICBfZ2V0RGlyZWN0aW9uOiBmdW5jdGlvbiBfZ2V0RGlyZWN0aW9uKGV2dCwgdGFyZ2V0KSB7XG4gICAgcmV0dXJuIHR5cGVvZiB0aGlzLm9wdGlvbnMuZGlyZWN0aW9uID09PSAnZnVuY3Rpb24nID8gdGhpcy5vcHRpb25zLmRpcmVjdGlvbi5jYWxsKHRoaXMsIGV2dCwgdGFyZ2V0LCBkcmFnRWwpIDogdGhpcy5vcHRpb25zLmRpcmVjdGlvbjtcbiAgfSxcbiAgX29uVGFwU3RhcnQ6IGZ1bmN0aW9uIF9vblRhcFN0YXJ0KFxuICAvKiogRXZlbnR8VG91Y2hFdmVudCAqL1xuICBldnQpIHtcbiAgICBpZiAoIWV2dC5jYW5jZWxhYmxlKSByZXR1cm47XG5cbiAgICB2YXIgX3RoaXMgPSB0aGlzLFxuICAgICAgICBlbCA9IHRoaXMuZWwsXG4gICAgICAgIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnMsXG4gICAgICAgIHByZXZlbnRPbkZpbHRlciA9IG9wdGlvbnMucHJldmVudE9uRmlsdGVyLFxuICAgICAgICB0eXBlID0gZXZ0LnR5cGUsXG4gICAgICAgIHRvdWNoID0gZXZ0LnRvdWNoZXMgJiYgZXZ0LnRvdWNoZXNbMF0gfHwgZXZ0LnBvaW50ZXJUeXBlICYmIGV2dC5wb2ludGVyVHlwZSA9PT0gJ3RvdWNoJyAmJiBldnQsXG4gICAgICAgIHRhcmdldCA9ICh0b3VjaCB8fCBldnQpLnRhcmdldCxcbiAgICAgICAgb3JpZ2luYWxUYXJnZXQgPSBldnQudGFyZ2V0LnNoYWRvd1Jvb3QgJiYgKGV2dC5wYXRoICYmIGV2dC5wYXRoWzBdIHx8IGV2dC5jb21wb3NlZFBhdGggJiYgZXZ0LmNvbXBvc2VkUGF0aCgpWzBdKSB8fCB0YXJnZXQsXG4gICAgICAgIGZpbHRlciA9IG9wdGlvbnMuZmlsdGVyO1xuXG4gICAgX3NhdmVJbnB1dENoZWNrZWRTdGF0ZShlbCk7IC8vIERvbid0IHRyaWdnZXIgc3RhcnQgZXZlbnQgd2hlbiBhbiBlbGVtZW50IGlzIGJlZW4gZHJhZ2dlZCwgb3RoZXJ3aXNlIHRoZSBldnQub2xkaW5kZXggYWx3YXlzIHdyb25nIHdoZW4gc2V0IG9wdGlvbi5ncm91cC5cblxuXG4gICAgaWYgKGRyYWdFbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICgvbW91c2Vkb3dufHBvaW50ZXJkb3duLy50ZXN0KHR5cGUpICYmIGV2dC5idXR0b24gIT09IDAgfHwgb3B0aW9ucy5kaXNhYmxlZCkge1xuICAgICAgcmV0dXJuOyAvLyBvbmx5IGxlZnQgYnV0dG9uIGFuZCBlbmFibGVkXG4gICAgfSAvLyBjYW5jZWwgZG5kIGlmIG9yaWdpbmFsIHRhcmdldCBpcyBjb250ZW50IGVkaXRhYmxlXG5cblxuICAgIGlmIChvcmlnaW5hbFRhcmdldC5pc0NvbnRlbnRFZGl0YWJsZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRhcmdldCA9IGNsb3Nlc3QodGFyZ2V0LCBvcHRpb25zLmRyYWdnYWJsZSwgZWwsIGZhbHNlKTtcblxuICAgIGlmICh0YXJnZXQgJiYgdGFyZ2V0LmFuaW1hdGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGxhc3REb3duRWwgPT09IHRhcmdldCkge1xuICAgICAgLy8gSWdub3JpbmcgZHVwbGljYXRlIGBkb3duYFxuICAgICAgcmV0dXJuO1xuICAgIH0gLy8gR2V0IHRoZSBpbmRleCBvZiB0aGUgZHJhZ2dlZCBlbGVtZW50IHdpdGhpbiBpdHMgcGFyZW50XG5cblxuICAgIG9sZEluZGV4ID0gaW5kZXgodGFyZ2V0KTtcbiAgICBvbGREcmFnZ2FibGVJbmRleCA9IGluZGV4KHRhcmdldCwgb3B0aW9ucy5kcmFnZ2FibGUpOyAvLyBDaGVjayBmaWx0ZXJcblxuICAgIGlmICh0eXBlb2YgZmlsdGVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBpZiAoZmlsdGVyLmNhbGwodGhpcywgZXZ0LCB0YXJnZXQsIHRoaXMpKSB7XG4gICAgICAgIF9kaXNwYXRjaEV2ZW50KHtcbiAgICAgICAgICBzb3J0YWJsZTogX3RoaXMsXG4gICAgICAgICAgcm9vdEVsOiBvcmlnaW5hbFRhcmdldCxcbiAgICAgICAgICBuYW1lOiAnZmlsdGVyJyxcbiAgICAgICAgICB0YXJnZXRFbDogdGFyZ2V0LFxuICAgICAgICAgIHRvRWw6IGVsLFxuICAgICAgICAgIGZyb21FbDogZWxcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcGx1Z2luRXZlbnQoJ2ZpbHRlcicsIF90aGlzLCB7XG4gICAgICAgICAgZXZ0OiBldnRcbiAgICAgICAgfSk7XG4gICAgICAgIHByZXZlbnRPbkZpbHRlciAmJiBldnQuY2FuY2VsYWJsZSAmJiBldnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgcmV0dXJuOyAvLyBjYW5jZWwgZG5kXG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChmaWx0ZXIpIHtcbiAgICAgIGZpbHRlciA9IGZpbHRlci5zcGxpdCgnLCcpLnNvbWUoZnVuY3Rpb24gKGNyaXRlcmlhKSB7XG4gICAgICAgIGNyaXRlcmlhID0gY2xvc2VzdChvcmlnaW5hbFRhcmdldCwgY3JpdGVyaWEudHJpbSgpLCBlbCwgZmFsc2UpO1xuXG4gICAgICAgIGlmIChjcml0ZXJpYSkge1xuICAgICAgICAgIF9kaXNwYXRjaEV2ZW50KHtcbiAgICAgICAgICAgIHNvcnRhYmxlOiBfdGhpcyxcbiAgICAgICAgICAgIHJvb3RFbDogY3JpdGVyaWEsXG4gICAgICAgICAgICBuYW1lOiAnZmlsdGVyJyxcbiAgICAgICAgICAgIHRhcmdldEVsOiB0YXJnZXQsXG4gICAgICAgICAgICBmcm9tRWw6IGVsLFxuICAgICAgICAgICAgdG9FbDogZWxcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIHBsdWdpbkV2ZW50KCdmaWx0ZXInLCBfdGhpcywge1xuICAgICAgICAgICAgZXZ0OiBldnRcbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIGlmIChmaWx0ZXIpIHtcbiAgICAgICAgcHJldmVudE9uRmlsdGVyICYmIGV2dC5jYW5jZWxhYmxlICYmIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICByZXR1cm47IC8vIGNhbmNlbCBkbmRcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy5oYW5kbGUgJiYgIWNsb3Nlc3Qob3JpZ2luYWxUYXJnZXQsIG9wdGlvbnMuaGFuZGxlLCBlbCwgZmFsc2UpKSB7XG4gICAgICByZXR1cm47XG4gICAgfSAvLyBQcmVwYXJlIGBkcmFnc3RhcnRgXG5cblxuICAgIHRoaXMuX3ByZXBhcmVEcmFnU3RhcnQoZXZ0LCB0b3VjaCwgdGFyZ2V0KTtcbiAgfSxcbiAgX3ByZXBhcmVEcmFnU3RhcnQ6IGZ1bmN0aW9uIF9wcmVwYXJlRHJhZ1N0YXJ0KFxuICAvKiogRXZlbnQgKi9cbiAgZXZ0LFxuICAvKiogVG91Y2ggKi9cbiAgdG91Y2gsXG4gIC8qKiBIVE1MRWxlbWVudCAqL1xuICB0YXJnZXQpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzLFxuICAgICAgICBlbCA9IF90aGlzLmVsLFxuICAgICAgICBvcHRpb25zID0gX3RoaXMub3B0aW9ucyxcbiAgICAgICAgb3duZXJEb2N1bWVudCA9IGVsLm93bmVyRG9jdW1lbnQsXG4gICAgICAgIGRyYWdTdGFydEZuO1xuXG4gICAgaWYgKHRhcmdldCAmJiAhZHJhZ0VsICYmIHRhcmdldC5wYXJlbnROb2RlID09PSBlbCkge1xuICAgICAgdmFyIGRyYWdSZWN0ID0gZ2V0UmVjdCh0YXJnZXQpO1xuICAgICAgcm9vdEVsID0gZWw7XG4gICAgICBkcmFnRWwgPSB0YXJnZXQ7XG4gICAgICBwYXJlbnRFbCA9IGRyYWdFbC5wYXJlbnROb2RlO1xuICAgICAgbmV4dEVsID0gZHJhZ0VsLm5leHRTaWJsaW5nO1xuICAgICAgbGFzdERvd25FbCA9IHRhcmdldDtcbiAgICAgIGFjdGl2ZUdyb3VwID0gb3B0aW9ucy5ncm91cDtcbiAgICAgIFNvcnRhYmxlLmRyYWdnZWQgPSBkcmFnRWw7XG4gICAgICB0YXBFdnQgPSB7XG4gICAgICAgIHRhcmdldDogZHJhZ0VsLFxuICAgICAgICBjbGllbnRYOiAodG91Y2ggfHwgZXZ0KS5jbGllbnRYLFxuICAgICAgICBjbGllbnRZOiAodG91Y2ggfHwgZXZ0KS5jbGllbnRZXG4gICAgICB9O1xuICAgICAgdGFwRGlzdGFuY2VMZWZ0ID0gdGFwRXZ0LmNsaWVudFggLSBkcmFnUmVjdC5sZWZ0O1xuICAgICAgdGFwRGlzdGFuY2VUb3AgPSB0YXBFdnQuY2xpZW50WSAtIGRyYWdSZWN0LnRvcDtcbiAgICAgIHRoaXMuX2xhc3RYID0gKHRvdWNoIHx8IGV2dCkuY2xpZW50WDtcbiAgICAgIHRoaXMuX2xhc3RZID0gKHRvdWNoIHx8IGV2dCkuY2xpZW50WTtcbiAgICAgIGRyYWdFbC5zdHlsZVsnd2lsbC1jaGFuZ2UnXSA9ICdhbGwnO1xuXG4gICAgICBkcmFnU3RhcnRGbiA9IGZ1bmN0aW9uIGRyYWdTdGFydEZuKCkge1xuICAgICAgICBwbHVnaW5FdmVudCgnZGVsYXlFbmRlZCcsIF90aGlzLCB7XG4gICAgICAgICAgZXZ0OiBldnRcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKFNvcnRhYmxlLmV2ZW50Q2FuY2VsZWQpIHtcbiAgICAgICAgICBfdGhpcy5fb25Ecm9wKCk7XG5cbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH0gLy8gRGVsYXllZCBkcmFnIGhhcyBiZWVuIHRyaWdnZXJlZFxuICAgICAgICAvLyB3ZSBjYW4gcmUtZW5hYmxlIHRoZSBldmVudHM6IHRvdWNobW92ZS9tb3VzZW1vdmVcblxuXG4gICAgICAgIF90aGlzLl9kaXNhYmxlRGVsYXllZERyYWdFdmVudHMoKTtcblxuICAgICAgICBpZiAoIUZpcmVGb3ggJiYgX3RoaXMubmF0aXZlRHJhZ2dhYmxlKSB7XG4gICAgICAgICAgZHJhZ0VsLmRyYWdnYWJsZSA9IHRydWU7XG4gICAgICAgIH0gLy8gQmluZCB0aGUgZXZlbnRzOiBkcmFnc3RhcnQvZHJhZ2VuZFxuXG5cbiAgICAgICAgX3RoaXMuX3RyaWdnZXJEcmFnU3RhcnQoZXZ0LCB0b3VjaCk7IC8vIERyYWcgc3RhcnQgZXZlbnRcblxuXG4gICAgICAgIF9kaXNwYXRjaEV2ZW50KHtcbiAgICAgICAgICBzb3J0YWJsZTogX3RoaXMsXG4gICAgICAgICAgbmFtZTogJ2Nob29zZScsXG4gICAgICAgICAgb3JpZ2luYWxFdmVudDogZXZ0XG4gICAgICAgIH0pOyAvLyBDaG9zZW4gaXRlbVxuXG5cbiAgICAgICAgdG9nZ2xlQ2xhc3MoZHJhZ0VsLCBvcHRpb25zLmNob3NlbkNsYXNzLCB0cnVlKTtcbiAgICAgIH07IC8vIERpc2FibGUgXCJkcmFnZ2FibGVcIlxuXG5cbiAgICAgIG9wdGlvbnMuaWdub3JlLnNwbGl0KCcsJykuZm9yRWFjaChmdW5jdGlvbiAoY3JpdGVyaWEpIHtcbiAgICAgICAgZmluZChkcmFnRWwsIGNyaXRlcmlhLnRyaW0oKSwgX2Rpc2FibGVEcmFnZ2FibGUpO1xuICAgICAgfSk7XG4gICAgICBvbihvd25lckRvY3VtZW50LCAnZHJhZ292ZXInLCBuZWFyZXN0RW1wdHlJbnNlcnREZXRlY3RFdmVudCk7XG4gICAgICBvbihvd25lckRvY3VtZW50LCAnbW91c2Vtb3ZlJywgbmVhcmVzdEVtcHR5SW5zZXJ0RGV0ZWN0RXZlbnQpO1xuICAgICAgb24ob3duZXJEb2N1bWVudCwgJ3RvdWNobW92ZScsIG5lYXJlc3RFbXB0eUluc2VydERldGVjdEV2ZW50KTtcbiAgICAgIG9uKG93bmVyRG9jdW1lbnQsICdtb3VzZXVwJywgX3RoaXMuX29uRHJvcCk7XG4gICAgICBvbihvd25lckRvY3VtZW50LCAndG91Y2hlbmQnLCBfdGhpcy5fb25Ecm9wKTtcbiAgICAgIG9uKG93bmVyRG9jdW1lbnQsICd0b3VjaGNhbmNlbCcsIF90aGlzLl9vbkRyb3ApOyAvLyBNYWtlIGRyYWdFbCBkcmFnZ2FibGUgKG11c3QgYmUgYmVmb3JlIGRlbGF5IGZvciBGaXJlRm94KVxuXG4gICAgICBpZiAoRmlyZUZveCAmJiB0aGlzLm5hdGl2ZURyYWdnYWJsZSkge1xuICAgICAgICB0aGlzLm9wdGlvbnMudG91Y2hTdGFydFRocmVzaG9sZCA9IDQ7XG4gICAgICAgIGRyYWdFbC5kcmFnZ2FibGUgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICBwbHVnaW5FdmVudCgnZGVsYXlTdGFydCcsIHRoaXMsIHtcbiAgICAgICAgZXZ0OiBldnRcbiAgICAgIH0pOyAvLyBEZWxheSBpcyBpbXBvc3NpYmxlIGZvciBuYXRpdmUgRG5EIGluIEVkZ2Ugb3IgSUVcblxuICAgICAgaWYgKG9wdGlvbnMuZGVsYXkgJiYgKCFvcHRpb25zLmRlbGF5T25Ub3VjaE9ubHkgfHwgdG91Y2gpICYmICghdGhpcy5uYXRpdmVEcmFnZ2FibGUgfHwgIShFZGdlIHx8IElFMTFPckxlc3MpKSkge1xuICAgICAgICBpZiAoU29ydGFibGUuZXZlbnRDYW5jZWxlZCkge1xuICAgICAgICAgIHRoaXMuX29uRHJvcCgpO1xuXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9IC8vIElmIHRoZSB1c2VyIG1vdmVzIHRoZSBwb2ludGVyIG9yIGxldCBnbyB0aGUgY2xpY2sgb3IgdG91Y2hcbiAgICAgICAgLy8gYmVmb3JlIHRoZSBkZWxheSBoYXMgYmVlbiByZWFjaGVkOlxuICAgICAgICAvLyBkaXNhYmxlIHRoZSBkZWxheWVkIGRyYWdcblxuXG4gICAgICAgIG9uKG93bmVyRG9jdW1lbnQsICdtb3VzZXVwJywgX3RoaXMuX2Rpc2FibGVEZWxheWVkRHJhZyk7XG4gICAgICAgIG9uKG93bmVyRG9jdW1lbnQsICd0b3VjaGVuZCcsIF90aGlzLl9kaXNhYmxlRGVsYXllZERyYWcpO1xuICAgICAgICBvbihvd25lckRvY3VtZW50LCAndG91Y2hjYW5jZWwnLCBfdGhpcy5fZGlzYWJsZURlbGF5ZWREcmFnKTtcbiAgICAgICAgb24ob3duZXJEb2N1bWVudCwgJ21vdXNlbW92ZScsIF90aGlzLl9kZWxheWVkRHJhZ1RvdWNoTW92ZUhhbmRsZXIpO1xuICAgICAgICBvbihvd25lckRvY3VtZW50LCAndG91Y2htb3ZlJywgX3RoaXMuX2RlbGF5ZWREcmFnVG91Y2hNb3ZlSGFuZGxlcik7XG4gICAgICAgIG9wdGlvbnMuc3VwcG9ydFBvaW50ZXIgJiYgb24ob3duZXJEb2N1bWVudCwgJ3BvaW50ZXJtb3ZlJywgX3RoaXMuX2RlbGF5ZWREcmFnVG91Y2hNb3ZlSGFuZGxlcik7XG4gICAgICAgIF90aGlzLl9kcmFnU3RhcnRUaW1lciA9IHNldFRpbWVvdXQoZHJhZ1N0YXJ0Rm4sIG9wdGlvbnMuZGVsYXkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZHJhZ1N0YXJ0Rm4oKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIF9kZWxheWVkRHJhZ1RvdWNoTW92ZUhhbmRsZXI6IGZ1bmN0aW9uIF9kZWxheWVkRHJhZ1RvdWNoTW92ZUhhbmRsZXIoXG4gIC8qKiBUb3VjaEV2ZW50fFBvaW50ZXJFdmVudCAqKi9cbiAgZSkge1xuICAgIHZhciB0b3VjaCA9IGUudG91Y2hlcyA/IGUudG91Y2hlc1swXSA6IGU7XG5cbiAgICBpZiAoTWF0aC5tYXgoTWF0aC5hYnModG91Y2guY2xpZW50WCAtIHRoaXMuX2xhc3RYKSwgTWF0aC5hYnModG91Y2guY2xpZW50WSAtIHRoaXMuX2xhc3RZKSkgPj0gTWF0aC5mbG9vcih0aGlzLm9wdGlvbnMudG91Y2hTdGFydFRocmVzaG9sZCAvICh0aGlzLm5hdGl2ZURyYWdnYWJsZSAmJiB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbyB8fCAxKSkpIHtcbiAgICAgIHRoaXMuX2Rpc2FibGVEZWxheWVkRHJhZygpO1xuICAgIH1cbiAgfSxcbiAgX2Rpc2FibGVEZWxheWVkRHJhZzogZnVuY3Rpb24gX2Rpc2FibGVEZWxheWVkRHJhZygpIHtcbiAgICBkcmFnRWwgJiYgX2Rpc2FibGVEcmFnZ2FibGUoZHJhZ0VsKTtcbiAgICBjbGVhclRpbWVvdXQodGhpcy5fZHJhZ1N0YXJ0VGltZXIpO1xuXG4gICAgdGhpcy5fZGlzYWJsZURlbGF5ZWREcmFnRXZlbnRzKCk7XG4gIH0sXG4gIF9kaXNhYmxlRGVsYXllZERyYWdFdmVudHM6IGZ1bmN0aW9uIF9kaXNhYmxlRGVsYXllZERyYWdFdmVudHMoKSB7XG4gICAgdmFyIG93bmVyRG9jdW1lbnQgPSB0aGlzLmVsLm93bmVyRG9jdW1lbnQ7XG4gICAgb2ZmKG93bmVyRG9jdW1lbnQsICdtb3VzZXVwJywgdGhpcy5fZGlzYWJsZURlbGF5ZWREcmFnKTtcbiAgICBvZmYob3duZXJEb2N1bWVudCwgJ3RvdWNoZW5kJywgdGhpcy5fZGlzYWJsZURlbGF5ZWREcmFnKTtcbiAgICBvZmYob3duZXJEb2N1bWVudCwgJ3RvdWNoY2FuY2VsJywgdGhpcy5fZGlzYWJsZURlbGF5ZWREcmFnKTtcbiAgICBvZmYob3duZXJEb2N1bWVudCwgJ21vdXNlbW92ZScsIHRoaXMuX2RlbGF5ZWREcmFnVG91Y2hNb3ZlSGFuZGxlcik7XG4gICAgb2ZmKG93bmVyRG9jdW1lbnQsICd0b3VjaG1vdmUnLCB0aGlzLl9kZWxheWVkRHJhZ1RvdWNoTW92ZUhhbmRsZXIpO1xuICAgIG9mZihvd25lckRvY3VtZW50LCAncG9pbnRlcm1vdmUnLCB0aGlzLl9kZWxheWVkRHJhZ1RvdWNoTW92ZUhhbmRsZXIpO1xuICB9LFxuICBfdHJpZ2dlckRyYWdTdGFydDogZnVuY3Rpb24gX3RyaWdnZXJEcmFnU3RhcnQoXG4gIC8qKiBFdmVudCAqL1xuICBldnQsXG4gIC8qKiBUb3VjaCAqL1xuICB0b3VjaCkge1xuICAgIHRvdWNoID0gdG91Y2ggfHwgZXZ0LnBvaW50ZXJUeXBlID09ICd0b3VjaCcgJiYgZXZ0O1xuXG4gICAgaWYgKCF0aGlzLm5hdGl2ZURyYWdnYWJsZSB8fCB0b3VjaCkge1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy5zdXBwb3J0UG9pbnRlcikge1xuICAgICAgICBvbihkb2N1bWVudCwgJ3BvaW50ZXJtb3ZlJywgdGhpcy5fb25Ub3VjaE1vdmUpO1xuICAgICAgfSBlbHNlIGlmICh0b3VjaCkge1xuICAgICAgICBvbihkb2N1bWVudCwgJ3RvdWNobW92ZScsIHRoaXMuX29uVG91Y2hNb3ZlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG9uKGRvY3VtZW50LCAnbW91c2Vtb3ZlJywgdGhpcy5fb25Ub3VjaE1vdmUpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBvbihkcmFnRWwsICdkcmFnZW5kJywgdGhpcyk7XG4gICAgICBvbihyb290RWwsICdkcmFnc3RhcnQnLCB0aGlzLl9vbkRyYWdTdGFydCk7XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIGlmIChkb2N1bWVudC5zZWxlY3Rpb24pIHtcbiAgICAgICAgLy8gVGltZW91dCBuZWNjZXNzYXJ5IGZvciBJRTlcbiAgICAgICAgX25leHRUaWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBkb2N1bWVudC5zZWxlY3Rpb24uZW1wdHkoKTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB3aW5kb3cuZ2V0U2VsZWN0aW9uKCkucmVtb3ZlQWxsUmFuZ2VzKCk7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyKSB7fVxuICB9LFxuICBfZHJhZ1N0YXJ0ZWQ6IGZ1bmN0aW9uIF9kcmFnU3RhcnRlZChmYWxsYmFjaywgZXZ0KSB7XG5cbiAgICBhd2FpdGluZ0RyYWdTdGFydGVkID0gZmFsc2U7XG5cbiAgICBpZiAocm9vdEVsICYmIGRyYWdFbCkge1xuICAgICAgcGx1Z2luRXZlbnQoJ2RyYWdTdGFydGVkJywgdGhpcywge1xuICAgICAgICBldnQ6IGV2dFxuICAgICAgfSk7XG5cbiAgICAgIGlmICh0aGlzLm5hdGl2ZURyYWdnYWJsZSkge1xuICAgICAgICBvbihkb2N1bWVudCwgJ2RyYWdvdmVyJywgX2NoZWNrT3V0c2lkZVRhcmdldEVsKTtcbiAgICAgIH1cblxuICAgICAgdmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7IC8vIEFwcGx5IGVmZmVjdFxuXG4gICAgICAhZmFsbGJhY2sgJiYgdG9nZ2xlQ2xhc3MoZHJhZ0VsLCBvcHRpb25zLmRyYWdDbGFzcywgZmFsc2UpO1xuICAgICAgdG9nZ2xlQ2xhc3MoZHJhZ0VsLCBvcHRpb25zLmdob3N0Q2xhc3MsIHRydWUpO1xuICAgICAgU29ydGFibGUuYWN0aXZlID0gdGhpcztcbiAgICAgIGZhbGxiYWNrICYmIHRoaXMuX2FwcGVuZEdob3N0KCk7IC8vIERyYWcgc3RhcnQgZXZlbnRcblxuICAgICAgX2Rpc3BhdGNoRXZlbnQoe1xuICAgICAgICBzb3J0YWJsZTogdGhpcyxcbiAgICAgICAgbmFtZTogJ3N0YXJ0JyxcbiAgICAgICAgb3JpZ2luYWxFdmVudDogZXZ0XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fbnVsbGluZygpO1xuICAgIH1cbiAgfSxcbiAgX2VtdWxhdGVEcmFnT3ZlcjogZnVuY3Rpb24gX2VtdWxhdGVEcmFnT3ZlcigpIHtcbiAgICBpZiAodG91Y2hFdnQpIHtcbiAgICAgIHRoaXMuX2xhc3RYID0gdG91Y2hFdnQuY2xpZW50WDtcbiAgICAgIHRoaXMuX2xhc3RZID0gdG91Y2hFdnQuY2xpZW50WTtcblxuICAgICAgX2hpZGVHaG9zdEZvclRhcmdldCgpO1xuXG4gICAgICB2YXIgdGFyZ2V0ID0gZG9jdW1lbnQuZWxlbWVudEZyb21Qb2ludCh0b3VjaEV2dC5jbGllbnRYLCB0b3VjaEV2dC5jbGllbnRZKTtcbiAgICAgIHZhciBwYXJlbnQgPSB0YXJnZXQ7XG5cbiAgICAgIHdoaWxlICh0YXJnZXQgJiYgdGFyZ2V0LnNoYWRvd1Jvb3QpIHtcbiAgICAgICAgdGFyZ2V0ID0gdGFyZ2V0LnNoYWRvd1Jvb3QuZWxlbWVudEZyb21Qb2ludCh0b3VjaEV2dC5jbGllbnRYLCB0b3VjaEV2dC5jbGllbnRZKTtcbiAgICAgICAgaWYgKHRhcmdldCA9PT0gcGFyZW50KSBicmVhaztcbiAgICAgICAgcGFyZW50ID0gdGFyZ2V0O1xuICAgICAgfVxuXG4gICAgICBkcmFnRWwucGFyZW50Tm9kZVtleHBhbmRvXS5faXNPdXRzaWRlVGhpc0VsKHRhcmdldCk7XG5cbiAgICAgIGlmIChwYXJlbnQpIHtcbiAgICAgICAgZG8ge1xuICAgICAgICAgIGlmIChwYXJlbnRbZXhwYW5kb10pIHtcbiAgICAgICAgICAgIHZhciBpbnNlcnRlZCA9IHZvaWQgMDtcbiAgICAgICAgICAgIGluc2VydGVkID0gcGFyZW50W2V4cGFuZG9dLl9vbkRyYWdPdmVyKHtcbiAgICAgICAgICAgICAgY2xpZW50WDogdG91Y2hFdnQuY2xpZW50WCxcbiAgICAgICAgICAgICAgY2xpZW50WTogdG91Y2hFdnQuY2xpZW50WSxcbiAgICAgICAgICAgICAgdGFyZ2V0OiB0YXJnZXQsXG4gICAgICAgICAgICAgIHJvb3RFbDogcGFyZW50XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgaWYgKGluc2VydGVkICYmICF0aGlzLm9wdGlvbnMuZHJhZ292ZXJCdWJibGUpIHtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGFyZ2V0ID0gcGFyZW50OyAvLyBzdG9yZSBsYXN0IGVsZW1lbnRcbiAgICAgICAgfVxuICAgICAgICAvKiBqc2hpbnQgYm9zczp0cnVlICovXG4gICAgICAgIHdoaWxlIChwYXJlbnQgPSBwYXJlbnQucGFyZW50Tm9kZSk7XG4gICAgICB9XG5cbiAgICAgIF91bmhpZGVHaG9zdEZvclRhcmdldCgpO1xuICAgIH1cbiAgfSxcbiAgX29uVG91Y2hNb3ZlOiBmdW5jdGlvbiBfb25Ub3VjaE1vdmUoXG4gIC8qKlRvdWNoRXZlbnQqL1xuICBldnQpIHtcbiAgICBpZiAodGFwRXZ0KSB7XG4gICAgICB2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucyxcbiAgICAgICAgICBmYWxsYmFja1RvbGVyYW5jZSA9IG9wdGlvbnMuZmFsbGJhY2tUb2xlcmFuY2UsXG4gICAgICAgICAgZmFsbGJhY2tPZmZzZXQgPSBvcHRpb25zLmZhbGxiYWNrT2Zmc2V0LFxuICAgICAgICAgIHRvdWNoID0gZXZ0LnRvdWNoZXMgPyBldnQudG91Y2hlc1swXSA6IGV2dCxcbiAgICAgICAgICBnaG9zdE1hdHJpeCA9IGdob3N0RWwgJiYgbWF0cml4KGdob3N0RWwsIHRydWUpLFxuICAgICAgICAgIHNjYWxlWCA9IGdob3N0RWwgJiYgZ2hvc3RNYXRyaXggJiYgZ2hvc3RNYXRyaXguYSxcbiAgICAgICAgICBzY2FsZVkgPSBnaG9zdEVsICYmIGdob3N0TWF0cml4ICYmIGdob3N0TWF0cml4LmQsXG4gICAgICAgICAgcmVsYXRpdmVTY3JvbGxPZmZzZXQgPSBQb3NpdGlvbkdob3N0QWJzb2x1dGVseSAmJiBnaG9zdFJlbGF0aXZlUGFyZW50ICYmIGdldFJlbGF0aXZlU2Nyb2xsT2Zmc2V0KGdob3N0UmVsYXRpdmVQYXJlbnQpLFxuICAgICAgICAgIGR4ID0gKHRvdWNoLmNsaWVudFggLSB0YXBFdnQuY2xpZW50WCArIGZhbGxiYWNrT2Zmc2V0LngpIC8gKHNjYWxlWCB8fCAxKSArIChyZWxhdGl2ZVNjcm9sbE9mZnNldCA/IHJlbGF0aXZlU2Nyb2xsT2Zmc2V0WzBdIC0gZ2hvc3RSZWxhdGl2ZVBhcmVudEluaXRpYWxTY3JvbGxbMF0gOiAwKSAvIChzY2FsZVggfHwgMSksXG4gICAgICAgICAgZHkgPSAodG91Y2guY2xpZW50WSAtIHRhcEV2dC5jbGllbnRZICsgZmFsbGJhY2tPZmZzZXQueSkgLyAoc2NhbGVZIHx8IDEpICsgKHJlbGF0aXZlU2Nyb2xsT2Zmc2V0ID8gcmVsYXRpdmVTY3JvbGxPZmZzZXRbMV0gLSBnaG9zdFJlbGF0aXZlUGFyZW50SW5pdGlhbFNjcm9sbFsxXSA6IDApIC8gKHNjYWxlWSB8fCAxKTsgLy8gb25seSBzZXQgdGhlIHN0YXR1cyB0byBkcmFnZ2luZywgd2hlbiB3ZSBhcmUgYWN0dWFsbHkgZHJhZ2dpbmdcblxuICAgICAgaWYgKCFTb3J0YWJsZS5hY3RpdmUgJiYgIWF3YWl0aW5nRHJhZ1N0YXJ0ZWQpIHtcbiAgICAgICAgaWYgKGZhbGxiYWNrVG9sZXJhbmNlICYmIE1hdGgubWF4KE1hdGguYWJzKHRvdWNoLmNsaWVudFggLSB0aGlzLl9sYXN0WCksIE1hdGguYWJzKHRvdWNoLmNsaWVudFkgLSB0aGlzLl9sYXN0WSkpIDwgZmFsbGJhY2tUb2xlcmFuY2UpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9vbkRyYWdTdGFydChldnQsIHRydWUpO1xuICAgICAgfVxuXG4gICAgICBpZiAoZ2hvc3RFbCkge1xuICAgICAgICBpZiAoZ2hvc3RNYXRyaXgpIHtcbiAgICAgICAgICBnaG9zdE1hdHJpeC5lICs9IGR4IC0gKGxhc3REeCB8fCAwKTtcbiAgICAgICAgICBnaG9zdE1hdHJpeC5mICs9IGR5IC0gKGxhc3REeSB8fCAwKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBnaG9zdE1hdHJpeCA9IHtcbiAgICAgICAgICAgIGE6IDEsXG4gICAgICAgICAgICBiOiAwLFxuICAgICAgICAgICAgYzogMCxcbiAgICAgICAgICAgIGQ6IDEsXG4gICAgICAgICAgICBlOiBkeCxcbiAgICAgICAgICAgIGY6IGR5XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBjc3NNYXRyaXggPSBcIm1hdHJpeChcIi5jb25jYXQoZ2hvc3RNYXRyaXguYSwgXCIsXCIpLmNvbmNhdChnaG9zdE1hdHJpeC5iLCBcIixcIikuY29uY2F0KGdob3N0TWF0cml4LmMsIFwiLFwiKS5jb25jYXQoZ2hvc3RNYXRyaXguZCwgXCIsXCIpLmNvbmNhdChnaG9zdE1hdHJpeC5lLCBcIixcIikuY29uY2F0KGdob3N0TWF0cml4LmYsIFwiKVwiKTtcbiAgICAgICAgY3NzKGdob3N0RWwsICd3ZWJraXRUcmFuc2Zvcm0nLCBjc3NNYXRyaXgpO1xuICAgICAgICBjc3MoZ2hvc3RFbCwgJ21velRyYW5zZm9ybScsIGNzc01hdHJpeCk7XG4gICAgICAgIGNzcyhnaG9zdEVsLCAnbXNUcmFuc2Zvcm0nLCBjc3NNYXRyaXgpO1xuICAgICAgICBjc3MoZ2hvc3RFbCwgJ3RyYW5zZm9ybScsIGNzc01hdHJpeCk7XG4gICAgICAgIGxhc3REeCA9IGR4O1xuICAgICAgICBsYXN0RHkgPSBkeTtcbiAgICAgICAgdG91Y2hFdnQgPSB0b3VjaDtcbiAgICAgIH1cblxuICAgICAgZXZ0LmNhbmNlbGFibGUgJiYgZXZ0LnByZXZlbnREZWZhdWx0KCk7XG4gICAgfVxuICB9LFxuICBfYXBwZW5kR2hvc3Q6IGZ1bmN0aW9uIF9hcHBlbmRHaG9zdCgpIHtcbiAgICAvLyBCdWcgaWYgdXNpbmcgc2NhbGUoKTogaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMjYzNzA1OFxuICAgIC8vIE5vdCBiZWluZyBhZGp1c3RlZCBmb3JcbiAgICBpZiAoIWdob3N0RWwpIHtcbiAgICAgIHZhciBjb250YWluZXIgPSB0aGlzLm9wdGlvbnMuZmFsbGJhY2tPbkJvZHkgPyBkb2N1bWVudC5ib2R5IDogcm9vdEVsLFxuICAgICAgICAgIHJlY3QgPSBnZXRSZWN0KGRyYWdFbCwgdHJ1ZSwgUG9zaXRpb25HaG9zdEFic29sdXRlbHksIHRydWUsIGNvbnRhaW5lciksXG4gICAgICAgICAgb3B0aW9ucyA9IHRoaXMub3B0aW9uczsgLy8gUG9zaXRpb24gYWJzb2x1dGVseVxuXG4gICAgICBpZiAoUG9zaXRpb25HaG9zdEFic29sdXRlbHkpIHtcbiAgICAgICAgLy8gR2V0IHJlbGF0aXZlbHkgcG9zaXRpb25lZCBwYXJlbnRcbiAgICAgICAgZ2hvc3RSZWxhdGl2ZVBhcmVudCA9IGNvbnRhaW5lcjtcblxuICAgICAgICB3aGlsZSAoY3NzKGdob3N0UmVsYXRpdmVQYXJlbnQsICdwb3NpdGlvbicpID09PSAnc3RhdGljJyAmJiBjc3MoZ2hvc3RSZWxhdGl2ZVBhcmVudCwgJ3RyYW5zZm9ybScpID09PSAnbm9uZScgJiYgZ2hvc3RSZWxhdGl2ZVBhcmVudCAhPT0gZG9jdW1lbnQpIHtcbiAgICAgICAgICBnaG9zdFJlbGF0aXZlUGFyZW50ID0gZ2hvc3RSZWxhdGl2ZVBhcmVudC5wYXJlbnROb2RlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGdob3N0UmVsYXRpdmVQYXJlbnQgIT09IGRvY3VtZW50LmJvZHkgJiYgZ2hvc3RSZWxhdGl2ZVBhcmVudCAhPT0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50KSB7XG4gICAgICAgICAgaWYgKGdob3N0UmVsYXRpdmVQYXJlbnQgPT09IGRvY3VtZW50KSBnaG9zdFJlbGF0aXZlUGFyZW50ID0gZ2V0V2luZG93U2Nyb2xsaW5nRWxlbWVudCgpO1xuICAgICAgICAgIHJlY3QudG9wICs9IGdob3N0UmVsYXRpdmVQYXJlbnQuc2Nyb2xsVG9wO1xuICAgICAgICAgIHJlY3QubGVmdCArPSBnaG9zdFJlbGF0aXZlUGFyZW50LnNjcm9sbExlZnQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZ2hvc3RSZWxhdGl2ZVBhcmVudCA9IGdldFdpbmRvd1Njcm9sbGluZ0VsZW1lbnQoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGdob3N0UmVsYXRpdmVQYXJlbnRJbml0aWFsU2Nyb2xsID0gZ2V0UmVsYXRpdmVTY3JvbGxPZmZzZXQoZ2hvc3RSZWxhdGl2ZVBhcmVudCk7XG4gICAgICB9XG5cbiAgICAgIGdob3N0RWwgPSBkcmFnRWwuY2xvbmVOb2RlKHRydWUpO1xuICAgICAgdG9nZ2xlQ2xhc3MoZ2hvc3RFbCwgb3B0aW9ucy5naG9zdENsYXNzLCBmYWxzZSk7XG4gICAgICB0b2dnbGVDbGFzcyhnaG9zdEVsLCBvcHRpb25zLmZhbGxiYWNrQ2xhc3MsIHRydWUpO1xuICAgICAgdG9nZ2xlQ2xhc3MoZ2hvc3RFbCwgb3B0aW9ucy5kcmFnQ2xhc3MsIHRydWUpO1xuICAgICAgY3NzKGdob3N0RWwsICd0cmFuc2l0aW9uJywgJycpO1xuICAgICAgY3NzKGdob3N0RWwsICd0cmFuc2Zvcm0nLCAnJyk7XG4gICAgICBjc3MoZ2hvc3RFbCwgJ2JveC1zaXppbmcnLCAnYm9yZGVyLWJveCcpO1xuICAgICAgY3NzKGdob3N0RWwsICdtYXJnaW4nLCAwKTtcbiAgICAgIGNzcyhnaG9zdEVsLCAndG9wJywgcmVjdC50b3ApO1xuICAgICAgY3NzKGdob3N0RWwsICdsZWZ0JywgcmVjdC5sZWZ0KTtcbiAgICAgIGNzcyhnaG9zdEVsLCAnd2lkdGgnLCByZWN0LndpZHRoKTtcbiAgICAgIGNzcyhnaG9zdEVsLCAnaGVpZ2h0JywgcmVjdC5oZWlnaHQpO1xuICAgICAgY3NzKGdob3N0RWwsICdvcGFjaXR5JywgJzAuOCcpO1xuICAgICAgY3NzKGdob3N0RWwsICdwb3NpdGlvbicsIFBvc2l0aW9uR2hvc3RBYnNvbHV0ZWx5ID8gJ2Fic29sdXRlJyA6ICdmaXhlZCcpO1xuICAgICAgY3NzKGdob3N0RWwsICd6SW5kZXgnLCAnMTAwMDAwJyk7XG4gICAgICBjc3MoZ2hvc3RFbCwgJ3BvaW50ZXJFdmVudHMnLCAnbm9uZScpO1xuICAgICAgU29ydGFibGUuZ2hvc3QgPSBnaG9zdEVsO1xuICAgICAgY29udGFpbmVyLmFwcGVuZENoaWxkKGdob3N0RWwpOyAvLyBTZXQgdHJhbnNmb3JtLW9yaWdpblxuXG4gICAgICBjc3MoZ2hvc3RFbCwgJ3RyYW5zZm9ybS1vcmlnaW4nLCB0YXBEaXN0YW5jZUxlZnQgLyBwYXJzZUludChnaG9zdEVsLnN0eWxlLndpZHRoKSAqIDEwMCArICclICcgKyB0YXBEaXN0YW5jZVRvcCAvIHBhcnNlSW50KGdob3N0RWwuc3R5bGUuaGVpZ2h0KSAqIDEwMCArICclJyk7XG4gICAgfVxuICB9LFxuICBfb25EcmFnU3RhcnQ6IGZ1bmN0aW9uIF9vbkRyYWdTdGFydChcbiAgLyoqRXZlbnQqL1xuICBldnQsXG4gIC8qKmJvb2xlYW4qL1xuICBmYWxsYmFjaykge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICB2YXIgZGF0YVRyYW5zZmVyID0gZXZ0LmRhdGFUcmFuc2ZlcjtcbiAgICB2YXIgb3B0aW9ucyA9IF90aGlzLm9wdGlvbnM7XG4gICAgcGx1Z2luRXZlbnQoJ2RyYWdTdGFydCcsIHRoaXMsIHtcbiAgICAgIGV2dDogZXZ0XG4gICAgfSk7XG5cbiAgICBpZiAoU29ydGFibGUuZXZlbnRDYW5jZWxlZCkge1xuICAgICAgdGhpcy5fb25Ecm9wKCk7XG5cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBwbHVnaW5FdmVudCgnc2V0dXBDbG9uZScsIHRoaXMpO1xuXG4gICAgaWYgKCFTb3J0YWJsZS5ldmVudENhbmNlbGVkKSB7XG4gICAgICBjbG9uZUVsID0gY2xvbmUoZHJhZ0VsKTtcbiAgICAgIGNsb25lRWwuZHJhZ2dhYmxlID0gZmFsc2U7XG4gICAgICBjbG9uZUVsLnN0eWxlWyd3aWxsLWNoYW5nZSddID0gJyc7XG5cbiAgICAgIHRoaXMuX2hpZGVDbG9uZSgpO1xuXG4gICAgICB0b2dnbGVDbGFzcyhjbG9uZUVsLCB0aGlzLm9wdGlvbnMuY2hvc2VuQ2xhc3MsIGZhbHNlKTtcbiAgICAgIFNvcnRhYmxlLmNsb25lID0gY2xvbmVFbDtcbiAgICB9IC8vICMxMTQzOiBJRnJhbWUgc3VwcG9ydCB3b3JrYXJvdW5kXG5cblxuICAgIF90aGlzLmNsb25lSWQgPSBfbmV4dFRpY2soZnVuY3Rpb24gKCkge1xuICAgICAgcGx1Z2luRXZlbnQoJ2Nsb25lJywgX3RoaXMpO1xuICAgICAgaWYgKFNvcnRhYmxlLmV2ZW50Q2FuY2VsZWQpIHJldHVybjtcblxuICAgICAgaWYgKCFfdGhpcy5vcHRpb25zLnJlbW92ZUNsb25lT25IaWRlKSB7XG4gICAgICAgIHJvb3RFbC5pbnNlcnRCZWZvcmUoY2xvbmVFbCwgZHJhZ0VsKTtcbiAgICAgIH1cblxuICAgICAgX3RoaXMuX2hpZGVDbG9uZSgpO1xuXG4gICAgICBfZGlzcGF0Y2hFdmVudCh7XG4gICAgICAgIHNvcnRhYmxlOiBfdGhpcyxcbiAgICAgICAgbmFtZTogJ2Nsb25lJ1xuICAgICAgfSk7XG4gICAgfSk7XG4gICAgIWZhbGxiYWNrICYmIHRvZ2dsZUNsYXNzKGRyYWdFbCwgb3B0aW9ucy5kcmFnQ2xhc3MsIHRydWUpOyAvLyBTZXQgcHJvcGVyIGRyb3AgZXZlbnRzXG5cbiAgICBpZiAoZmFsbGJhY2spIHtcbiAgICAgIGlnbm9yZU5leHRDbGljayA9IHRydWU7XG4gICAgICBfdGhpcy5fbG9vcElkID0gc2V0SW50ZXJ2YWwoX3RoaXMuX2VtdWxhdGVEcmFnT3ZlciwgNTApO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBVbmRvIHdoYXQgd2FzIHNldCBpbiBfcHJlcGFyZURyYWdTdGFydCBiZWZvcmUgZHJhZyBzdGFydGVkXG4gICAgICBvZmYoZG9jdW1lbnQsICdtb3VzZXVwJywgX3RoaXMuX29uRHJvcCk7XG4gICAgICBvZmYoZG9jdW1lbnQsICd0b3VjaGVuZCcsIF90aGlzLl9vbkRyb3ApO1xuICAgICAgb2ZmKGRvY3VtZW50LCAndG91Y2hjYW5jZWwnLCBfdGhpcy5fb25Ecm9wKTtcblxuICAgICAgaWYgKGRhdGFUcmFuc2Zlcikge1xuICAgICAgICBkYXRhVHJhbnNmZXIuZWZmZWN0QWxsb3dlZCA9ICdtb3ZlJztcbiAgICAgICAgb3B0aW9ucy5zZXREYXRhICYmIG9wdGlvbnMuc2V0RGF0YS5jYWxsKF90aGlzLCBkYXRhVHJhbnNmZXIsIGRyYWdFbCk7XG4gICAgICB9XG5cbiAgICAgIG9uKGRvY3VtZW50LCAnZHJvcCcsIF90aGlzKTsgLy8gIzEyNzYgZml4OlxuXG4gICAgICBjc3MoZHJhZ0VsLCAndHJhbnNmb3JtJywgJ3RyYW5zbGF0ZVooMCknKTtcbiAgICB9XG5cbiAgICBhd2FpdGluZ0RyYWdTdGFydGVkID0gdHJ1ZTtcbiAgICBfdGhpcy5fZHJhZ1N0YXJ0SWQgPSBfbmV4dFRpY2soX3RoaXMuX2RyYWdTdGFydGVkLmJpbmQoX3RoaXMsIGZhbGxiYWNrLCBldnQpKTtcbiAgICBvbihkb2N1bWVudCwgJ3NlbGVjdHN0YXJ0JywgX3RoaXMpO1xuICAgIG1vdmVkID0gdHJ1ZTtcblxuICAgIGlmIChTYWZhcmkpIHtcbiAgICAgIGNzcyhkb2N1bWVudC5ib2R5LCAndXNlci1zZWxlY3QnLCAnbm9uZScpO1xuICAgIH1cbiAgfSxcbiAgLy8gUmV0dXJucyB0cnVlIC0gaWYgbm8gZnVydGhlciBhY3Rpb24gaXMgbmVlZGVkIChlaXRoZXIgaW5zZXJ0ZWQgb3IgYW5vdGhlciBjb25kaXRpb24pXG4gIF9vbkRyYWdPdmVyOiBmdW5jdGlvbiBfb25EcmFnT3ZlcihcbiAgLyoqRXZlbnQqL1xuICBldnQpIHtcbiAgICB2YXIgZWwgPSB0aGlzLmVsLFxuICAgICAgICB0YXJnZXQgPSBldnQudGFyZ2V0LFxuICAgICAgICBkcmFnUmVjdCxcbiAgICAgICAgdGFyZ2V0UmVjdCxcbiAgICAgICAgcmV2ZXJ0LFxuICAgICAgICBvcHRpb25zID0gdGhpcy5vcHRpb25zLFxuICAgICAgICBncm91cCA9IG9wdGlvbnMuZ3JvdXAsXG4gICAgICAgIGFjdGl2ZVNvcnRhYmxlID0gU29ydGFibGUuYWN0aXZlLFxuICAgICAgICBpc093bmVyID0gYWN0aXZlR3JvdXAgPT09IGdyb3VwLFxuICAgICAgICBjYW5Tb3J0ID0gb3B0aW9ucy5zb3J0LFxuICAgICAgICBmcm9tU29ydGFibGUgPSBwdXRTb3J0YWJsZSB8fCBhY3RpdmVTb3J0YWJsZSxcbiAgICAgICAgdmVydGljYWwsXG4gICAgICAgIF90aGlzID0gdGhpcyxcbiAgICAgICAgY29tcGxldGVkRmlyZWQgPSBmYWxzZTtcblxuICAgIGlmIChfc2lsZW50KSByZXR1cm47XG5cbiAgICBmdW5jdGlvbiBkcmFnT3ZlckV2ZW50KG5hbWUsIGV4dHJhKSB7XG4gICAgICBwbHVnaW5FdmVudChuYW1lLCBfdGhpcywgX29iamVjdFNwcmVhZCh7XG4gICAgICAgIGV2dDogZXZ0LFxuICAgICAgICBpc093bmVyOiBpc093bmVyLFxuICAgICAgICBheGlzOiB2ZXJ0aWNhbCA/ICd2ZXJ0aWNhbCcgOiAnaG9yaXpvbnRhbCcsXG4gICAgICAgIHJldmVydDogcmV2ZXJ0LFxuICAgICAgICBkcmFnUmVjdDogZHJhZ1JlY3QsXG4gICAgICAgIHRhcmdldFJlY3Q6IHRhcmdldFJlY3QsXG4gICAgICAgIGNhblNvcnQ6IGNhblNvcnQsXG4gICAgICAgIGZyb21Tb3J0YWJsZTogZnJvbVNvcnRhYmxlLFxuICAgICAgICB0YXJnZXQ6IHRhcmdldCxcbiAgICAgICAgY29tcGxldGVkOiBjb21wbGV0ZWQsXG4gICAgICAgIG9uTW92ZTogZnVuY3Rpb24gb25Nb3ZlKHRhcmdldCwgYWZ0ZXIpIHtcbiAgICAgICAgICByZXR1cm4gX29uTW92ZShyb290RWwsIGVsLCBkcmFnRWwsIGRyYWdSZWN0LCB0YXJnZXQsIGdldFJlY3QodGFyZ2V0KSwgZXZ0LCBhZnRlcik7XG4gICAgICAgIH0sXG4gICAgICAgIGNoYW5nZWQ6IGNoYW5nZWRcbiAgICAgIH0sIGV4dHJhKSk7XG4gICAgfSAvLyBDYXB0dXJlIGFuaW1hdGlvbiBzdGF0ZVxuXG5cbiAgICBmdW5jdGlvbiBjYXB0dXJlKCkge1xuICAgICAgZHJhZ092ZXJFdmVudCgnZHJhZ092ZXJBbmltYXRpb25DYXB0dXJlJyk7XG5cbiAgICAgIF90aGlzLmNhcHR1cmVBbmltYXRpb25TdGF0ZSgpO1xuXG4gICAgICBpZiAoX3RoaXMgIT09IGZyb21Tb3J0YWJsZSkge1xuICAgICAgICBmcm9tU29ydGFibGUuY2FwdHVyZUFuaW1hdGlvblN0YXRlKCk7XG4gICAgICB9XG4gICAgfSAvLyBSZXR1cm4gaW52b2NhdGlvbiB3aGVuIGRyYWdFbCBpcyBpbnNlcnRlZCAob3IgY29tcGxldGVkKVxuXG5cbiAgICBmdW5jdGlvbiBjb21wbGV0ZWQoaW5zZXJ0aW9uKSB7XG4gICAgICBkcmFnT3ZlckV2ZW50KCdkcmFnT3ZlckNvbXBsZXRlZCcsIHtcbiAgICAgICAgaW5zZXJ0aW9uOiBpbnNlcnRpb25cbiAgICAgIH0pO1xuXG4gICAgICBpZiAoaW5zZXJ0aW9uKSB7XG4gICAgICAgIC8vIENsb25lcyBtdXN0IGJlIGhpZGRlbiBiZWZvcmUgZm9sZGluZyBhbmltYXRpb24gdG8gY2FwdHVyZSBkcmFnUmVjdEFic29sdXRlIHByb3Blcmx5XG4gICAgICAgIGlmIChpc093bmVyKSB7XG4gICAgICAgICAgYWN0aXZlU29ydGFibGUuX2hpZGVDbG9uZSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGFjdGl2ZVNvcnRhYmxlLl9zaG93Q2xvbmUoX3RoaXMpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKF90aGlzICE9PSBmcm9tU29ydGFibGUpIHtcbiAgICAgICAgICAvLyBTZXQgZ2hvc3QgY2xhc3MgdG8gbmV3IHNvcnRhYmxlJ3MgZ2hvc3QgY2xhc3NcbiAgICAgICAgICB0b2dnbGVDbGFzcyhkcmFnRWwsIHB1dFNvcnRhYmxlID8gcHV0U29ydGFibGUub3B0aW9ucy5naG9zdENsYXNzIDogYWN0aXZlU29ydGFibGUub3B0aW9ucy5naG9zdENsYXNzLCBmYWxzZSk7XG4gICAgICAgICAgdG9nZ2xlQ2xhc3MoZHJhZ0VsLCBvcHRpb25zLmdob3N0Q2xhc3MsIHRydWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHB1dFNvcnRhYmxlICE9PSBfdGhpcyAmJiBfdGhpcyAhPT0gU29ydGFibGUuYWN0aXZlKSB7XG4gICAgICAgICAgcHV0U29ydGFibGUgPSBfdGhpcztcbiAgICAgICAgfSBlbHNlIGlmIChfdGhpcyA9PT0gU29ydGFibGUuYWN0aXZlICYmIHB1dFNvcnRhYmxlKSB7XG4gICAgICAgICAgcHV0U29ydGFibGUgPSBudWxsO1xuICAgICAgICB9IC8vIEFuaW1hdGlvblxuXG5cbiAgICAgICAgaWYgKGZyb21Tb3J0YWJsZSA9PT0gX3RoaXMpIHtcbiAgICAgICAgICBfdGhpcy5faWdub3JlV2hpbGVBbmltYXRpbmcgPSB0YXJnZXQ7XG4gICAgICAgIH1cblxuICAgICAgICBfdGhpcy5hbmltYXRlQWxsKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBkcmFnT3ZlckV2ZW50KCdkcmFnT3ZlckFuaW1hdGlvbkNvbXBsZXRlJyk7XG4gICAgICAgICAgX3RoaXMuX2lnbm9yZVdoaWxlQW5pbWF0aW5nID0gbnVsbDtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKF90aGlzICE9PSBmcm9tU29ydGFibGUpIHtcbiAgICAgICAgICBmcm9tU29ydGFibGUuYW5pbWF0ZUFsbCgpO1xuICAgICAgICAgIGZyb21Tb3J0YWJsZS5faWdub3JlV2hpbGVBbmltYXRpbmcgPSBudWxsO1xuICAgICAgICB9XG4gICAgICB9IC8vIE51bGwgbGFzdFRhcmdldCBpZiBpdCBpcyBub3QgaW5zaWRlIGEgcHJldmlvdXNseSBzd2FwcGVkIGVsZW1lbnRcblxuXG4gICAgICBpZiAodGFyZ2V0ID09PSBkcmFnRWwgJiYgIWRyYWdFbC5hbmltYXRlZCB8fCB0YXJnZXQgPT09IGVsICYmICF0YXJnZXQuYW5pbWF0ZWQpIHtcbiAgICAgICAgbGFzdFRhcmdldCA9IG51bGw7XG4gICAgICB9IC8vIG5vIGJ1YmJsaW5nIGFuZCBub3QgZmFsbGJhY2tcblxuXG4gICAgICBpZiAoIW9wdGlvbnMuZHJhZ292ZXJCdWJibGUgJiYgIWV2dC5yb290RWwgJiYgdGFyZ2V0ICE9PSBkb2N1bWVudCkge1xuICAgICAgICBkcmFnRWwucGFyZW50Tm9kZVtleHBhbmRvXS5faXNPdXRzaWRlVGhpc0VsKGV2dC50YXJnZXQpOyAvLyBEbyBub3QgZGV0ZWN0IGZvciBlbXB0eSBpbnNlcnQgaWYgYWxyZWFkeSBpbnNlcnRlZFxuXG5cbiAgICAgICAgIWluc2VydGlvbiAmJiBuZWFyZXN0RW1wdHlJbnNlcnREZXRlY3RFdmVudChldnQpO1xuICAgICAgfVxuXG4gICAgICAhb3B0aW9ucy5kcmFnb3ZlckJ1YmJsZSAmJiBldnQuc3RvcFByb3BhZ2F0aW9uICYmIGV2dC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgIHJldHVybiBjb21wbGV0ZWRGaXJlZCA9IHRydWU7XG4gICAgfSAvLyBDYWxsIHdoZW4gZHJhZ0VsIGhhcyBiZWVuIGluc2VydGVkXG5cblxuICAgIGZ1bmN0aW9uIGNoYW5nZWQoKSB7XG4gICAgICBuZXdJbmRleCA9IGluZGV4KGRyYWdFbCk7XG4gICAgICBuZXdEcmFnZ2FibGVJbmRleCA9IGluZGV4KGRyYWdFbCwgb3B0aW9ucy5kcmFnZ2FibGUpO1xuXG4gICAgICBfZGlzcGF0Y2hFdmVudCh7XG4gICAgICAgIHNvcnRhYmxlOiBfdGhpcyxcbiAgICAgICAgbmFtZTogJ2NoYW5nZScsXG4gICAgICAgIHRvRWw6IGVsLFxuICAgICAgICBuZXdJbmRleDogbmV3SW5kZXgsXG4gICAgICAgIG5ld0RyYWdnYWJsZUluZGV4OiBuZXdEcmFnZ2FibGVJbmRleCxcbiAgICAgICAgb3JpZ2luYWxFdmVudDogZXZ0XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAoZXZ0LnByZXZlbnREZWZhdWx0ICE9PSB2b2lkIDApIHtcbiAgICAgIGV2dC5jYW5jZWxhYmxlICYmIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH1cblxuICAgIHRhcmdldCA9IGNsb3Nlc3QodGFyZ2V0LCBvcHRpb25zLmRyYWdnYWJsZSwgZWwsIHRydWUpO1xuICAgIGRyYWdPdmVyRXZlbnQoJ2RyYWdPdmVyJyk7XG4gICAgaWYgKFNvcnRhYmxlLmV2ZW50Q2FuY2VsZWQpIHJldHVybiBjb21wbGV0ZWRGaXJlZDtcblxuICAgIGlmIChkcmFnRWwuY29udGFpbnMoZXZ0LnRhcmdldCkgfHwgdGFyZ2V0LmFuaW1hdGVkICYmIHRhcmdldC5hbmltYXRpbmdYICYmIHRhcmdldC5hbmltYXRpbmdZIHx8IF90aGlzLl9pZ25vcmVXaGlsZUFuaW1hdGluZyA9PT0gdGFyZ2V0KSB7XG4gICAgICByZXR1cm4gY29tcGxldGVkKGZhbHNlKTtcbiAgICB9XG5cbiAgICBpZ25vcmVOZXh0Q2xpY2sgPSBmYWxzZTtcblxuICAgIGlmIChhY3RpdmVTb3J0YWJsZSAmJiAhb3B0aW9ucy5kaXNhYmxlZCAmJiAoaXNPd25lciA/IGNhblNvcnQgfHwgKHJldmVydCA9ICFyb290RWwuY29udGFpbnMoZHJhZ0VsKSkgLy8gUmV2ZXJ0aW5nIGl0ZW0gaW50byB0aGUgb3JpZ2luYWwgbGlzdFxuICAgIDogcHV0U29ydGFibGUgPT09IHRoaXMgfHwgKHRoaXMubGFzdFB1dE1vZGUgPSBhY3RpdmVHcm91cC5jaGVja1B1bGwodGhpcywgYWN0aXZlU29ydGFibGUsIGRyYWdFbCwgZXZ0KSkgJiYgZ3JvdXAuY2hlY2tQdXQodGhpcywgYWN0aXZlU29ydGFibGUsIGRyYWdFbCwgZXZ0KSkpIHtcbiAgICAgIHZlcnRpY2FsID0gdGhpcy5fZ2V0RGlyZWN0aW9uKGV2dCwgdGFyZ2V0KSA9PT0gJ3ZlcnRpY2FsJztcbiAgICAgIGRyYWdSZWN0ID0gZ2V0UmVjdChkcmFnRWwpO1xuICAgICAgZHJhZ092ZXJFdmVudCgnZHJhZ092ZXJWYWxpZCcpO1xuICAgICAgaWYgKFNvcnRhYmxlLmV2ZW50Q2FuY2VsZWQpIHJldHVybiBjb21wbGV0ZWRGaXJlZDtcblxuICAgICAgaWYgKHJldmVydCkge1xuICAgICAgICBwYXJlbnRFbCA9IHJvb3RFbDsgLy8gYWN0dWFsaXphdGlvblxuXG4gICAgICAgIGNhcHR1cmUoKTtcblxuICAgICAgICB0aGlzLl9oaWRlQ2xvbmUoKTtcblxuICAgICAgICBkcmFnT3ZlckV2ZW50KCdyZXZlcnQnKTtcblxuICAgICAgICBpZiAoIVNvcnRhYmxlLmV2ZW50Q2FuY2VsZWQpIHtcbiAgICAgICAgICBpZiAobmV4dEVsKSB7XG4gICAgICAgICAgICByb290RWwuaW5zZXJ0QmVmb3JlKGRyYWdFbCwgbmV4dEVsKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcm9vdEVsLmFwcGVuZENoaWxkKGRyYWdFbCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGNvbXBsZXRlZCh0cnVlKTtcbiAgICAgIH1cblxuICAgICAgdmFyIGVsTGFzdENoaWxkID0gbGFzdENoaWxkKGVsLCBvcHRpb25zLmRyYWdnYWJsZSk7XG5cbiAgICAgIGlmICghZWxMYXN0Q2hpbGQgfHwgX2dob3N0SXNMYXN0KGV2dCwgdmVydGljYWwsIHRoaXMpICYmICFlbExhc3RDaGlsZC5hbmltYXRlZCkge1xuICAgICAgICAvLyBJZiBhbHJlYWR5IGF0IGVuZCBvZiBsaXN0OiBEbyBub3QgaW5zZXJ0XG4gICAgICAgIGlmIChlbExhc3RDaGlsZCA9PT0gZHJhZ0VsKSB7XG4gICAgICAgICAgcmV0dXJuIGNvbXBsZXRlZChmYWxzZSk7XG4gICAgICAgIH0gLy8gYXNzaWduIHRhcmdldCBvbmx5IGlmIGNvbmRpdGlvbiBpcyB0cnVlXG5cblxuICAgICAgICBpZiAoZWxMYXN0Q2hpbGQgJiYgZWwgPT09IGV2dC50YXJnZXQpIHtcbiAgICAgICAgICB0YXJnZXQgPSBlbExhc3RDaGlsZDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0YXJnZXQpIHtcbiAgICAgICAgICB0YXJnZXRSZWN0ID0gZ2V0UmVjdCh0YXJnZXQpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKF9vbk1vdmUocm9vdEVsLCBlbCwgZHJhZ0VsLCBkcmFnUmVjdCwgdGFyZ2V0LCB0YXJnZXRSZWN0LCBldnQsICEhdGFyZ2V0KSAhPT0gZmFsc2UpIHtcbiAgICAgICAgICBjYXB0dXJlKCk7XG4gICAgICAgICAgZWwuYXBwZW5kQ2hpbGQoZHJhZ0VsKTtcbiAgICAgICAgICBwYXJlbnRFbCA9IGVsOyAvLyBhY3R1YWxpemF0aW9uXG5cbiAgICAgICAgICBjaGFuZ2VkKCk7XG4gICAgICAgICAgcmV0dXJuIGNvbXBsZXRlZCh0cnVlKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh0YXJnZXQucGFyZW50Tm9kZSA9PT0gZWwpIHtcbiAgICAgICAgdGFyZ2V0UmVjdCA9IGdldFJlY3QodGFyZ2V0KTtcbiAgICAgICAgdmFyIGRpcmVjdGlvbiA9IDAsXG4gICAgICAgICAgICB0YXJnZXRCZWZvcmVGaXJzdFN3YXAsXG4gICAgICAgICAgICBkaWZmZXJlbnRMZXZlbCA9IGRyYWdFbC5wYXJlbnROb2RlICE9PSBlbCxcbiAgICAgICAgICAgIGRpZmZlcmVudFJvd0NvbCA9ICFfZHJhZ0VsSW5Sb3dDb2x1bW4oZHJhZ0VsLmFuaW1hdGVkICYmIGRyYWdFbC50b1JlY3QgfHwgZHJhZ1JlY3QsIHRhcmdldC5hbmltYXRlZCAmJiB0YXJnZXQudG9SZWN0IHx8IHRhcmdldFJlY3QsIHZlcnRpY2FsKSxcbiAgICAgICAgICAgIHNpZGUxID0gdmVydGljYWwgPyAndG9wJyA6ICdsZWZ0JyxcbiAgICAgICAgICAgIHNjcm9sbGVkUGFzdFRvcCA9IGlzU2Nyb2xsZWRQYXN0KHRhcmdldCwgJ3RvcCcsICd0b3AnKSB8fCBpc1Njcm9sbGVkUGFzdChkcmFnRWwsICd0b3AnLCAndG9wJyksXG4gICAgICAgICAgICBzY3JvbGxCZWZvcmUgPSBzY3JvbGxlZFBhc3RUb3AgPyBzY3JvbGxlZFBhc3RUb3Auc2Nyb2xsVG9wIDogdm9pZCAwO1xuXG4gICAgICAgIGlmIChsYXN0VGFyZ2V0ICE9PSB0YXJnZXQpIHtcbiAgICAgICAgICB0YXJnZXRCZWZvcmVGaXJzdFN3YXAgPSB0YXJnZXRSZWN0W3NpZGUxXTtcbiAgICAgICAgICBwYXN0Rmlyc3RJbnZlcnRUaHJlc2ggPSBmYWxzZTtcbiAgICAgICAgICBpc0NpcmN1bXN0YW50aWFsSW52ZXJ0ID0gIWRpZmZlcmVudFJvd0NvbCAmJiBvcHRpb25zLmludmVydFN3YXAgfHwgZGlmZmVyZW50TGV2ZWw7XG4gICAgICAgIH1cblxuICAgICAgICBkaXJlY3Rpb24gPSBfZ2V0U3dhcERpcmVjdGlvbihldnQsIHRhcmdldCwgdGFyZ2V0UmVjdCwgdmVydGljYWwsIGRpZmZlcmVudFJvd0NvbCA/IDEgOiBvcHRpb25zLnN3YXBUaHJlc2hvbGQsIG9wdGlvbnMuaW52ZXJ0ZWRTd2FwVGhyZXNob2xkID09IG51bGwgPyBvcHRpb25zLnN3YXBUaHJlc2hvbGQgOiBvcHRpb25zLmludmVydGVkU3dhcFRocmVzaG9sZCwgaXNDaXJjdW1zdGFudGlhbEludmVydCwgbGFzdFRhcmdldCA9PT0gdGFyZ2V0KTtcbiAgICAgICAgdmFyIHNpYmxpbmc7XG5cbiAgICAgICAgaWYgKGRpcmVjdGlvbiAhPT0gMCkge1xuICAgICAgICAgIC8vIENoZWNrIGlmIHRhcmdldCBpcyBiZXNpZGUgZHJhZ0VsIGluIHJlc3BlY3RpdmUgZGlyZWN0aW9uIChpZ25vcmluZyBoaWRkZW4gZWxlbWVudHMpXG4gICAgICAgICAgdmFyIGRyYWdJbmRleCA9IGluZGV4KGRyYWdFbCk7XG5cbiAgICAgICAgICBkbyB7XG4gICAgICAgICAgICBkcmFnSW5kZXggLT0gZGlyZWN0aW9uO1xuICAgICAgICAgICAgc2libGluZyA9IHBhcmVudEVsLmNoaWxkcmVuW2RyYWdJbmRleF07XG4gICAgICAgICAgfSB3aGlsZSAoc2libGluZyAmJiAoY3NzKHNpYmxpbmcsICdkaXNwbGF5JykgPT09ICdub25lJyB8fCBzaWJsaW5nID09PSBnaG9zdEVsKSk7XG4gICAgICAgIH0gLy8gSWYgZHJhZ0VsIGlzIGFscmVhZHkgYmVzaWRlIHRhcmdldDogRG8gbm90IGluc2VydFxuXG5cbiAgICAgICAgaWYgKGRpcmVjdGlvbiA9PT0gMCB8fCBzaWJsaW5nID09PSB0YXJnZXQpIHtcbiAgICAgICAgICByZXR1cm4gY29tcGxldGVkKGZhbHNlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxhc3RUYXJnZXQgPSB0YXJnZXQ7XG4gICAgICAgIGxhc3REaXJlY3Rpb24gPSBkaXJlY3Rpb247XG4gICAgICAgIHZhciBuZXh0U2libGluZyA9IHRhcmdldC5uZXh0RWxlbWVudFNpYmxpbmcsXG4gICAgICAgICAgICBhZnRlciA9IGZhbHNlO1xuICAgICAgICBhZnRlciA9IGRpcmVjdGlvbiA9PT0gMTtcblxuICAgICAgICB2YXIgbW92ZVZlY3RvciA9IF9vbk1vdmUocm9vdEVsLCBlbCwgZHJhZ0VsLCBkcmFnUmVjdCwgdGFyZ2V0LCB0YXJnZXRSZWN0LCBldnQsIGFmdGVyKTtcblxuICAgICAgICBpZiAobW92ZVZlY3RvciAhPT0gZmFsc2UpIHtcbiAgICAgICAgICBpZiAobW92ZVZlY3RvciA9PT0gMSB8fCBtb3ZlVmVjdG9yID09PSAtMSkge1xuICAgICAgICAgICAgYWZ0ZXIgPSBtb3ZlVmVjdG9yID09PSAxO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIF9zaWxlbnQgPSB0cnVlO1xuICAgICAgICAgIHNldFRpbWVvdXQoX3Vuc2lsZW50LCAzMCk7XG4gICAgICAgICAgY2FwdHVyZSgpO1xuXG4gICAgICAgICAgaWYgKGFmdGVyICYmICFuZXh0U2libGluZykge1xuICAgICAgICAgICAgZWwuYXBwZW5kQ2hpbGQoZHJhZ0VsKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGFyZ2V0LnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKGRyYWdFbCwgYWZ0ZXIgPyBuZXh0U2libGluZyA6IHRhcmdldCk7XG4gICAgICAgICAgfSAvLyBVbmRvIGNocm9tZSdzIHNjcm9sbCBhZGp1c3RtZW50IChoYXMgbm8gZWZmZWN0IG9uIG90aGVyIGJyb3dzZXJzKVxuXG5cbiAgICAgICAgICBpZiAoc2Nyb2xsZWRQYXN0VG9wKSB7XG4gICAgICAgICAgICBzY3JvbGxCeShzY3JvbGxlZFBhc3RUb3AsIDAsIHNjcm9sbEJlZm9yZSAtIHNjcm9sbGVkUGFzdFRvcC5zY3JvbGxUb3ApO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHBhcmVudEVsID0gZHJhZ0VsLnBhcmVudE5vZGU7IC8vIGFjdHVhbGl6YXRpb25cbiAgICAgICAgICAvLyBtdXN0IGJlIGRvbmUgYmVmb3JlIGFuaW1hdGlvblxuXG4gICAgICAgICAgaWYgKHRhcmdldEJlZm9yZUZpcnN0U3dhcCAhPT0gdW5kZWZpbmVkICYmICFpc0NpcmN1bXN0YW50aWFsSW52ZXJ0KSB7XG4gICAgICAgICAgICB0YXJnZXRNb3ZlRGlzdGFuY2UgPSBNYXRoLmFicyh0YXJnZXRCZWZvcmVGaXJzdFN3YXAgLSBnZXRSZWN0KHRhcmdldClbc2lkZTFdKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjaGFuZ2VkKCk7XG4gICAgICAgICAgcmV0dXJuIGNvbXBsZXRlZCh0cnVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoZWwuY29udGFpbnMoZHJhZ0VsKSkge1xuICAgICAgICByZXR1cm4gY29tcGxldGVkKGZhbHNlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH0sXG4gIF9pZ25vcmVXaGlsZUFuaW1hdGluZzogbnVsbCxcbiAgX29mZk1vdmVFdmVudHM6IGZ1bmN0aW9uIF9vZmZNb3ZlRXZlbnRzKCkge1xuICAgIG9mZihkb2N1bWVudCwgJ21vdXNlbW92ZScsIHRoaXMuX29uVG91Y2hNb3ZlKTtcbiAgICBvZmYoZG9jdW1lbnQsICd0b3VjaG1vdmUnLCB0aGlzLl9vblRvdWNoTW92ZSk7XG4gICAgb2ZmKGRvY3VtZW50LCAncG9pbnRlcm1vdmUnLCB0aGlzLl9vblRvdWNoTW92ZSk7XG4gICAgb2ZmKGRvY3VtZW50LCAnZHJhZ292ZXInLCBuZWFyZXN0RW1wdHlJbnNlcnREZXRlY3RFdmVudCk7XG4gICAgb2ZmKGRvY3VtZW50LCAnbW91c2Vtb3ZlJywgbmVhcmVzdEVtcHR5SW5zZXJ0RGV0ZWN0RXZlbnQpO1xuICAgIG9mZihkb2N1bWVudCwgJ3RvdWNobW92ZScsIG5lYXJlc3RFbXB0eUluc2VydERldGVjdEV2ZW50KTtcbiAgfSxcbiAgX29mZlVwRXZlbnRzOiBmdW5jdGlvbiBfb2ZmVXBFdmVudHMoKSB7XG4gICAgdmFyIG93bmVyRG9jdW1lbnQgPSB0aGlzLmVsLm93bmVyRG9jdW1lbnQ7XG4gICAgb2ZmKG93bmVyRG9jdW1lbnQsICdtb3VzZXVwJywgdGhpcy5fb25Ecm9wKTtcbiAgICBvZmYob3duZXJEb2N1bWVudCwgJ3RvdWNoZW5kJywgdGhpcy5fb25Ecm9wKTtcbiAgICBvZmYob3duZXJEb2N1bWVudCwgJ3BvaW50ZXJ1cCcsIHRoaXMuX29uRHJvcCk7XG4gICAgb2ZmKG93bmVyRG9jdW1lbnQsICd0b3VjaGNhbmNlbCcsIHRoaXMuX29uRHJvcCk7XG4gICAgb2ZmKGRvY3VtZW50LCAnc2VsZWN0c3RhcnQnLCB0aGlzKTtcbiAgfSxcbiAgX29uRHJvcDogZnVuY3Rpb24gX29uRHJvcChcbiAgLyoqRXZlbnQqL1xuICBldnQpIHtcbiAgICB2YXIgZWwgPSB0aGlzLmVsLFxuICAgICAgICBvcHRpb25zID0gdGhpcy5vcHRpb25zOyAvLyBHZXQgdGhlIGluZGV4IG9mIHRoZSBkcmFnZ2VkIGVsZW1lbnQgd2l0aGluIGl0cyBwYXJlbnRcblxuICAgIG5ld0luZGV4ID0gaW5kZXgoZHJhZ0VsKTtcbiAgICBuZXdEcmFnZ2FibGVJbmRleCA9IGluZGV4KGRyYWdFbCwgb3B0aW9ucy5kcmFnZ2FibGUpO1xuICAgIHBsdWdpbkV2ZW50KCdkcm9wJywgdGhpcywge1xuICAgICAgZXZ0OiBldnRcbiAgICB9KTtcbiAgICBwYXJlbnRFbCA9IGRyYWdFbCAmJiBkcmFnRWwucGFyZW50Tm9kZTsgLy8gR2V0IGFnYWluIGFmdGVyIHBsdWdpbiBldmVudFxuXG4gICAgbmV3SW5kZXggPSBpbmRleChkcmFnRWwpO1xuICAgIG5ld0RyYWdnYWJsZUluZGV4ID0gaW5kZXgoZHJhZ0VsLCBvcHRpb25zLmRyYWdnYWJsZSk7XG5cbiAgICBpZiAoU29ydGFibGUuZXZlbnRDYW5jZWxlZCkge1xuICAgICAgdGhpcy5fbnVsbGluZygpO1xuXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgYXdhaXRpbmdEcmFnU3RhcnRlZCA9IGZhbHNlO1xuICAgIGlzQ2lyY3Vtc3RhbnRpYWxJbnZlcnQgPSBmYWxzZTtcbiAgICBwYXN0Rmlyc3RJbnZlcnRUaHJlc2ggPSBmYWxzZTtcbiAgICBjbGVhckludGVydmFsKHRoaXMuX2xvb3BJZCk7XG4gICAgY2xlYXJUaW1lb3V0KHRoaXMuX2RyYWdTdGFydFRpbWVyKTtcblxuICAgIF9jYW5jZWxOZXh0VGljayh0aGlzLmNsb25lSWQpO1xuXG4gICAgX2NhbmNlbE5leHRUaWNrKHRoaXMuX2RyYWdTdGFydElkKTsgLy8gVW5iaW5kIGV2ZW50c1xuXG5cbiAgICBpZiAodGhpcy5uYXRpdmVEcmFnZ2FibGUpIHtcbiAgICAgIG9mZihkb2N1bWVudCwgJ2Ryb3AnLCB0aGlzKTtcbiAgICAgIG9mZihlbCwgJ2RyYWdzdGFydCcsIHRoaXMuX29uRHJhZ1N0YXJ0KTtcbiAgICB9XG5cbiAgICB0aGlzLl9vZmZNb3ZlRXZlbnRzKCk7XG5cbiAgICB0aGlzLl9vZmZVcEV2ZW50cygpO1xuXG4gICAgaWYgKFNhZmFyaSkge1xuICAgICAgY3NzKGRvY3VtZW50LmJvZHksICd1c2VyLXNlbGVjdCcsICcnKTtcbiAgICB9XG5cbiAgICBjc3MoZHJhZ0VsLCAndHJhbnNmb3JtJywgJycpO1xuXG4gICAgaWYgKGV2dCkge1xuICAgICAgaWYgKG1vdmVkKSB7XG4gICAgICAgIGV2dC5jYW5jZWxhYmxlICYmIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAhb3B0aW9ucy5kcm9wQnViYmxlICYmIGV2dC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgIH1cblxuICAgICAgZ2hvc3RFbCAmJiBnaG9zdEVsLnBhcmVudE5vZGUgJiYgZ2hvc3RFbC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGdob3N0RWwpO1xuXG4gICAgICBpZiAocm9vdEVsID09PSBwYXJlbnRFbCB8fCBwdXRTb3J0YWJsZSAmJiBwdXRTb3J0YWJsZS5sYXN0UHV0TW9kZSAhPT0gJ2Nsb25lJykge1xuICAgICAgICAvLyBSZW1vdmUgY2xvbmUocylcbiAgICAgICAgY2xvbmVFbCAmJiBjbG9uZUVsLnBhcmVudE5vZGUgJiYgY2xvbmVFbC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGNsb25lRWwpO1xuICAgICAgfVxuXG4gICAgICBpZiAoZHJhZ0VsKSB7XG4gICAgICAgIGlmICh0aGlzLm5hdGl2ZURyYWdnYWJsZSkge1xuICAgICAgICAgIG9mZihkcmFnRWwsICdkcmFnZW5kJywgdGhpcyk7XG4gICAgICAgIH1cblxuICAgICAgICBfZGlzYWJsZURyYWdnYWJsZShkcmFnRWwpO1xuXG4gICAgICAgIGRyYWdFbC5zdHlsZVsnd2lsbC1jaGFuZ2UnXSA9ICcnOyAvLyBSZW1vdmUgY2xhc3Nlc1xuICAgICAgICAvLyBnaG9zdENsYXNzIGlzIGFkZGVkIGluIGRyYWdTdGFydGVkXG5cbiAgICAgICAgaWYgKG1vdmVkICYmICFhd2FpdGluZ0RyYWdTdGFydGVkKSB7XG4gICAgICAgICAgdG9nZ2xlQ2xhc3MoZHJhZ0VsLCBwdXRTb3J0YWJsZSA/IHB1dFNvcnRhYmxlLm9wdGlvbnMuZ2hvc3RDbGFzcyA6IHRoaXMub3B0aW9ucy5naG9zdENsYXNzLCBmYWxzZSk7XG4gICAgICAgIH1cblxuICAgICAgICB0b2dnbGVDbGFzcyhkcmFnRWwsIHRoaXMub3B0aW9ucy5jaG9zZW5DbGFzcywgZmFsc2UpOyAvLyBEcmFnIHN0b3AgZXZlbnRcblxuICAgICAgICBfZGlzcGF0Y2hFdmVudCh7XG4gICAgICAgICAgc29ydGFibGU6IHRoaXMsXG4gICAgICAgICAgbmFtZTogJ3VuY2hvb3NlJyxcbiAgICAgICAgICB0b0VsOiBwYXJlbnRFbCxcbiAgICAgICAgICBuZXdJbmRleDogbnVsbCxcbiAgICAgICAgICBuZXdEcmFnZ2FibGVJbmRleDogbnVsbCxcbiAgICAgICAgICBvcmlnaW5hbEV2ZW50OiBldnRcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKHJvb3RFbCAhPT0gcGFyZW50RWwpIHtcbiAgICAgICAgICBpZiAobmV3SW5kZXggPj0gMCkge1xuICAgICAgICAgICAgLy8gQWRkIGV2ZW50XG4gICAgICAgICAgICBfZGlzcGF0Y2hFdmVudCh7XG4gICAgICAgICAgICAgIHJvb3RFbDogcGFyZW50RWwsXG4gICAgICAgICAgICAgIG5hbWU6ICdhZGQnLFxuICAgICAgICAgICAgICB0b0VsOiBwYXJlbnRFbCxcbiAgICAgICAgICAgICAgZnJvbUVsOiByb290RWwsXG4gICAgICAgICAgICAgIG9yaWdpbmFsRXZlbnQ6IGV2dFxuICAgICAgICAgICAgfSk7IC8vIFJlbW92ZSBldmVudFxuXG5cbiAgICAgICAgICAgIF9kaXNwYXRjaEV2ZW50KHtcbiAgICAgICAgICAgICAgc29ydGFibGU6IHRoaXMsXG4gICAgICAgICAgICAgIG5hbWU6ICdyZW1vdmUnLFxuICAgICAgICAgICAgICB0b0VsOiBwYXJlbnRFbCxcbiAgICAgICAgICAgICAgb3JpZ2luYWxFdmVudDogZXZ0XG4gICAgICAgICAgICB9KTsgLy8gZHJhZyBmcm9tIG9uZSBsaXN0IGFuZCBkcm9wIGludG8gYW5vdGhlclxuXG5cbiAgICAgICAgICAgIF9kaXNwYXRjaEV2ZW50KHtcbiAgICAgICAgICAgICAgcm9vdEVsOiBwYXJlbnRFbCxcbiAgICAgICAgICAgICAgbmFtZTogJ3NvcnQnLFxuICAgICAgICAgICAgICB0b0VsOiBwYXJlbnRFbCxcbiAgICAgICAgICAgICAgZnJvbUVsOiByb290RWwsXG4gICAgICAgICAgICAgIG9yaWdpbmFsRXZlbnQ6IGV2dFxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIF9kaXNwYXRjaEV2ZW50KHtcbiAgICAgICAgICAgICAgc29ydGFibGU6IHRoaXMsXG4gICAgICAgICAgICAgIG5hbWU6ICdzb3J0JyxcbiAgICAgICAgICAgICAgdG9FbDogcGFyZW50RWwsXG4gICAgICAgICAgICAgIG9yaWdpbmFsRXZlbnQ6IGV2dFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcHV0U29ydGFibGUgJiYgcHV0U29ydGFibGUuc2F2ZSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChuZXdJbmRleCAhPT0gb2xkSW5kZXgpIHtcbiAgICAgICAgICAgIGlmIChuZXdJbmRleCA+PSAwKSB7XG4gICAgICAgICAgICAgIC8vIGRyYWcgJiBkcm9wIHdpdGhpbiB0aGUgc2FtZSBsaXN0XG4gICAgICAgICAgICAgIF9kaXNwYXRjaEV2ZW50KHtcbiAgICAgICAgICAgICAgICBzb3J0YWJsZTogdGhpcyxcbiAgICAgICAgICAgICAgICBuYW1lOiAndXBkYXRlJyxcbiAgICAgICAgICAgICAgICB0b0VsOiBwYXJlbnRFbCxcbiAgICAgICAgICAgICAgICBvcmlnaW5hbEV2ZW50OiBldnRcbiAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgX2Rpc3BhdGNoRXZlbnQoe1xuICAgICAgICAgICAgICAgIHNvcnRhYmxlOiB0aGlzLFxuICAgICAgICAgICAgICAgIG5hbWU6ICdzb3J0JyxcbiAgICAgICAgICAgICAgICB0b0VsOiBwYXJlbnRFbCxcbiAgICAgICAgICAgICAgICBvcmlnaW5hbEV2ZW50OiBldnRcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKFNvcnRhYmxlLmFjdGl2ZSkge1xuICAgICAgICAgIC8qIGpzaGludCBlcW51bGw6dHJ1ZSAqL1xuICAgICAgICAgIGlmIChuZXdJbmRleCA9PSBudWxsIHx8IG5ld0luZGV4ID09PSAtMSkge1xuICAgICAgICAgICAgbmV3SW5kZXggPSBvbGRJbmRleDtcbiAgICAgICAgICAgIG5ld0RyYWdnYWJsZUluZGV4ID0gb2xkRHJhZ2dhYmxlSW5kZXg7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgX2Rpc3BhdGNoRXZlbnQoe1xuICAgICAgICAgICAgc29ydGFibGU6IHRoaXMsXG4gICAgICAgICAgICBuYW1lOiAnZW5kJyxcbiAgICAgICAgICAgIHRvRWw6IHBhcmVudEVsLFxuICAgICAgICAgICAgb3JpZ2luYWxFdmVudDogZXZ0XG4gICAgICAgICAgfSk7IC8vIFNhdmUgc29ydGluZ1xuXG5cbiAgICAgICAgICB0aGlzLnNhdmUoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuX251bGxpbmcoKTtcbiAgfSxcbiAgX251bGxpbmc6IGZ1bmN0aW9uIF9udWxsaW5nKCkge1xuICAgIHBsdWdpbkV2ZW50KCdudWxsaW5nJywgdGhpcyk7XG4gICAgcm9vdEVsID0gZHJhZ0VsID0gcGFyZW50RWwgPSBnaG9zdEVsID0gbmV4dEVsID0gY2xvbmVFbCA9IGxhc3REb3duRWwgPSBjbG9uZUhpZGRlbiA9IHRhcEV2dCA9IHRvdWNoRXZ0ID0gbW92ZWQgPSBuZXdJbmRleCA9IG5ld0RyYWdnYWJsZUluZGV4ID0gb2xkSW5kZXggPSBvbGREcmFnZ2FibGVJbmRleCA9IGxhc3RUYXJnZXQgPSBsYXN0RGlyZWN0aW9uID0gcHV0U29ydGFibGUgPSBhY3RpdmVHcm91cCA9IFNvcnRhYmxlLmRyYWdnZWQgPSBTb3J0YWJsZS5naG9zdCA9IFNvcnRhYmxlLmNsb25lID0gU29ydGFibGUuYWN0aXZlID0gbnVsbDtcbiAgICBzYXZlZElucHV0Q2hlY2tlZC5mb3JFYWNoKGZ1bmN0aW9uIChlbCkge1xuICAgICAgZWwuY2hlY2tlZCA9IHRydWU7XG4gICAgfSk7XG4gICAgc2F2ZWRJbnB1dENoZWNrZWQubGVuZ3RoID0gbGFzdER4ID0gbGFzdER5ID0gMDtcbiAgfSxcbiAgaGFuZGxlRXZlbnQ6IGZ1bmN0aW9uIGhhbmRsZUV2ZW50KFxuICAvKipFdmVudCovXG4gIGV2dCkge1xuICAgIHN3aXRjaCAoZXZ0LnR5cGUpIHtcbiAgICAgIGNhc2UgJ2Ryb3AnOlxuICAgICAgY2FzZSAnZHJhZ2VuZCc6XG4gICAgICAgIHRoaXMuX29uRHJvcChldnQpO1xuXG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdkcmFnZW50ZXInOlxuICAgICAgY2FzZSAnZHJhZ292ZXInOlxuICAgICAgICBpZiAoZHJhZ0VsKSB7XG4gICAgICAgICAgdGhpcy5fb25EcmFnT3ZlcihldnQpO1xuXG4gICAgICAgICAgX2dsb2JhbERyYWdPdmVyKGV2dCk7XG4gICAgICAgIH1cblxuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnc2VsZWN0c3RhcnQnOlxuICAgICAgICBldnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBTZXJpYWxpemVzIHRoZSBpdGVtIGludG8gYW4gYXJyYXkgb2Ygc3RyaW5nLlxuICAgKiBAcmV0dXJucyB7U3RyaW5nW119XG4gICAqL1xuICB0b0FycmF5OiBmdW5jdGlvbiB0b0FycmF5KCkge1xuICAgIHZhciBvcmRlciA9IFtdLFxuICAgICAgICBlbCxcbiAgICAgICAgY2hpbGRyZW4gPSB0aGlzLmVsLmNoaWxkcmVuLFxuICAgICAgICBpID0gMCxcbiAgICAgICAgbiA9IGNoaWxkcmVuLmxlbmd0aCxcbiAgICAgICAgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcblxuICAgIGZvciAoOyBpIDwgbjsgaSsrKSB7XG4gICAgICBlbCA9IGNoaWxkcmVuW2ldO1xuXG4gICAgICBpZiAoY2xvc2VzdChlbCwgb3B0aW9ucy5kcmFnZ2FibGUsIHRoaXMuZWwsIGZhbHNlKSkge1xuICAgICAgICBvcmRlci5wdXNoKGVsLmdldEF0dHJpYnV0ZShvcHRpb25zLmRhdGFJZEF0dHIpIHx8IF9nZW5lcmF0ZUlkKGVsKSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG9yZGVyO1xuICB9LFxuXG4gIC8qKlxuICAgKiBTb3J0cyB0aGUgZWxlbWVudHMgYWNjb3JkaW5nIHRvIHRoZSBhcnJheS5cbiAgICogQHBhcmFtICB7U3RyaW5nW119ICBvcmRlciAgb3JkZXIgb2YgdGhlIGl0ZW1zXG4gICAqL1xuICBzb3J0OiBmdW5jdGlvbiBzb3J0KG9yZGVyKSB7XG4gICAgdmFyIGl0ZW1zID0ge30sXG4gICAgICAgIHJvb3RFbCA9IHRoaXMuZWw7XG4gICAgdGhpcy50b0FycmF5KCkuZm9yRWFjaChmdW5jdGlvbiAoaWQsIGkpIHtcbiAgICAgIHZhciBlbCA9IHJvb3RFbC5jaGlsZHJlbltpXTtcblxuICAgICAgaWYgKGNsb3Nlc3QoZWwsIHRoaXMub3B0aW9ucy5kcmFnZ2FibGUsIHJvb3RFbCwgZmFsc2UpKSB7XG4gICAgICAgIGl0ZW1zW2lkXSA9IGVsO1xuICAgICAgfVxuICAgIH0sIHRoaXMpO1xuICAgIG9yZGVyLmZvckVhY2goZnVuY3Rpb24gKGlkKSB7XG4gICAgICBpZiAoaXRlbXNbaWRdKSB7XG4gICAgICAgIHJvb3RFbC5yZW1vdmVDaGlsZChpdGVtc1tpZF0pO1xuICAgICAgICByb290RWwuYXBwZW5kQ2hpbGQoaXRlbXNbaWRdKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSxcblxuICAvKipcbiAgICogU2F2ZSB0aGUgY3VycmVudCBzb3J0aW5nXG4gICAqL1xuICBzYXZlOiBmdW5jdGlvbiBzYXZlKCkge1xuICAgIHZhciBzdG9yZSA9IHRoaXMub3B0aW9ucy5zdG9yZTtcbiAgICBzdG9yZSAmJiBzdG9yZS5zZXQgJiYgc3RvcmUuc2V0KHRoaXMpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBGb3IgZWFjaCBlbGVtZW50IGluIHRoZSBzZXQsIGdldCB0aGUgZmlyc3QgZWxlbWVudCB0aGF0IG1hdGNoZXMgdGhlIHNlbGVjdG9yIGJ5IHRlc3RpbmcgdGhlIGVsZW1lbnQgaXRzZWxmIGFuZCB0cmF2ZXJzaW5nIHVwIHRocm91Z2ggaXRzIGFuY2VzdG9ycyBpbiB0aGUgRE9NIHRyZWUuXG4gICAqIEBwYXJhbSAgIHtIVE1MRWxlbWVudH0gIGVsXG4gICAqIEBwYXJhbSAgIHtTdHJpbmd9ICAgICAgIFtzZWxlY3Rvcl0gIGRlZmF1bHQ6IGBvcHRpb25zLmRyYWdnYWJsZWBcbiAgICogQHJldHVybnMge0hUTUxFbGVtZW50fG51bGx9XG4gICAqL1xuICBjbG9zZXN0OiBmdW5jdGlvbiBjbG9zZXN0JDEoZWwsIHNlbGVjdG9yKSB7XG4gICAgcmV0dXJuIGNsb3Nlc3QoZWwsIHNlbGVjdG9yIHx8IHRoaXMub3B0aW9ucy5kcmFnZ2FibGUsIHRoaXMuZWwsIGZhbHNlKTtcbiAgfSxcblxuICAvKipcbiAgICogU2V0L2dldCBvcHRpb25cbiAgICogQHBhcmFtICAge3N0cmluZ30gbmFtZVxuICAgKiBAcGFyYW0gICB7Kn0gICAgICBbdmFsdWVdXG4gICAqIEByZXR1cm5zIHsqfVxuICAgKi9cbiAgb3B0aW9uOiBmdW5jdGlvbiBvcHRpb24obmFtZSwgdmFsdWUpIHtcbiAgICB2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcblxuICAgIGlmICh2YWx1ZSA9PT0gdm9pZCAwKSB7XG4gICAgICByZXR1cm4gb3B0aW9uc1tuYW1lXTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIG1vZGlmaWVkVmFsdWUgPSBQbHVnaW5NYW5hZ2VyLm1vZGlmeU9wdGlvbih0aGlzLCBuYW1lLCB2YWx1ZSk7XG5cbiAgICAgIGlmICh0eXBlb2YgbW9kaWZpZWRWYWx1ZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgb3B0aW9uc1tuYW1lXSA9IG1vZGlmaWVkVmFsdWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvcHRpb25zW25hbWVdID0gdmFsdWU7XG4gICAgICB9XG5cbiAgICAgIGlmIChuYW1lID09PSAnZ3JvdXAnKSB7XG4gICAgICAgIF9wcmVwYXJlR3JvdXAob3B0aW9ucyk7XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBEZXN0cm95XG4gICAqL1xuICBkZXN0cm95OiBmdW5jdGlvbiBkZXN0cm95KCkge1xuICAgIHBsdWdpbkV2ZW50KCdkZXN0cm95JywgdGhpcyk7XG4gICAgdmFyIGVsID0gdGhpcy5lbDtcbiAgICBlbFtleHBhbmRvXSA9IG51bGw7XG4gICAgb2ZmKGVsLCAnbW91c2Vkb3duJywgdGhpcy5fb25UYXBTdGFydCk7XG4gICAgb2ZmKGVsLCAndG91Y2hzdGFydCcsIHRoaXMuX29uVGFwU3RhcnQpO1xuICAgIG9mZihlbCwgJ3BvaW50ZXJkb3duJywgdGhpcy5fb25UYXBTdGFydCk7XG5cbiAgICBpZiAodGhpcy5uYXRpdmVEcmFnZ2FibGUpIHtcbiAgICAgIG9mZihlbCwgJ2RyYWdvdmVyJywgdGhpcyk7XG4gICAgICBvZmYoZWwsICdkcmFnZW50ZXInLCB0aGlzKTtcbiAgICB9IC8vIFJlbW92ZSBkcmFnZ2FibGUgYXR0cmlidXRlc1xuXG5cbiAgICBBcnJheS5wcm90b3R5cGUuZm9yRWFjaC5jYWxsKGVsLnF1ZXJ5U2VsZWN0b3JBbGwoJ1tkcmFnZ2FibGVdJyksIGZ1bmN0aW9uIChlbCkge1xuICAgICAgZWwucmVtb3ZlQXR0cmlidXRlKCdkcmFnZ2FibGUnKTtcbiAgICB9KTtcblxuICAgIHRoaXMuX29uRHJvcCgpO1xuXG4gICAgdGhpcy5fZGlzYWJsZURlbGF5ZWREcmFnRXZlbnRzKCk7XG5cbiAgICBzb3J0YWJsZXMuc3BsaWNlKHNvcnRhYmxlcy5pbmRleE9mKHRoaXMuZWwpLCAxKTtcbiAgICB0aGlzLmVsID0gZWwgPSBudWxsO1xuICB9LFxuICBfaGlkZUNsb25lOiBmdW5jdGlvbiBfaGlkZUNsb25lKCkge1xuICAgIGlmICghY2xvbmVIaWRkZW4pIHtcbiAgICAgIHBsdWdpbkV2ZW50KCdoaWRlQ2xvbmUnLCB0aGlzKTtcbiAgICAgIGlmIChTb3J0YWJsZS5ldmVudENhbmNlbGVkKSByZXR1cm47XG4gICAgICBjc3MoY2xvbmVFbCwgJ2Rpc3BsYXknLCAnbm9uZScpO1xuXG4gICAgICBpZiAodGhpcy5vcHRpb25zLnJlbW92ZUNsb25lT25IaWRlICYmIGNsb25lRWwucGFyZW50Tm9kZSkge1xuICAgICAgICBjbG9uZUVsLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoY2xvbmVFbCk7XG4gICAgICB9XG5cbiAgICAgIGNsb25lSGlkZGVuID0gdHJ1ZTtcbiAgICB9XG4gIH0sXG4gIF9zaG93Q2xvbmU6IGZ1bmN0aW9uIF9zaG93Q2xvbmUocHV0U29ydGFibGUpIHtcbiAgICBpZiAocHV0U29ydGFibGUubGFzdFB1dE1vZGUgIT09ICdjbG9uZScpIHtcbiAgICAgIHRoaXMuX2hpZGVDbG9uZSgpO1xuXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGNsb25lSGlkZGVuKSB7XG4gICAgICBwbHVnaW5FdmVudCgnc2hvd0Nsb25lJywgdGhpcyk7XG4gICAgICBpZiAoU29ydGFibGUuZXZlbnRDYW5jZWxlZCkgcmV0dXJuOyAvLyBzaG93IGNsb25lIGF0IGRyYWdFbCBvciBvcmlnaW5hbCBwb3NpdGlvblxuXG4gICAgICBpZiAocm9vdEVsLmNvbnRhaW5zKGRyYWdFbCkgJiYgIXRoaXMub3B0aW9ucy5ncm91cC5yZXZlcnRDbG9uZSkge1xuICAgICAgICByb290RWwuaW5zZXJ0QmVmb3JlKGNsb25lRWwsIGRyYWdFbCk7XG4gICAgICB9IGVsc2UgaWYgKG5leHRFbCkge1xuICAgICAgICByb290RWwuaW5zZXJ0QmVmb3JlKGNsb25lRWwsIG5leHRFbCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByb290RWwuYXBwZW5kQ2hpbGQoY2xvbmVFbCk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuZ3JvdXAucmV2ZXJ0Q2xvbmUpIHtcbiAgICAgICAgdGhpcy5hbmltYXRlKGRyYWdFbCwgY2xvbmVFbCk7XG4gICAgICB9XG5cbiAgICAgIGNzcyhjbG9uZUVsLCAnZGlzcGxheScsICcnKTtcbiAgICAgIGNsb25lSGlkZGVuID0gZmFsc2U7XG4gICAgfVxuICB9XG59O1xuXG5mdW5jdGlvbiBfZ2xvYmFsRHJhZ092ZXIoXG4vKipFdmVudCovXG5ldnQpIHtcbiAgaWYgKGV2dC5kYXRhVHJhbnNmZXIpIHtcbiAgICBldnQuZGF0YVRyYW5zZmVyLmRyb3BFZmZlY3QgPSAnbW92ZSc7XG4gIH1cblxuICBldnQuY2FuY2VsYWJsZSAmJiBldnQucHJldmVudERlZmF1bHQoKTtcbn1cblxuZnVuY3Rpb24gX29uTW92ZShmcm9tRWwsIHRvRWwsIGRyYWdFbCwgZHJhZ1JlY3QsIHRhcmdldEVsLCB0YXJnZXRSZWN0LCBvcmlnaW5hbEV2ZW50LCB3aWxsSW5zZXJ0QWZ0ZXIpIHtcbiAgdmFyIGV2dCxcbiAgICAgIHNvcnRhYmxlID0gZnJvbUVsW2V4cGFuZG9dLFxuICAgICAgb25Nb3ZlRm4gPSBzb3J0YWJsZS5vcHRpb25zLm9uTW92ZSxcbiAgICAgIHJldFZhbDsgLy8gU3VwcG9ydCBmb3IgbmV3IEN1c3RvbUV2ZW50IGZlYXR1cmVcblxuICBpZiAod2luZG93LkN1c3RvbUV2ZW50ICYmICFJRTExT3JMZXNzICYmICFFZGdlKSB7XG4gICAgZXZ0ID0gbmV3IEN1c3RvbUV2ZW50KCdtb3ZlJywge1xuICAgICAgYnViYmxlczogdHJ1ZSxcbiAgICAgIGNhbmNlbGFibGU6IHRydWVcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBldnQgPSBkb2N1bWVudC5jcmVhdGVFdmVudCgnRXZlbnQnKTtcbiAgICBldnQuaW5pdEV2ZW50KCdtb3ZlJywgdHJ1ZSwgdHJ1ZSk7XG4gIH1cblxuICBldnQudG8gPSB0b0VsO1xuICBldnQuZnJvbSA9IGZyb21FbDtcbiAgZXZ0LmRyYWdnZWQgPSBkcmFnRWw7XG4gIGV2dC5kcmFnZ2VkUmVjdCA9IGRyYWdSZWN0O1xuICBldnQucmVsYXRlZCA9IHRhcmdldEVsIHx8IHRvRWw7XG4gIGV2dC5yZWxhdGVkUmVjdCA9IHRhcmdldFJlY3QgfHwgZ2V0UmVjdCh0b0VsKTtcbiAgZXZ0LndpbGxJbnNlcnRBZnRlciA9IHdpbGxJbnNlcnRBZnRlcjtcbiAgZXZ0Lm9yaWdpbmFsRXZlbnQgPSBvcmlnaW5hbEV2ZW50O1xuICBmcm9tRWwuZGlzcGF0Y2hFdmVudChldnQpO1xuXG4gIGlmIChvbk1vdmVGbikge1xuICAgIHJldFZhbCA9IG9uTW92ZUZuLmNhbGwoc29ydGFibGUsIGV2dCwgb3JpZ2luYWxFdmVudCk7XG4gIH1cblxuICByZXR1cm4gcmV0VmFsO1xufVxuXG5mdW5jdGlvbiBfZGlzYWJsZURyYWdnYWJsZShlbCkge1xuICBlbC5kcmFnZ2FibGUgPSBmYWxzZTtcbn1cblxuZnVuY3Rpb24gX3Vuc2lsZW50KCkge1xuICBfc2lsZW50ID0gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIF9naG9zdElzTGFzdChldnQsIHZlcnRpY2FsLCBzb3J0YWJsZSkge1xuICB2YXIgcmVjdCA9IGdldFJlY3QobGFzdENoaWxkKHNvcnRhYmxlLmVsLCBzb3J0YWJsZS5vcHRpb25zLmRyYWdnYWJsZSkpO1xuICB2YXIgc3BhY2VyID0gMTA7XG4gIHJldHVybiB2ZXJ0aWNhbCA/IGV2dC5jbGllbnRYID4gcmVjdC5yaWdodCArIHNwYWNlciB8fCBldnQuY2xpZW50WCA8PSByZWN0LnJpZ2h0ICYmIGV2dC5jbGllbnRZID4gcmVjdC5ib3R0b20gJiYgZXZ0LmNsaWVudFggPj0gcmVjdC5sZWZ0IDogZXZ0LmNsaWVudFggPiByZWN0LnJpZ2h0ICYmIGV2dC5jbGllbnRZID4gcmVjdC50b3AgfHwgZXZ0LmNsaWVudFggPD0gcmVjdC5yaWdodCAmJiBldnQuY2xpZW50WSA+IHJlY3QuYm90dG9tICsgc3BhY2VyO1xufVxuXG5mdW5jdGlvbiBfZ2V0U3dhcERpcmVjdGlvbihldnQsIHRhcmdldCwgdGFyZ2V0UmVjdCwgdmVydGljYWwsIHN3YXBUaHJlc2hvbGQsIGludmVydGVkU3dhcFRocmVzaG9sZCwgaW52ZXJ0U3dhcCwgaXNMYXN0VGFyZ2V0KSB7XG4gIHZhciBtb3VzZU9uQXhpcyA9IHZlcnRpY2FsID8gZXZ0LmNsaWVudFkgOiBldnQuY2xpZW50WCxcbiAgICAgIHRhcmdldExlbmd0aCA9IHZlcnRpY2FsID8gdGFyZ2V0UmVjdC5oZWlnaHQgOiB0YXJnZXRSZWN0LndpZHRoLFxuICAgICAgdGFyZ2V0UzEgPSB2ZXJ0aWNhbCA/IHRhcmdldFJlY3QudG9wIDogdGFyZ2V0UmVjdC5sZWZ0LFxuICAgICAgdGFyZ2V0UzIgPSB2ZXJ0aWNhbCA/IHRhcmdldFJlY3QuYm90dG9tIDogdGFyZ2V0UmVjdC5yaWdodCxcbiAgICAgIGludmVydCA9IGZhbHNlO1xuXG4gIGlmICghaW52ZXJ0U3dhcCkge1xuICAgIC8vIE5ldmVyIGludmVydCBvciBjcmVhdGUgZHJhZ0VsIHNoYWRvdyB3aGVuIHRhcmdldCBtb3ZlbWVuZXQgY2F1c2VzIG1vdXNlIHRvIG1vdmUgcGFzdCB0aGUgZW5kIG9mIHJlZ3VsYXIgc3dhcFRocmVzaG9sZFxuICAgIGlmIChpc0xhc3RUYXJnZXQgJiYgdGFyZ2V0TW92ZURpc3RhbmNlIDwgdGFyZ2V0TGVuZ3RoICogc3dhcFRocmVzaG9sZCkge1xuICAgICAgLy8gbXVsdGlwbGllZCBvbmx5IGJ5IHN3YXBUaHJlc2hvbGQgYmVjYXVzZSBtb3VzZSB3aWxsIGFscmVhZHkgYmUgaW5zaWRlIHRhcmdldCBieSAoMSAtIHRocmVzaG9sZCkgKiB0YXJnZXRMZW5ndGggLyAyXG4gICAgICAvLyBjaGVjayBpZiBwYXN0IGZpcnN0IGludmVydCB0aHJlc2hvbGQgb24gc2lkZSBvcHBvc2l0ZSBvZiBsYXN0RGlyZWN0aW9uXG4gICAgICBpZiAoIXBhc3RGaXJzdEludmVydFRocmVzaCAmJiAobGFzdERpcmVjdGlvbiA9PT0gMSA/IG1vdXNlT25BeGlzID4gdGFyZ2V0UzEgKyB0YXJnZXRMZW5ndGggKiBpbnZlcnRlZFN3YXBUaHJlc2hvbGQgLyAyIDogbW91c2VPbkF4aXMgPCB0YXJnZXRTMiAtIHRhcmdldExlbmd0aCAqIGludmVydGVkU3dhcFRocmVzaG9sZCAvIDIpKSB7XG4gICAgICAgIC8vIHBhc3QgZmlyc3QgaW52ZXJ0IHRocmVzaG9sZCwgZG8gbm90IHJlc3RyaWN0IGludmVydGVkIHRocmVzaG9sZCB0byBkcmFnRWwgc2hhZG93XG4gICAgICAgIHBhc3RGaXJzdEludmVydFRocmVzaCA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIGlmICghcGFzdEZpcnN0SW52ZXJ0VGhyZXNoKSB7XG4gICAgICAgIC8vIGRyYWdFbCBzaGFkb3cgKHRhcmdldCBtb3ZlIGRpc3RhbmNlIHNoYWRvdylcbiAgICAgICAgaWYgKGxhc3REaXJlY3Rpb24gPT09IDEgPyBtb3VzZU9uQXhpcyA8IHRhcmdldFMxICsgdGFyZ2V0TW92ZURpc3RhbmNlIC8vIG92ZXIgZHJhZ0VsIHNoYWRvd1xuICAgICAgICA6IG1vdXNlT25BeGlzID4gdGFyZ2V0UzIgLSB0YXJnZXRNb3ZlRGlzdGFuY2UpIHtcbiAgICAgICAgICByZXR1cm4gLWxhc3REaXJlY3Rpb247XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGludmVydCA9IHRydWU7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFJlZ3VsYXJcbiAgICAgIGlmIChtb3VzZU9uQXhpcyA+IHRhcmdldFMxICsgdGFyZ2V0TGVuZ3RoICogKDEgLSBzd2FwVGhyZXNob2xkKSAvIDIgJiYgbW91c2VPbkF4aXMgPCB0YXJnZXRTMiAtIHRhcmdldExlbmd0aCAqICgxIC0gc3dhcFRocmVzaG9sZCkgLyAyKSB7XG4gICAgICAgIHJldHVybiBfZ2V0SW5zZXJ0RGlyZWN0aW9uKHRhcmdldCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaW52ZXJ0ID0gaW52ZXJ0IHx8IGludmVydFN3YXA7XG5cbiAgaWYgKGludmVydCkge1xuICAgIC8vIEludmVydCBvZiByZWd1bGFyXG4gICAgaWYgKG1vdXNlT25BeGlzIDwgdGFyZ2V0UzEgKyB0YXJnZXRMZW5ndGggKiBpbnZlcnRlZFN3YXBUaHJlc2hvbGQgLyAyIHx8IG1vdXNlT25BeGlzID4gdGFyZ2V0UzIgLSB0YXJnZXRMZW5ndGggKiBpbnZlcnRlZFN3YXBUaHJlc2hvbGQgLyAyKSB7XG4gICAgICByZXR1cm4gbW91c2VPbkF4aXMgPiB0YXJnZXRTMSArIHRhcmdldExlbmd0aCAvIDIgPyAxIDogLTE7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIDA7XG59XG4vKipcbiAqIEdldHMgdGhlIGRpcmVjdGlvbiBkcmFnRWwgbXVzdCBiZSBzd2FwcGVkIHJlbGF0aXZlIHRvIHRhcmdldCBpbiBvcmRlciB0byBtYWtlIGl0XG4gKiBzZWVtIHRoYXQgZHJhZ0VsIGhhcyBiZWVuIFwiaW5zZXJ0ZWRcIiBpbnRvIHRoYXQgZWxlbWVudCdzIHBvc2l0aW9uXG4gKiBAcGFyYW0gIHtIVE1MRWxlbWVudH0gdGFyZ2V0ICAgICAgIFRoZSB0YXJnZXQgd2hvc2UgcG9zaXRpb24gZHJhZ0VsIGlzIGJlaW5nIGluc2VydGVkIGF0XG4gKiBAcmV0dXJuIHtOdW1iZXJ9ICAgICAgICAgICAgICAgICAgIERpcmVjdGlvbiBkcmFnRWwgbXVzdCBiZSBzd2FwcGVkXG4gKi9cblxuXG5mdW5jdGlvbiBfZ2V0SW5zZXJ0RGlyZWN0aW9uKHRhcmdldCkge1xuICBpZiAoaW5kZXgoZHJhZ0VsKSA8IGluZGV4KHRhcmdldCkpIHtcbiAgICByZXR1cm4gMTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gLTE7XG4gIH1cbn1cbi8qKlxuICogR2VuZXJhdGUgaWRcbiAqIEBwYXJhbSAgIHtIVE1MRWxlbWVudH0gZWxcbiAqIEByZXR1cm5zIHtTdHJpbmd9XG4gKiBAcHJpdmF0ZVxuICovXG5cblxuZnVuY3Rpb24gX2dlbmVyYXRlSWQoZWwpIHtcbiAgdmFyIHN0ciA9IGVsLnRhZ05hbWUgKyBlbC5jbGFzc05hbWUgKyBlbC5zcmMgKyBlbC5ocmVmICsgZWwudGV4dENvbnRlbnQsXG4gICAgICBpID0gc3RyLmxlbmd0aCxcbiAgICAgIHN1bSA9IDA7XG5cbiAgd2hpbGUgKGktLSkge1xuICAgIHN1bSArPSBzdHIuY2hhckNvZGVBdChpKTtcbiAgfVxuXG4gIHJldHVybiBzdW0udG9TdHJpbmcoMzYpO1xufVxuXG5mdW5jdGlvbiBfc2F2ZUlucHV0Q2hlY2tlZFN0YXRlKHJvb3QpIHtcbiAgc2F2ZWRJbnB1dENoZWNrZWQubGVuZ3RoID0gMDtcbiAgdmFyIGlucHV0cyA9IHJvb3QuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2lucHV0Jyk7XG4gIHZhciBpZHggPSBpbnB1dHMubGVuZ3RoO1xuXG4gIHdoaWxlIChpZHgtLSkge1xuICAgIHZhciBlbCA9IGlucHV0c1tpZHhdO1xuICAgIGVsLmNoZWNrZWQgJiYgc2F2ZWRJbnB1dENoZWNrZWQucHVzaChlbCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gX25leHRUaWNrKGZuKSB7XG4gIHJldHVybiBzZXRUaW1lb3V0KGZuLCAwKTtcbn1cblxuZnVuY3Rpb24gX2NhbmNlbE5leHRUaWNrKGlkKSB7XG4gIHJldHVybiBjbGVhclRpbWVvdXQoaWQpO1xufSAvLyBGaXhlZCAjOTczOlxuXG5cbmlmIChkb2N1bWVudEV4aXN0cykge1xuICBvbihkb2N1bWVudCwgJ3RvdWNobW92ZScsIGZ1bmN0aW9uIChldnQpIHtcbiAgICBpZiAoKFNvcnRhYmxlLmFjdGl2ZSB8fCBhd2FpdGluZ0RyYWdTdGFydGVkKSAmJiBldnQuY2FuY2VsYWJsZSkge1xuICAgICAgZXZ0LnByZXZlbnREZWZhdWx0KCk7XG4gICAgfVxuICB9KTtcbn0gLy8gRXhwb3J0IHV0aWxzXG5cblxuU29ydGFibGUudXRpbHMgPSB7XG4gIG9uOiBvbixcbiAgb2ZmOiBvZmYsXG4gIGNzczogY3NzLFxuICBmaW5kOiBmaW5kLFxuICBpczogZnVuY3Rpb24gaXMoZWwsIHNlbGVjdG9yKSB7XG4gICAgcmV0dXJuICEhY2xvc2VzdChlbCwgc2VsZWN0b3IsIGVsLCBmYWxzZSk7XG4gIH0sXG4gIGV4dGVuZDogZXh0ZW5kLFxuICB0aHJvdHRsZTogdGhyb3R0bGUsXG4gIGNsb3Nlc3Q6IGNsb3Nlc3QsXG4gIHRvZ2dsZUNsYXNzOiB0b2dnbGVDbGFzcyxcbiAgY2xvbmU6IGNsb25lLFxuICBpbmRleDogaW5kZXgsXG4gIG5leHRUaWNrOiBfbmV4dFRpY2ssXG4gIGNhbmNlbE5leHRUaWNrOiBfY2FuY2VsTmV4dFRpY2ssXG4gIGRldGVjdERpcmVjdGlvbjogX2RldGVjdERpcmVjdGlvbixcbiAgZ2V0Q2hpbGQ6IGdldENoaWxkXG59O1xuLyoqXG4gKiBHZXQgdGhlIFNvcnRhYmxlIGluc3RhbmNlIG9mIGFuIGVsZW1lbnRcbiAqIEBwYXJhbSAge0hUTUxFbGVtZW50fSBlbGVtZW50IFRoZSBlbGVtZW50XG4gKiBAcmV0dXJuIHtTb3J0YWJsZXx1bmRlZmluZWR9ICAgICAgICAgVGhlIGluc3RhbmNlIG9mIFNvcnRhYmxlXG4gKi9cblxuU29ydGFibGUuZ2V0ID0gZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgcmV0dXJuIGVsZW1lbnRbZXhwYW5kb107XG59O1xuLyoqXG4gKiBNb3VudCBhIHBsdWdpbiB0byBTb3J0YWJsZVxuICogQHBhcmFtICB7Li4uU29ydGFibGVQbHVnaW58U29ydGFibGVQbHVnaW5bXX0gcGx1Z2lucyAgICAgICBQbHVnaW5zIGJlaW5nIG1vdW50ZWRcbiAqL1xuXG5cblNvcnRhYmxlLm1vdW50ID0gZnVuY3Rpb24gKCkge1xuICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgcGx1Z2lucyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICBwbHVnaW5zW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICB9XG5cbiAgaWYgKHBsdWdpbnNbMF0uY29uc3RydWN0b3IgPT09IEFycmF5KSBwbHVnaW5zID0gcGx1Z2luc1swXTtcbiAgcGx1Z2lucy5mb3JFYWNoKGZ1bmN0aW9uIChwbHVnaW4pIHtcbiAgICBpZiAoIXBsdWdpbi5wcm90b3R5cGUgfHwgIXBsdWdpbi5wcm90b3R5cGUuY29uc3RydWN0b3IpIHtcbiAgICAgIHRocm93IFwiU29ydGFibGU6IE1vdW50ZWQgcGx1Z2luIG11c3QgYmUgYSBjb25zdHJ1Y3RvciBmdW5jdGlvbiwgbm90IFwiLmNvbmNhdCh7fS50b1N0cmluZy5jYWxsKHBsdWdpbikpO1xuICAgIH1cblxuICAgIGlmIChwbHVnaW4udXRpbHMpIFNvcnRhYmxlLnV0aWxzID0gX29iamVjdFNwcmVhZCh7fSwgU29ydGFibGUudXRpbHMsIHBsdWdpbi51dGlscyk7XG4gICAgUGx1Z2luTWFuYWdlci5tb3VudChwbHVnaW4pO1xuICB9KTtcbn07XG4vKipcbiAqIENyZWF0ZSBzb3J0YWJsZSBpbnN0YW5jZVxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gIGVsXG4gKiBAcGFyYW0ge09iamVjdH0gICAgICBbb3B0aW9uc11cbiAqL1xuXG5cblNvcnRhYmxlLmNyZWF0ZSA9IGZ1bmN0aW9uIChlbCwgb3B0aW9ucykge1xuICByZXR1cm4gbmV3IFNvcnRhYmxlKGVsLCBvcHRpb25zKTtcbn07IC8vIEV4cG9ydFxuXG5cblNvcnRhYmxlLnZlcnNpb24gPSB2ZXJzaW9uO1xuXG52YXIgYXV0b1Njcm9sbHMgPSBbXSxcbiAgICBzY3JvbGxFbCxcbiAgICBzY3JvbGxSb290RWwsXG4gICAgc2Nyb2xsaW5nID0gZmFsc2UsXG4gICAgbGFzdEF1dG9TY3JvbGxYLFxuICAgIGxhc3RBdXRvU2Nyb2xsWSxcbiAgICB0b3VjaEV2dCQxLFxuICAgIHBvaW50ZXJFbGVtQ2hhbmdlZEludGVydmFsO1xuXG5mdW5jdGlvbiBBdXRvU2Nyb2xsUGx1Z2luKCkge1xuICBmdW5jdGlvbiBBdXRvU2Nyb2xsKCkge1xuICAgIHRoaXMuZGVmYXVsdHMgPSB7XG4gICAgICBzY3JvbGw6IHRydWUsXG4gICAgICBzY3JvbGxTZW5zaXRpdml0eTogMzAsXG4gICAgICBzY3JvbGxTcGVlZDogMTAsXG4gICAgICBidWJibGVTY3JvbGw6IHRydWVcbiAgICB9OyAvLyBCaW5kIGFsbCBwcml2YXRlIG1ldGhvZHNcblxuICAgIGZvciAodmFyIGZuIGluIHRoaXMpIHtcbiAgICAgIGlmIChmbi5jaGFyQXQoMCkgPT09ICdfJyAmJiB0eXBlb2YgdGhpc1tmbl0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhpc1tmbl0gPSB0aGlzW2ZuXS5iaW5kKHRoaXMpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIEF1dG9TY3JvbGwucHJvdG90eXBlID0ge1xuICAgIGRyYWdTdGFydGVkOiBmdW5jdGlvbiBkcmFnU3RhcnRlZChfcmVmKSB7XG4gICAgICB2YXIgb3JpZ2luYWxFdmVudCA9IF9yZWYub3JpZ2luYWxFdmVudDtcblxuICAgICAgaWYgKHRoaXMuc29ydGFibGUubmF0aXZlRHJhZ2dhYmxlKSB7XG4gICAgICAgIG9uKGRvY3VtZW50LCAnZHJhZ292ZXInLCB0aGlzLl9oYW5kbGVBdXRvU2Nyb2xsKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuc3VwcG9ydFBvaW50ZXIpIHtcbiAgICAgICAgICBvbihkb2N1bWVudCwgJ3BvaW50ZXJtb3ZlJywgdGhpcy5faGFuZGxlRmFsbGJhY2tBdXRvU2Nyb2xsKTtcbiAgICAgICAgfSBlbHNlIGlmIChvcmlnaW5hbEV2ZW50LnRvdWNoZXMpIHtcbiAgICAgICAgICBvbihkb2N1bWVudCwgJ3RvdWNobW92ZScsIHRoaXMuX2hhbmRsZUZhbGxiYWNrQXV0b1Njcm9sbCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb24oZG9jdW1lbnQsICdtb3VzZW1vdmUnLCB0aGlzLl9oYW5kbGVGYWxsYmFja0F1dG9TY3JvbGwpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBkcmFnT3ZlckNvbXBsZXRlZDogZnVuY3Rpb24gZHJhZ092ZXJDb21wbGV0ZWQoX3JlZjIpIHtcbiAgICAgIHZhciBvcmlnaW5hbEV2ZW50ID0gX3JlZjIub3JpZ2luYWxFdmVudDtcblxuICAgICAgLy8gRm9yIHdoZW4gYnViYmxpbmcgaXMgY2FuY2VsZWQgYW5kIHVzaW5nIGZhbGxiYWNrIChmYWxsYmFjayAndG91Y2htb3ZlJyBhbHdheXMgcmVhY2hlZClcbiAgICAgIGlmICghdGhpcy5vcHRpb25zLmRyYWdPdmVyQnViYmxlICYmICFvcmlnaW5hbEV2ZW50LnJvb3RFbCkge1xuICAgICAgICB0aGlzLl9oYW5kbGVBdXRvU2Nyb2xsKG9yaWdpbmFsRXZlbnQpO1xuICAgICAgfVxuICAgIH0sXG4gICAgZHJvcDogZnVuY3Rpb24gZHJvcCgpIHtcbiAgICAgIGlmICh0aGlzLnNvcnRhYmxlLm5hdGl2ZURyYWdnYWJsZSkge1xuICAgICAgICBvZmYoZG9jdW1lbnQsICdkcmFnb3ZlcicsIHRoaXMuX2hhbmRsZUF1dG9TY3JvbGwpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb2ZmKGRvY3VtZW50LCAncG9pbnRlcm1vdmUnLCB0aGlzLl9oYW5kbGVGYWxsYmFja0F1dG9TY3JvbGwpO1xuICAgICAgICBvZmYoZG9jdW1lbnQsICd0b3VjaG1vdmUnLCB0aGlzLl9oYW5kbGVGYWxsYmFja0F1dG9TY3JvbGwpO1xuICAgICAgICBvZmYoZG9jdW1lbnQsICdtb3VzZW1vdmUnLCB0aGlzLl9oYW5kbGVGYWxsYmFja0F1dG9TY3JvbGwpO1xuICAgICAgfVxuXG4gICAgICBjbGVhclBvaW50ZXJFbGVtQ2hhbmdlZEludGVydmFsKCk7XG4gICAgICBjbGVhckF1dG9TY3JvbGxzKCk7XG4gICAgICBjYW5jZWxUaHJvdHRsZSgpO1xuICAgIH0sXG4gICAgbnVsbGluZzogZnVuY3Rpb24gbnVsbGluZygpIHtcbiAgICAgIHRvdWNoRXZ0JDEgPSBzY3JvbGxSb290RWwgPSBzY3JvbGxFbCA9IHNjcm9sbGluZyA9IHBvaW50ZXJFbGVtQ2hhbmdlZEludGVydmFsID0gbGFzdEF1dG9TY3JvbGxYID0gbGFzdEF1dG9TY3JvbGxZID0gbnVsbDtcbiAgICAgIGF1dG9TY3JvbGxzLmxlbmd0aCA9IDA7XG4gICAgfSxcbiAgICBfaGFuZGxlRmFsbGJhY2tBdXRvU2Nyb2xsOiBmdW5jdGlvbiBfaGFuZGxlRmFsbGJhY2tBdXRvU2Nyb2xsKGV2dCkge1xuICAgICAgdGhpcy5faGFuZGxlQXV0b1Njcm9sbChldnQsIHRydWUpO1xuICAgIH0sXG4gICAgX2hhbmRsZUF1dG9TY3JvbGw6IGZ1bmN0aW9uIF9oYW5kbGVBdXRvU2Nyb2xsKGV2dCwgZmFsbGJhY2spIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgIHZhciB4ID0gKGV2dC50b3VjaGVzID8gZXZ0LnRvdWNoZXNbMF0gOiBldnQpLmNsaWVudFgsXG4gICAgICAgICAgeSA9IChldnQudG91Y2hlcyA/IGV2dC50b3VjaGVzWzBdIDogZXZ0KS5jbGllbnRZLFxuICAgICAgICAgIGVsZW0gPSBkb2N1bWVudC5lbGVtZW50RnJvbVBvaW50KHgsIHkpO1xuICAgICAgdG91Y2hFdnQkMSA9IGV2dDsgLy8gSUUgZG9lcyBub3Qgc2VlbSB0byBoYXZlIG5hdGl2ZSBhdXRvc2Nyb2xsLFxuICAgICAgLy8gRWRnZSdzIGF1dG9zY3JvbGwgc2VlbXMgdG9vIGNvbmRpdGlvbmFsLFxuICAgICAgLy8gTUFDT1MgU2FmYXJpIGRvZXMgbm90IGhhdmUgYXV0b3Njcm9sbCxcbiAgICAgIC8vIEZpcmVmb3ggYW5kIENocm9tZSBhcmUgZ29vZFxuXG4gICAgICBpZiAoZmFsbGJhY2sgfHwgRWRnZSB8fCBJRTExT3JMZXNzIHx8IFNhZmFyaSkge1xuICAgICAgICBhdXRvU2Nyb2xsKGV2dCwgdGhpcy5vcHRpb25zLCBlbGVtLCBmYWxsYmFjayk7IC8vIExpc3RlbmVyIGZvciBwb2ludGVyIGVsZW1lbnQgY2hhbmdlXG5cbiAgICAgICAgdmFyIG9nRWxlbVNjcm9sbGVyID0gZ2V0UGFyZW50QXV0b1Njcm9sbEVsZW1lbnQoZWxlbSwgdHJ1ZSk7XG5cbiAgICAgICAgaWYgKHNjcm9sbGluZyAmJiAoIXBvaW50ZXJFbGVtQ2hhbmdlZEludGVydmFsIHx8IHggIT09IGxhc3RBdXRvU2Nyb2xsWCB8fCB5ICE9PSBsYXN0QXV0b1Njcm9sbFkpKSB7XG4gICAgICAgICAgcG9pbnRlckVsZW1DaGFuZ2VkSW50ZXJ2YWwgJiYgY2xlYXJQb2ludGVyRWxlbUNoYW5nZWRJbnRlcnZhbCgpOyAvLyBEZXRlY3QgZm9yIHBvaW50ZXIgZWxlbSBjaGFuZ2UsIGVtdWxhdGluZyBuYXRpdmUgRG5EIGJlaGF2aW91clxuXG4gICAgICAgICAgcG9pbnRlckVsZW1DaGFuZ2VkSW50ZXJ2YWwgPSBzZXRJbnRlcnZhbChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgbmV3RWxlbSA9IGdldFBhcmVudEF1dG9TY3JvbGxFbGVtZW50KGRvY3VtZW50LmVsZW1lbnRGcm9tUG9pbnQoeCwgeSksIHRydWUpO1xuXG4gICAgICAgICAgICBpZiAobmV3RWxlbSAhPT0gb2dFbGVtU2Nyb2xsZXIpIHtcbiAgICAgICAgICAgICAgb2dFbGVtU2Nyb2xsZXIgPSBuZXdFbGVtO1xuICAgICAgICAgICAgICBjbGVhckF1dG9TY3JvbGxzKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGF1dG9TY3JvbGwoZXZ0LCBfdGhpcy5vcHRpb25zLCBuZXdFbGVtLCBmYWxsYmFjayk7XG4gICAgICAgICAgfSwgMTApO1xuICAgICAgICAgIGxhc3RBdXRvU2Nyb2xsWCA9IHg7XG4gICAgICAgICAgbGFzdEF1dG9TY3JvbGxZID0geTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gaWYgRG5EIGlzIGVuYWJsZWQgKGFuZCBicm93c2VyIGhhcyBnb29kIGF1dG9zY3JvbGxpbmcpLCBmaXJzdCBhdXRvc2Nyb2xsIHdpbGwgYWxyZWFkeSBzY3JvbGwsIHNvIGdldCBwYXJlbnQgYXV0b3Njcm9sbCBvZiBmaXJzdCBhdXRvc2Nyb2xsXG4gICAgICAgIGlmICghdGhpcy5vcHRpb25zLmJ1YmJsZVNjcm9sbCB8fCBnZXRQYXJlbnRBdXRvU2Nyb2xsRWxlbWVudChlbGVtLCB0cnVlKSA9PT0gZ2V0V2luZG93U2Nyb2xsaW5nRWxlbWVudCgpKSB7XG4gICAgICAgICAgY2xlYXJBdXRvU2Nyb2xscygpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGF1dG9TY3JvbGwoZXZ0LCB0aGlzLm9wdGlvbnMsIGdldFBhcmVudEF1dG9TY3JvbGxFbGVtZW50KGVsZW0sIGZhbHNlKSwgZmFsc2UpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgcmV0dXJuIF9leHRlbmRzKEF1dG9TY3JvbGwsIHtcbiAgICBwbHVnaW5OYW1lOiAnc2Nyb2xsJyxcbiAgICBpbml0aWFsaXplQnlEZWZhdWx0OiB0cnVlXG4gIH0pO1xufVxuXG5mdW5jdGlvbiBjbGVhckF1dG9TY3JvbGxzKCkge1xuICBhdXRvU2Nyb2xscy5mb3JFYWNoKGZ1bmN0aW9uIChhdXRvU2Nyb2xsKSB7XG4gICAgY2xlYXJJbnRlcnZhbChhdXRvU2Nyb2xsLnBpZCk7XG4gIH0pO1xuICBhdXRvU2Nyb2xscyA9IFtdO1xufVxuXG5mdW5jdGlvbiBjbGVhclBvaW50ZXJFbGVtQ2hhbmdlZEludGVydmFsKCkge1xuICBjbGVhckludGVydmFsKHBvaW50ZXJFbGVtQ2hhbmdlZEludGVydmFsKTtcbn1cblxudmFyIGF1dG9TY3JvbGwgPSB0aHJvdHRsZShmdW5jdGlvbiAoZXZ0LCBvcHRpb25zLCByb290RWwsIGlzRmFsbGJhY2spIHtcbiAgLy8gQnVnOiBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD01MDU1MjFcbiAgaWYgKCFvcHRpb25zLnNjcm9sbCkgcmV0dXJuO1xuICB2YXIgeCA9IChldnQudG91Y2hlcyA/IGV2dC50b3VjaGVzWzBdIDogZXZ0KS5jbGllbnRYLFxuICAgICAgeSA9IChldnQudG91Y2hlcyA/IGV2dC50b3VjaGVzWzBdIDogZXZ0KS5jbGllbnRZLFxuICAgICAgc2VucyA9IG9wdGlvbnMuc2Nyb2xsU2Vuc2l0aXZpdHksXG4gICAgICBzcGVlZCA9IG9wdGlvbnMuc2Nyb2xsU3BlZWQsXG4gICAgICB3aW5TY3JvbGxlciA9IGdldFdpbmRvd1Njcm9sbGluZ0VsZW1lbnQoKTtcbiAgdmFyIHNjcm9sbFRoaXNJbnN0YW5jZSA9IGZhbHNlLFxuICAgICAgc2Nyb2xsQ3VzdG9tRm47IC8vIE5ldyBzY3JvbGwgcm9vdCwgc2V0IHNjcm9sbEVsXG5cbiAgaWYgKHNjcm9sbFJvb3RFbCAhPT0gcm9vdEVsKSB7XG4gICAgc2Nyb2xsUm9vdEVsID0gcm9vdEVsO1xuICAgIGNsZWFyQXV0b1Njcm9sbHMoKTtcbiAgICBzY3JvbGxFbCA9IG9wdGlvbnMuc2Nyb2xsO1xuICAgIHNjcm9sbEN1c3RvbUZuID0gb3B0aW9ucy5zY3JvbGxGbjtcblxuICAgIGlmIChzY3JvbGxFbCA9PT0gdHJ1ZSkge1xuICAgICAgc2Nyb2xsRWwgPSBnZXRQYXJlbnRBdXRvU2Nyb2xsRWxlbWVudChyb290RWwsIHRydWUpO1xuICAgIH1cbiAgfVxuXG4gIHZhciBsYXllcnNPdXQgPSAwO1xuICB2YXIgY3VycmVudFBhcmVudCA9IHNjcm9sbEVsO1xuXG4gIGRvIHtcbiAgICB2YXIgZWwgPSBjdXJyZW50UGFyZW50LFxuICAgICAgICByZWN0ID0gZ2V0UmVjdChlbCksXG4gICAgICAgIHRvcCA9IHJlY3QudG9wLFxuICAgICAgICBib3R0b20gPSByZWN0LmJvdHRvbSxcbiAgICAgICAgbGVmdCA9IHJlY3QubGVmdCxcbiAgICAgICAgcmlnaHQgPSByZWN0LnJpZ2h0LFxuICAgICAgICB3aWR0aCA9IHJlY3Qud2lkdGgsXG4gICAgICAgIGhlaWdodCA9IHJlY3QuaGVpZ2h0LFxuICAgICAgICBjYW5TY3JvbGxYID0gdm9pZCAwLFxuICAgICAgICBjYW5TY3JvbGxZID0gdm9pZCAwLFxuICAgICAgICBzY3JvbGxXaWR0aCA9IGVsLnNjcm9sbFdpZHRoLFxuICAgICAgICBzY3JvbGxIZWlnaHQgPSBlbC5zY3JvbGxIZWlnaHQsXG4gICAgICAgIGVsQ1NTID0gY3NzKGVsKSxcbiAgICAgICAgc2Nyb2xsUG9zWCA9IGVsLnNjcm9sbExlZnQsXG4gICAgICAgIHNjcm9sbFBvc1kgPSBlbC5zY3JvbGxUb3A7XG5cbiAgICBpZiAoZWwgPT09IHdpblNjcm9sbGVyKSB7XG4gICAgICBjYW5TY3JvbGxYID0gd2lkdGggPCBzY3JvbGxXaWR0aCAmJiAoZWxDU1Mub3ZlcmZsb3dYID09PSAnYXV0bycgfHwgZWxDU1Mub3ZlcmZsb3dYID09PSAnc2Nyb2xsJyB8fCBlbENTUy5vdmVyZmxvd1ggPT09ICd2aXNpYmxlJyk7XG4gICAgICBjYW5TY3JvbGxZID0gaGVpZ2h0IDwgc2Nyb2xsSGVpZ2h0ICYmIChlbENTUy5vdmVyZmxvd1kgPT09ICdhdXRvJyB8fCBlbENTUy5vdmVyZmxvd1kgPT09ICdzY3JvbGwnIHx8IGVsQ1NTLm92ZXJmbG93WSA9PT0gJ3Zpc2libGUnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY2FuU2Nyb2xsWCA9IHdpZHRoIDwgc2Nyb2xsV2lkdGggJiYgKGVsQ1NTLm92ZXJmbG93WCA9PT0gJ2F1dG8nIHx8IGVsQ1NTLm92ZXJmbG93WCA9PT0gJ3Njcm9sbCcpO1xuICAgICAgY2FuU2Nyb2xsWSA9IGhlaWdodCA8IHNjcm9sbEhlaWdodCAmJiAoZWxDU1Mub3ZlcmZsb3dZID09PSAnYXV0bycgfHwgZWxDU1Mub3ZlcmZsb3dZID09PSAnc2Nyb2xsJyk7XG4gICAgfVxuXG4gICAgdmFyIHZ4ID0gY2FuU2Nyb2xsWCAmJiAoTWF0aC5hYnMocmlnaHQgLSB4KSA8PSBzZW5zICYmIHNjcm9sbFBvc1ggKyB3aWR0aCA8IHNjcm9sbFdpZHRoKSAtIChNYXRoLmFicyhsZWZ0IC0geCkgPD0gc2VucyAmJiAhIXNjcm9sbFBvc1gpO1xuICAgIHZhciB2eSA9IGNhblNjcm9sbFkgJiYgKE1hdGguYWJzKGJvdHRvbSAtIHkpIDw9IHNlbnMgJiYgc2Nyb2xsUG9zWSArIGhlaWdodCA8IHNjcm9sbEhlaWdodCkgLSAoTWF0aC5hYnModG9wIC0geSkgPD0gc2VucyAmJiAhIXNjcm9sbFBvc1kpO1xuXG4gICAgaWYgKCFhdXRvU2Nyb2xsc1tsYXllcnNPdXRdKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8PSBsYXllcnNPdXQ7IGkrKykge1xuICAgICAgICBpZiAoIWF1dG9TY3JvbGxzW2ldKSB7XG4gICAgICAgICAgYXV0b1Njcm9sbHNbaV0gPSB7fTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChhdXRvU2Nyb2xsc1tsYXllcnNPdXRdLnZ4ICE9IHZ4IHx8IGF1dG9TY3JvbGxzW2xheWVyc091dF0udnkgIT0gdnkgfHwgYXV0b1Njcm9sbHNbbGF5ZXJzT3V0XS5lbCAhPT0gZWwpIHtcbiAgICAgIGF1dG9TY3JvbGxzW2xheWVyc091dF0uZWwgPSBlbDtcbiAgICAgIGF1dG9TY3JvbGxzW2xheWVyc091dF0udnggPSB2eDtcbiAgICAgIGF1dG9TY3JvbGxzW2xheWVyc091dF0udnkgPSB2eTtcbiAgICAgIGNsZWFySW50ZXJ2YWwoYXV0b1Njcm9sbHNbbGF5ZXJzT3V0XS5waWQpO1xuXG4gICAgICBpZiAodnggIT0gMCB8fCB2eSAhPSAwKSB7XG4gICAgICAgIHNjcm9sbFRoaXNJbnN0YW5jZSA9IHRydWU7XG4gICAgICAgIC8qIGpzaGludCBsb29wZnVuYzp0cnVlICovXG5cbiAgICAgICAgYXV0b1Njcm9sbHNbbGF5ZXJzT3V0XS5waWQgPSBzZXRJbnRlcnZhbChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgLy8gZW11bGF0ZSBkcmFnIG92ZXIgZHVyaW5nIGF1dG9zY3JvbGwgKGZhbGxiYWNrKSwgZW11bGF0aW5nIG5hdGl2ZSBEbkQgYmVoYXZpb3VyXG4gICAgICAgICAgaWYgKGlzRmFsbGJhY2sgJiYgdGhpcy5sYXllciA9PT0gMCkge1xuICAgICAgICAgICAgU29ydGFibGUuYWN0aXZlLl9vblRvdWNoTW92ZSh0b3VjaEV2dCQxKTsgLy8gVG8gbW92ZSBnaG9zdCBpZiBpdCBpcyBwb3NpdGlvbmVkIGFic29sdXRlbHlcblxuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBzY3JvbGxPZmZzZXRZID0gYXV0b1Njcm9sbHNbdGhpcy5sYXllcl0udnkgPyBhdXRvU2Nyb2xsc1t0aGlzLmxheWVyXS52eSAqIHNwZWVkIDogMDtcbiAgICAgICAgICB2YXIgc2Nyb2xsT2Zmc2V0WCA9IGF1dG9TY3JvbGxzW3RoaXMubGF5ZXJdLnZ4ID8gYXV0b1Njcm9sbHNbdGhpcy5sYXllcl0udnggKiBzcGVlZCA6IDA7XG5cbiAgICAgICAgICBpZiAodHlwZW9mIHNjcm9sbEN1c3RvbUZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBpZiAoc2Nyb2xsQ3VzdG9tRm4uY2FsbChTb3J0YWJsZS5kcmFnZ2VkLnBhcmVudE5vZGVbZXhwYW5kb10sIHNjcm9sbE9mZnNldFgsIHNjcm9sbE9mZnNldFksIGV2dCwgdG91Y2hFdnQkMSwgYXV0b1Njcm9sbHNbdGhpcy5sYXllcl0uZWwpICE9PSAnY29udGludWUnKSB7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBzY3JvbGxCeShhdXRvU2Nyb2xsc1t0aGlzLmxheWVyXS5lbCwgc2Nyb2xsT2Zmc2V0WCwgc2Nyb2xsT2Zmc2V0WSk7XG4gICAgICAgIH0uYmluZCh7XG4gICAgICAgICAgbGF5ZXI6IGxheWVyc091dFxuICAgICAgICB9KSwgMjQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGxheWVyc091dCsrO1xuICB9IHdoaWxlIChvcHRpb25zLmJ1YmJsZVNjcm9sbCAmJiBjdXJyZW50UGFyZW50ICE9PSB3aW5TY3JvbGxlciAmJiAoY3VycmVudFBhcmVudCA9IGdldFBhcmVudEF1dG9TY3JvbGxFbGVtZW50KGN1cnJlbnRQYXJlbnQsIGZhbHNlKSkpO1xuXG4gIHNjcm9sbGluZyA9IHNjcm9sbFRoaXNJbnN0YW5jZTsgLy8gaW4gY2FzZSBhbm90aGVyIGZ1bmN0aW9uIGNhdGNoZXMgc2Nyb2xsaW5nIGFzIGZhbHNlIGluIGJldHdlZW4gd2hlbiBpdCBpcyBub3Rcbn0sIDMwKTtcblxudmFyIGRyb3AgPSBmdW5jdGlvbiBkcm9wKF9yZWYpIHtcbiAgdmFyIG9yaWdpbmFsRXZlbnQgPSBfcmVmLm9yaWdpbmFsRXZlbnQsXG4gICAgICBwdXRTb3J0YWJsZSA9IF9yZWYucHV0U29ydGFibGUsXG4gICAgICBkcmFnRWwgPSBfcmVmLmRyYWdFbCxcbiAgICAgIGFjdGl2ZVNvcnRhYmxlID0gX3JlZi5hY3RpdmVTb3J0YWJsZSxcbiAgICAgIGRpc3BhdGNoU29ydGFibGVFdmVudCA9IF9yZWYuZGlzcGF0Y2hTb3J0YWJsZUV2ZW50LFxuICAgICAgaGlkZUdob3N0Rm9yVGFyZ2V0ID0gX3JlZi5oaWRlR2hvc3RGb3JUYXJnZXQsXG4gICAgICB1bmhpZGVHaG9zdEZvclRhcmdldCA9IF9yZWYudW5oaWRlR2hvc3RGb3JUYXJnZXQ7XG4gIGlmICghb3JpZ2luYWxFdmVudCkgcmV0dXJuO1xuICB2YXIgdG9Tb3J0YWJsZSA9IHB1dFNvcnRhYmxlIHx8IGFjdGl2ZVNvcnRhYmxlO1xuICBoaWRlR2hvc3RGb3JUYXJnZXQoKTtcbiAgdmFyIHRvdWNoID0gb3JpZ2luYWxFdmVudC5jaGFuZ2VkVG91Y2hlcyAmJiBvcmlnaW5hbEV2ZW50LmNoYW5nZWRUb3VjaGVzLmxlbmd0aCA/IG9yaWdpbmFsRXZlbnQuY2hhbmdlZFRvdWNoZXNbMF0gOiBvcmlnaW5hbEV2ZW50O1xuICB2YXIgdGFyZ2V0ID0gZG9jdW1lbnQuZWxlbWVudEZyb21Qb2ludCh0b3VjaC5jbGllbnRYLCB0b3VjaC5jbGllbnRZKTtcbiAgdW5oaWRlR2hvc3RGb3JUYXJnZXQoKTtcblxuICBpZiAodG9Tb3J0YWJsZSAmJiAhdG9Tb3J0YWJsZS5lbC5jb250YWlucyh0YXJnZXQpKSB7XG4gICAgZGlzcGF0Y2hTb3J0YWJsZUV2ZW50KCdzcGlsbCcpO1xuICAgIHRoaXMub25TcGlsbCh7XG4gICAgICBkcmFnRWw6IGRyYWdFbCxcbiAgICAgIHB1dFNvcnRhYmxlOiBwdXRTb3J0YWJsZVxuICAgIH0pO1xuICB9XG59O1xuXG5mdW5jdGlvbiBSZXZlcnQoKSB7fVxuXG5SZXZlcnQucHJvdG90eXBlID0ge1xuICBzdGFydEluZGV4OiBudWxsLFxuICBkcmFnU3RhcnQ6IGZ1bmN0aW9uIGRyYWdTdGFydChfcmVmMikge1xuICAgIHZhciBvbGREcmFnZ2FibGVJbmRleCA9IF9yZWYyLm9sZERyYWdnYWJsZUluZGV4O1xuICAgIHRoaXMuc3RhcnRJbmRleCA9IG9sZERyYWdnYWJsZUluZGV4O1xuICB9LFxuICBvblNwaWxsOiBmdW5jdGlvbiBvblNwaWxsKF9yZWYzKSB7XG4gICAgdmFyIGRyYWdFbCA9IF9yZWYzLmRyYWdFbCxcbiAgICAgICAgcHV0U29ydGFibGUgPSBfcmVmMy5wdXRTb3J0YWJsZTtcbiAgICB0aGlzLnNvcnRhYmxlLmNhcHR1cmVBbmltYXRpb25TdGF0ZSgpO1xuXG4gICAgaWYgKHB1dFNvcnRhYmxlKSB7XG4gICAgICBwdXRTb3J0YWJsZS5jYXB0dXJlQW5pbWF0aW9uU3RhdGUoKTtcbiAgICB9XG5cbiAgICB2YXIgbmV4dFNpYmxpbmcgPSBnZXRDaGlsZCh0aGlzLnNvcnRhYmxlLmVsLCB0aGlzLnN0YXJ0SW5kZXgsIHRoaXMub3B0aW9ucyk7XG5cbiAgICBpZiAobmV4dFNpYmxpbmcpIHtcbiAgICAgIHRoaXMuc29ydGFibGUuZWwuaW5zZXJ0QmVmb3JlKGRyYWdFbCwgbmV4dFNpYmxpbmcpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnNvcnRhYmxlLmVsLmFwcGVuZENoaWxkKGRyYWdFbCk7XG4gICAgfVxuXG4gICAgdGhpcy5zb3J0YWJsZS5hbmltYXRlQWxsKCk7XG5cbiAgICBpZiAocHV0U29ydGFibGUpIHtcbiAgICAgIHB1dFNvcnRhYmxlLmFuaW1hdGVBbGwoKTtcbiAgICB9XG4gIH0sXG4gIGRyb3A6IGRyb3Bcbn07XG5cbl9leHRlbmRzKFJldmVydCwge1xuICBwbHVnaW5OYW1lOiAncmV2ZXJ0T25TcGlsbCdcbn0pO1xuXG5mdW5jdGlvbiBSZW1vdmUoKSB7fVxuXG5SZW1vdmUucHJvdG90eXBlID0ge1xuICBvblNwaWxsOiBmdW5jdGlvbiBvblNwaWxsKF9yZWY0KSB7XG4gICAgdmFyIGRyYWdFbCA9IF9yZWY0LmRyYWdFbCxcbiAgICAgICAgcHV0U29ydGFibGUgPSBfcmVmNC5wdXRTb3J0YWJsZTtcbiAgICB2YXIgcGFyZW50U29ydGFibGUgPSBwdXRTb3J0YWJsZSB8fCB0aGlzLnNvcnRhYmxlO1xuICAgIHBhcmVudFNvcnRhYmxlLmNhcHR1cmVBbmltYXRpb25TdGF0ZSgpO1xuICAgIGRyYWdFbC5wYXJlbnROb2RlICYmIGRyYWdFbC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGRyYWdFbCk7XG4gICAgcGFyZW50U29ydGFibGUuYW5pbWF0ZUFsbCgpO1xuICB9LFxuICBkcm9wOiBkcm9wXG59O1xuXG5fZXh0ZW5kcyhSZW1vdmUsIHtcbiAgcGx1Z2luTmFtZTogJ3JlbW92ZU9uU3BpbGwnXG59KTtcblxudmFyIGxhc3RTd2FwRWw7XG5cbmZ1bmN0aW9uIFN3YXBQbHVnaW4oKSB7XG4gIGZ1bmN0aW9uIFN3YXAoKSB7XG4gICAgdGhpcy5kZWZhdWx0cyA9IHtcbiAgICAgIHN3YXBDbGFzczogJ3NvcnRhYmxlLXN3YXAtaGlnaGxpZ2h0J1xuICAgIH07XG4gIH1cblxuICBTd2FwLnByb3RvdHlwZSA9IHtcbiAgICBkcmFnU3RhcnQ6IGZ1bmN0aW9uIGRyYWdTdGFydChfcmVmKSB7XG4gICAgICB2YXIgZHJhZ0VsID0gX3JlZi5kcmFnRWw7XG4gICAgICBsYXN0U3dhcEVsID0gZHJhZ0VsO1xuICAgIH0sXG4gICAgZHJhZ092ZXJWYWxpZDogZnVuY3Rpb24gZHJhZ092ZXJWYWxpZChfcmVmMikge1xuICAgICAgdmFyIGNvbXBsZXRlZCA9IF9yZWYyLmNvbXBsZXRlZCxcbiAgICAgICAgICB0YXJnZXQgPSBfcmVmMi50YXJnZXQsXG4gICAgICAgICAgb25Nb3ZlID0gX3JlZjIub25Nb3ZlLFxuICAgICAgICAgIGFjdGl2ZVNvcnRhYmxlID0gX3JlZjIuYWN0aXZlU29ydGFibGUsXG4gICAgICAgICAgY2hhbmdlZCA9IF9yZWYyLmNoYW5nZWQsXG4gICAgICAgICAgY2FuY2VsID0gX3JlZjIuY2FuY2VsO1xuICAgICAgaWYgKCFhY3RpdmVTb3J0YWJsZS5vcHRpb25zLnN3YXApIHJldHVybjtcbiAgICAgIHZhciBlbCA9IHRoaXMuc29ydGFibGUuZWwsXG4gICAgICAgICAgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcblxuICAgICAgaWYgKHRhcmdldCAmJiB0YXJnZXQgIT09IGVsKSB7XG4gICAgICAgIHZhciBwcmV2U3dhcEVsID0gbGFzdFN3YXBFbDtcblxuICAgICAgICBpZiAob25Nb3ZlKHRhcmdldCkgIT09IGZhbHNlKSB7XG4gICAgICAgICAgdG9nZ2xlQ2xhc3ModGFyZ2V0LCBvcHRpb25zLnN3YXBDbGFzcywgdHJ1ZSk7XG4gICAgICAgICAgbGFzdFN3YXBFbCA9IHRhcmdldDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBsYXN0U3dhcEVsID0gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwcmV2U3dhcEVsICYmIHByZXZTd2FwRWwgIT09IGxhc3RTd2FwRWwpIHtcbiAgICAgICAgICB0b2dnbGVDbGFzcyhwcmV2U3dhcEVsLCBvcHRpb25zLnN3YXBDbGFzcywgZmFsc2UpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGNoYW5nZWQoKTtcbiAgICAgIGNvbXBsZXRlZCh0cnVlKTtcbiAgICAgIGNhbmNlbCgpO1xuICAgIH0sXG4gICAgZHJvcDogZnVuY3Rpb24gZHJvcChfcmVmMykge1xuICAgICAgdmFyIGFjdGl2ZVNvcnRhYmxlID0gX3JlZjMuYWN0aXZlU29ydGFibGUsXG4gICAgICAgICAgcHV0U29ydGFibGUgPSBfcmVmMy5wdXRTb3J0YWJsZSxcbiAgICAgICAgICBkcmFnRWwgPSBfcmVmMy5kcmFnRWw7XG4gICAgICB2YXIgdG9Tb3J0YWJsZSA9IHB1dFNvcnRhYmxlIHx8IHRoaXMuc29ydGFibGU7XG4gICAgICB2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgICAgIGxhc3RTd2FwRWwgJiYgdG9nZ2xlQ2xhc3MobGFzdFN3YXBFbCwgb3B0aW9ucy5zd2FwQ2xhc3MsIGZhbHNlKTtcblxuICAgICAgaWYgKGxhc3RTd2FwRWwgJiYgKG9wdGlvbnMuc3dhcCB8fCBwdXRTb3J0YWJsZSAmJiBwdXRTb3J0YWJsZS5vcHRpb25zLnN3YXApKSB7XG4gICAgICAgIGlmIChkcmFnRWwgIT09IGxhc3RTd2FwRWwpIHtcbiAgICAgICAgICB0b1NvcnRhYmxlLmNhcHR1cmVBbmltYXRpb25TdGF0ZSgpO1xuICAgICAgICAgIGlmICh0b1NvcnRhYmxlICE9PSBhY3RpdmVTb3J0YWJsZSkgYWN0aXZlU29ydGFibGUuY2FwdHVyZUFuaW1hdGlvblN0YXRlKCk7XG4gICAgICAgICAgc3dhcE5vZGVzKGRyYWdFbCwgbGFzdFN3YXBFbCk7XG4gICAgICAgICAgdG9Tb3J0YWJsZS5hbmltYXRlQWxsKCk7XG4gICAgICAgICAgaWYgKHRvU29ydGFibGUgIT09IGFjdGl2ZVNvcnRhYmxlKSBhY3RpdmVTb3J0YWJsZS5hbmltYXRlQWxsKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIG51bGxpbmc6IGZ1bmN0aW9uIG51bGxpbmcoKSB7XG4gICAgICBsYXN0U3dhcEVsID0gbnVsbDtcbiAgICB9XG4gIH07XG4gIHJldHVybiBfZXh0ZW5kcyhTd2FwLCB7XG4gICAgcGx1Z2luTmFtZTogJ3N3YXAnLFxuICAgIGV2ZW50UHJvcGVydGllczogZnVuY3Rpb24gZXZlbnRQcm9wZXJ0aWVzKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc3dhcEl0ZW06IGxhc3RTd2FwRWxcbiAgICAgIH07XG4gICAgfVxuICB9KTtcbn1cblxuZnVuY3Rpb24gc3dhcE5vZGVzKG4xLCBuMikge1xuICB2YXIgcDEgPSBuMS5wYXJlbnROb2RlLFxuICAgICAgcDIgPSBuMi5wYXJlbnROb2RlLFxuICAgICAgaTEsXG4gICAgICBpMjtcbiAgaWYgKCFwMSB8fCAhcDIgfHwgcDEuaXNFcXVhbE5vZGUobjIpIHx8IHAyLmlzRXF1YWxOb2RlKG4xKSkgcmV0dXJuO1xuICBpMSA9IGluZGV4KG4xKTtcbiAgaTIgPSBpbmRleChuMik7XG5cbiAgaWYgKHAxLmlzRXF1YWxOb2RlKHAyKSAmJiBpMSA8IGkyKSB7XG4gICAgaTIrKztcbiAgfVxuXG4gIHAxLmluc2VydEJlZm9yZShuMiwgcDEuY2hpbGRyZW5baTFdKTtcbiAgcDIuaW5zZXJ0QmVmb3JlKG4xLCBwMi5jaGlsZHJlbltpMl0pO1xufVxuXG52YXIgbXVsdGlEcmFnRWxlbWVudHMgPSBbXSxcbiAgICBtdWx0aURyYWdDbG9uZXMgPSBbXSxcbiAgICBsYXN0TXVsdGlEcmFnU2VsZWN0LFxuICAgIC8vIGZvciBzZWxlY3Rpb24gd2l0aCBtb2RpZmllciBrZXkgZG93biAoU0hJRlQpXG5tdWx0aURyYWdTb3J0YWJsZSxcbiAgICBpbml0aWFsRm9sZGluZyA9IGZhbHNlLFxuICAgIC8vIEluaXRpYWwgbXVsdGktZHJhZyBmb2xkIHdoZW4gZHJhZyBzdGFydGVkXG5mb2xkaW5nID0gZmFsc2UsXG4gICAgLy8gRm9sZGluZyBhbnkgb3RoZXIgdGltZVxuZHJhZ1N0YXJ0ZWQgPSBmYWxzZSxcbiAgICBkcmFnRWwkMSxcbiAgICBjbG9uZXNGcm9tUmVjdCxcbiAgICBjbG9uZXNIaWRkZW47XG5cbmZ1bmN0aW9uIE11bHRpRHJhZ1BsdWdpbigpIHtcbiAgZnVuY3Rpb24gTXVsdGlEcmFnKHNvcnRhYmxlKSB7XG4gICAgLy8gQmluZCBhbGwgcHJpdmF0ZSBtZXRob2RzXG4gICAgZm9yICh2YXIgZm4gaW4gdGhpcykge1xuICAgICAgaWYgKGZuLmNoYXJBdCgwKSA9PT0gJ18nICYmIHR5cGVvZiB0aGlzW2ZuXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aGlzW2ZuXSA9IHRoaXNbZm5dLmJpbmQodGhpcyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHNvcnRhYmxlLm9wdGlvbnMuc3VwcG9ydFBvaW50ZXIpIHtcbiAgICAgIG9uKGRvY3VtZW50LCAncG9pbnRlcnVwJywgdGhpcy5fZGVzZWxlY3RNdWx0aURyYWcpO1xuICAgIH0gZWxzZSB7XG4gICAgICBvbihkb2N1bWVudCwgJ21vdXNldXAnLCB0aGlzLl9kZXNlbGVjdE11bHRpRHJhZyk7XG4gICAgICBvbihkb2N1bWVudCwgJ3RvdWNoZW5kJywgdGhpcy5fZGVzZWxlY3RNdWx0aURyYWcpO1xuICAgIH1cblxuICAgIG9uKGRvY3VtZW50LCAna2V5ZG93bicsIHRoaXMuX2NoZWNrS2V5RG93bik7XG4gICAgb24oZG9jdW1lbnQsICdrZXl1cCcsIHRoaXMuX2NoZWNrS2V5VXApO1xuICAgIHRoaXMuZGVmYXVsdHMgPSB7XG4gICAgICBzZWxlY3RlZENsYXNzOiAnc29ydGFibGUtc2VsZWN0ZWQnLFxuICAgICAgbXVsdGlEcmFnS2V5OiBudWxsLFxuICAgICAgc2V0RGF0YTogZnVuY3Rpb24gc2V0RGF0YShkYXRhVHJhbnNmZXIsIGRyYWdFbCkge1xuICAgICAgICB2YXIgZGF0YSA9ICcnO1xuXG4gICAgICAgIGlmIChtdWx0aURyYWdFbGVtZW50cy5sZW5ndGggJiYgbXVsdGlEcmFnU29ydGFibGUgPT09IHNvcnRhYmxlKSB7XG4gICAgICAgICAgbXVsdGlEcmFnRWxlbWVudHMuZm9yRWFjaChmdW5jdGlvbiAobXVsdGlEcmFnRWxlbWVudCwgaSkge1xuICAgICAgICAgICAgZGF0YSArPSAoIWkgPyAnJyA6ICcsICcpICsgbXVsdGlEcmFnRWxlbWVudC50ZXh0Q29udGVudDtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkYXRhID0gZHJhZ0VsLnRleHRDb250ZW50O1xuICAgICAgICB9XG5cbiAgICAgICAgZGF0YVRyYW5zZmVyLnNldERhdGEoJ1RleHQnLCBkYXRhKTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgTXVsdGlEcmFnLnByb3RvdHlwZSA9IHtcbiAgICBtdWx0aURyYWdLZXlEb3duOiBmYWxzZSxcbiAgICBpc011bHRpRHJhZzogZmFsc2UsXG4gICAgZGVsYXlTdGFydEdsb2JhbDogZnVuY3Rpb24gZGVsYXlTdGFydEdsb2JhbChfcmVmKSB7XG4gICAgICB2YXIgZHJhZ2dlZCA9IF9yZWYuZHJhZ0VsO1xuICAgICAgZHJhZ0VsJDEgPSBkcmFnZ2VkO1xuICAgIH0sXG4gICAgZGVsYXlFbmRlZDogZnVuY3Rpb24gZGVsYXlFbmRlZCgpIHtcbiAgICAgIHRoaXMuaXNNdWx0aURyYWcgPSB+bXVsdGlEcmFnRWxlbWVudHMuaW5kZXhPZihkcmFnRWwkMSk7XG4gICAgfSxcbiAgICBzZXR1cENsb25lOiBmdW5jdGlvbiBzZXR1cENsb25lKF9yZWYyKSB7XG4gICAgICB2YXIgc29ydGFibGUgPSBfcmVmMi5zb3J0YWJsZSxcbiAgICAgICAgICBjYW5jZWwgPSBfcmVmMi5jYW5jZWw7XG4gICAgICBpZiAoIXRoaXMuaXNNdWx0aURyYWcpIHJldHVybjtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtdWx0aURyYWdFbGVtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBtdWx0aURyYWdDbG9uZXMucHVzaChjbG9uZShtdWx0aURyYWdFbGVtZW50c1tpXSkpO1xuICAgICAgICBtdWx0aURyYWdDbG9uZXNbaV0uc29ydGFibGVJbmRleCA9IG11bHRpRHJhZ0VsZW1lbnRzW2ldLnNvcnRhYmxlSW5kZXg7XG4gICAgICAgIG11bHRpRHJhZ0Nsb25lc1tpXS5kcmFnZ2FibGUgPSBmYWxzZTtcbiAgICAgICAgbXVsdGlEcmFnQ2xvbmVzW2ldLnN0eWxlWyd3aWxsLWNoYW5nZSddID0gJyc7XG4gICAgICAgIHRvZ2dsZUNsYXNzKG11bHRpRHJhZ0Nsb25lc1tpXSwgdGhpcy5vcHRpb25zLnNlbGVjdGVkQ2xhc3MsIGZhbHNlKTtcbiAgICAgICAgbXVsdGlEcmFnRWxlbWVudHNbaV0gPT09IGRyYWdFbCQxICYmIHRvZ2dsZUNsYXNzKG11bHRpRHJhZ0Nsb25lc1tpXSwgdGhpcy5vcHRpb25zLmNob3NlbkNsYXNzLCBmYWxzZSk7XG4gICAgICB9XG5cbiAgICAgIHNvcnRhYmxlLl9oaWRlQ2xvbmUoKTtcblxuICAgICAgY2FuY2VsKCk7XG4gICAgfSxcbiAgICBjbG9uZTogZnVuY3Rpb24gY2xvbmUoX3JlZjMpIHtcbiAgICAgIHZhciBzb3J0YWJsZSA9IF9yZWYzLnNvcnRhYmxlLFxuICAgICAgICAgIHJvb3RFbCA9IF9yZWYzLnJvb3RFbCxcbiAgICAgICAgICBkaXNwYXRjaFNvcnRhYmxlRXZlbnQgPSBfcmVmMy5kaXNwYXRjaFNvcnRhYmxlRXZlbnQsXG4gICAgICAgICAgY2FuY2VsID0gX3JlZjMuY2FuY2VsO1xuICAgICAgaWYgKCF0aGlzLmlzTXVsdGlEcmFnKSByZXR1cm47XG5cbiAgICAgIGlmICghdGhpcy5vcHRpb25zLnJlbW92ZUNsb25lT25IaWRlKSB7XG4gICAgICAgIGlmIChtdWx0aURyYWdFbGVtZW50cy5sZW5ndGggJiYgbXVsdGlEcmFnU29ydGFibGUgPT09IHNvcnRhYmxlKSB7XG4gICAgICAgICAgaW5zZXJ0TXVsdGlEcmFnQ2xvbmVzKHRydWUsIHJvb3RFbCk7XG4gICAgICAgICAgZGlzcGF0Y2hTb3J0YWJsZUV2ZW50KCdjbG9uZScpO1xuICAgICAgICAgIGNhbmNlbCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBzaG93Q2xvbmU6IGZ1bmN0aW9uIHNob3dDbG9uZShfcmVmNCkge1xuICAgICAgdmFyIGNsb25lTm93U2hvd24gPSBfcmVmNC5jbG9uZU5vd1Nob3duLFxuICAgICAgICAgIHJvb3RFbCA9IF9yZWY0LnJvb3RFbCxcbiAgICAgICAgICBjYW5jZWwgPSBfcmVmNC5jYW5jZWw7XG4gICAgICBpZiAoIXRoaXMuaXNNdWx0aURyYWcpIHJldHVybjtcbiAgICAgIGluc2VydE11bHRpRHJhZ0Nsb25lcyhmYWxzZSwgcm9vdEVsKTtcbiAgICAgIG11bHRpRHJhZ0Nsb25lcy5mb3JFYWNoKGZ1bmN0aW9uIChjbG9uZSkge1xuICAgICAgICBjc3MoY2xvbmUsICdkaXNwbGF5JywgJycpO1xuICAgICAgfSk7XG4gICAgICBjbG9uZU5vd1Nob3duKCk7XG4gICAgICBjbG9uZXNIaWRkZW4gPSBmYWxzZTtcbiAgICAgIGNhbmNlbCgpO1xuICAgIH0sXG4gICAgaGlkZUNsb25lOiBmdW5jdGlvbiBoaWRlQ2xvbmUoX3JlZjUpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgIHZhciBzb3J0YWJsZSA9IF9yZWY1LnNvcnRhYmxlLFxuICAgICAgICAgIGNsb25lTm93SGlkZGVuID0gX3JlZjUuY2xvbmVOb3dIaWRkZW4sXG4gICAgICAgICAgY2FuY2VsID0gX3JlZjUuY2FuY2VsO1xuICAgICAgaWYgKCF0aGlzLmlzTXVsdGlEcmFnKSByZXR1cm47XG4gICAgICBtdWx0aURyYWdDbG9uZXMuZm9yRWFjaChmdW5jdGlvbiAoY2xvbmUpIHtcbiAgICAgICAgY3NzKGNsb25lLCAnZGlzcGxheScsICdub25lJyk7XG5cbiAgICAgICAgaWYgKF90aGlzLm9wdGlvbnMucmVtb3ZlQ2xvbmVPbkhpZGUgJiYgY2xvbmUucGFyZW50Tm9kZSkge1xuICAgICAgICAgIGNsb25lLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoY2xvbmUpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGNsb25lTm93SGlkZGVuKCk7XG4gICAgICBjbG9uZXNIaWRkZW4gPSB0cnVlO1xuICAgICAgY2FuY2VsKCk7XG4gICAgfSxcbiAgICBkcmFnU3RhcnRHbG9iYWw6IGZ1bmN0aW9uIGRyYWdTdGFydEdsb2JhbChfcmVmNikge1xuICAgICAgdmFyIHNvcnRhYmxlID0gX3JlZjYuc29ydGFibGU7XG5cbiAgICAgIGlmICghdGhpcy5pc011bHRpRHJhZyAmJiBtdWx0aURyYWdTb3J0YWJsZSkge1xuICAgICAgICBtdWx0aURyYWdTb3J0YWJsZS5tdWx0aURyYWcuX2Rlc2VsZWN0TXVsdGlEcmFnKCk7XG4gICAgICB9XG5cbiAgICAgIG11bHRpRHJhZ0VsZW1lbnRzLmZvckVhY2goZnVuY3Rpb24gKG11bHRpRHJhZ0VsZW1lbnQpIHtcbiAgICAgICAgbXVsdGlEcmFnRWxlbWVudC5zb3J0YWJsZUluZGV4ID0gaW5kZXgobXVsdGlEcmFnRWxlbWVudCk7XG4gICAgICB9KTsgLy8gU29ydCBtdWx0aS1kcmFnIGVsZW1lbnRzXG5cbiAgICAgIG11bHRpRHJhZ0VsZW1lbnRzID0gbXVsdGlEcmFnRWxlbWVudHMuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICByZXR1cm4gYS5zb3J0YWJsZUluZGV4IC0gYi5zb3J0YWJsZUluZGV4O1xuICAgICAgfSk7XG4gICAgICBkcmFnU3RhcnRlZCA9IHRydWU7XG4gICAgfSxcbiAgICBkcmFnU3RhcnRlZDogZnVuY3Rpb24gZHJhZ1N0YXJ0ZWQoX3JlZjcpIHtcbiAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgICB2YXIgc29ydGFibGUgPSBfcmVmNy5zb3J0YWJsZTtcbiAgICAgIGlmICghdGhpcy5pc011bHRpRHJhZykgcmV0dXJuO1xuXG4gICAgICBpZiAodGhpcy5vcHRpb25zLnNvcnQpIHtcbiAgICAgICAgLy8gQ2FwdHVyZSByZWN0cyxcbiAgICAgICAgLy8gaGlkZSBtdWx0aSBkcmFnIGVsZW1lbnRzIChieSBwb3NpdGlvbmluZyB0aGVtIGFic29sdXRlKSxcbiAgICAgICAgLy8gc2V0IG11bHRpIGRyYWcgZWxlbWVudHMgcmVjdHMgdG8gZHJhZ1JlY3QsXG4gICAgICAgIC8vIHNob3cgbXVsdGkgZHJhZyBlbGVtZW50cyxcbiAgICAgICAgLy8gYW5pbWF0ZSB0byByZWN0cyxcbiAgICAgICAgLy8gdW5zZXQgcmVjdHMgJiByZW1vdmUgZnJvbSBET01cbiAgICAgICAgc29ydGFibGUuY2FwdHVyZUFuaW1hdGlvblN0YXRlKCk7XG5cbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5hbmltYXRpb24pIHtcbiAgICAgICAgICBtdWx0aURyYWdFbGVtZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChtdWx0aURyYWdFbGVtZW50KSB7XG4gICAgICAgICAgICBpZiAobXVsdGlEcmFnRWxlbWVudCA9PT0gZHJhZ0VsJDEpIHJldHVybjtcbiAgICAgICAgICAgIGNzcyhtdWx0aURyYWdFbGVtZW50LCAncG9zaXRpb24nLCAnYWJzb2x1dGUnKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICB2YXIgZHJhZ1JlY3QgPSBnZXRSZWN0KGRyYWdFbCQxLCBmYWxzZSwgdHJ1ZSwgdHJ1ZSk7XG4gICAgICAgICAgbXVsdGlEcmFnRWxlbWVudHMuZm9yRWFjaChmdW5jdGlvbiAobXVsdGlEcmFnRWxlbWVudCkge1xuICAgICAgICAgICAgaWYgKG11bHRpRHJhZ0VsZW1lbnQgPT09IGRyYWdFbCQxKSByZXR1cm47XG4gICAgICAgICAgICBzZXRSZWN0KG11bHRpRHJhZ0VsZW1lbnQsIGRyYWdSZWN0KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBmb2xkaW5nID0gdHJ1ZTtcbiAgICAgICAgICBpbml0aWFsRm9sZGluZyA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgc29ydGFibGUuYW5pbWF0ZUFsbChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZvbGRpbmcgPSBmYWxzZTtcbiAgICAgICAgaW5pdGlhbEZvbGRpbmcgPSBmYWxzZTtcblxuICAgICAgICBpZiAoX3RoaXMyLm9wdGlvbnMuYW5pbWF0aW9uKSB7XG4gICAgICAgICAgbXVsdGlEcmFnRWxlbWVudHMuZm9yRWFjaChmdW5jdGlvbiAobXVsdGlEcmFnRWxlbWVudCkge1xuICAgICAgICAgICAgdW5zZXRSZWN0KG11bHRpRHJhZ0VsZW1lbnQpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9IC8vIFJlbW92ZSBhbGwgYXV4aWxpYXJ5IG11bHRpZHJhZyBpdGVtcyBmcm9tIGVsLCBpZiBzb3J0aW5nIGVuYWJsZWRcblxuXG4gICAgICAgIGlmIChfdGhpczIub3B0aW9ucy5zb3J0KSB7XG4gICAgICAgICAgcmVtb3ZlTXVsdGlEcmFnRWxlbWVudHMoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSxcbiAgICBkcmFnT3ZlcjogZnVuY3Rpb24gZHJhZ092ZXIoX3JlZjgpIHtcbiAgICAgIHZhciB0YXJnZXQgPSBfcmVmOC50YXJnZXQsXG4gICAgICAgICAgY29tcGxldGVkID0gX3JlZjguY29tcGxldGVkLFxuICAgICAgICAgIGNhbmNlbCA9IF9yZWY4LmNhbmNlbDtcblxuICAgICAgaWYgKGZvbGRpbmcgJiYgfm11bHRpRHJhZ0VsZW1lbnRzLmluZGV4T2YodGFyZ2V0KSkge1xuICAgICAgICBjb21wbGV0ZWQoZmFsc2UpO1xuICAgICAgICBjYW5jZWwoKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHJldmVydDogZnVuY3Rpb24gcmV2ZXJ0KF9yZWY5KSB7XG4gICAgICB2YXIgZnJvbVNvcnRhYmxlID0gX3JlZjkuZnJvbVNvcnRhYmxlLFxuICAgICAgICAgIHJvb3RFbCA9IF9yZWY5LnJvb3RFbCxcbiAgICAgICAgICBzb3J0YWJsZSA9IF9yZWY5LnNvcnRhYmxlLFxuICAgICAgICAgIGRyYWdSZWN0ID0gX3JlZjkuZHJhZ1JlY3Q7XG5cbiAgICAgIGlmIChtdWx0aURyYWdFbGVtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgIC8vIFNldHVwIHVuZm9sZCBhbmltYXRpb25cbiAgICAgICAgbXVsdGlEcmFnRWxlbWVudHMuZm9yRWFjaChmdW5jdGlvbiAobXVsdGlEcmFnRWxlbWVudCkge1xuICAgICAgICAgIHNvcnRhYmxlLmFkZEFuaW1hdGlvblN0YXRlKHtcbiAgICAgICAgICAgIHRhcmdldDogbXVsdGlEcmFnRWxlbWVudCxcbiAgICAgICAgICAgIHJlY3Q6IGZvbGRpbmcgPyBnZXRSZWN0KG11bHRpRHJhZ0VsZW1lbnQpIDogZHJhZ1JlY3RcbiAgICAgICAgICB9KTtcbiAgICAgICAgICB1bnNldFJlY3QobXVsdGlEcmFnRWxlbWVudCk7XG4gICAgICAgICAgbXVsdGlEcmFnRWxlbWVudC5mcm9tUmVjdCA9IGRyYWdSZWN0O1xuICAgICAgICAgIGZyb21Tb3J0YWJsZS5yZW1vdmVBbmltYXRpb25TdGF0ZShtdWx0aURyYWdFbGVtZW50KTtcbiAgICAgICAgfSk7XG4gICAgICAgIGZvbGRpbmcgPSBmYWxzZTtcbiAgICAgICAgaW5zZXJ0TXVsdGlEcmFnRWxlbWVudHMoIXRoaXMub3B0aW9ucy5yZW1vdmVDbG9uZU9uSGlkZSwgcm9vdEVsKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGRyYWdPdmVyQ29tcGxldGVkOiBmdW5jdGlvbiBkcmFnT3ZlckNvbXBsZXRlZChfcmVmMTApIHtcbiAgICAgIHZhciBzb3J0YWJsZSA9IF9yZWYxMC5zb3J0YWJsZSxcbiAgICAgICAgICBpc093bmVyID0gX3JlZjEwLmlzT3duZXIsXG4gICAgICAgICAgaW5zZXJ0aW9uID0gX3JlZjEwLmluc2VydGlvbixcbiAgICAgICAgICBhY3RpdmVTb3J0YWJsZSA9IF9yZWYxMC5hY3RpdmVTb3J0YWJsZSxcbiAgICAgICAgICBwYXJlbnRFbCA9IF9yZWYxMC5wYXJlbnRFbCxcbiAgICAgICAgICBwdXRTb3J0YWJsZSA9IF9yZWYxMC5wdXRTb3J0YWJsZTtcbiAgICAgIHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuXG4gICAgICBpZiAoaW5zZXJ0aW9uKSB7XG4gICAgICAgIC8vIENsb25lcyBtdXN0IGJlIGhpZGRlbiBiZWZvcmUgZm9sZGluZyBhbmltYXRpb24gdG8gY2FwdHVyZSBkcmFnUmVjdEFic29sdXRlIHByb3Blcmx5XG4gICAgICAgIGlmIChpc093bmVyKSB7XG4gICAgICAgICAgYWN0aXZlU29ydGFibGUuX2hpZGVDbG9uZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgaW5pdGlhbEZvbGRpbmcgPSBmYWxzZTsgLy8gSWYgbGVhdmluZyBzb3J0OmZhbHNlIHJvb3QsIG9yIGFscmVhZHkgZm9sZGluZyAtIEZvbGQgdG8gbmV3IGxvY2F0aW9uXG5cbiAgICAgICAgaWYgKG9wdGlvbnMuYW5pbWF0aW9uICYmIG11bHRpRHJhZ0VsZW1lbnRzLmxlbmd0aCA+IDEgJiYgKGZvbGRpbmcgfHwgIWlzT3duZXIgJiYgIWFjdGl2ZVNvcnRhYmxlLm9wdGlvbnMuc29ydCAmJiAhcHV0U29ydGFibGUpKSB7XG4gICAgICAgICAgLy8gRm9sZDogU2V0IGFsbCBtdWx0aSBkcmFnIGVsZW1lbnRzJ3MgcmVjdHMgdG8gZHJhZ0VsJ3MgcmVjdCB3aGVuIG11bHRpLWRyYWcgZWxlbWVudHMgYXJlIGludmlzaWJsZVxuICAgICAgICAgIHZhciBkcmFnUmVjdEFic29sdXRlID0gZ2V0UmVjdChkcmFnRWwkMSwgZmFsc2UsIHRydWUsIHRydWUpO1xuICAgICAgICAgIG11bHRpRHJhZ0VsZW1lbnRzLmZvckVhY2goZnVuY3Rpb24gKG11bHRpRHJhZ0VsZW1lbnQpIHtcbiAgICAgICAgICAgIGlmIChtdWx0aURyYWdFbGVtZW50ID09PSBkcmFnRWwkMSkgcmV0dXJuO1xuICAgICAgICAgICAgc2V0UmVjdChtdWx0aURyYWdFbGVtZW50LCBkcmFnUmVjdEFic29sdXRlKTsgLy8gTW92ZSBlbGVtZW50KHMpIHRvIGVuZCBvZiBwYXJlbnRFbCBzbyB0aGF0IGl0IGRvZXMgbm90IGludGVyZmVyZSB3aXRoIG11bHRpLWRyYWcgY2xvbmVzIGluc2VydGlvbiBpZiB0aGV5IGFyZSBpbnNlcnRlZFxuICAgICAgICAgICAgLy8gd2hpbGUgZm9sZGluZywgYW5kIHNvIHRoYXQgd2UgY2FuIGNhcHR1cmUgdGhlbSBhZ2FpbiBiZWNhdXNlIG9sZCBzb3J0YWJsZSB3aWxsIG5vIGxvbmdlciBiZSBmcm9tU29ydGFibGVcblxuICAgICAgICAgICAgcGFyZW50RWwuYXBwZW5kQ2hpbGQobXVsdGlEcmFnRWxlbWVudCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgZm9sZGluZyA9IHRydWU7XG4gICAgICAgIH0gLy8gQ2xvbmVzIG11c3QgYmUgc2hvd24gKGFuZCBjaGVjayB0byByZW1vdmUgbXVsdGkgZHJhZ3MpIGFmdGVyIGZvbGRpbmcgd2hlbiBpbnRlcmZlcmluZyBtdWx0aURyYWdFbGVtZW50cyBhcmUgbW92ZWQgb3V0XG5cblxuICAgICAgICBpZiAoIWlzT3duZXIpIHtcbiAgICAgICAgICAvLyBPbmx5IHJlbW92ZSBpZiBub3QgZm9sZGluZyAoZm9sZGluZyB3aWxsIHJlbW92ZSB0aGVtIGFueXdheXMpXG4gICAgICAgICAgaWYgKCFmb2xkaW5nKSB7XG4gICAgICAgICAgICByZW1vdmVNdWx0aURyYWdFbGVtZW50cygpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChtdWx0aURyYWdFbGVtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICB2YXIgY2xvbmVzSGlkZGVuQmVmb3JlID0gY2xvbmVzSGlkZGVuO1xuXG4gICAgICAgICAgICBhY3RpdmVTb3J0YWJsZS5fc2hvd0Nsb25lKHNvcnRhYmxlKTsgLy8gVW5mb2xkIGFuaW1hdGlvbiBmb3IgY2xvbmVzIGlmIHNob3dpbmcgZnJvbSBoaWRkZW5cblxuXG4gICAgICAgICAgICBpZiAoYWN0aXZlU29ydGFibGUub3B0aW9ucy5hbmltYXRpb24gJiYgIWNsb25lc0hpZGRlbiAmJiBjbG9uZXNIaWRkZW5CZWZvcmUpIHtcbiAgICAgICAgICAgICAgbXVsdGlEcmFnQ2xvbmVzLmZvckVhY2goZnVuY3Rpb24gKGNsb25lKSB7XG4gICAgICAgICAgICAgICAgYWN0aXZlU29ydGFibGUuYWRkQW5pbWF0aW9uU3RhdGUoe1xuICAgICAgICAgICAgICAgICAgdGFyZ2V0OiBjbG9uZSxcbiAgICAgICAgICAgICAgICAgIHJlY3Q6IGNsb25lc0Zyb21SZWN0XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgY2xvbmUuZnJvbVJlY3QgPSBjbG9uZXNGcm9tUmVjdDtcbiAgICAgICAgICAgICAgICBjbG9uZS50aGlzQW5pbWF0aW9uRHVyYXRpb24gPSBudWxsO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYWN0aXZlU29ydGFibGUuX3Nob3dDbG9uZShzb3J0YWJsZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBkcmFnT3ZlckFuaW1hdGlvbkNhcHR1cmU6IGZ1bmN0aW9uIGRyYWdPdmVyQW5pbWF0aW9uQ2FwdHVyZShfcmVmMTEpIHtcbiAgICAgIHZhciBkcmFnUmVjdCA9IF9yZWYxMS5kcmFnUmVjdCxcbiAgICAgICAgICBpc093bmVyID0gX3JlZjExLmlzT3duZXIsXG4gICAgICAgICAgYWN0aXZlU29ydGFibGUgPSBfcmVmMTEuYWN0aXZlU29ydGFibGU7XG4gICAgICBtdWx0aURyYWdFbGVtZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChtdWx0aURyYWdFbGVtZW50KSB7XG4gICAgICAgIG11bHRpRHJhZ0VsZW1lbnQudGhpc0FuaW1hdGlvbkR1cmF0aW9uID0gbnVsbDtcbiAgICAgIH0pO1xuXG4gICAgICBpZiAoYWN0aXZlU29ydGFibGUub3B0aW9ucy5hbmltYXRpb24gJiYgIWlzT3duZXIgJiYgYWN0aXZlU29ydGFibGUubXVsdGlEcmFnLmlzTXVsdGlEcmFnKSB7XG4gICAgICAgIGNsb25lc0Zyb21SZWN0ID0gX2V4dGVuZHMoe30sIGRyYWdSZWN0KTtcbiAgICAgICAgdmFyIGRyYWdNYXRyaXggPSBtYXRyaXgoZHJhZ0VsJDEsIHRydWUpO1xuICAgICAgICBjbG9uZXNGcm9tUmVjdC50b3AgLT0gZHJhZ01hdHJpeC5mO1xuICAgICAgICBjbG9uZXNGcm9tUmVjdC5sZWZ0IC09IGRyYWdNYXRyaXguZTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGRyYWdPdmVyQW5pbWF0aW9uQ29tcGxldGU6IGZ1bmN0aW9uIGRyYWdPdmVyQW5pbWF0aW9uQ29tcGxldGUoKSB7XG4gICAgICBpZiAoZm9sZGluZykge1xuICAgICAgICBmb2xkaW5nID0gZmFsc2U7XG4gICAgICAgIHJlbW92ZU11bHRpRHJhZ0VsZW1lbnRzKCk7XG4gICAgICB9XG4gICAgfSxcbiAgICBkcm9wOiBmdW5jdGlvbiBkcm9wKF9yZWYxMikge1xuICAgICAgdmFyIGV2dCA9IF9yZWYxMi5vcmlnaW5hbEV2ZW50LFxuICAgICAgICAgIHJvb3RFbCA9IF9yZWYxMi5yb290RWwsXG4gICAgICAgICAgcGFyZW50RWwgPSBfcmVmMTIucGFyZW50RWwsXG4gICAgICAgICAgc29ydGFibGUgPSBfcmVmMTIuc29ydGFibGUsXG4gICAgICAgICAgZGlzcGF0Y2hTb3J0YWJsZUV2ZW50ID0gX3JlZjEyLmRpc3BhdGNoU29ydGFibGVFdmVudCxcbiAgICAgICAgICBvbGRJbmRleCA9IF9yZWYxMi5vbGRJbmRleCxcbiAgICAgICAgICBwdXRTb3J0YWJsZSA9IF9yZWYxMi5wdXRTb3J0YWJsZTtcbiAgICAgIHZhciB0b1NvcnRhYmxlID0gcHV0U29ydGFibGUgfHwgdGhpcy5zb3J0YWJsZTtcbiAgICAgIGlmICghZXZ0KSByZXR1cm47XG4gICAgICB2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucyxcbiAgICAgICAgICBjaGlsZHJlbiA9IHBhcmVudEVsLmNoaWxkcmVuOyAvLyBNdWx0aS1kcmFnIHNlbGVjdGlvblxuXG4gICAgICBpZiAoIWRyYWdTdGFydGVkKSB7XG4gICAgICAgIGlmIChvcHRpb25zLm11bHRpRHJhZ0tleSAmJiAhdGhpcy5tdWx0aURyYWdLZXlEb3duKSB7XG4gICAgICAgICAgdGhpcy5fZGVzZWxlY3RNdWx0aURyYWcoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRvZ2dsZUNsYXNzKGRyYWdFbCQxLCBvcHRpb25zLnNlbGVjdGVkQ2xhc3MsICF+bXVsdGlEcmFnRWxlbWVudHMuaW5kZXhPZihkcmFnRWwkMSkpO1xuXG4gICAgICAgIGlmICghfm11bHRpRHJhZ0VsZW1lbnRzLmluZGV4T2YoZHJhZ0VsJDEpKSB7XG4gICAgICAgICAgbXVsdGlEcmFnRWxlbWVudHMucHVzaChkcmFnRWwkMSk7XG4gICAgICAgICAgZGlzcGF0Y2hFdmVudCh7XG4gICAgICAgICAgICBzb3J0YWJsZTogc29ydGFibGUsXG4gICAgICAgICAgICByb290RWw6IHJvb3RFbCxcbiAgICAgICAgICAgIG5hbWU6ICdzZWxlY3QnLFxuICAgICAgICAgICAgdGFyZ2V0RWw6IGRyYWdFbCQxLFxuICAgICAgICAgICAgb3JpZ2luYWxFdnQ6IGV2dFxuICAgICAgICAgIH0pOyAvLyBNb2RpZmllciBhY3RpdmF0ZWQsIHNlbGVjdCBmcm9tIGxhc3QgdG8gZHJhZ0VsXG5cbiAgICAgICAgICBpZiAoZXZ0LnNoaWZ0S2V5ICYmIGxhc3RNdWx0aURyYWdTZWxlY3QgJiYgc29ydGFibGUuZWwuY29udGFpbnMobGFzdE11bHRpRHJhZ1NlbGVjdCkpIHtcbiAgICAgICAgICAgIHZhciBsYXN0SW5kZXggPSBpbmRleChsYXN0TXVsdGlEcmFnU2VsZWN0KSxcbiAgICAgICAgICAgICAgICBjdXJyZW50SW5kZXggPSBpbmRleChkcmFnRWwkMSk7XG5cbiAgICAgICAgICAgIGlmICh+bGFzdEluZGV4ICYmIH5jdXJyZW50SW5kZXggJiYgbGFzdEluZGV4ICE9PSBjdXJyZW50SW5kZXgpIHtcbiAgICAgICAgICAgICAgLy8gTXVzdCBpbmNsdWRlIGxhc3RNdWx0aURyYWdTZWxlY3QgKHNlbGVjdCBpdCksIGluIGNhc2UgbW9kaWZpZWQgc2VsZWN0aW9uIGZyb20gbm8gc2VsZWN0aW9uXG4gICAgICAgICAgICAgIC8vIChidXQgcHJldmlvdXMgc2VsZWN0aW9uIGV4aXN0ZWQpXG4gICAgICAgICAgICAgIHZhciBuLCBpO1xuXG4gICAgICAgICAgICAgIGlmIChjdXJyZW50SW5kZXggPiBsYXN0SW5kZXgpIHtcbiAgICAgICAgICAgICAgICBpID0gbGFzdEluZGV4O1xuICAgICAgICAgICAgICAgIG4gPSBjdXJyZW50SW5kZXg7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaSA9IGN1cnJlbnRJbmRleDtcbiAgICAgICAgICAgICAgICBuID0gbGFzdEluZGV4ICsgMTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGZvciAoOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKH5tdWx0aURyYWdFbGVtZW50cy5pbmRleE9mKGNoaWxkcmVuW2ldKSkgY29udGludWU7XG4gICAgICAgICAgICAgICAgdG9nZ2xlQ2xhc3MoY2hpbGRyZW5baV0sIG9wdGlvbnMuc2VsZWN0ZWRDbGFzcywgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgbXVsdGlEcmFnRWxlbWVudHMucHVzaChjaGlsZHJlbltpXSk7XG4gICAgICAgICAgICAgICAgZGlzcGF0Y2hFdmVudCh7XG4gICAgICAgICAgICAgICAgICBzb3J0YWJsZTogc29ydGFibGUsXG4gICAgICAgICAgICAgICAgICByb290RWw6IHJvb3RFbCxcbiAgICAgICAgICAgICAgICAgIG5hbWU6ICdzZWxlY3QnLFxuICAgICAgICAgICAgICAgICAgdGFyZ2V0RWw6IGNoaWxkcmVuW2ldLFxuICAgICAgICAgICAgICAgICAgb3JpZ2luYWxFdnQ6IGV2dFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxhc3RNdWx0aURyYWdTZWxlY3QgPSBkcmFnRWwkMTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBtdWx0aURyYWdTb3J0YWJsZSA9IHRvU29ydGFibGU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbXVsdGlEcmFnRWxlbWVudHMuc3BsaWNlKG11bHRpRHJhZ0VsZW1lbnRzLmluZGV4T2YoZHJhZ0VsJDEpLCAxKTtcbiAgICAgICAgICBsYXN0TXVsdGlEcmFnU2VsZWN0ID0gbnVsbDtcbiAgICAgICAgICBkaXNwYXRjaEV2ZW50KHtcbiAgICAgICAgICAgIHNvcnRhYmxlOiBzb3J0YWJsZSxcbiAgICAgICAgICAgIHJvb3RFbDogcm9vdEVsLFxuICAgICAgICAgICAgbmFtZTogJ2Rlc2VsZWN0JyxcbiAgICAgICAgICAgIHRhcmdldEVsOiBkcmFnRWwkMSxcbiAgICAgICAgICAgIG9yaWdpbmFsRXZ0OiBldnRcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSAvLyBNdWx0aS1kcmFnIGRyb3BcblxuXG4gICAgICBpZiAoZHJhZ1N0YXJ0ZWQgJiYgdGhpcy5pc011bHRpRHJhZykge1xuICAgICAgICAvLyBEbyBub3QgXCJ1bmZvbGRcIiBhZnRlciBhcm91bmQgZHJhZ0VsIGlmIHJldmVydGVkXG4gICAgICAgIGlmICgocGFyZW50RWxbZXhwYW5kb10ub3B0aW9ucy5zb3J0IHx8IHBhcmVudEVsICE9PSByb290RWwpICYmIG11bHRpRHJhZ0VsZW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICB2YXIgZHJhZ1JlY3QgPSBnZXRSZWN0KGRyYWdFbCQxKSxcbiAgICAgICAgICAgICAgbXVsdGlEcmFnSW5kZXggPSBpbmRleChkcmFnRWwkMSwgJzpub3QoLicgKyB0aGlzLm9wdGlvbnMuc2VsZWN0ZWRDbGFzcyArICcpJyk7XG4gICAgICAgICAgaWYgKCFpbml0aWFsRm9sZGluZyAmJiBvcHRpb25zLmFuaW1hdGlvbikgZHJhZ0VsJDEudGhpc0FuaW1hdGlvbkR1cmF0aW9uID0gbnVsbDtcbiAgICAgICAgICB0b1NvcnRhYmxlLmNhcHR1cmVBbmltYXRpb25TdGF0ZSgpO1xuXG4gICAgICAgICAgaWYgKCFpbml0aWFsRm9sZGluZykge1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMuYW5pbWF0aW9uKSB7XG4gICAgICAgICAgICAgIGRyYWdFbCQxLmZyb21SZWN0ID0gZHJhZ1JlY3Q7XG4gICAgICAgICAgICAgIG11bHRpRHJhZ0VsZW1lbnRzLmZvckVhY2goZnVuY3Rpb24gKG11bHRpRHJhZ0VsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICBtdWx0aURyYWdFbGVtZW50LnRoaXNBbmltYXRpb25EdXJhdGlvbiA9IG51bGw7XG5cbiAgICAgICAgICAgICAgICBpZiAobXVsdGlEcmFnRWxlbWVudCAhPT0gZHJhZ0VsJDEpIHtcbiAgICAgICAgICAgICAgICAgIHZhciByZWN0ID0gZm9sZGluZyA/IGdldFJlY3QobXVsdGlEcmFnRWxlbWVudCkgOiBkcmFnUmVjdDtcbiAgICAgICAgICAgICAgICAgIG11bHRpRHJhZ0VsZW1lbnQuZnJvbVJlY3QgPSByZWN0OyAvLyBQcmVwYXJlIHVuZm9sZCBhbmltYXRpb25cblxuICAgICAgICAgICAgICAgICAgdG9Tb3J0YWJsZS5hZGRBbmltYXRpb25TdGF0ZSh7XG4gICAgICAgICAgICAgICAgICAgIHRhcmdldDogbXVsdGlEcmFnRWxlbWVudCxcbiAgICAgICAgICAgICAgICAgICAgcmVjdDogcmVjdFxuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gLy8gTXVsdGkgZHJhZyBlbGVtZW50cyBhcmUgbm90IG5lY2Vzc2FyaWx5IHJlbW92ZWQgZnJvbSB0aGUgRE9NIG9uIGRyb3AsIHNvIHRvIHJlaW5zZXJ0XG4gICAgICAgICAgICAvLyBwcm9wZXJseSB0aGV5IG11c3QgYWxsIGJlIHJlbW92ZWRcblxuXG4gICAgICAgICAgICByZW1vdmVNdWx0aURyYWdFbGVtZW50cygpO1xuICAgICAgICAgICAgbXVsdGlEcmFnRWxlbWVudHMuZm9yRWFjaChmdW5jdGlvbiAobXVsdGlEcmFnRWxlbWVudCkge1xuICAgICAgICAgICAgICBpZiAoY2hpbGRyZW5bbXVsdGlEcmFnSW5kZXhdKSB7XG4gICAgICAgICAgICAgICAgcGFyZW50RWwuaW5zZXJ0QmVmb3JlKG11bHRpRHJhZ0VsZW1lbnQsIGNoaWxkcmVuW211bHRpRHJhZ0luZGV4XSk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcGFyZW50RWwuYXBwZW5kQ2hpbGQobXVsdGlEcmFnRWxlbWVudCk7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBtdWx0aURyYWdJbmRleCsrO1xuICAgICAgICAgICAgfSk7IC8vIElmIGluaXRpYWwgZm9sZGluZyBpcyBkb25lLCB0aGUgZWxlbWVudHMgbWF5IGhhdmUgY2hhbmdlZCBwb3NpdGlvbiBiZWNhdXNlIHRoZXkgYXJlIG5vd1xuICAgICAgICAgICAgLy8gdW5mb2xkaW5nIGFyb3VuZCBkcmFnRWwsIGV2ZW4gdGhvdWdoIGRyYWdFbCBtYXkgbm90IGhhdmUgaGlzIGluZGV4IGNoYW5nZWQsIHNvIHVwZGF0ZSBldmVudFxuICAgICAgICAgICAgLy8gbXVzdCBiZSBmaXJlZCBoZXJlIGFzIFNvcnRhYmxlIHdpbGwgbm90LlxuXG4gICAgICAgICAgICBpZiAob2xkSW5kZXggPT09IGluZGV4KGRyYWdFbCQxKSkge1xuICAgICAgICAgICAgICB2YXIgdXBkYXRlID0gZmFsc2U7XG4gICAgICAgICAgICAgIG11bHRpRHJhZ0VsZW1lbnRzLmZvckVhY2goZnVuY3Rpb24gKG11bHRpRHJhZ0VsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICBpZiAobXVsdGlEcmFnRWxlbWVudC5zb3J0YWJsZUluZGV4ICE9PSBpbmRleChtdWx0aURyYWdFbGVtZW50KSkge1xuICAgICAgICAgICAgICAgICAgdXBkYXRlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgIGlmICh1cGRhdGUpIHtcbiAgICAgICAgICAgICAgICBkaXNwYXRjaFNvcnRhYmxlRXZlbnQoJ3VwZGF0ZScpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSAvLyBNdXN0IGJlIGRvbmUgYWZ0ZXIgY2FwdHVyaW5nIGluZGl2aWR1YWwgcmVjdHMgKHNjcm9sbCBiYXIpXG5cblxuICAgICAgICAgIG11bHRpRHJhZ0VsZW1lbnRzLmZvckVhY2goZnVuY3Rpb24gKG11bHRpRHJhZ0VsZW1lbnQpIHtcbiAgICAgICAgICAgIHVuc2V0UmVjdChtdWx0aURyYWdFbGVtZW50KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICB0b1NvcnRhYmxlLmFuaW1hdGVBbGwoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIG11bHRpRHJhZ1NvcnRhYmxlID0gdG9Tb3J0YWJsZTtcbiAgICAgIH0gLy8gUmVtb3ZlIGNsb25lcyBpZiBuZWNlc3NhcnlcblxuXG4gICAgICBpZiAocm9vdEVsID09PSBwYXJlbnRFbCB8fCBwdXRTb3J0YWJsZSAmJiBwdXRTb3J0YWJsZS5sYXN0UHV0TW9kZSAhPT0gJ2Nsb25lJykge1xuICAgICAgICBtdWx0aURyYWdDbG9uZXMuZm9yRWFjaChmdW5jdGlvbiAoY2xvbmUpIHtcbiAgICAgICAgICBjbG9uZS5wYXJlbnROb2RlICYmIGNsb25lLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoY2xvbmUpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9LFxuICAgIG51bGxpbmdHbG9iYWw6IGZ1bmN0aW9uIG51bGxpbmdHbG9iYWwoKSB7XG4gICAgICB0aGlzLmlzTXVsdGlEcmFnID0gZHJhZ1N0YXJ0ZWQgPSBmYWxzZTtcbiAgICAgIG11bHRpRHJhZ0Nsb25lcy5sZW5ndGggPSAwO1xuICAgIH0sXG4gICAgZGVzdHJveUdsb2JhbDogZnVuY3Rpb24gZGVzdHJveUdsb2JhbCgpIHtcbiAgICAgIHRoaXMuX2Rlc2VsZWN0TXVsdGlEcmFnKCk7XG5cbiAgICAgIG9mZihkb2N1bWVudCwgJ3BvaW50ZXJ1cCcsIHRoaXMuX2Rlc2VsZWN0TXVsdGlEcmFnKTtcbiAgICAgIG9mZihkb2N1bWVudCwgJ21vdXNldXAnLCB0aGlzLl9kZXNlbGVjdE11bHRpRHJhZyk7XG4gICAgICBvZmYoZG9jdW1lbnQsICd0b3VjaGVuZCcsIHRoaXMuX2Rlc2VsZWN0TXVsdGlEcmFnKTtcbiAgICAgIG9mZihkb2N1bWVudCwgJ2tleWRvd24nLCB0aGlzLl9jaGVja0tleURvd24pO1xuICAgICAgb2ZmKGRvY3VtZW50LCAna2V5dXAnLCB0aGlzLl9jaGVja0tleVVwKTtcbiAgICB9LFxuICAgIF9kZXNlbGVjdE11bHRpRHJhZzogZnVuY3Rpb24gX2Rlc2VsZWN0TXVsdGlEcmFnKGV2dCkge1xuICAgICAgaWYgKHR5cGVvZiBkcmFnU3RhcnRlZCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBkcmFnU3RhcnRlZCkgcmV0dXJuOyAvLyBPbmx5IGRlc2VsZWN0IGlmIHNlbGVjdGlvbiBpcyBpbiB0aGlzIHNvcnRhYmxlXG5cbiAgICAgIGlmIChtdWx0aURyYWdTb3J0YWJsZSAhPT0gdGhpcy5zb3J0YWJsZSkgcmV0dXJuOyAvLyBPbmx5IGRlc2VsZWN0IGlmIHRhcmdldCBpcyBub3QgaXRlbSBpbiB0aGlzIHNvcnRhYmxlXG5cbiAgICAgIGlmIChldnQgJiYgY2xvc2VzdChldnQudGFyZ2V0LCB0aGlzLm9wdGlvbnMuZHJhZ2dhYmxlLCB0aGlzLnNvcnRhYmxlLmVsLCBmYWxzZSkpIHJldHVybjsgLy8gT25seSBkZXNlbGVjdCBpZiBsZWZ0IGNsaWNrXG5cbiAgICAgIGlmIChldnQgJiYgZXZ0LmJ1dHRvbiAhPT0gMCkgcmV0dXJuO1xuXG4gICAgICB3aGlsZSAobXVsdGlEcmFnRWxlbWVudHMubGVuZ3RoKSB7XG4gICAgICAgIHZhciBlbCA9IG11bHRpRHJhZ0VsZW1lbnRzWzBdO1xuICAgICAgICB0b2dnbGVDbGFzcyhlbCwgdGhpcy5vcHRpb25zLnNlbGVjdGVkQ2xhc3MsIGZhbHNlKTtcbiAgICAgICAgbXVsdGlEcmFnRWxlbWVudHMuc2hpZnQoKTtcbiAgICAgICAgZGlzcGF0Y2hFdmVudCh7XG4gICAgICAgICAgc29ydGFibGU6IHRoaXMuc29ydGFibGUsXG4gICAgICAgICAgcm9vdEVsOiB0aGlzLnNvcnRhYmxlLmVsLFxuICAgICAgICAgIG5hbWU6ICdkZXNlbGVjdCcsXG4gICAgICAgICAgdGFyZ2V0RWw6IGVsLFxuICAgICAgICAgIG9yaWdpbmFsRXZ0OiBldnRcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSxcbiAgICBfY2hlY2tLZXlEb3duOiBmdW5jdGlvbiBfY2hlY2tLZXlEb3duKGV2dCkge1xuICAgICAgaWYgKGV2dC5rZXkgPT09IHRoaXMub3B0aW9ucy5tdWx0aURyYWdLZXkpIHtcbiAgICAgICAgdGhpcy5tdWx0aURyYWdLZXlEb3duID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9LFxuICAgIF9jaGVja0tleVVwOiBmdW5jdGlvbiBfY2hlY2tLZXlVcChldnQpIHtcbiAgICAgIGlmIChldnQua2V5ID09PSB0aGlzLm9wdGlvbnMubXVsdGlEcmFnS2V5KSB7XG4gICAgICAgIHRoaXMubXVsdGlEcmFnS2V5RG93biA9IGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgcmV0dXJuIF9leHRlbmRzKE11bHRpRHJhZywge1xuICAgIC8vIFN0YXRpYyBtZXRob2RzICYgcHJvcGVydGllc1xuICAgIHBsdWdpbk5hbWU6ICdtdWx0aURyYWcnLFxuICAgIHV0aWxzOiB7XG4gICAgICAvKipcclxuICAgICAgICogU2VsZWN0cyB0aGUgcHJvdmlkZWQgbXVsdGktZHJhZyBpdGVtXHJcbiAgICAgICAqIEBwYXJhbSAge0hUTUxFbGVtZW50fSBlbCAgICBUaGUgZWxlbWVudCB0byBiZSBzZWxlY3RlZFxyXG4gICAgICAgKi9cbiAgICAgIHNlbGVjdDogZnVuY3Rpb24gc2VsZWN0KGVsKSB7XG4gICAgICAgIHZhciBzb3J0YWJsZSA9IGVsLnBhcmVudE5vZGVbZXhwYW5kb107XG4gICAgICAgIGlmICghc29ydGFibGUgfHwgIXNvcnRhYmxlLm9wdGlvbnMubXVsdGlEcmFnIHx8IH5tdWx0aURyYWdFbGVtZW50cy5pbmRleE9mKGVsKSkgcmV0dXJuO1xuXG4gICAgICAgIGlmIChtdWx0aURyYWdTb3J0YWJsZSAmJiBtdWx0aURyYWdTb3J0YWJsZSAhPT0gc29ydGFibGUpIHtcbiAgICAgICAgICBtdWx0aURyYWdTb3J0YWJsZS5tdWx0aURyYWcuX2Rlc2VsZWN0TXVsdGlEcmFnKCk7XG5cbiAgICAgICAgICBtdWx0aURyYWdTb3J0YWJsZSA9IHNvcnRhYmxlO1xuICAgICAgICB9XG5cbiAgICAgICAgdG9nZ2xlQ2xhc3MoZWwsIHNvcnRhYmxlLm9wdGlvbnMuc2VsZWN0ZWRDbGFzcywgdHJ1ZSk7XG4gICAgICAgIG11bHRpRHJhZ0VsZW1lbnRzLnB1c2goZWwpO1xuICAgICAgfSxcblxuICAgICAgLyoqXHJcbiAgICAgICAqIERlc2VsZWN0cyB0aGUgcHJvdmlkZWQgbXVsdGktZHJhZyBpdGVtXHJcbiAgICAgICAqIEBwYXJhbSAge0hUTUxFbGVtZW50fSBlbCAgICBUaGUgZWxlbWVudCB0byBiZSBkZXNlbGVjdGVkXHJcbiAgICAgICAqL1xuICAgICAgZGVzZWxlY3Q6IGZ1bmN0aW9uIGRlc2VsZWN0KGVsKSB7XG4gICAgICAgIHZhciBzb3J0YWJsZSA9IGVsLnBhcmVudE5vZGVbZXhwYW5kb10sXG4gICAgICAgICAgICBpbmRleCA9IG11bHRpRHJhZ0VsZW1lbnRzLmluZGV4T2YoZWwpO1xuICAgICAgICBpZiAoIXNvcnRhYmxlIHx8ICFzb3J0YWJsZS5vcHRpb25zLm11bHRpRHJhZyB8fCAhfmluZGV4KSByZXR1cm47XG4gICAgICAgIHRvZ2dsZUNsYXNzKGVsLCBzb3J0YWJsZS5vcHRpb25zLnNlbGVjdGVkQ2xhc3MsIGZhbHNlKTtcbiAgICAgICAgbXVsdGlEcmFnRWxlbWVudHMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGV2ZW50UHJvcGVydGllczogZnVuY3Rpb24gZXZlbnRQcm9wZXJ0aWVzKCkge1xuICAgICAgdmFyIF90aGlzMyA9IHRoaXM7XG5cbiAgICAgIHZhciBvbGRJbmRpY2llcyA9IFtdLFxuICAgICAgICAgIG5ld0luZGljaWVzID0gW107XG4gICAgICBtdWx0aURyYWdFbGVtZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChtdWx0aURyYWdFbGVtZW50KSB7XG4gICAgICAgIG9sZEluZGljaWVzLnB1c2goe1xuICAgICAgICAgIG11bHRpRHJhZ0VsZW1lbnQ6IG11bHRpRHJhZ0VsZW1lbnQsXG4gICAgICAgICAgaW5kZXg6IG11bHRpRHJhZ0VsZW1lbnQuc29ydGFibGVJbmRleFxuICAgICAgICB9KTsgLy8gbXVsdGlEcmFnRWxlbWVudHMgd2lsbCBhbHJlYWR5IGJlIHNvcnRlZCBpZiBmb2xkaW5nXG5cbiAgICAgICAgdmFyIG5ld0luZGV4O1xuXG4gICAgICAgIGlmIChmb2xkaW5nICYmIG11bHRpRHJhZ0VsZW1lbnQgIT09IGRyYWdFbCQxKSB7XG4gICAgICAgICAgbmV3SW5kZXggPSAtMTtcbiAgICAgICAgfSBlbHNlIGlmIChmb2xkaW5nKSB7XG4gICAgICAgICAgbmV3SW5kZXggPSBpbmRleChtdWx0aURyYWdFbGVtZW50LCAnOm5vdCguJyArIF90aGlzMy5vcHRpb25zLnNlbGVjdGVkQ2xhc3MgKyAnKScpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5ld0luZGV4ID0gaW5kZXgobXVsdGlEcmFnRWxlbWVudCk7XG4gICAgICAgIH1cblxuICAgICAgICBuZXdJbmRpY2llcy5wdXNoKHtcbiAgICAgICAgICBtdWx0aURyYWdFbGVtZW50OiBtdWx0aURyYWdFbGVtZW50LFxuICAgICAgICAgIGluZGV4OiBuZXdJbmRleFxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgaXRlbXM6IF90b0NvbnN1bWFibGVBcnJheShtdWx0aURyYWdFbGVtZW50cyksXG4gICAgICAgIGNsb25lczogW10uY29uY2F0KG11bHRpRHJhZ0Nsb25lcyksXG4gICAgICAgIG9sZEluZGljaWVzOiBvbGRJbmRpY2llcyxcbiAgICAgICAgbmV3SW5kaWNpZXM6IG5ld0luZGljaWVzXG4gICAgICB9O1xuICAgIH0sXG4gICAgb3B0aW9uTGlzdGVuZXJzOiB7XG4gICAgICBtdWx0aURyYWdLZXk6IGZ1bmN0aW9uIG11bHRpRHJhZ0tleShrZXkpIHtcbiAgICAgICAga2V5ID0ga2V5LnRvTG93ZXJDYXNlKCk7XG5cbiAgICAgICAgaWYgKGtleSA9PT0gJ2N0cmwnKSB7XG4gICAgICAgICAga2V5ID0gJ0NvbnRyb2wnO1xuICAgICAgICB9IGVsc2UgaWYgKGtleS5sZW5ndGggPiAxKSB7XG4gICAgICAgICAga2V5ID0ga2V5LmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsga2V5LnN1YnN0cigxKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBrZXk7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbn1cblxuZnVuY3Rpb24gaW5zZXJ0TXVsdGlEcmFnRWxlbWVudHMoY2xvbmVzSW5zZXJ0ZWQsIHJvb3RFbCkge1xuICBtdWx0aURyYWdFbGVtZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChtdWx0aURyYWdFbGVtZW50LCBpKSB7XG4gICAgdmFyIHRhcmdldCA9IHJvb3RFbC5jaGlsZHJlblttdWx0aURyYWdFbGVtZW50LnNvcnRhYmxlSW5kZXggKyAoY2xvbmVzSW5zZXJ0ZWQgPyBOdW1iZXIoaSkgOiAwKV07XG5cbiAgICBpZiAodGFyZ2V0KSB7XG4gICAgICByb290RWwuaW5zZXJ0QmVmb3JlKG11bHRpRHJhZ0VsZW1lbnQsIHRhcmdldCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJvb3RFbC5hcHBlbmRDaGlsZChtdWx0aURyYWdFbGVtZW50KTtcbiAgICB9XG4gIH0pO1xufVxuLyoqXHJcbiAqIEluc2VydCBtdWx0aS1kcmFnIGNsb25lc1xyXG4gKiBAcGFyYW0gIHtbQm9vbGVhbl19IGVsZW1lbnRzSW5zZXJ0ZWQgIFdoZXRoZXIgdGhlIG11bHRpLWRyYWcgZWxlbWVudHMgYXJlIGluc2VydGVkXHJcbiAqIEBwYXJhbSAge0hUTUxFbGVtZW50fSByb290RWxcclxuICovXG5cblxuZnVuY3Rpb24gaW5zZXJ0TXVsdGlEcmFnQ2xvbmVzKGVsZW1lbnRzSW5zZXJ0ZWQsIHJvb3RFbCkge1xuICBtdWx0aURyYWdDbG9uZXMuZm9yRWFjaChmdW5jdGlvbiAoY2xvbmUsIGkpIHtcbiAgICB2YXIgdGFyZ2V0ID0gcm9vdEVsLmNoaWxkcmVuW2Nsb25lLnNvcnRhYmxlSW5kZXggKyAoZWxlbWVudHNJbnNlcnRlZCA/IE51bWJlcihpKSA6IDApXTtcblxuICAgIGlmICh0YXJnZXQpIHtcbiAgICAgIHJvb3RFbC5pbnNlcnRCZWZvcmUoY2xvbmUsIHRhcmdldCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJvb3RFbC5hcHBlbmRDaGlsZChjbG9uZSk7XG4gICAgfVxuICB9KTtcbn1cblxuZnVuY3Rpb24gcmVtb3ZlTXVsdGlEcmFnRWxlbWVudHMoKSB7XG4gIG11bHRpRHJhZ0VsZW1lbnRzLmZvckVhY2goZnVuY3Rpb24gKG11bHRpRHJhZ0VsZW1lbnQpIHtcbiAgICBpZiAobXVsdGlEcmFnRWxlbWVudCA9PT0gZHJhZ0VsJDEpIHJldHVybjtcbiAgICBtdWx0aURyYWdFbGVtZW50LnBhcmVudE5vZGUgJiYgbXVsdGlEcmFnRWxlbWVudC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKG11bHRpRHJhZ0VsZW1lbnQpO1xuICB9KTtcbn1cblxuU29ydGFibGUubW91bnQobmV3IEF1dG9TY3JvbGxQbHVnaW4oKSk7XG5Tb3J0YWJsZS5tb3VudChSZW1vdmUsIFJldmVydCk7XG5cbmV4cG9ydCBkZWZhdWx0IFNvcnRhYmxlO1xuZXhwb3J0IHsgTXVsdGlEcmFnUGx1Z2luIGFzIE11bHRpRHJhZywgU29ydGFibGUsIFN3YXBQbHVnaW4gYXMgU3dhcCB9O1xuIiwidmFyIGFwaSA9IHJlcXVpcmUoXCIhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9kaXN0L3J1bnRpbWUvaW5qZWN0U3R5bGVzSW50b1N0eWxlVGFnLmpzXCIpO1xuICAgICAgICAgICAgdmFyIGNvbnRlbnQgPSByZXF1aXJlKFwiISEuLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L2Nqcy5qcyEuLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvbG9hZGVycy9zdHlsZVBvc3RMb2FkZXIuanMhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Nhc3MtbG9hZGVyL2Rpc3QvY2pzLmpzIS4vbWFpbi5zY3NzP3Z1ZSZ0eXBlPXN0eWxlJmluZGV4PTAmbGFuZz1zY3NzJlwiKTtcblxuICAgICAgICAgICAgY29udGVudCA9IGNvbnRlbnQuX19lc01vZHVsZSA/IGNvbnRlbnQuZGVmYXVsdCA6IGNvbnRlbnQ7XG5cbiAgICAgICAgICAgIGlmICh0eXBlb2YgY29udGVudCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgY29udGVudCA9IFtbbW9kdWxlLmlkLCBjb250ZW50LCAnJ11dO1xuICAgICAgICAgICAgfVxuXG52YXIgb3B0aW9ucyA9IHt9O1xuXG5vcHRpb25zLmluc2VydCA9IFwiaGVhZFwiO1xub3B0aW9ucy5zaW5nbGV0b24gPSBmYWxzZTtcblxudmFyIHVwZGF0ZSA9IGFwaShjb250ZW50LCBvcHRpb25zKTtcblxuXG5cbm1vZHVsZS5leHBvcnRzID0gY29udGVudC5sb2NhbHMgfHwge307IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBpc09sZElFID0gZnVuY3Rpb24gaXNPbGRJRSgpIHtcbiAgdmFyIG1lbW87XG4gIHJldHVybiBmdW5jdGlvbiBtZW1vcml6ZSgpIHtcbiAgICBpZiAodHlwZW9mIG1lbW8gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAvLyBUZXN0IGZvciBJRSA8PSA5IGFzIHByb3Bvc2VkIGJ5IEJyb3dzZXJoYWNrc1xuICAgICAgLy8gQHNlZSBodHRwOi8vYnJvd3NlcmhhY2tzLmNvbS8jaGFjay1lNzFkODY5MmY2NTMzNDE3M2ZlZTcxNWMyMjJjYjgwNVxuICAgICAgLy8gVGVzdHMgZm9yIGV4aXN0ZW5jZSBvZiBzdGFuZGFyZCBnbG9iYWxzIGlzIHRvIGFsbG93IHN0eWxlLWxvYWRlclxuICAgICAgLy8gdG8gb3BlcmF0ZSBjb3JyZWN0bHkgaW50byBub24tc3RhbmRhcmQgZW52aXJvbm1lbnRzXG4gICAgICAvLyBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS93ZWJwYWNrLWNvbnRyaWIvc3R5bGUtbG9hZGVyL2lzc3Vlcy8xNzdcbiAgICAgIG1lbW8gPSBCb29sZWFuKHdpbmRvdyAmJiBkb2N1bWVudCAmJiBkb2N1bWVudC5hbGwgJiYgIXdpbmRvdy5hdG9iKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbWVtbztcbiAgfTtcbn0oKTtcblxudmFyIGdldFRhcmdldCA9IGZ1bmN0aW9uIGdldFRhcmdldCgpIHtcbiAgdmFyIG1lbW8gPSB7fTtcbiAgcmV0dXJuIGZ1bmN0aW9uIG1lbW9yaXplKHRhcmdldCkge1xuICAgIGlmICh0eXBlb2YgbWVtb1t0YXJnZXRdID09PSAndW5kZWZpbmVkJykge1xuICAgICAgdmFyIHN0eWxlVGFyZ2V0ID0gZG9jdW1lbnQucXVlcnlTZWxlY3Rvcih0YXJnZXQpOyAvLyBTcGVjaWFsIGNhc2UgdG8gcmV0dXJuIGhlYWQgb2YgaWZyYW1lIGluc3RlYWQgb2YgaWZyYW1lIGl0c2VsZlxuXG4gICAgICBpZiAod2luZG93LkhUTUxJRnJhbWVFbGVtZW50ICYmIHN0eWxlVGFyZ2V0IGluc3RhbmNlb2Ygd2luZG93LkhUTUxJRnJhbWVFbGVtZW50KSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgLy8gVGhpcyB3aWxsIHRocm93IGFuIGV4Y2VwdGlvbiBpZiBhY2Nlc3MgdG8gaWZyYW1lIGlzIGJsb2NrZWRcbiAgICAgICAgICAvLyBkdWUgdG8gY3Jvc3Mtb3JpZ2luIHJlc3RyaWN0aW9uc1xuICAgICAgICAgIHN0eWxlVGFyZ2V0ID0gc3R5bGVUYXJnZXQuY29udGVudERvY3VtZW50LmhlYWQ7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAvLyBpc3RhbmJ1bCBpZ25vcmUgbmV4dFxuICAgICAgICAgIHN0eWxlVGFyZ2V0ID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBtZW1vW3RhcmdldF0gPSBzdHlsZVRhcmdldDtcbiAgICB9XG5cbiAgICByZXR1cm4gbWVtb1t0YXJnZXRdO1xuICB9O1xufSgpO1xuXG52YXIgc3R5bGVzSW5Eb20gPSBbXTtcblxuZnVuY3Rpb24gZ2V0SW5kZXhCeUlkZW50aWZpZXIoaWRlbnRpZmllcikge1xuICB2YXIgcmVzdWx0ID0gLTE7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHlsZXNJbkRvbS5sZW5ndGg7IGkrKykge1xuICAgIGlmIChzdHlsZXNJbkRvbVtpXS5pZGVudGlmaWVyID09PSBpZGVudGlmaWVyKSB7XG4gICAgICByZXN1bHQgPSBpO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZnVuY3Rpb24gbW9kdWxlc1RvRG9tKGxpc3QsIG9wdGlvbnMpIHtcbiAgdmFyIGlkQ291bnRNYXAgPSB7fTtcbiAgdmFyIGlkZW50aWZpZXJzID0gW107XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGl0ZW0gPSBsaXN0W2ldO1xuICAgIHZhciBpZCA9IG9wdGlvbnMuYmFzZSA/IGl0ZW1bMF0gKyBvcHRpb25zLmJhc2UgOiBpdGVtWzBdO1xuICAgIHZhciBjb3VudCA9IGlkQ291bnRNYXBbaWRdIHx8IDA7XG4gICAgdmFyIGlkZW50aWZpZXIgPSBcIlwiLmNvbmNhdChpZCwgXCIgXCIpLmNvbmNhdChjb3VudCk7XG4gICAgaWRDb3VudE1hcFtpZF0gPSBjb3VudCArIDE7XG4gICAgdmFyIGluZGV4ID0gZ2V0SW5kZXhCeUlkZW50aWZpZXIoaWRlbnRpZmllcik7XG4gICAgdmFyIG9iaiA9IHtcbiAgICAgIGNzczogaXRlbVsxXSxcbiAgICAgIG1lZGlhOiBpdGVtWzJdLFxuICAgICAgc291cmNlTWFwOiBpdGVtWzNdXG4gICAgfTtcblxuICAgIGlmIChpbmRleCAhPT0gLTEpIHtcbiAgICAgIHN0eWxlc0luRG9tW2luZGV4XS5yZWZlcmVuY2VzKys7XG4gICAgICBzdHlsZXNJbkRvbVtpbmRleF0udXBkYXRlcihvYmopO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdHlsZXNJbkRvbS5wdXNoKHtcbiAgICAgICAgaWRlbnRpZmllcjogaWRlbnRpZmllcixcbiAgICAgICAgdXBkYXRlcjogYWRkU3R5bGUob2JqLCBvcHRpb25zKSxcbiAgICAgICAgcmVmZXJlbmNlczogMVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWRlbnRpZmllcnMucHVzaChpZGVudGlmaWVyKTtcbiAgfVxuXG4gIHJldHVybiBpZGVudGlmaWVycztcbn1cblxuZnVuY3Rpb24gaW5zZXJ0U3R5bGVFbGVtZW50KG9wdGlvbnMpIHtcbiAgdmFyIHN0eWxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3R5bGUnKTtcbiAgdmFyIGF0dHJpYnV0ZXMgPSBvcHRpb25zLmF0dHJpYnV0ZXMgfHwge307XG5cbiAgaWYgKHR5cGVvZiBhdHRyaWJ1dGVzLm5vbmNlID09PSAndW5kZWZpbmVkJykge1xuICAgIHZhciBub25jZSA9IHR5cGVvZiBfX3dlYnBhY2tfbm9uY2VfXyAhPT0gJ3VuZGVmaW5lZCcgPyBfX3dlYnBhY2tfbm9uY2VfXyA6IG51bGw7XG5cbiAgICBpZiAobm9uY2UpIHtcbiAgICAgIGF0dHJpYnV0ZXMubm9uY2UgPSBub25jZTtcbiAgICB9XG4gIH1cblxuICBPYmplY3Qua2V5cyhhdHRyaWJ1dGVzKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICBzdHlsZS5zZXRBdHRyaWJ1dGUoa2V5LCBhdHRyaWJ1dGVzW2tleV0pO1xuICB9KTtcblxuICBpZiAodHlwZW9mIG9wdGlvbnMuaW5zZXJ0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgb3B0aW9ucy5pbnNlcnQoc3R5bGUpO1xuICB9IGVsc2Uge1xuICAgIHZhciB0YXJnZXQgPSBnZXRUYXJnZXQob3B0aW9ucy5pbnNlcnQgfHwgJ2hlYWQnKTtcblxuICAgIGlmICghdGFyZ2V0KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDb3VsZG4ndCBmaW5kIGEgc3R5bGUgdGFyZ2V0LiBUaGlzIHByb2JhYmx5IG1lYW5zIHRoYXQgdGhlIHZhbHVlIGZvciB0aGUgJ2luc2VydCcgcGFyYW1ldGVyIGlzIGludmFsaWQuXCIpO1xuICAgIH1cblxuICAgIHRhcmdldC5hcHBlbmRDaGlsZChzdHlsZSk7XG4gIH1cblxuICByZXR1cm4gc3R5bGU7XG59XG5cbmZ1bmN0aW9uIHJlbW92ZVN0eWxlRWxlbWVudChzdHlsZSkge1xuICAvLyBpc3RhbmJ1bCBpZ25vcmUgaWZcbiAgaWYgKHN0eWxlLnBhcmVudE5vZGUgPT09IG51bGwpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBzdHlsZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHN0eWxlKTtcbn1cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICAqL1xuXG5cbnZhciByZXBsYWNlVGV4dCA9IGZ1bmN0aW9uIHJlcGxhY2VUZXh0KCkge1xuICB2YXIgdGV4dFN0b3JlID0gW107XG4gIHJldHVybiBmdW5jdGlvbiByZXBsYWNlKGluZGV4LCByZXBsYWNlbWVudCkge1xuICAgIHRleHRTdG9yZVtpbmRleF0gPSByZXBsYWNlbWVudDtcbiAgICByZXR1cm4gdGV4dFN0b3JlLmZpbHRlcihCb29sZWFuKS5qb2luKCdcXG4nKTtcbiAgfTtcbn0oKTtcblxuZnVuY3Rpb24gYXBwbHlUb1NpbmdsZXRvblRhZyhzdHlsZSwgaW5kZXgsIHJlbW92ZSwgb2JqKSB7XG4gIHZhciBjc3MgPSByZW1vdmUgPyAnJyA6IG9iai5tZWRpYSA/IFwiQG1lZGlhIFwiLmNvbmNhdChvYmoubWVkaWEsIFwiIHtcIikuY29uY2F0KG9iai5jc3MsIFwifVwiKSA6IG9iai5jc3M7IC8vIEZvciBvbGQgSUVcblxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgICovXG5cbiAgaWYgKHN0eWxlLnN0eWxlU2hlZXQpIHtcbiAgICBzdHlsZS5zdHlsZVNoZWV0LmNzc1RleHQgPSByZXBsYWNlVGV4dChpbmRleCwgY3NzKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgY3NzTm9kZSA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGNzcyk7XG4gICAgdmFyIGNoaWxkTm9kZXMgPSBzdHlsZS5jaGlsZE5vZGVzO1xuXG4gICAgaWYgKGNoaWxkTm9kZXNbaW5kZXhdKSB7XG4gICAgICBzdHlsZS5yZW1vdmVDaGlsZChjaGlsZE5vZGVzW2luZGV4XSk7XG4gICAgfVxuXG4gICAgaWYgKGNoaWxkTm9kZXMubGVuZ3RoKSB7XG4gICAgICBzdHlsZS5pbnNlcnRCZWZvcmUoY3NzTm9kZSwgY2hpbGROb2Rlc1tpbmRleF0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdHlsZS5hcHBlbmRDaGlsZChjc3NOb2RlKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gYXBwbHlUb1RhZyhzdHlsZSwgb3B0aW9ucywgb2JqKSB7XG4gIHZhciBjc3MgPSBvYmouY3NzO1xuICB2YXIgbWVkaWEgPSBvYmoubWVkaWE7XG4gIHZhciBzb3VyY2VNYXAgPSBvYmouc291cmNlTWFwO1xuXG4gIGlmIChtZWRpYSkge1xuICAgIHN0eWxlLnNldEF0dHJpYnV0ZSgnbWVkaWEnLCBtZWRpYSk7XG4gIH0gZWxzZSB7XG4gICAgc3R5bGUucmVtb3ZlQXR0cmlidXRlKCdtZWRpYScpO1xuICB9XG5cbiAgaWYgKHNvdXJjZU1hcCAmJiB0eXBlb2YgYnRvYSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBjc3MgKz0gXCJcXG4vKiMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247YmFzZTY0LFwiLmNvbmNhdChidG9hKHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChKU09OLnN0cmluZ2lmeShzb3VyY2VNYXApKSkpLCBcIiAqL1wiKTtcbiAgfSAvLyBGb3Igb2xkIElFXG5cbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICAqL1xuXG5cbiAgaWYgKHN0eWxlLnN0eWxlU2hlZXQpIHtcbiAgICBzdHlsZS5zdHlsZVNoZWV0LmNzc1RleHQgPSBjc3M7XG4gIH0gZWxzZSB7XG4gICAgd2hpbGUgKHN0eWxlLmZpcnN0Q2hpbGQpIHtcbiAgICAgIHN0eWxlLnJlbW92ZUNoaWxkKHN0eWxlLmZpcnN0Q2hpbGQpO1xuICAgIH1cblxuICAgIHN0eWxlLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGNzcykpO1xuICB9XG59XG5cbnZhciBzaW5nbGV0b24gPSBudWxsO1xudmFyIHNpbmdsZXRvbkNvdW50ZXIgPSAwO1xuXG5mdW5jdGlvbiBhZGRTdHlsZShvYmosIG9wdGlvbnMpIHtcbiAgdmFyIHN0eWxlO1xuICB2YXIgdXBkYXRlO1xuICB2YXIgcmVtb3ZlO1xuXG4gIGlmIChvcHRpb25zLnNpbmdsZXRvbikge1xuICAgIHZhciBzdHlsZUluZGV4ID0gc2luZ2xldG9uQ291bnRlcisrO1xuICAgIHN0eWxlID0gc2luZ2xldG9uIHx8IChzaW5nbGV0b24gPSBpbnNlcnRTdHlsZUVsZW1lbnQob3B0aW9ucykpO1xuICAgIHVwZGF0ZSA9IGFwcGx5VG9TaW5nbGV0b25UYWcuYmluZChudWxsLCBzdHlsZSwgc3R5bGVJbmRleCwgZmFsc2UpO1xuICAgIHJlbW92ZSA9IGFwcGx5VG9TaW5nbGV0b25UYWcuYmluZChudWxsLCBzdHlsZSwgc3R5bGVJbmRleCwgdHJ1ZSk7XG4gIH0gZWxzZSB7XG4gICAgc3R5bGUgPSBpbnNlcnRTdHlsZUVsZW1lbnQob3B0aW9ucyk7XG4gICAgdXBkYXRlID0gYXBwbHlUb1RhZy5iaW5kKG51bGwsIHN0eWxlLCBvcHRpb25zKTtcblxuICAgIHJlbW92ZSA9IGZ1bmN0aW9uIHJlbW92ZSgpIHtcbiAgICAgIHJlbW92ZVN0eWxlRWxlbWVudChzdHlsZSk7XG4gICAgfTtcbiAgfVxuXG4gIHVwZGF0ZShvYmopO1xuICByZXR1cm4gZnVuY3Rpb24gdXBkYXRlU3R5bGUobmV3T2JqKSB7XG4gICAgaWYgKG5ld09iaikge1xuICAgICAgaWYgKG5ld09iai5jc3MgPT09IG9iai5jc3MgJiYgbmV3T2JqLm1lZGlhID09PSBvYmoubWVkaWEgJiYgbmV3T2JqLnNvdXJjZU1hcCA9PT0gb2JqLnNvdXJjZU1hcCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHVwZGF0ZShvYmogPSBuZXdPYmopO1xuICAgIH0gZWxzZSB7XG4gICAgICByZW1vdmUoKTtcbiAgICB9XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGxpc3QsIG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307IC8vIEZvcmNlIHNpbmdsZS10YWcgc29sdXRpb24gb24gSUU2LTksIHdoaWNoIGhhcyBhIGhhcmQgbGltaXQgb24gdGhlICMgb2YgPHN0eWxlPlxuICAvLyB0YWdzIGl0IHdpbGwgYWxsb3cgb24gYSBwYWdlXG5cbiAgaWYgKCFvcHRpb25zLnNpbmdsZXRvbiAmJiB0eXBlb2Ygb3B0aW9ucy5zaW5nbGV0b24gIT09ICdib29sZWFuJykge1xuICAgIG9wdGlvbnMuc2luZ2xldG9uID0gaXNPbGRJRSgpO1xuICB9XG5cbiAgbGlzdCA9IGxpc3QgfHwgW107XG4gIHZhciBsYXN0SWRlbnRpZmllcnMgPSBtb2R1bGVzVG9Eb20obGlzdCwgb3B0aW9ucyk7XG4gIHJldHVybiBmdW5jdGlvbiB1cGRhdGUobmV3TGlzdCkge1xuICAgIG5ld0xpc3QgPSBuZXdMaXN0IHx8IFtdO1xuXG4gICAgaWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChuZXdMaXN0KSAhPT0gJ1tvYmplY3QgQXJyYXldJykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGFzdElkZW50aWZpZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgaWRlbnRpZmllciA9IGxhc3RJZGVudGlmaWVyc1tpXTtcbiAgICAgIHZhciBpbmRleCA9IGdldEluZGV4QnlJZGVudGlmaWVyKGlkZW50aWZpZXIpO1xuICAgICAgc3R5bGVzSW5Eb21baW5kZXhdLnJlZmVyZW5jZXMtLTtcbiAgICB9XG5cbiAgICB2YXIgbmV3TGFzdElkZW50aWZpZXJzID0gbW9kdWxlc1RvRG9tKG5ld0xpc3QsIG9wdGlvbnMpO1xuXG4gICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGxhc3RJZGVudGlmaWVycy5sZW5ndGg7IF9pKyspIHtcbiAgICAgIHZhciBfaWRlbnRpZmllciA9IGxhc3RJZGVudGlmaWVyc1tfaV07XG5cbiAgICAgIHZhciBfaW5kZXggPSBnZXRJbmRleEJ5SWRlbnRpZmllcihfaWRlbnRpZmllcik7XG5cbiAgICAgIGlmIChzdHlsZXNJbkRvbVtfaW5kZXhdLnJlZmVyZW5jZXMgPT09IDApIHtcbiAgICAgICAgc3R5bGVzSW5Eb21bX2luZGV4XS51cGRhdGVyKCk7XG5cbiAgICAgICAgc3R5bGVzSW5Eb20uc3BsaWNlKF9pbmRleCwgMSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgbGFzdElkZW50aWZpZXJzID0gbmV3TGFzdElkZW50aWZpZXJzO1xuICB9O1xufTsiLCJ2YXIgc2NvcGUgPSAodHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBnbG9iYWwpIHx8XG4gICAgICAgICAgICAodHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgJiYgc2VsZikgfHxcbiAgICAgICAgICAgIHdpbmRvdztcbnZhciBhcHBseSA9IEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseTtcblxuLy8gRE9NIEFQSXMsIGZvciBjb21wbGV0ZW5lc3NcblxuZXhwb3J0cy5zZXRUaW1lb3V0ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBuZXcgVGltZW91dChhcHBseS5jYWxsKHNldFRpbWVvdXQsIHNjb3BlLCBhcmd1bWVudHMpLCBjbGVhclRpbWVvdXQpO1xufTtcbmV4cG9ydHMuc2V0SW50ZXJ2YWwgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIG5ldyBUaW1lb3V0KGFwcGx5LmNhbGwoc2V0SW50ZXJ2YWwsIHNjb3BlLCBhcmd1bWVudHMpLCBjbGVhckludGVydmFsKTtcbn07XG5leHBvcnRzLmNsZWFyVGltZW91dCA9XG5leHBvcnRzLmNsZWFySW50ZXJ2YWwgPSBmdW5jdGlvbih0aW1lb3V0KSB7XG4gIGlmICh0aW1lb3V0KSB7XG4gICAgdGltZW91dC5jbG9zZSgpO1xuICB9XG59O1xuXG5mdW5jdGlvbiBUaW1lb3V0KGlkLCBjbGVhckZuKSB7XG4gIHRoaXMuX2lkID0gaWQ7XG4gIHRoaXMuX2NsZWFyRm4gPSBjbGVhckZuO1xufVxuVGltZW91dC5wcm90b3R5cGUudW5yZWYgPSBUaW1lb3V0LnByb3RvdHlwZS5yZWYgPSBmdW5jdGlvbigpIHt9O1xuVGltZW91dC5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5fY2xlYXJGbi5jYWxsKHNjb3BlLCB0aGlzLl9pZCk7XG59O1xuXG4vLyBEb2VzIG5vdCBzdGFydCB0aGUgdGltZSwganVzdCBzZXRzIHVwIHRoZSBtZW1iZXJzIG5lZWRlZC5cbmV4cG9ydHMuZW5yb2xsID0gZnVuY3Rpb24oaXRlbSwgbXNlY3MpIHtcbiAgY2xlYXJUaW1lb3V0KGl0ZW0uX2lkbGVUaW1lb3V0SWQpO1xuICBpdGVtLl9pZGxlVGltZW91dCA9IG1zZWNzO1xufTtcblxuZXhwb3J0cy51bmVucm9sbCA9IGZ1bmN0aW9uKGl0ZW0pIHtcbiAgY2xlYXJUaW1lb3V0KGl0ZW0uX2lkbGVUaW1lb3V0SWQpO1xuICBpdGVtLl9pZGxlVGltZW91dCA9IC0xO1xufTtcblxuZXhwb3J0cy5fdW5yZWZBY3RpdmUgPSBleHBvcnRzLmFjdGl2ZSA9IGZ1bmN0aW9uKGl0ZW0pIHtcbiAgY2xlYXJUaW1lb3V0KGl0ZW0uX2lkbGVUaW1lb3V0SWQpO1xuXG4gIHZhciBtc2VjcyA9IGl0ZW0uX2lkbGVUaW1lb3V0O1xuICBpZiAobXNlY3MgPj0gMCkge1xuICAgIGl0ZW0uX2lkbGVUaW1lb3V0SWQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uIG9uVGltZW91dCgpIHtcbiAgICAgIGlmIChpdGVtLl9vblRpbWVvdXQpXG4gICAgICAgIGl0ZW0uX29uVGltZW91dCgpO1xuICAgIH0sIG1zZWNzKTtcbiAgfVxufTtcblxuLy8gc2V0aW1tZWRpYXRlIGF0dGFjaGVzIGl0c2VsZiB0byB0aGUgZ2xvYmFsIG9iamVjdFxucmVxdWlyZShcInNldGltbWVkaWF0ZVwiKTtcbi8vIE9uIHNvbWUgZXhvdGljIGVudmlyb25tZW50cywgaXQncyBub3QgY2xlYXIgd2hpY2ggb2JqZWN0IGBzZXRpbW1lZGlhdGVgIHdhc1xuLy8gYWJsZSB0byBpbnN0YWxsIG9udG8uICBTZWFyY2ggZWFjaCBwb3NzaWJpbGl0eSBpbiB0aGUgc2FtZSBvcmRlciBhcyB0aGVcbi8vIGBzZXRpbW1lZGlhdGVgIGxpYnJhcnkuXG5leHBvcnRzLnNldEltbWVkaWF0ZSA9ICh0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiAmJiBzZWxmLnNldEltbWVkaWF0ZSkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgKHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgJiYgZ2xvYmFsLnNldEltbWVkaWF0ZSkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgKHRoaXMgJiYgdGhpcy5zZXRJbW1lZGlhdGUpO1xuZXhwb3J0cy5jbGVhckltbWVkaWF0ZSA9ICh0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiAmJiBzZWxmLmNsZWFySW1tZWRpYXRlKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICh0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiICYmIGdsb2JhbC5jbGVhckltbWVkaWF0ZSkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAodGhpcyAmJiB0aGlzLmNsZWFySW1tZWRpYXRlKTtcbiIsInZhciByZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBfdm0gPSB0aGlzXG4gIHZhciBfaCA9IF92bS4kY3JlYXRlRWxlbWVudFxuICB2YXIgX2MgPSBfdm0uX3NlbGYuX2MgfHwgX2hcbiAgcmV0dXJuIF9jKFwiZGl2XCIsIHsgc3RhdGljQ2xhc3M6IFwibWFpblwiIH0sIFtcbiAgICBfYyhcImRpdlwiLCB7IHN0YXRpY0NsYXNzOiBcInRvZG8tYXBwXCIgfSwgW1xuICAgICAgX2MoXCJkaXZcIiwgeyBzdGF0aWNDbGFzczogXCJjaGVsaWstaW5wdXRcIiB9LCBbXG4gICAgICAgIF9jKFwiZGl2XCIsIFtcbiAgICAgICAgICBfdm0uX3YoXCJcXG4gICAgICAgICAgICAgINCk0LDQvNC40LvQuNGPINGH0LXQu9C40LrQsDogXCIpLFxuICAgICAgICAgIF9jKFwiaW5wdXRcIiwge1xuICAgICAgICAgICAgZGlyZWN0aXZlczogW1xuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbmFtZTogXCJtb2RlbFwiLFxuICAgICAgICAgICAgICAgIHJhd05hbWU6IFwidi1tb2RlbFwiLFxuICAgICAgICAgICAgICAgIHZhbHVlOiBfdm0ubmFtZVNlY29uZCxcbiAgICAgICAgICAgICAgICBleHByZXNzaW9uOiBcIm5hbWVTZWNvbmRcIixcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBkb21Qcm9wczogeyB2YWx1ZTogX3ZtLm5hbWVTZWNvbmQgfSxcbiAgICAgICAgICAgIG9uOiB7XG4gICAgICAgICAgICAgIGlucHV0OiBmdW5jdGlvbiAoJGV2ZW50KSB7XG4gICAgICAgICAgICAgICAgaWYgKCRldmVudC50YXJnZXQuY29tcG9zaW5nKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm5cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgX3ZtLm5hbWVTZWNvbmQgPSAkZXZlbnQudGFyZ2V0LnZhbHVlXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICAgIH0pLFxuICAgICAgICBdKSxcbiAgICAgICAgX3ZtLl92KFwiIFwiKSxcbiAgICAgICAgX2MoXCJkaXZcIiwgW1xuICAgICAgICAgIF92bS5fdihcIlxcbiAgICAgICAgICAgICAg0JjQvNGPINGH0LXQu9C40LrQsDogXCIpLFxuICAgICAgICAgIF9jKFwiaW5wdXRcIiwge1xuICAgICAgICAgICAgZGlyZWN0aXZlczogW1xuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbmFtZTogXCJtb2RlbFwiLFxuICAgICAgICAgICAgICAgIHJhd05hbWU6IFwidi1tb2RlbFwiLFxuICAgICAgICAgICAgICAgIHZhbHVlOiBfdm0ubmFtZUZpcnN0LFxuICAgICAgICAgICAgICAgIGV4cHJlc3Npb246IFwibmFtZUZpcnN0XCIsXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgZG9tUHJvcHM6IHsgdmFsdWU6IF92bS5uYW1lRmlyc3QgfSxcbiAgICAgICAgICAgIG9uOiB7XG4gICAgICAgICAgICAgIGlucHV0OiBmdW5jdGlvbiAoJGV2ZW50KSB7XG4gICAgICAgICAgICAgICAgaWYgKCRldmVudC50YXJnZXQuY29tcG9zaW5nKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm5cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgX3ZtLm5hbWVGaXJzdCA9ICRldmVudC50YXJnZXQudmFsdWVcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgfSksXG4gICAgICAgIF0pLFxuICAgICAgICBfdm0uX3YoXCIgXCIpLFxuICAgICAgICBfYyhcImRpdlwiLCBbXG4gICAgICAgICAgX3ZtLl92KFwiXFxuICAgICAgICAgICAgICDQntGC0YfQtdGB0YLQstC+INGH0LXQu9C40LrQsDogXCIpLFxuICAgICAgICAgIF9jKFwiaW5wdXRcIiwge1xuICAgICAgICAgICAgZGlyZWN0aXZlczogW1xuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbmFtZTogXCJtb2RlbFwiLFxuICAgICAgICAgICAgICAgIHJhd05hbWU6IFwidi1tb2RlbFwiLFxuICAgICAgICAgICAgICAgIHZhbHVlOiBfdm0ubmFtZUxhc3QsXG4gICAgICAgICAgICAgICAgZXhwcmVzc2lvbjogXCJuYW1lTGFzdFwiLFxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIGRvbVByb3BzOiB7IHZhbHVlOiBfdm0ubmFtZUxhc3QgfSxcbiAgICAgICAgICAgIG9uOiB7XG4gICAgICAgICAgICAgIGlucHV0OiBmdW5jdGlvbiAoJGV2ZW50KSB7XG4gICAgICAgICAgICAgICAgaWYgKCRldmVudC50YXJnZXQuY29tcG9zaW5nKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm5cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgX3ZtLm5hbWVMYXN0ID0gJGV2ZW50LnRhcmdldC52YWx1ZVxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICB9KSxcbiAgICAgICAgXSksXG4gICAgICAgIF92bS5fdihcIiBcIiksXG4gICAgICAgIF9jKFwiZGl2XCIsIFtcbiAgICAgICAgICBfdm0uX3YoXCJcXG4gICAgICAgICAgICAgINCS0L7Qt9GA0LDRgdGCINGH0LXQu9C40LrQsDogXCIpLFxuICAgICAgICAgIF9jKFwiaW5wdXRcIiwge1xuICAgICAgICAgICAgZGlyZWN0aXZlczogW1xuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbmFtZTogXCJtb2RlbFwiLFxuICAgICAgICAgICAgICAgIHJhd05hbWU6IFwidi1tb2RlbFwiLFxuICAgICAgICAgICAgICAgIHZhbHVlOiBfdm0uYWdlLFxuICAgICAgICAgICAgICAgIGV4cHJlc3Npb246IFwiYWdlXCIsXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgZG9tUHJvcHM6IHsgdmFsdWU6IF92bS5hZ2UgfSxcbiAgICAgICAgICAgIG9uOiB7XG4gICAgICAgICAgICAgIGlucHV0OiBmdW5jdGlvbiAoJGV2ZW50KSB7XG4gICAgICAgICAgICAgICAgaWYgKCRldmVudC50YXJnZXQuY29tcG9zaW5nKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm5cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgX3ZtLmFnZSA9ICRldmVudC50YXJnZXQudmFsdWVcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgfSksXG4gICAgICAgIF0pLFxuICAgICAgXSksXG4gICAgICBfdm0uX3YoXCIgXCIpLFxuICAgICAgX2MoXCJidXR0b25cIiwgeyBvbjogeyBjbGljazogX3ZtLmFkZE5ldyB9IH0sIFtfdm0uX3YoXCLQlNC+0LHQsNCy0LjRgtGMXCIpXSksXG4gICAgICBfdm0uX3YoXCIgXCIpLFxuICAgICAgX2MoXCJidXR0b25cIiwgeyBvbjogeyBjbGljazogX3ZtLmNsZWFySW5wdXQgfSB9LCBbX3ZtLl92KFwi0J7Rh9C40YHQuNGC0Ywg0LLQstC+0LRcIildKSxcbiAgICAgIF92bS5fdihcIiBcIiksXG4gICAgICBfdm0uc2hvd0Zyb21Mb2NhbFxuICAgICAgICA/IF9jKFwiZGl2XCIsIHsgc3RhdGljQ2xhc3M6IFwiY2hlbGlrLXRhYmxlXCIgfSwgW1xuICAgICAgICAgICAgX2MoXG4gICAgICAgICAgICAgIFwiZGl2XCIsXG4gICAgICAgICAgICAgIHsgc3RhdGljQ2xhc3M6IFwiY2hlbGlrLWluZm9fX3dyYXBcIiB9LFxuICAgICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgX2MoXCJkaXZcIiwgeyBzdGF0aWNDbGFzczogXCJjaGVsaWstaW5mb19fdGl0bGVcIiB9LCBbXG4gICAgICAgICAgICAgICAgICBfdm0uX3YoXCLQl9Cw0L/QvtC80L3QtdC90L5cIiksXG4gICAgICAgICAgICAgICAgXSksXG4gICAgICAgICAgICAgICAgX3ZtLl92KFwiIFwiKSxcbiAgICAgICAgICAgICAgICBfdm0uX20oMCksXG4gICAgICAgICAgICAgICAgX3ZtLl92KFwiIFwiKSxcbiAgICAgICAgICAgICAgICBfYyhcbiAgICAgICAgICAgICAgICAgIFwiZHJhZ2dhYmxlXCIsXG4gICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXRpY0NsYXNzOiBcImNoZWxpay1pbmZvX19saXN0XCIsXG4gICAgICAgICAgICAgICAgICAgIGF0dHJzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgZ3JvdXA6IFwicGVvcGxlc1wiLFxuICAgICAgICAgICAgICAgICAgICAgIHRhZzogXCJkaXZcIixcbiAgICAgICAgICAgICAgICAgICAgICBcImdob3N0LWNsYXNzXCI6IFwibW92aW5nLWl0ZW1cIixcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgbW9kZWw6IHtcbiAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogX3ZtLnBlb3BsZXMsXG4gICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2s6IGZ1bmN0aW9uICgkJHYpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF92bS5wZW9wbGVzID0gJCR2XG4gICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICBleHByZXNzaW9uOiBcInBlb3BsZXNcIixcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICBfdm0uX2woX3ZtLnBlb3BsZXMsIGZ1bmN0aW9uIChjaGVsaWssIGluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfYyhcbiAgICAgICAgICAgICAgICAgICAgICBcImRpdlwiLFxuICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGtleTogY2hlbGlrLm5hbWVGaXJzdCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRpY0NsYXNzOiBcImNoZWxpay1pbmZvX19pdGVtXCIsXG4gICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgICAgICAgICBfYyhcImRpdlwiLCB7IHN0YXRpY0NsYXNzOiBcImNoZWxpay1pbmZvX19pdGVtLWluZGV4XCIgfSwgW1xuICAgICAgICAgICAgICAgICAgICAgICAgICBfdm0uX3YoX3ZtLl9zKGluZGV4ICsgMSkpLFxuICAgICAgICAgICAgICAgICAgICAgICAgXSksXG4gICAgICAgICAgICAgICAgICAgICAgICBfdm0uX3YoXCIgXCIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgX2MoXCJkaXZcIiwgeyBzdGF0aWNDbGFzczogXCJjaGVsaWstaW5mb19faXRlbS1uYW1lXCIgfSwgW1xuICAgICAgICAgICAgICAgICAgICAgICAgICBjaGVsaWsubmFtZVNlY29uZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gX2MoXCJzcGFuXCIsIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3ZtLl92KFwiIFwiICsgX3ZtLl9zKGNoZWxpay5uYW1lU2Vjb25kKSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBdKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogX3ZtLl9lKCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgIF92bS5fdihcIiBcIiksXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGNoZWxpay5uYW1lRmlyc3RcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IF9jKFwic3BhblwiLCBbX3ZtLl92KF92bS5fcyhjaGVsaWsubmFtZUZpcnN0KSldKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogX3ZtLl9lKCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgIF92bS5fdihcIiBcIiksXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGNoZWxpay5uYW1lTGFzdFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gX2MoXCJzcGFuXCIsIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3ZtLl92KFwiIFwiICsgX3ZtLl9zKGNoZWxpay5uYW1lTGFzdCkpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IF92bS5fZSgpLFxuICAgICAgICAgICAgICAgICAgICAgICAgXSksXG4gICAgICAgICAgICAgICAgICAgICAgICBfdm0uX3YoXCIgXCIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgX2MoXCJkaXZcIiwgeyBzdGF0aWNDbGFzczogXCJjaGVsaWstaW5mb19faXRlbS1hZ2VcIiB9LCBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGNoZWxpay5zYXZlZEFnZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gX2MoXCJzcGFuXCIsIFtfdm0uX3YoX3ZtLl9zKGNoZWxpay5zYXZlZEFnZSkpXSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IF92bS5fZSgpLFxuICAgICAgICAgICAgICAgICAgICAgICAgXSksXG4gICAgICAgICAgICAgICAgICAgICAgICBfdm0uX3YoXCIgXCIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgX2MoXCJkaXZcIiwgeyBzdGF0aWNDbGFzczogXCJjaGVsaWstaW5mb19faXRlbS1kZWxcIiB9LCBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgIF9jKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiYnV0dG9uXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb246IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xpY2s6IGZ1bmN0aW9uICgkZXZlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3ZtLmRlbGV0ZUNoZWxpayhpbmRleClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBbX3ZtLl92KFwiWFwiKV1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIF0pLFxuICAgICAgICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgICAwXG4gICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgMVxuICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIF92bS5fdihcIiBcIiksXG4gICAgICAgICAgICBfYyhcImJ1dHRvblwiLCB7IG9uOiB7IGNsaWNrOiBfdm0uY2xlYXJMb2NhbCB9IH0sIFtcbiAgICAgICAgICAgICAgX3ZtLl92KFwi0J7Rh9C40YHRgtC40YLRjFwiKSxcbiAgICAgICAgICAgIF0pLFxuICAgICAgICAgIF0pXG4gICAgICAgIDogX3ZtLl9lKCksXG4gICAgXSksXG4gIF0pXG59XG52YXIgc3RhdGljUmVuZGVyRm5zID0gW1xuICBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIF92bSA9IHRoaXNcbiAgICB2YXIgX2ggPSBfdm0uJGNyZWF0ZUVsZW1lbnRcbiAgICB2YXIgX2MgPSBfdm0uX3NlbGYuX2MgfHwgX2hcbiAgICByZXR1cm4gX2MoXCJkaXZcIiwgeyBzdGF0aWNDbGFzczogXCJjaGVsaWstaW5mb19fcHJvcGVydGllcy1saXN0XCIgfSwgW1xuICAgICAgX2MoXCJkaXZcIiwgeyBzdGF0aWNDbGFzczogXCJjaGVsaWstaW5mb19fcHJvcGVydGllcy1pbmRleFwiIH0sIFtcbiAgICAgICAgX3ZtLl92KFwi0J3QvtC80LXRgDpcIiksXG4gICAgICBdKSxcbiAgICAgIF92bS5fdihcIiBcIiksXG4gICAgICBfYyhcImRpdlwiLCB7IHN0YXRpY0NsYXNzOiBcImNoZWxpay1pbmZvX19wcm9wZXJ0aWVzLW5hbWVcIiB9LCBbXG4gICAgICAgIF92bS5fdihcItCk0JjQnjpcIiksXG4gICAgICBdKSxcbiAgICAgIF92bS5fdihcIiBcIiksXG4gICAgICBfYyhcImRpdlwiLCB7IHN0YXRpY0NsYXNzOiBcImNoZWxpay1pbmZvX19wcm9wZXJ0aWVzLWFnZVwiIH0sIFtcbiAgICAgICAgX3ZtLl92KFwi0JLQvtC30YDQsNGB0YI6XCIpLFxuICAgICAgXSksXG4gICAgICBfdm0uX3YoXCIgXCIpLFxuICAgICAgX2MoXCJkaXZcIiwgeyBzdGF0aWNDbGFzczogXCJjaGVsaWstaW5mb19fcHJvcGVydGllcy1ibGFua1wiIH0pLFxuICAgIF0pXG4gIH0sXG5dXG5yZW5kZXIuX3dpdGhTdHJpcHBlZCA9IHRydWVcblxuZXhwb3J0IHsgcmVuZGVyLCBzdGF0aWNSZW5kZXJGbnMgfSIsIi8qIGdsb2JhbHMgX19WVUVfU1NSX0NPTlRFWFRfXyAqL1xuXG4vLyBJTVBPUlRBTlQ6IERvIE5PVCB1c2UgRVMyMDE1IGZlYXR1cmVzIGluIHRoaXMgZmlsZSAoZXhjZXB0IGZvciBtb2R1bGVzKS5cbi8vIFRoaXMgbW9kdWxlIGlzIGEgcnVudGltZSB1dGlsaXR5IGZvciBjbGVhbmVyIGNvbXBvbmVudCBtb2R1bGUgb3V0cHV0IGFuZCB3aWxsXG4vLyBiZSBpbmNsdWRlZCBpbiB0aGUgZmluYWwgd2VicGFjayB1c2VyIGJ1bmRsZS5cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gbm9ybWFsaXplQ29tcG9uZW50IChcbiAgc2NyaXB0RXhwb3J0cyxcbiAgcmVuZGVyLFxuICBzdGF0aWNSZW5kZXJGbnMsXG4gIGZ1bmN0aW9uYWxUZW1wbGF0ZSxcbiAgaW5qZWN0U3R5bGVzLFxuICBzY29wZUlkLFxuICBtb2R1bGVJZGVudGlmaWVyLCAvKiBzZXJ2ZXIgb25seSAqL1xuICBzaGFkb3dNb2RlIC8qIHZ1ZS1jbGkgb25seSAqL1xuKSB7XG4gIC8vIFZ1ZS5leHRlbmQgY29uc3RydWN0b3IgZXhwb3J0IGludGVyb3BcbiAgdmFyIG9wdGlvbnMgPSB0eXBlb2Ygc2NyaXB0RXhwb3J0cyA9PT0gJ2Z1bmN0aW9uJ1xuICAgID8gc2NyaXB0RXhwb3J0cy5vcHRpb25zXG4gICAgOiBzY3JpcHRFeHBvcnRzXG5cbiAgLy8gcmVuZGVyIGZ1bmN0aW9uc1xuICBpZiAocmVuZGVyKSB7XG4gICAgb3B0aW9ucy5yZW5kZXIgPSByZW5kZXJcbiAgICBvcHRpb25zLnN0YXRpY1JlbmRlckZucyA9IHN0YXRpY1JlbmRlckZuc1xuICAgIG9wdGlvbnMuX2NvbXBpbGVkID0gdHJ1ZVxuICB9XG5cbiAgLy8gZnVuY3Rpb25hbCB0ZW1wbGF0ZVxuICBpZiAoZnVuY3Rpb25hbFRlbXBsYXRlKSB7XG4gICAgb3B0aW9ucy5mdW5jdGlvbmFsID0gdHJ1ZVxuICB9XG5cbiAgLy8gc2NvcGVkSWRcbiAgaWYgKHNjb3BlSWQpIHtcbiAgICBvcHRpb25zLl9zY29wZUlkID0gJ2RhdGEtdi0nICsgc2NvcGVJZFxuICB9XG5cbiAgdmFyIGhvb2tcbiAgaWYgKG1vZHVsZUlkZW50aWZpZXIpIHsgLy8gc2VydmVyIGJ1aWxkXG4gICAgaG9vayA9IGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gICAgICAvLyAyLjMgaW5qZWN0aW9uXG4gICAgICBjb250ZXh0ID1cbiAgICAgICAgY29udGV4dCB8fCAvLyBjYWNoZWQgY2FsbFxuICAgICAgICAodGhpcy4kdm5vZGUgJiYgdGhpcy4kdm5vZGUuc3NyQ29udGV4dCkgfHwgLy8gc3RhdGVmdWxcbiAgICAgICAgKHRoaXMucGFyZW50ICYmIHRoaXMucGFyZW50LiR2bm9kZSAmJiB0aGlzLnBhcmVudC4kdm5vZGUuc3NyQ29udGV4dCkgLy8gZnVuY3Rpb25hbFxuICAgICAgLy8gMi4yIHdpdGggcnVuSW5OZXdDb250ZXh0OiB0cnVlXG4gICAgICBpZiAoIWNvbnRleHQgJiYgdHlwZW9mIF9fVlVFX1NTUl9DT05URVhUX18gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGNvbnRleHQgPSBfX1ZVRV9TU1JfQ09OVEVYVF9fXG4gICAgICB9XG4gICAgICAvLyBpbmplY3QgY29tcG9uZW50IHN0eWxlc1xuICAgICAgaWYgKGluamVjdFN0eWxlcykge1xuICAgICAgICBpbmplY3RTdHlsZXMuY2FsbCh0aGlzLCBjb250ZXh0KVxuICAgICAgfVxuICAgICAgLy8gcmVnaXN0ZXIgY29tcG9uZW50IG1vZHVsZSBpZGVudGlmaWVyIGZvciBhc3luYyBjaHVuayBpbmZlcnJlbmNlXG4gICAgICBpZiAoY29udGV4dCAmJiBjb250ZXh0Ll9yZWdpc3RlcmVkQ29tcG9uZW50cykge1xuICAgICAgICBjb250ZXh0Ll9yZWdpc3RlcmVkQ29tcG9uZW50cy5hZGQobW9kdWxlSWRlbnRpZmllcilcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gdXNlZCBieSBzc3IgaW4gY2FzZSBjb21wb25lbnQgaXMgY2FjaGVkIGFuZCBiZWZvcmVDcmVhdGVcbiAgICAvLyBuZXZlciBnZXRzIGNhbGxlZFxuICAgIG9wdGlvbnMuX3NzclJlZ2lzdGVyID0gaG9va1xuICB9IGVsc2UgaWYgKGluamVjdFN0eWxlcykge1xuICAgIGhvb2sgPSBzaGFkb3dNb2RlXG4gICAgICA/IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaW5qZWN0U3R5bGVzLmNhbGwoXG4gICAgICAgICAgdGhpcyxcbiAgICAgICAgICAob3B0aW9ucy5mdW5jdGlvbmFsID8gdGhpcy5wYXJlbnQgOiB0aGlzKS4kcm9vdC4kb3B0aW9ucy5zaGFkb3dSb290XG4gICAgICAgIClcbiAgICAgIH1cbiAgICAgIDogaW5qZWN0U3R5bGVzXG4gIH1cblxuICBpZiAoaG9vaykge1xuICAgIGlmIChvcHRpb25zLmZ1bmN0aW9uYWwpIHtcbiAgICAgIC8vIGZvciB0ZW1wbGF0ZS1vbmx5IGhvdC1yZWxvYWQgYmVjYXVzZSBpbiB0aGF0IGNhc2UgdGhlIHJlbmRlciBmbiBkb2Vzbid0XG4gICAgICAvLyBnbyB0aHJvdWdoIHRoZSBub3JtYWxpemVyXG4gICAgICBvcHRpb25zLl9pbmplY3RTdHlsZXMgPSBob29rXG4gICAgICAvLyByZWdpc3RlciBmb3IgZnVuY3Rpb25hbCBjb21wb25lbnQgaW4gdnVlIGZpbGVcbiAgICAgIHZhciBvcmlnaW5hbFJlbmRlciA9IG9wdGlvbnMucmVuZGVyXG4gICAgICBvcHRpb25zLnJlbmRlciA9IGZ1bmN0aW9uIHJlbmRlcldpdGhTdHlsZUluamVjdGlvbiAoaCwgY29udGV4dCkge1xuICAgICAgICBob29rLmNhbGwoY29udGV4dClcbiAgICAgICAgcmV0dXJuIG9yaWdpbmFsUmVuZGVyKGgsIGNvbnRleHQpXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGluamVjdCBjb21wb25lbnQgcmVnaXN0cmF0aW9uIGFzIGJlZm9yZUNyZWF0ZSBob29rXG4gICAgICB2YXIgZXhpc3RpbmcgPSBvcHRpb25zLmJlZm9yZUNyZWF0ZVxuICAgICAgb3B0aW9ucy5iZWZvcmVDcmVhdGUgPSBleGlzdGluZ1xuICAgICAgICA/IFtdLmNvbmNhdChleGlzdGluZywgaG9vaylcbiAgICAgICAgOiBbaG9va11cbiAgICB9XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGV4cG9ydHM6IHNjcmlwdEV4cG9ydHMsXG4gICAgb3B0aW9uczogb3B0aW9uc1xuICB9XG59XG4iLCIvKiFcbiAqIFZ1ZS5qcyB2Mi42LjE0XG4gKiAoYykgMjAxNC0yMDIxIEV2YW4gWW91XG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG4gKi9cbi8qICAqL1xuXG52YXIgZW1wdHlPYmplY3QgPSBPYmplY3QuZnJlZXplKHt9KTtcblxuLy8gVGhlc2UgaGVscGVycyBwcm9kdWNlIGJldHRlciBWTSBjb2RlIGluIEpTIGVuZ2luZXMgZHVlIHRvIHRoZWlyXG4vLyBleHBsaWNpdG5lc3MgYW5kIGZ1bmN0aW9uIGlubGluaW5nLlxuZnVuY3Rpb24gaXNVbmRlZiAodikge1xuICByZXR1cm4gdiA9PT0gdW5kZWZpbmVkIHx8IHYgPT09IG51bGxcbn1cblxuZnVuY3Rpb24gaXNEZWYgKHYpIHtcbiAgcmV0dXJuIHYgIT09IHVuZGVmaW5lZCAmJiB2ICE9PSBudWxsXG59XG5cbmZ1bmN0aW9uIGlzVHJ1ZSAodikge1xuICByZXR1cm4gdiA9PT0gdHJ1ZVxufVxuXG5mdW5jdGlvbiBpc0ZhbHNlICh2KSB7XG4gIHJldHVybiB2ID09PSBmYWxzZVxufVxuXG4vKipcbiAqIENoZWNrIGlmIHZhbHVlIGlzIHByaW1pdGl2ZS5cbiAqL1xuZnVuY3Rpb24gaXNQcmltaXRpdmUgKHZhbHVlKSB7XG4gIHJldHVybiAoXG4gICAgdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyB8fFxuICAgIHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgfHxcbiAgICAvLyAkZmxvdy1kaXNhYmxlLWxpbmVcbiAgICB0eXBlb2YgdmFsdWUgPT09ICdzeW1ib2wnIHx8XG4gICAgdHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbidcbiAgKVxufVxuXG4vKipcbiAqIFF1aWNrIG9iamVjdCBjaGVjayAtIHRoaXMgaXMgcHJpbWFyaWx5IHVzZWQgdG8gdGVsbFxuICogT2JqZWN0cyBmcm9tIHByaW1pdGl2ZSB2YWx1ZXMgd2hlbiB3ZSBrbm93IHRoZSB2YWx1ZVxuICogaXMgYSBKU09OLWNvbXBsaWFudCB0eXBlLlxuICovXG5mdW5jdGlvbiBpc09iamVjdCAob2JqKSB7XG4gIHJldHVybiBvYmogIT09IG51bGwgJiYgdHlwZW9mIG9iaiA9PT0gJ29iamVjdCdcbn1cblxuLyoqXG4gKiBHZXQgdGhlIHJhdyB0eXBlIHN0cmluZyBvZiBhIHZhbHVlLCBlLmcuLCBbb2JqZWN0IE9iamVjdF0uXG4gKi9cbnZhciBfdG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xuXG5mdW5jdGlvbiB0b1Jhd1R5cGUgKHZhbHVlKSB7XG4gIHJldHVybiBfdG9TdHJpbmcuY2FsbCh2YWx1ZSkuc2xpY2UoOCwgLTEpXG59XG5cbi8qKlxuICogU3RyaWN0IG9iamVjdCB0eXBlIGNoZWNrLiBPbmx5IHJldHVybnMgdHJ1ZVxuICogZm9yIHBsYWluIEphdmFTY3JpcHQgb2JqZWN0cy5cbiAqL1xuZnVuY3Rpb24gaXNQbGFpbk9iamVjdCAob2JqKSB7XG4gIHJldHVybiBfdG9TdHJpbmcuY2FsbChvYmopID09PSAnW29iamVjdCBPYmplY3RdJ1xufVxuXG5mdW5jdGlvbiBpc1JlZ0V4cCAodikge1xuICByZXR1cm4gX3RvU3RyaW5nLmNhbGwodikgPT09ICdbb2JqZWN0IFJlZ0V4cF0nXG59XG5cbi8qKlxuICogQ2hlY2sgaWYgdmFsIGlzIGEgdmFsaWQgYXJyYXkgaW5kZXguXG4gKi9cbmZ1bmN0aW9uIGlzVmFsaWRBcnJheUluZGV4ICh2YWwpIHtcbiAgdmFyIG4gPSBwYXJzZUZsb2F0KFN0cmluZyh2YWwpKTtcbiAgcmV0dXJuIG4gPj0gMCAmJiBNYXRoLmZsb29yKG4pID09PSBuICYmIGlzRmluaXRlKHZhbClcbn1cblxuZnVuY3Rpb24gaXNQcm9taXNlICh2YWwpIHtcbiAgcmV0dXJuIChcbiAgICBpc0RlZih2YWwpICYmXG4gICAgdHlwZW9mIHZhbC50aGVuID09PSAnZnVuY3Rpb24nICYmXG4gICAgdHlwZW9mIHZhbC5jYXRjaCA9PT0gJ2Z1bmN0aW9uJ1xuICApXG59XG5cbi8qKlxuICogQ29udmVydCBhIHZhbHVlIHRvIGEgc3RyaW5nIHRoYXQgaXMgYWN0dWFsbHkgcmVuZGVyZWQuXG4gKi9cbmZ1bmN0aW9uIHRvU3RyaW5nICh2YWwpIHtcbiAgcmV0dXJuIHZhbCA9PSBudWxsXG4gICAgPyAnJ1xuICAgIDogQXJyYXkuaXNBcnJheSh2YWwpIHx8IChpc1BsYWluT2JqZWN0KHZhbCkgJiYgdmFsLnRvU3RyaW5nID09PSBfdG9TdHJpbmcpXG4gICAgICA/IEpTT04uc3RyaW5naWZ5KHZhbCwgbnVsbCwgMilcbiAgICAgIDogU3RyaW5nKHZhbClcbn1cblxuLyoqXG4gKiBDb252ZXJ0IGFuIGlucHV0IHZhbHVlIHRvIGEgbnVtYmVyIGZvciBwZXJzaXN0ZW5jZS5cbiAqIElmIHRoZSBjb252ZXJzaW9uIGZhaWxzLCByZXR1cm4gb3JpZ2luYWwgc3RyaW5nLlxuICovXG5mdW5jdGlvbiB0b051bWJlciAodmFsKSB7XG4gIHZhciBuID0gcGFyc2VGbG9hdCh2YWwpO1xuICByZXR1cm4gaXNOYU4obikgPyB2YWwgOiBuXG59XG5cbi8qKlxuICogTWFrZSBhIG1hcCBhbmQgcmV0dXJuIGEgZnVuY3Rpb24gZm9yIGNoZWNraW5nIGlmIGEga2V5XG4gKiBpcyBpbiB0aGF0IG1hcC5cbiAqL1xuZnVuY3Rpb24gbWFrZU1hcCAoXG4gIHN0cixcbiAgZXhwZWN0c0xvd2VyQ2FzZVxuKSB7XG4gIHZhciBtYXAgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICB2YXIgbGlzdCA9IHN0ci5zcGxpdCgnLCcpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICBtYXBbbGlzdFtpXV0gPSB0cnVlO1xuICB9XG4gIHJldHVybiBleHBlY3RzTG93ZXJDYXNlXG4gICAgPyBmdW5jdGlvbiAodmFsKSB7IHJldHVybiBtYXBbdmFsLnRvTG93ZXJDYXNlKCldOyB9XG4gICAgOiBmdW5jdGlvbiAodmFsKSB7IHJldHVybiBtYXBbdmFsXTsgfVxufVxuXG4vKipcbiAqIENoZWNrIGlmIGEgdGFnIGlzIGEgYnVpbHQtaW4gdGFnLlxuICovXG52YXIgaXNCdWlsdEluVGFnID0gbWFrZU1hcCgnc2xvdCxjb21wb25lbnQnLCB0cnVlKTtcblxuLyoqXG4gKiBDaGVjayBpZiBhbiBhdHRyaWJ1dGUgaXMgYSByZXNlcnZlZCBhdHRyaWJ1dGUuXG4gKi9cbnZhciBpc1Jlc2VydmVkQXR0cmlidXRlID0gbWFrZU1hcCgna2V5LHJlZixzbG90LHNsb3Qtc2NvcGUsaXMnKTtcblxuLyoqXG4gKiBSZW1vdmUgYW4gaXRlbSBmcm9tIGFuIGFycmF5LlxuICovXG5mdW5jdGlvbiByZW1vdmUgKGFyciwgaXRlbSkge1xuICBpZiAoYXJyLmxlbmd0aCkge1xuICAgIHZhciBpbmRleCA9IGFyci5pbmRleE9mKGl0ZW0pO1xuICAgIGlmIChpbmRleCA+IC0xKSB7XG4gICAgICByZXR1cm4gYXJyLnNwbGljZShpbmRleCwgMSlcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBDaGVjayB3aGV0aGVyIGFuIG9iamVjdCBoYXMgdGhlIHByb3BlcnR5LlxuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuZnVuY3Rpb24gaGFzT3duIChvYmosIGtleSkge1xuICByZXR1cm4gaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSlcbn1cblxuLyoqXG4gKiBDcmVhdGUgYSBjYWNoZWQgdmVyc2lvbiBvZiBhIHB1cmUgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGNhY2hlZCAoZm4pIHtcbiAgdmFyIGNhY2hlID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgcmV0dXJuIChmdW5jdGlvbiBjYWNoZWRGbiAoc3RyKSB7XG4gICAgdmFyIGhpdCA9IGNhY2hlW3N0cl07XG4gICAgcmV0dXJuIGhpdCB8fCAoY2FjaGVbc3RyXSA9IGZuKHN0cikpXG4gIH0pXG59XG5cbi8qKlxuICogQ2FtZWxpemUgYSBoeXBoZW4tZGVsaW1pdGVkIHN0cmluZy5cbiAqL1xudmFyIGNhbWVsaXplUkUgPSAvLShcXHcpL2c7XG52YXIgY2FtZWxpemUgPSBjYWNoZWQoZnVuY3Rpb24gKHN0cikge1xuICByZXR1cm4gc3RyLnJlcGxhY2UoY2FtZWxpemVSRSwgZnVuY3Rpb24gKF8sIGMpIHsgcmV0dXJuIGMgPyBjLnRvVXBwZXJDYXNlKCkgOiAnJzsgfSlcbn0pO1xuXG4vKipcbiAqIENhcGl0YWxpemUgYSBzdHJpbmcuXG4gKi9cbnZhciBjYXBpdGFsaXplID0gY2FjaGVkKGZ1bmN0aW9uIChzdHIpIHtcbiAgcmV0dXJuIHN0ci5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHN0ci5zbGljZSgxKVxufSk7XG5cbi8qKlxuICogSHlwaGVuYXRlIGEgY2FtZWxDYXNlIHN0cmluZy5cbiAqL1xudmFyIGh5cGhlbmF0ZVJFID0gL1xcQihbQS1aXSkvZztcbnZhciBoeXBoZW5hdGUgPSBjYWNoZWQoZnVuY3Rpb24gKHN0cikge1xuICByZXR1cm4gc3RyLnJlcGxhY2UoaHlwaGVuYXRlUkUsICctJDEnKS50b0xvd2VyQ2FzZSgpXG59KTtcblxuLyoqXG4gKiBTaW1wbGUgYmluZCBwb2x5ZmlsbCBmb3IgZW52aXJvbm1lbnRzIHRoYXQgZG8gbm90IHN1cHBvcnQgaXQsXG4gKiBlLmcuLCBQaGFudG9tSlMgMS54LiBUZWNobmljYWxseSwgd2UgZG9uJ3QgbmVlZCB0aGlzIGFueW1vcmVcbiAqIHNpbmNlIG5hdGl2ZSBiaW5kIGlzIG5vdyBwZXJmb3JtYW50IGVub3VnaCBpbiBtb3N0IGJyb3dzZXJzLlxuICogQnV0IHJlbW92aW5nIGl0IHdvdWxkIG1lYW4gYnJlYWtpbmcgY29kZSB0aGF0IHdhcyBhYmxlIHRvIHJ1biBpblxuICogUGhhbnRvbUpTIDEueCwgc28gdGhpcyBtdXN0IGJlIGtlcHQgZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHkuXG4gKi9cblxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbmZ1bmN0aW9uIHBvbHlmaWxsQmluZCAoZm4sIGN0eCkge1xuICBmdW5jdGlvbiBib3VuZEZuIChhKSB7XG4gICAgdmFyIGwgPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIHJldHVybiBsXG4gICAgICA/IGwgPiAxXG4gICAgICAgID8gZm4uYXBwbHkoY3R4LCBhcmd1bWVudHMpXG4gICAgICAgIDogZm4uY2FsbChjdHgsIGEpXG4gICAgICA6IGZuLmNhbGwoY3R4KVxuICB9XG5cbiAgYm91bmRGbi5fbGVuZ3RoID0gZm4ubGVuZ3RoO1xuICByZXR1cm4gYm91bmRGblxufVxuXG5mdW5jdGlvbiBuYXRpdmVCaW5kIChmbiwgY3R4KSB7XG4gIHJldHVybiBmbi5iaW5kKGN0eClcbn1cblxudmFyIGJpbmQgPSBGdW5jdGlvbi5wcm90b3R5cGUuYmluZFxuICA/IG5hdGl2ZUJpbmRcbiAgOiBwb2x5ZmlsbEJpbmQ7XG5cbi8qKlxuICogQ29udmVydCBhbiBBcnJheS1saWtlIG9iamVjdCB0byBhIHJlYWwgQXJyYXkuXG4gKi9cbmZ1bmN0aW9uIHRvQXJyYXkgKGxpc3QsIHN0YXJ0KSB7XG4gIHN0YXJ0ID0gc3RhcnQgfHwgMDtcbiAgdmFyIGkgPSBsaXN0Lmxlbmd0aCAtIHN0YXJ0O1xuICB2YXIgcmV0ID0gbmV3IEFycmF5KGkpO1xuICB3aGlsZSAoaS0tKSB7XG4gICAgcmV0W2ldID0gbGlzdFtpICsgc3RhcnRdO1xuICB9XG4gIHJldHVybiByZXRcbn1cblxuLyoqXG4gKiBNaXggcHJvcGVydGllcyBpbnRvIHRhcmdldCBvYmplY3QuXG4gKi9cbmZ1bmN0aW9uIGV4dGVuZCAodG8sIF9mcm9tKSB7XG4gIGZvciAodmFyIGtleSBpbiBfZnJvbSkge1xuICAgIHRvW2tleV0gPSBfZnJvbVtrZXldO1xuICB9XG4gIHJldHVybiB0b1xufVxuXG4vKipcbiAqIE1lcmdlIGFuIEFycmF5IG9mIE9iamVjdHMgaW50byBhIHNpbmdsZSBPYmplY3QuXG4gKi9cbmZ1bmN0aW9uIHRvT2JqZWN0IChhcnIpIHtcbiAgdmFyIHJlcyA9IHt9O1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xuICAgIGlmIChhcnJbaV0pIHtcbiAgICAgIGV4dGVuZChyZXMsIGFycltpXSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuLyogZXNsaW50LWRpc2FibGUgbm8tdW51c2VkLXZhcnMgKi9cblxuLyoqXG4gKiBQZXJmb3JtIG5vIG9wZXJhdGlvbi5cbiAqIFN0dWJiaW5nIGFyZ3MgdG8gbWFrZSBGbG93IGhhcHB5IHdpdGhvdXQgbGVhdmluZyB1c2VsZXNzIHRyYW5zcGlsZWQgY29kZVxuICogd2l0aCAuLi5yZXN0IChodHRwczovL2Zsb3cub3JnL2Jsb2cvMjAxNy8wNS8wNy9TdHJpY3QtRnVuY3Rpb24tQ2FsbC1Bcml0eS8pLlxuICovXG5mdW5jdGlvbiBub29wIChhLCBiLCBjKSB7fVxuXG4vKipcbiAqIEFsd2F5cyByZXR1cm4gZmFsc2UuXG4gKi9cbnZhciBubyA9IGZ1bmN0aW9uIChhLCBiLCBjKSB7IHJldHVybiBmYWxzZTsgfTtcblxuLyogZXNsaW50LWVuYWJsZSBuby11bnVzZWQtdmFycyAqL1xuXG4vKipcbiAqIFJldHVybiB0aGUgc2FtZSB2YWx1ZS5cbiAqL1xudmFyIGlkZW50aXR5ID0gZnVuY3Rpb24gKF8pIHsgcmV0dXJuIF87IH07XG5cbi8qKlxuICogQ2hlY2sgaWYgdHdvIHZhbHVlcyBhcmUgbG9vc2VseSBlcXVhbCAtIHRoYXQgaXMsXG4gKiBpZiB0aGV5IGFyZSBwbGFpbiBvYmplY3RzLCBkbyB0aGV5IGhhdmUgdGhlIHNhbWUgc2hhcGU/XG4gKi9cbmZ1bmN0aW9uIGxvb3NlRXF1YWwgKGEsIGIpIHtcbiAgaWYgKGEgPT09IGIpIHsgcmV0dXJuIHRydWUgfVxuICB2YXIgaXNPYmplY3RBID0gaXNPYmplY3QoYSk7XG4gIHZhciBpc09iamVjdEIgPSBpc09iamVjdChiKTtcbiAgaWYgKGlzT2JqZWN0QSAmJiBpc09iamVjdEIpIHtcbiAgICB0cnkge1xuICAgICAgdmFyIGlzQXJyYXlBID0gQXJyYXkuaXNBcnJheShhKTtcbiAgICAgIHZhciBpc0FycmF5QiA9IEFycmF5LmlzQXJyYXkoYik7XG4gICAgICBpZiAoaXNBcnJheUEgJiYgaXNBcnJheUIpIHtcbiAgICAgICAgcmV0dXJuIGEubGVuZ3RoID09PSBiLmxlbmd0aCAmJiBhLmV2ZXJ5KGZ1bmN0aW9uIChlLCBpKSB7XG4gICAgICAgICAgcmV0dXJuIGxvb3NlRXF1YWwoZSwgYltpXSlcbiAgICAgICAgfSlcbiAgICAgIH0gZWxzZSBpZiAoYSBpbnN0YW5jZW9mIERhdGUgJiYgYiBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICAgICAgcmV0dXJuIGEuZ2V0VGltZSgpID09PSBiLmdldFRpbWUoKVxuICAgICAgfSBlbHNlIGlmICghaXNBcnJheUEgJiYgIWlzQXJyYXlCKSB7XG4gICAgICAgIHZhciBrZXlzQSA9IE9iamVjdC5rZXlzKGEpO1xuICAgICAgICB2YXIga2V5c0IgPSBPYmplY3Qua2V5cyhiKTtcbiAgICAgICAgcmV0dXJuIGtleXNBLmxlbmd0aCA9PT0ga2V5c0IubGVuZ3RoICYmIGtleXNBLmV2ZXJ5KGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICByZXR1cm4gbG9vc2VFcXVhbChhW2tleV0sIGJba2V5XSlcbiAgICAgICAgfSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG4gIH0gZWxzZSBpZiAoIWlzT2JqZWN0QSAmJiAhaXNPYmplY3RCKSB7XG4gICAgcmV0dXJuIFN0cmluZyhhKSA9PT0gU3RyaW5nKGIpXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbn1cblxuLyoqXG4gKiBSZXR1cm4gdGhlIGZpcnN0IGluZGV4IGF0IHdoaWNoIGEgbG9vc2VseSBlcXVhbCB2YWx1ZSBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBhcnJheSAoaWYgdmFsdWUgaXMgYSBwbGFpbiBvYmplY3QsIHRoZSBhcnJheSBtdXN0XG4gKiBjb250YWluIGFuIG9iamVjdCBvZiB0aGUgc2FtZSBzaGFwZSksIG9yIC0xIGlmIGl0IGlzIG5vdCBwcmVzZW50LlxuICovXG5mdW5jdGlvbiBsb29zZUluZGV4T2YgKGFyciwgdmFsKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKGxvb3NlRXF1YWwoYXJyW2ldLCB2YWwpKSB7IHJldHVybiBpIH1cbiAgfVxuICByZXR1cm4gLTFcbn1cblxuLyoqXG4gKiBFbnN1cmUgYSBmdW5jdGlvbiBpcyBjYWxsZWQgb25seSBvbmNlLlxuICovXG5mdW5jdGlvbiBvbmNlIChmbikge1xuICB2YXIgY2FsbGVkID0gZmFsc2U7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCFjYWxsZWQpIHtcbiAgICAgIGNhbGxlZCA9IHRydWU7XG4gICAgICBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgfVxufVxuXG52YXIgU1NSX0FUVFIgPSAnZGF0YS1zZXJ2ZXItcmVuZGVyZWQnO1xuXG52YXIgQVNTRVRfVFlQRVMgPSBbXG4gICdjb21wb25lbnQnLFxuICAnZGlyZWN0aXZlJyxcbiAgJ2ZpbHRlcidcbl07XG5cbnZhciBMSUZFQ1lDTEVfSE9PS1MgPSBbXG4gICdiZWZvcmVDcmVhdGUnLFxuICAnY3JlYXRlZCcsXG4gICdiZWZvcmVNb3VudCcsXG4gICdtb3VudGVkJyxcbiAgJ2JlZm9yZVVwZGF0ZScsXG4gICd1cGRhdGVkJyxcbiAgJ2JlZm9yZURlc3Ryb3knLFxuICAnZGVzdHJveWVkJyxcbiAgJ2FjdGl2YXRlZCcsXG4gICdkZWFjdGl2YXRlZCcsXG4gICdlcnJvckNhcHR1cmVkJyxcbiAgJ3NlcnZlclByZWZldGNoJ1xuXTtcblxuLyogICovXG5cblxuXG52YXIgY29uZmlnID0gKHtcbiAgLyoqXG4gICAqIE9wdGlvbiBtZXJnZSBzdHJhdGVnaWVzICh1c2VkIGluIGNvcmUvdXRpbC9vcHRpb25zKVxuICAgKi9cbiAgLy8gJGZsb3ctZGlzYWJsZS1saW5lXG4gIG9wdGlvbk1lcmdlU3RyYXRlZ2llczogT2JqZWN0LmNyZWF0ZShudWxsKSxcblxuICAvKipcbiAgICogV2hldGhlciB0byBzdXBwcmVzcyB3YXJuaW5ncy5cbiAgICovXG4gIHNpbGVudDogZmFsc2UsXG5cbiAgLyoqXG4gICAqIFNob3cgcHJvZHVjdGlvbiBtb2RlIHRpcCBtZXNzYWdlIG9uIGJvb3Q/XG4gICAqL1xuICBwcm9kdWN0aW9uVGlwOiBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nLFxuXG4gIC8qKlxuICAgKiBXaGV0aGVyIHRvIGVuYWJsZSBkZXZ0b29sc1xuICAgKi9cbiAgZGV2dG9vbHM6IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicsXG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgdG8gcmVjb3JkIHBlcmZcbiAgICovXG4gIHBlcmZvcm1hbmNlOiBmYWxzZSxcblxuICAvKipcbiAgICogRXJyb3IgaGFuZGxlciBmb3Igd2F0Y2hlciBlcnJvcnNcbiAgICovXG4gIGVycm9ySGFuZGxlcjogbnVsbCxcblxuICAvKipcbiAgICogV2FybiBoYW5kbGVyIGZvciB3YXRjaGVyIHdhcm5zXG4gICAqL1xuICB3YXJuSGFuZGxlcjogbnVsbCxcblxuICAvKipcbiAgICogSWdub3JlIGNlcnRhaW4gY3VzdG9tIGVsZW1lbnRzXG4gICAqL1xuICBpZ25vcmVkRWxlbWVudHM6IFtdLFxuXG4gIC8qKlxuICAgKiBDdXN0b20gdXNlciBrZXkgYWxpYXNlcyBmb3Igdi1vblxuICAgKi9cbiAgLy8gJGZsb3ctZGlzYWJsZS1saW5lXG4gIGtleUNvZGVzOiBPYmplY3QuY3JlYXRlKG51bGwpLFxuXG4gIC8qKlxuICAgKiBDaGVjayBpZiBhIHRhZyBpcyByZXNlcnZlZCBzbyB0aGF0IGl0IGNhbm5vdCBiZSByZWdpc3RlcmVkIGFzIGFcbiAgICogY29tcG9uZW50LiBUaGlzIGlzIHBsYXRmb3JtLWRlcGVuZGVudCBhbmQgbWF5IGJlIG92ZXJ3cml0dGVuLlxuICAgKi9cbiAgaXNSZXNlcnZlZFRhZzogbm8sXG5cbiAgLyoqXG4gICAqIENoZWNrIGlmIGFuIGF0dHJpYnV0ZSBpcyByZXNlcnZlZCBzbyB0aGF0IGl0IGNhbm5vdCBiZSB1c2VkIGFzIGEgY29tcG9uZW50XG4gICAqIHByb3AuIFRoaXMgaXMgcGxhdGZvcm0tZGVwZW5kZW50IGFuZCBtYXkgYmUgb3ZlcndyaXR0ZW4uXG4gICAqL1xuICBpc1Jlc2VydmVkQXR0cjogbm8sXG5cbiAgLyoqXG4gICAqIENoZWNrIGlmIGEgdGFnIGlzIGFuIHVua25vd24gZWxlbWVudC5cbiAgICogUGxhdGZvcm0tZGVwZW5kZW50LlxuICAgKi9cbiAgaXNVbmtub3duRWxlbWVudDogbm8sXG5cbiAgLyoqXG4gICAqIEdldCB0aGUgbmFtZXNwYWNlIG9mIGFuIGVsZW1lbnRcbiAgICovXG4gIGdldFRhZ05hbWVzcGFjZTogbm9vcCxcblxuICAvKipcbiAgICogUGFyc2UgdGhlIHJlYWwgdGFnIG5hbWUgZm9yIHRoZSBzcGVjaWZpYyBwbGF0Zm9ybS5cbiAgICovXG4gIHBhcnNlUGxhdGZvcm1UYWdOYW1lOiBpZGVudGl0eSxcblxuICAvKipcbiAgICogQ2hlY2sgaWYgYW4gYXR0cmlidXRlIG11c3QgYmUgYm91bmQgdXNpbmcgcHJvcGVydHksIGUuZy4gdmFsdWVcbiAgICogUGxhdGZvcm0tZGVwZW5kZW50LlxuICAgKi9cbiAgbXVzdFVzZVByb3A6IG5vLFxuXG4gIC8qKlxuICAgKiBQZXJmb3JtIHVwZGF0ZXMgYXN5bmNocm9ub3VzbHkuIEludGVuZGVkIHRvIGJlIHVzZWQgYnkgVnVlIFRlc3QgVXRpbHNcbiAgICogVGhpcyB3aWxsIHNpZ25pZmljYW50bHkgcmVkdWNlIHBlcmZvcm1hbmNlIGlmIHNldCB0byBmYWxzZS5cbiAgICovXG4gIGFzeW5jOiB0cnVlLFxuXG4gIC8qKlxuICAgKiBFeHBvc2VkIGZvciBsZWdhY3kgcmVhc29uc1xuICAgKi9cbiAgX2xpZmVjeWNsZUhvb2tzOiBMSUZFQ1lDTEVfSE9PS1Ncbn0pO1xuXG4vKiAgKi9cblxuLyoqXG4gKiB1bmljb2RlIGxldHRlcnMgdXNlZCBmb3IgcGFyc2luZyBodG1sIHRhZ3MsIGNvbXBvbmVudCBuYW1lcyBhbmQgcHJvcGVydHkgcGF0aHMuXG4gKiB1c2luZyBodHRwczovL3d3dy53My5vcmcvVFIvaHRtbDUzL3NlbWFudGljcy1zY3JpcHRpbmcuaHRtbCNwb3RlbnRpYWxjdXN0b21lbGVtZW50bmFtZVxuICogc2tpcHBpbmcgXFx1MTAwMDAtXFx1RUZGRkYgZHVlIHRvIGl0IGZyZWV6aW5nIHVwIFBoYW50b21KU1xuICovXG52YXIgdW5pY29kZVJlZ0V4cCA9IC9hLXpBLVpcXHUwMEI3XFx1MDBDMC1cXHUwMEQ2XFx1MDBEOC1cXHUwMEY2XFx1MDBGOC1cXHUwMzdEXFx1MDM3Ri1cXHUxRkZGXFx1MjAwQy1cXHUyMDBEXFx1MjAzRi1cXHUyMDQwXFx1MjA3MC1cXHUyMThGXFx1MkMwMC1cXHUyRkVGXFx1MzAwMS1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRkZELztcblxuLyoqXG4gKiBDaGVjayBpZiBhIHN0cmluZyBzdGFydHMgd2l0aCAkIG9yIF9cbiAqL1xuZnVuY3Rpb24gaXNSZXNlcnZlZCAoc3RyKSB7XG4gIHZhciBjID0gKHN0ciArICcnKS5jaGFyQ29kZUF0KDApO1xuICByZXR1cm4gYyA9PT0gMHgyNCB8fCBjID09PSAweDVGXG59XG5cbi8qKlxuICogRGVmaW5lIGEgcHJvcGVydHkuXG4gKi9cbmZ1bmN0aW9uIGRlZiAob2JqLCBrZXksIHZhbCwgZW51bWVyYWJsZSkge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHtcbiAgICB2YWx1ZTogdmFsLFxuICAgIGVudW1lcmFibGU6ICEhZW51bWVyYWJsZSxcbiAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG59XG5cbi8qKlxuICogUGFyc2Ugc2ltcGxlIHBhdGguXG4gKi9cbnZhciBiYWlsUkUgPSBuZXcgUmVnRXhwKChcIlteXCIgKyAodW5pY29kZVJlZ0V4cC5zb3VyY2UpICsgXCIuJF9cXFxcZF1cIikpO1xuZnVuY3Rpb24gcGFyc2VQYXRoIChwYXRoKSB7XG4gIGlmIChiYWlsUkUudGVzdChwYXRoKSkge1xuICAgIHJldHVyblxuICB9XG4gIHZhciBzZWdtZW50cyA9IHBhdGguc3BsaXQoJy4nKTtcbiAgcmV0dXJuIGZ1bmN0aW9uIChvYmopIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNlZ21lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoIW9iaikgeyByZXR1cm4gfVxuICAgICAgb2JqID0gb2JqW3NlZ21lbnRzW2ldXTtcbiAgICB9XG4gICAgcmV0dXJuIG9ialxuICB9XG59XG5cbi8qICAqL1xuXG4vLyBjYW4gd2UgdXNlIF9fcHJvdG9fXz9cbnZhciBoYXNQcm90byA9ICdfX3Byb3RvX18nIGluIHt9O1xuXG4vLyBCcm93c2VyIGVudmlyb25tZW50IHNuaWZmaW5nXG52YXIgaW5Ccm93c2VyID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCc7XG52YXIgaW5XZWV4ID0gdHlwZW9mIFdYRW52aXJvbm1lbnQgIT09ICd1bmRlZmluZWQnICYmICEhV1hFbnZpcm9ubWVudC5wbGF0Zm9ybTtcbnZhciB3ZWV4UGxhdGZvcm0gPSBpbldlZXggJiYgV1hFbnZpcm9ubWVudC5wbGF0Zm9ybS50b0xvd2VyQ2FzZSgpO1xudmFyIFVBID0gaW5Ccm93c2VyICYmIHdpbmRvdy5uYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCk7XG52YXIgaXNJRSA9IFVBICYmIC9tc2llfHRyaWRlbnQvLnRlc3QoVUEpO1xudmFyIGlzSUU5ID0gVUEgJiYgVUEuaW5kZXhPZignbXNpZSA5LjAnKSA+IDA7XG52YXIgaXNFZGdlID0gVUEgJiYgVUEuaW5kZXhPZignZWRnZS8nKSA+IDA7XG52YXIgaXNBbmRyb2lkID0gKFVBICYmIFVBLmluZGV4T2YoJ2FuZHJvaWQnKSA+IDApIHx8ICh3ZWV4UGxhdGZvcm0gPT09ICdhbmRyb2lkJyk7XG52YXIgaXNJT1MgPSAoVUEgJiYgL2lwaG9uZXxpcGFkfGlwb2R8aW9zLy50ZXN0KFVBKSkgfHwgKHdlZXhQbGF0Zm9ybSA9PT0gJ2lvcycpO1xudmFyIGlzQ2hyb21lID0gVUEgJiYgL2Nocm9tZVxcL1xcZCsvLnRlc3QoVUEpICYmICFpc0VkZ2U7XG52YXIgaXNQaGFudG9tSlMgPSBVQSAmJiAvcGhhbnRvbWpzLy50ZXN0KFVBKTtcbnZhciBpc0ZGID0gVUEgJiYgVUEubWF0Y2goL2ZpcmVmb3hcXC8oXFxkKykvKTtcblxuLy8gRmlyZWZveCBoYXMgYSBcIndhdGNoXCIgZnVuY3Rpb24gb24gT2JqZWN0LnByb3RvdHlwZS4uLlxudmFyIG5hdGl2ZVdhdGNoID0gKHt9KS53YXRjaDtcblxudmFyIHN1cHBvcnRzUGFzc2l2ZSA9IGZhbHNlO1xuaWYgKGluQnJvd3Nlcikge1xuICB0cnkge1xuICAgIHZhciBvcHRzID0ge307XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9wdHMsICdwYXNzaXZlJywgKHtcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0ICgpIHtcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgc3VwcG9ydHNQYXNzaXZlID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9KSk7IC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9mbG93L2lzc3Vlcy8yODVcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigndGVzdC1wYXNzaXZlJywgbnVsbCwgb3B0cyk7XG4gIH0gY2F0Y2ggKGUpIHt9XG59XG5cbi8vIHRoaXMgbmVlZHMgdG8gYmUgbGF6eS1ldmFsZWQgYmVjYXVzZSB2dWUgbWF5IGJlIHJlcXVpcmVkIGJlZm9yZVxuLy8gdnVlLXNlcnZlci1yZW5kZXJlciBjYW4gc2V0IFZVRV9FTlZcbnZhciBfaXNTZXJ2ZXI7XG52YXIgaXNTZXJ2ZXJSZW5kZXJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gIGlmIChfaXNTZXJ2ZXIgPT09IHVuZGVmaW5lZCkge1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmICghaW5Ccm93c2VyICYmICFpbldlZXggJiYgdHlwZW9mIGdsb2JhbCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIC8vIGRldGVjdCBwcmVzZW5jZSBvZiB2dWUtc2VydmVyLXJlbmRlcmVyIGFuZCBhdm9pZFxuICAgICAgLy8gV2VicGFjayBzaGltbWluZyB0aGUgcHJvY2Vzc1xuICAgICAgX2lzU2VydmVyID0gZ2xvYmFsWydwcm9jZXNzJ10gJiYgZ2xvYmFsWydwcm9jZXNzJ10uZW52LlZVRV9FTlYgPT09ICdzZXJ2ZXInO1xuICAgIH0gZWxzZSB7XG4gICAgICBfaXNTZXJ2ZXIgPSBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIF9pc1NlcnZlclxufTtcblxuLy8gZGV0ZWN0IGRldnRvb2xzXG52YXIgZGV2dG9vbHMgPSBpbkJyb3dzZXIgJiYgd2luZG93Ll9fVlVFX0RFVlRPT0xTX0dMT0JBTF9IT09LX187XG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5mdW5jdGlvbiBpc05hdGl2ZSAoQ3Rvcikge1xuICByZXR1cm4gdHlwZW9mIEN0b3IgPT09ICdmdW5jdGlvbicgJiYgL25hdGl2ZSBjb2RlLy50ZXN0KEN0b3IudG9TdHJpbmcoKSlcbn1cblxudmFyIGhhc1N5bWJvbCA9XG4gIHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIGlzTmF0aXZlKFN5bWJvbCkgJiZcbiAgdHlwZW9mIFJlZmxlY3QgIT09ICd1bmRlZmluZWQnICYmIGlzTmF0aXZlKFJlZmxlY3Qub3duS2V5cyk7XG5cbnZhciBfU2V0O1xuLyogaXN0YW5idWwgaWdub3JlIGlmICovIC8vICRmbG93LWRpc2FibGUtbGluZVxuaWYgKHR5cGVvZiBTZXQgIT09ICd1bmRlZmluZWQnICYmIGlzTmF0aXZlKFNldCkpIHtcbiAgLy8gdXNlIG5hdGl2ZSBTZXQgd2hlbiBhdmFpbGFibGUuXG4gIF9TZXQgPSBTZXQ7XG59IGVsc2Uge1xuICAvLyBhIG5vbi1zdGFuZGFyZCBTZXQgcG9seWZpbGwgdGhhdCBvbmx5IHdvcmtzIHdpdGggcHJpbWl0aXZlIGtleXMuXG4gIF9TZXQgPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBTZXQgKCkge1xuICAgICAgdGhpcy5zZXQgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIH1cbiAgICBTZXQucHJvdG90eXBlLmhhcyA9IGZ1bmN0aW9uIGhhcyAoa2V5KSB7XG4gICAgICByZXR1cm4gdGhpcy5zZXRba2V5XSA9PT0gdHJ1ZVxuICAgIH07XG4gICAgU2V0LnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiBhZGQgKGtleSkge1xuICAgICAgdGhpcy5zZXRba2V5XSA9IHRydWU7XG4gICAgfTtcbiAgICBTZXQucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24gY2xlYXIgKCkge1xuICAgICAgdGhpcy5zZXQgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIH07XG5cbiAgICByZXR1cm4gU2V0O1xuICB9KCkpO1xufVxuXG4vKiAgKi9cblxudmFyIHdhcm4gPSBub29wO1xudmFyIHRpcCA9IG5vb3A7XG52YXIgZ2VuZXJhdGVDb21wb25lbnRUcmFjZSA9IChub29wKTsgLy8gd29yayBhcm91bmQgZmxvdyBjaGVja1xudmFyIGZvcm1hdENvbXBvbmVudE5hbWUgPSAobm9vcCk7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIHZhciBoYXNDb25zb2xlID0gdHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnO1xuICB2YXIgY2xhc3NpZnlSRSA9IC8oPzpefFstX10pKFxcdykvZztcbiAgdmFyIGNsYXNzaWZ5ID0gZnVuY3Rpb24gKHN0cikgeyByZXR1cm4gc3RyXG4gICAgLnJlcGxhY2UoY2xhc3NpZnlSRSwgZnVuY3Rpb24gKGMpIHsgcmV0dXJuIGMudG9VcHBlckNhc2UoKTsgfSlcbiAgICAucmVwbGFjZSgvWy1fXS9nLCAnJyk7IH07XG5cbiAgd2FybiA9IGZ1bmN0aW9uIChtc2csIHZtKSB7XG4gICAgdmFyIHRyYWNlID0gdm0gPyBnZW5lcmF0ZUNvbXBvbmVudFRyYWNlKHZtKSA6ICcnO1xuXG4gICAgaWYgKGNvbmZpZy53YXJuSGFuZGxlcikge1xuICAgICAgY29uZmlnLndhcm5IYW5kbGVyLmNhbGwobnVsbCwgbXNnLCB2bSwgdHJhY2UpO1xuICAgIH0gZWxzZSBpZiAoaGFzQ29uc29sZSAmJiAoIWNvbmZpZy5zaWxlbnQpKSB7XG4gICAgICBjb25zb2xlLmVycm9yKChcIltWdWUgd2Fybl06IFwiICsgbXNnICsgdHJhY2UpKTtcbiAgICB9XG4gIH07XG5cbiAgdGlwID0gZnVuY3Rpb24gKG1zZywgdm0pIHtcbiAgICBpZiAoaGFzQ29uc29sZSAmJiAoIWNvbmZpZy5zaWxlbnQpKSB7XG4gICAgICBjb25zb2xlLndhcm4oXCJbVnVlIHRpcF06IFwiICsgbXNnICsgKFxuICAgICAgICB2bSA/IGdlbmVyYXRlQ29tcG9uZW50VHJhY2Uodm0pIDogJydcbiAgICAgICkpO1xuICAgIH1cbiAgfTtcblxuICBmb3JtYXRDb21wb25lbnROYW1lID0gZnVuY3Rpb24gKHZtLCBpbmNsdWRlRmlsZSkge1xuICAgIGlmICh2bS4kcm9vdCA9PT0gdm0pIHtcbiAgICAgIHJldHVybiAnPFJvb3Q+J1xuICAgIH1cbiAgICB2YXIgb3B0aW9ucyA9IHR5cGVvZiB2bSA9PT0gJ2Z1bmN0aW9uJyAmJiB2bS5jaWQgIT0gbnVsbFxuICAgICAgPyB2bS5vcHRpb25zXG4gICAgICA6IHZtLl9pc1Z1ZVxuICAgICAgICA/IHZtLiRvcHRpb25zIHx8IHZtLmNvbnN0cnVjdG9yLm9wdGlvbnNcbiAgICAgICAgOiB2bTtcbiAgICB2YXIgbmFtZSA9IG9wdGlvbnMubmFtZSB8fCBvcHRpb25zLl9jb21wb25lbnRUYWc7XG4gICAgdmFyIGZpbGUgPSBvcHRpb25zLl9fZmlsZTtcbiAgICBpZiAoIW5hbWUgJiYgZmlsZSkge1xuICAgICAgdmFyIG1hdGNoID0gZmlsZS5tYXRjaCgvKFteL1xcXFxdKylcXC52dWUkLyk7XG4gICAgICBuYW1lID0gbWF0Y2ggJiYgbWF0Y2hbMV07XG4gICAgfVxuXG4gICAgcmV0dXJuIChcbiAgICAgIChuYW1lID8gKFwiPFwiICsgKGNsYXNzaWZ5KG5hbWUpKSArIFwiPlwiKSA6IFwiPEFub255bW91cz5cIikgK1xuICAgICAgKGZpbGUgJiYgaW5jbHVkZUZpbGUgIT09IGZhbHNlID8gKFwiIGF0IFwiICsgZmlsZSkgOiAnJylcbiAgICApXG4gIH07XG5cbiAgdmFyIHJlcGVhdCA9IGZ1bmN0aW9uIChzdHIsIG4pIHtcbiAgICB2YXIgcmVzID0gJyc7XG4gICAgd2hpbGUgKG4pIHtcbiAgICAgIGlmIChuICUgMiA9PT0gMSkgeyByZXMgKz0gc3RyOyB9XG4gICAgICBpZiAobiA+IDEpIHsgc3RyICs9IHN0cjsgfVxuICAgICAgbiA+Pj0gMTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc1xuICB9O1xuXG4gIGdlbmVyYXRlQ29tcG9uZW50VHJhY2UgPSBmdW5jdGlvbiAodm0pIHtcbiAgICBpZiAodm0uX2lzVnVlICYmIHZtLiRwYXJlbnQpIHtcbiAgICAgIHZhciB0cmVlID0gW107XG4gICAgICB2YXIgY3VycmVudFJlY3Vyc2l2ZVNlcXVlbmNlID0gMDtcbiAgICAgIHdoaWxlICh2bSkge1xuICAgICAgICBpZiAodHJlZS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgdmFyIGxhc3QgPSB0cmVlW3RyZWUubGVuZ3RoIC0gMV07XG4gICAgICAgICAgaWYgKGxhc3QuY29uc3RydWN0b3IgPT09IHZtLmNvbnN0cnVjdG9yKSB7XG4gICAgICAgICAgICBjdXJyZW50UmVjdXJzaXZlU2VxdWVuY2UrKztcbiAgICAgICAgICAgIHZtID0gdm0uJHBhcmVudDtcbiAgICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgICAgfSBlbHNlIGlmIChjdXJyZW50UmVjdXJzaXZlU2VxdWVuY2UgPiAwKSB7XG4gICAgICAgICAgICB0cmVlW3RyZWUubGVuZ3RoIC0gMV0gPSBbbGFzdCwgY3VycmVudFJlY3Vyc2l2ZVNlcXVlbmNlXTtcbiAgICAgICAgICAgIGN1cnJlbnRSZWN1cnNpdmVTZXF1ZW5jZSA9IDA7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRyZWUucHVzaCh2bSk7XG4gICAgICAgIHZtID0gdm0uJHBhcmVudDtcbiAgICAgIH1cbiAgICAgIHJldHVybiAnXFxuXFxuZm91bmQgaW5cXG5cXG4nICsgdHJlZVxuICAgICAgICAubWFwKGZ1bmN0aW9uICh2bSwgaSkgeyByZXR1cm4gKFwiXCIgKyAoaSA9PT0gMCA/ICctLS0+ICcgOiByZXBlYXQoJyAnLCA1ICsgaSAqIDIpKSArIChBcnJheS5pc0FycmF5KHZtKVxuICAgICAgICAgICAgPyAoKGZvcm1hdENvbXBvbmVudE5hbWUodm1bMF0pKSArIFwiLi4uIChcIiArICh2bVsxXSkgKyBcIiByZWN1cnNpdmUgY2FsbHMpXCIpXG4gICAgICAgICAgICA6IGZvcm1hdENvbXBvbmVudE5hbWUodm0pKSk7IH0pXG4gICAgICAgIC5qb2luKCdcXG4nKVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKFwiXFxuXFxuKGZvdW5kIGluIFwiICsgKGZvcm1hdENvbXBvbmVudE5hbWUodm0pKSArIFwiKVwiKVxuICAgIH1cbiAgfTtcbn1cblxuLyogICovXG5cbnZhciB1aWQgPSAwO1xuXG4vKipcbiAqIEEgZGVwIGlzIGFuIG9ic2VydmFibGUgdGhhdCBjYW4gaGF2ZSBtdWx0aXBsZVxuICogZGlyZWN0aXZlcyBzdWJzY3JpYmluZyB0byBpdC5cbiAqL1xudmFyIERlcCA9IGZ1bmN0aW9uIERlcCAoKSB7XG4gIHRoaXMuaWQgPSB1aWQrKztcbiAgdGhpcy5zdWJzID0gW107XG59O1xuXG5EZXAucHJvdG90eXBlLmFkZFN1YiA9IGZ1bmN0aW9uIGFkZFN1YiAoc3ViKSB7XG4gIHRoaXMuc3Vicy5wdXNoKHN1Yik7XG59O1xuXG5EZXAucHJvdG90eXBlLnJlbW92ZVN1YiA9IGZ1bmN0aW9uIHJlbW92ZVN1YiAoc3ViKSB7XG4gIHJlbW92ZSh0aGlzLnN1YnMsIHN1Yik7XG59O1xuXG5EZXAucHJvdG90eXBlLmRlcGVuZCA9IGZ1bmN0aW9uIGRlcGVuZCAoKSB7XG4gIGlmIChEZXAudGFyZ2V0KSB7XG4gICAgRGVwLnRhcmdldC5hZGREZXAodGhpcyk7XG4gIH1cbn07XG5cbkRlcC5wcm90b3R5cGUubm90aWZ5ID0gZnVuY3Rpb24gbm90aWZ5ICgpIHtcbiAgLy8gc3RhYmlsaXplIHRoZSBzdWJzY3JpYmVyIGxpc3QgZmlyc3RcbiAgdmFyIHN1YnMgPSB0aGlzLnN1YnMuc2xpY2UoKTtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgIWNvbmZpZy5hc3luYykge1xuICAgIC8vIHN1YnMgYXJlbid0IHNvcnRlZCBpbiBzY2hlZHVsZXIgaWYgbm90IHJ1bm5pbmcgYXN5bmNcbiAgICAvLyB3ZSBuZWVkIHRvIHNvcnQgdGhlbSBub3cgdG8gbWFrZSBzdXJlIHRoZXkgZmlyZSBpbiBjb3JyZWN0XG4gICAgLy8gb3JkZXJcbiAgICBzdWJzLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHsgcmV0dXJuIGEuaWQgLSBiLmlkOyB9KTtcbiAgfVxuICBmb3IgKHZhciBpID0gMCwgbCA9IHN1YnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgc3Vic1tpXS51cGRhdGUoKTtcbiAgfVxufTtcblxuLy8gVGhlIGN1cnJlbnQgdGFyZ2V0IHdhdGNoZXIgYmVpbmcgZXZhbHVhdGVkLlxuLy8gVGhpcyBpcyBnbG9iYWxseSB1bmlxdWUgYmVjYXVzZSBvbmx5IG9uZSB3YXRjaGVyXG4vLyBjYW4gYmUgZXZhbHVhdGVkIGF0IGEgdGltZS5cbkRlcC50YXJnZXQgPSBudWxsO1xudmFyIHRhcmdldFN0YWNrID0gW107XG5cbmZ1bmN0aW9uIHB1c2hUYXJnZXQgKHRhcmdldCkge1xuICB0YXJnZXRTdGFjay5wdXNoKHRhcmdldCk7XG4gIERlcC50YXJnZXQgPSB0YXJnZXQ7XG59XG5cbmZ1bmN0aW9uIHBvcFRhcmdldCAoKSB7XG4gIHRhcmdldFN0YWNrLnBvcCgpO1xuICBEZXAudGFyZ2V0ID0gdGFyZ2V0U3RhY2tbdGFyZ2V0U3RhY2subGVuZ3RoIC0gMV07XG59XG5cbi8qICAqL1xuXG52YXIgVk5vZGUgPSBmdW5jdGlvbiBWTm9kZSAoXG4gIHRhZyxcbiAgZGF0YSxcbiAgY2hpbGRyZW4sXG4gIHRleHQsXG4gIGVsbSxcbiAgY29udGV4dCxcbiAgY29tcG9uZW50T3B0aW9ucyxcbiAgYXN5bmNGYWN0b3J5XG4pIHtcbiAgdGhpcy50YWcgPSB0YWc7XG4gIHRoaXMuZGF0YSA9IGRhdGE7XG4gIHRoaXMuY2hpbGRyZW4gPSBjaGlsZHJlbjtcbiAgdGhpcy50ZXh0ID0gdGV4dDtcbiAgdGhpcy5lbG0gPSBlbG07XG4gIHRoaXMubnMgPSB1bmRlZmluZWQ7XG4gIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gIHRoaXMuZm5Db250ZXh0ID0gdW5kZWZpbmVkO1xuICB0aGlzLmZuT3B0aW9ucyA9IHVuZGVmaW5lZDtcbiAgdGhpcy5mblNjb3BlSWQgPSB1bmRlZmluZWQ7XG4gIHRoaXMua2V5ID0gZGF0YSAmJiBkYXRhLmtleTtcbiAgdGhpcy5jb21wb25lbnRPcHRpb25zID0gY29tcG9uZW50T3B0aW9ucztcbiAgdGhpcy5jb21wb25lbnRJbnN0YW5jZSA9IHVuZGVmaW5lZDtcbiAgdGhpcy5wYXJlbnQgPSB1bmRlZmluZWQ7XG4gIHRoaXMucmF3ID0gZmFsc2U7XG4gIHRoaXMuaXNTdGF0aWMgPSBmYWxzZTtcbiAgdGhpcy5pc1Jvb3RJbnNlcnQgPSB0cnVlO1xuICB0aGlzLmlzQ29tbWVudCA9IGZhbHNlO1xuICB0aGlzLmlzQ2xvbmVkID0gZmFsc2U7XG4gIHRoaXMuaXNPbmNlID0gZmFsc2U7XG4gIHRoaXMuYXN5bmNGYWN0b3J5ID0gYXN5bmNGYWN0b3J5O1xuICB0aGlzLmFzeW5jTWV0YSA9IHVuZGVmaW5lZDtcbiAgdGhpcy5pc0FzeW5jUGxhY2Vob2xkZXIgPSBmYWxzZTtcbn07XG5cbnZhciBwcm90b3R5cGVBY2Nlc3NvcnMgPSB7IGNoaWxkOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH07XG5cbi8vIERFUFJFQ0FURUQ6IGFsaWFzIGZvciBjb21wb25lbnRJbnN0YW5jZSBmb3IgYmFja3dhcmRzIGNvbXBhdC5cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5wcm90b3R5cGVBY2Nlc3NvcnMuY2hpbGQuZ2V0ID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5jb21wb25lbnRJbnN0YW5jZVxufTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoIFZOb2RlLnByb3RvdHlwZSwgcHJvdG90eXBlQWNjZXNzb3JzICk7XG5cbnZhciBjcmVhdGVFbXB0eVZOb2RlID0gZnVuY3Rpb24gKHRleHQpIHtcbiAgaWYgKCB0ZXh0ID09PSB2b2lkIDAgKSB0ZXh0ID0gJyc7XG5cbiAgdmFyIG5vZGUgPSBuZXcgVk5vZGUoKTtcbiAgbm9kZS50ZXh0ID0gdGV4dDtcbiAgbm9kZS5pc0NvbW1lbnQgPSB0cnVlO1xuICByZXR1cm4gbm9kZVxufTtcblxuZnVuY3Rpb24gY3JlYXRlVGV4dFZOb2RlICh2YWwpIHtcbiAgcmV0dXJuIG5ldyBWTm9kZSh1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBTdHJpbmcodmFsKSlcbn1cblxuLy8gb3B0aW1pemVkIHNoYWxsb3cgY2xvbmVcbi8vIHVzZWQgZm9yIHN0YXRpYyBub2RlcyBhbmQgc2xvdCBub2RlcyBiZWNhdXNlIHRoZXkgbWF5IGJlIHJldXNlZCBhY3Jvc3Ncbi8vIG11bHRpcGxlIHJlbmRlcnMsIGNsb25pbmcgdGhlbSBhdm9pZHMgZXJyb3JzIHdoZW4gRE9NIG1hbmlwdWxhdGlvbnMgcmVseVxuLy8gb24gdGhlaXIgZWxtIHJlZmVyZW5jZS5cbmZ1bmN0aW9uIGNsb25lVk5vZGUgKHZub2RlKSB7XG4gIHZhciBjbG9uZWQgPSBuZXcgVk5vZGUoXG4gICAgdm5vZGUudGFnLFxuICAgIHZub2RlLmRhdGEsXG4gICAgLy8gIzc5NzVcbiAgICAvLyBjbG9uZSBjaGlsZHJlbiBhcnJheSB0byBhdm9pZCBtdXRhdGluZyBvcmlnaW5hbCBpbiBjYXNlIG9mIGNsb25pbmdcbiAgICAvLyBhIGNoaWxkLlxuICAgIHZub2RlLmNoaWxkcmVuICYmIHZub2RlLmNoaWxkcmVuLnNsaWNlKCksXG4gICAgdm5vZGUudGV4dCxcbiAgICB2bm9kZS5lbG0sXG4gICAgdm5vZGUuY29udGV4dCxcbiAgICB2bm9kZS5jb21wb25lbnRPcHRpb25zLFxuICAgIHZub2RlLmFzeW5jRmFjdG9yeVxuICApO1xuICBjbG9uZWQubnMgPSB2bm9kZS5ucztcbiAgY2xvbmVkLmlzU3RhdGljID0gdm5vZGUuaXNTdGF0aWM7XG4gIGNsb25lZC5rZXkgPSB2bm9kZS5rZXk7XG4gIGNsb25lZC5pc0NvbW1lbnQgPSB2bm9kZS5pc0NvbW1lbnQ7XG4gIGNsb25lZC5mbkNvbnRleHQgPSB2bm9kZS5mbkNvbnRleHQ7XG4gIGNsb25lZC5mbk9wdGlvbnMgPSB2bm9kZS5mbk9wdGlvbnM7XG4gIGNsb25lZC5mblNjb3BlSWQgPSB2bm9kZS5mblNjb3BlSWQ7XG4gIGNsb25lZC5hc3luY01ldGEgPSB2bm9kZS5hc3luY01ldGE7XG4gIGNsb25lZC5pc0Nsb25lZCA9IHRydWU7XG4gIHJldHVybiBjbG9uZWRcbn1cblxuLypcbiAqIG5vdCB0eXBlIGNoZWNraW5nIHRoaXMgZmlsZSBiZWNhdXNlIGZsb3cgZG9lc24ndCBwbGF5IHdlbGwgd2l0aFxuICogZHluYW1pY2FsbHkgYWNjZXNzaW5nIG1ldGhvZHMgb24gQXJyYXkgcHJvdG90eXBlXG4gKi9cblxudmFyIGFycmF5UHJvdG8gPSBBcnJheS5wcm90b3R5cGU7XG52YXIgYXJyYXlNZXRob2RzID0gT2JqZWN0LmNyZWF0ZShhcnJheVByb3RvKTtcblxudmFyIG1ldGhvZHNUb1BhdGNoID0gW1xuICAncHVzaCcsXG4gICdwb3AnLFxuICAnc2hpZnQnLFxuICAndW5zaGlmdCcsXG4gICdzcGxpY2UnLFxuICAnc29ydCcsXG4gICdyZXZlcnNlJ1xuXTtcblxuLyoqXG4gKiBJbnRlcmNlcHQgbXV0YXRpbmcgbWV0aG9kcyBhbmQgZW1pdCBldmVudHNcbiAqL1xubWV0aG9kc1RvUGF0Y2guZm9yRWFjaChmdW5jdGlvbiAobWV0aG9kKSB7XG4gIC8vIGNhY2hlIG9yaWdpbmFsIG1ldGhvZFxuICB2YXIgb3JpZ2luYWwgPSBhcnJheVByb3RvW21ldGhvZF07XG4gIGRlZihhcnJheU1ldGhvZHMsIG1ldGhvZCwgZnVuY3Rpb24gbXV0YXRvciAoKSB7XG4gICAgdmFyIGFyZ3MgPSBbXSwgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICB3aGlsZSAoIGxlbi0tICkgYXJnc1sgbGVuIF0gPSBhcmd1bWVudHNbIGxlbiBdO1xuXG4gICAgdmFyIHJlc3VsdCA9IG9yaWdpbmFsLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgIHZhciBvYiA9IHRoaXMuX19vYl9fO1xuICAgIHZhciBpbnNlcnRlZDtcbiAgICBzd2l0Y2ggKG1ldGhvZCkge1xuICAgICAgY2FzZSAncHVzaCc6XG4gICAgICBjYXNlICd1bnNoaWZ0JzpcbiAgICAgICAgaW5zZXJ0ZWQgPSBhcmdzO1xuICAgICAgICBicmVha1xuICAgICAgY2FzZSAnc3BsaWNlJzpcbiAgICAgICAgaW5zZXJ0ZWQgPSBhcmdzLnNsaWNlKDIpO1xuICAgICAgICBicmVha1xuICAgIH1cbiAgICBpZiAoaW5zZXJ0ZWQpIHsgb2Iub2JzZXJ2ZUFycmF5KGluc2VydGVkKTsgfVxuICAgIC8vIG5vdGlmeSBjaGFuZ2VcbiAgICBvYi5kZXAubm90aWZ5KCk7XG4gICAgcmV0dXJuIHJlc3VsdFxuICB9KTtcbn0pO1xuXG4vKiAgKi9cblxudmFyIGFycmF5S2V5cyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKGFycmF5TWV0aG9kcyk7XG5cbi8qKlxuICogSW4gc29tZSBjYXNlcyB3ZSBtYXkgd2FudCB0byBkaXNhYmxlIG9ic2VydmF0aW9uIGluc2lkZSBhIGNvbXBvbmVudCdzXG4gKiB1cGRhdGUgY29tcHV0YXRpb24uXG4gKi9cbnZhciBzaG91bGRPYnNlcnZlID0gdHJ1ZTtcblxuZnVuY3Rpb24gdG9nZ2xlT2JzZXJ2aW5nICh2YWx1ZSkge1xuICBzaG91bGRPYnNlcnZlID0gdmFsdWU7XG59XG5cbi8qKlxuICogT2JzZXJ2ZXIgY2xhc3MgdGhhdCBpcyBhdHRhY2hlZCB0byBlYWNoIG9ic2VydmVkXG4gKiBvYmplY3QuIE9uY2UgYXR0YWNoZWQsIHRoZSBvYnNlcnZlciBjb252ZXJ0cyB0aGUgdGFyZ2V0XG4gKiBvYmplY3QncyBwcm9wZXJ0eSBrZXlzIGludG8gZ2V0dGVyL3NldHRlcnMgdGhhdFxuICogY29sbGVjdCBkZXBlbmRlbmNpZXMgYW5kIGRpc3BhdGNoIHVwZGF0ZXMuXG4gKi9cbnZhciBPYnNlcnZlciA9IGZ1bmN0aW9uIE9ic2VydmVyICh2YWx1ZSkge1xuICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gIHRoaXMuZGVwID0gbmV3IERlcCgpO1xuICB0aGlzLnZtQ291bnQgPSAwO1xuICBkZWYodmFsdWUsICdfX29iX18nLCB0aGlzKTtcbiAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgaWYgKGhhc1Byb3RvKSB7XG4gICAgICBwcm90b0F1Z21lbnQodmFsdWUsIGFycmF5TWV0aG9kcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvcHlBdWdtZW50KHZhbHVlLCBhcnJheU1ldGhvZHMsIGFycmF5S2V5cyk7XG4gICAgfVxuICAgIHRoaXMub2JzZXJ2ZUFycmF5KHZhbHVlKTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLndhbGsodmFsdWUpO1xuICB9XG59O1xuXG4vKipcbiAqIFdhbGsgdGhyb3VnaCBhbGwgcHJvcGVydGllcyBhbmQgY29udmVydCB0aGVtIGludG9cbiAqIGdldHRlci9zZXR0ZXJzLiBUaGlzIG1ldGhvZCBzaG91bGQgb25seSBiZSBjYWxsZWQgd2hlblxuICogdmFsdWUgdHlwZSBpcyBPYmplY3QuXG4gKi9cbk9ic2VydmVyLnByb3RvdHlwZS53YWxrID0gZnVuY3Rpb24gd2FsayAob2JqKSB7XG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgZGVmaW5lUmVhY3RpdmUkJDEob2JqLCBrZXlzW2ldKTtcbiAgfVxufTtcblxuLyoqXG4gKiBPYnNlcnZlIGEgbGlzdCBvZiBBcnJheSBpdGVtcy5cbiAqL1xuT2JzZXJ2ZXIucHJvdG90eXBlLm9ic2VydmVBcnJheSA9IGZ1bmN0aW9uIG9ic2VydmVBcnJheSAoaXRlbXMpIHtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBpdGVtcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBvYnNlcnZlKGl0ZW1zW2ldKTtcbiAgfVxufTtcblxuLy8gaGVscGVyc1xuXG4vKipcbiAqIEF1Z21lbnQgYSB0YXJnZXQgT2JqZWN0IG9yIEFycmF5IGJ5IGludGVyY2VwdGluZ1xuICogdGhlIHByb3RvdHlwZSBjaGFpbiB1c2luZyBfX3Byb3RvX19cbiAqL1xuZnVuY3Rpb24gcHJvdG9BdWdtZW50ICh0YXJnZXQsIHNyYykge1xuICAvKiBlc2xpbnQtZGlzYWJsZSBuby1wcm90byAqL1xuICB0YXJnZXQuX19wcm90b19fID0gc3JjO1xuICAvKiBlc2xpbnQtZW5hYmxlIG5vLXByb3RvICovXG59XG5cbi8qKlxuICogQXVnbWVudCBhIHRhcmdldCBPYmplY3Qgb3IgQXJyYXkgYnkgZGVmaW5pbmdcbiAqIGhpZGRlbiBwcm9wZXJ0aWVzLlxuICovXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuZnVuY3Rpb24gY29weUF1Z21lbnQgKHRhcmdldCwgc3JjLCBrZXlzKSB7XG4gIGZvciAodmFyIGkgPSAwLCBsID0ga2V5cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICB2YXIga2V5ID0ga2V5c1tpXTtcbiAgICBkZWYodGFyZ2V0LCBrZXksIHNyY1trZXldKTtcbiAgfVxufVxuXG4vKipcbiAqIEF0dGVtcHQgdG8gY3JlYXRlIGFuIG9ic2VydmVyIGluc3RhbmNlIGZvciBhIHZhbHVlLFxuICogcmV0dXJucyB0aGUgbmV3IG9ic2VydmVyIGlmIHN1Y2Nlc3NmdWxseSBvYnNlcnZlZCxcbiAqIG9yIHRoZSBleGlzdGluZyBvYnNlcnZlciBpZiB0aGUgdmFsdWUgYWxyZWFkeSBoYXMgb25lLlxuICovXG5mdW5jdGlvbiBvYnNlcnZlICh2YWx1ZSwgYXNSb290RGF0YSkge1xuICBpZiAoIWlzT2JqZWN0KHZhbHVlKSB8fCB2YWx1ZSBpbnN0YW5jZW9mIFZOb2RlKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgdmFyIG9iO1xuICBpZiAoaGFzT3duKHZhbHVlLCAnX19vYl9fJykgJiYgdmFsdWUuX19vYl9fIGluc3RhbmNlb2YgT2JzZXJ2ZXIpIHtcbiAgICBvYiA9IHZhbHVlLl9fb2JfXztcbiAgfSBlbHNlIGlmIChcbiAgICBzaG91bGRPYnNlcnZlICYmXG4gICAgIWlzU2VydmVyUmVuZGVyaW5nKCkgJiZcbiAgICAoQXJyYXkuaXNBcnJheSh2YWx1ZSkgfHwgaXNQbGFpbk9iamVjdCh2YWx1ZSkpICYmXG4gICAgT2JqZWN0LmlzRXh0ZW5zaWJsZSh2YWx1ZSkgJiZcbiAgICAhdmFsdWUuX2lzVnVlXG4gICkge1xuICAgIG9iID0gbmV3IE9ic2VydmVyKHZhbHVlKTtcbiAgfVxuICBpZiAoYXNSb290RGF0YSAmJiBvYikge1xuICAgIG9iLnZtQ291bnQrKztcbiAgfVxuICByZXR1cm4gb2Jcbn1cblxuLyoqXG4gKiBEZWZpbmUgYSByZWFjdGl2ZSBwcm9wZXJ0eSBvbiBhbiBPYmplY3QuXG4gKi9cbmZ1bmN0aW9uIGRlZmluZVJlYWN0aXZlJCQxIChcbiAgb2JqLFxuICBrZXksXG4gIHZhbCxcbiAgY3VzdG9tU2V0dGVyLFxuICBzaGFsbG93XG4pIHtcbiAgdmFyIGRlcCA9IG5ldyBEZXAoKTtcblxuICB2YXIgcHJvcGVydHkgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iaiwga2V5KTtcbiAgaWYgKHByb3BlcnR5ICYmIHByb3BlcnR5LmNvbmZpZ3VyYWJsZSA9PT0gZmFsc2UpIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIC8vIGNhdGVyIGZvciBwcmUtZGVmaW5lZCBnZXR0ZXIvc2V0dGVyc1xuICB2YXIgZ2V0dGVyID0gcHJvcGVydHkgJiYgcHJvcGVydHkuZ2V0O1xuICB2YXIgc2V0dGVyID0gcHJvcGVydHkgJiYgcHJvcGVydHkuc2V0O1xuICBpZiAoKCFnZXR0ZXIgfHwgc2V0dGVyKSAmJiBhcmd1bWVudHMubGVuZ3RoID09PSAyKSB7XG4gICAgdmFsID0gb2JqW2tleV07XG4gIH1cblxuICB2YXIgY2hpbGRPYiA9ICFzaGFsbG93ICYmIG9ic2VydmUodmFsKTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiByZWFjdGl2ZUdldHRlciAoKSB7XG4gICAgICB2YXIgdmFsdWUgPSBnZXR0ZXIgPyBnZXR0ZXIuY2FsbChvYmopIDogdmFsO1xuICAgICAgaWYgKERlcC50YXJnZXQpIHtcbiAgICAgICAgZGVwLmRlcGVuZCgpO1xuICAgICAgICBpZiAoY2hpbGRPYikge1xuICAgICAgICAgIGNoaWxkT2IuZGVwLmRlcGVuZCgpO1xuICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgZGVwZW5kQXJyYXkodmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHZhbHVlXG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uIHJlYWN0aXZlU2V0dGVyIChuZXdWYWwpIHtcbiAgICAgIHZhciB2YWx1ZSA9IGdldHRlciA/IGdldHRlci5jYWxsKG9iaikgOiB2YWw7XG4gICAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby1zZWxmLWNvbXBhcmUgKi9cbiAgICAgIGlmIChuZXdWYWwgPT09IHZhbHVlIHx8IChuZXdWYWwgIT09IG5ld1ZhbCAmJiB2YWx1ZSAhPT0gdmFsdWUpKSB7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgICAgLyogZXNsaW50LWVuYWJsZSBuby1zZWxmLWNvbXBhcmUgKi9cbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGN1c3RvbVNldHRlcikge1xuICAgICAgICBjdXN0b21TZXR0ZXIoKTtcbiAgICAgIH1cbiAgICAgIC8vICM3OTgxOiBmb3IgYWNjZXNzb3IgcHJvcGVydGllcyB3aXRob3V0IHNldHRlclxuICAgICAgaWYgKGdldHRlciAmJiAhc2V0dGVyKSB7IHJldHVybiB9XG4gICAgICBpZiAoc2V0dGVyKSB7XG4gICAgICAgIHNldHRlci5jYWxsKG9iaiwgbmV3VmFsKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhbCA9IG5ld1ZhbDtcbiAgICAgIH1cbiAgICAgIGNoaWxkT2IgPSAhc2hhbGxvdyAmJiBvYnNlcnZlKG5ld1ZhbCk7XG4gICAgICBkZXAubm90aWZ5KCk7XG4gICAgfVxuICB9KTtcbn1cblxuLyoqXG4gKiBTZXQgYSBwcm9wZXJ0eSBvbiBhbiBvYmplY3QuIEFkZHMgdGhlIG5ldyBwcm9wZXJ0eSBhbmRcbiAqIHRyaWdnZXJzIGNoYW5nZSBub3RpZmljYXRpb24gaWYgdGhlIHByb3BlcnR5IGRvZXNuJ3RcbiAqIGFscmVhZHkgZXhpc3QuXG4gKi9cbmZ1bmN0aW9uIHNldCAodGFyZ2V0LCBrZXksIHZhbCkge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJlxuICAgIChpc1VuZGVmKHRhcmdldCkgfHwgaXNQcmltaXRpdmUodGFyZ2V0KSlcbiAgKSB7XG4gICAgd2FybigoXCJDYW5ub3Qgc2V0IHJlYWN0aXZlIHByb3BlcnR5IG9uIHVuZGVmaW5lZCwgbnVsbCwgb3IgcHJpbWl0aXZlIHZhbHVlOiBcIiArICgodGFyZ2V0KSkpKTtcbiAgfVxuICBpZiAoQXJyYXkuaXNBcnJheSh0YXJnZXQpICYmIGlzVmFsaWRBcnJheUluZGV4KGtleSkpIHtcbiAgICB0YXJnZXQubGVuZ3RoID0gTWF0aC5tYXgodGFyZ2V0Lmxlbmd0aCwga2V5KTtcbiAgICB0YXJnZXQuc3BsaWNlKGtleSwgMSwgdmFsKTtcbiAgICByZXR1cm4gdmFsXG4gIH1cbiAgaWYgKGtleSBpbiB0YXJnZXQgJiYgIShrZXkgaW4gT2JqZWN0LnByb3RvdHlwZSkpIHtcbiAgICB0YXJnZXRba2V5XSA9IHZhbDtcbiAgICByZXR1cm4gdmFsXG4gIH1cbiAgdmFyIG9iID0gKHRhcmdldCkuX19vYl9fO1xuICBpZiAodGFyZ2V0Ll9pc1Z1ZSB8fCAob2IgJiYgb2Iudm1Db3VudCkpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oXG4gICAgICAnQXZvaWQgYWRkaW5nIHJlYWN0aXZlIHByb3BlcnRpZXMgdG8gYSBWdWUgaW5zdGFuY2Ugb3IgaXRzIHJvb3QgJGRhdGEgJyArXG4gICAgICAnYXQgcnVudGltZSAtIGRlY2xhcmUgaXQgdXBmcm9udCBpbiB0aGUgZGF0YSBvcHRpb24uJ1xuICAgICk7XG4gICAgcmV0dXJuIHZhbFxuICB9XG4gIGlmICghb2IpIHtcbiAgICB0YXJnZXRba2V5XSA9IHZhbDtcbiAgICByZXR1cm4gdmFsXG4gIH1cbiAgZGVmaW5lUmVhY3RpdmUkJDEob2IudmFsdWUsIGtleSwgdmFsKTtcbiAgb2IuZGVwLm5vdGlmeSgpO1xuICByZXR1cm4gdmFsXG59XG5cbi8qKlxuICogRGVsZXRlIGEgcHJvcGVydHkgYW5kIHRyaWdnZXIgY2hhbmdlIGlmIG5lY2Vzc2FyeS5cbiAqL1xuZnVuY3Rpb24gZGVsICh0YXJnZXQsIGtleSkge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJlxuICAgIChpc1VuZGVmKHRhcmdldCkgfHwgaXNQcmltaXRpdmUodGFyZ2V0KSlcbiAgKSB7XG4gICAgd2FybigoXCJDYW5ub3QgZGVsZXRlIHJlYWN0aXZlIHByb3BlcnR5IG9uIHVuZGVmaW5lZCwgbnVsbCwgb3IgcHJpbWl0aXZlIHZhbHVlOiBcIiArICgodGFyZ2V0KSkpKTtcbiAgfVxuICBpZiAoQXJyYXkuaXNBcnJheSh0YXJnZXQpICYmIGlzVmFsaWRBcnJheUluZGV4KGtleSkpIHtcbiAgICB0YXJnZXQuc3BsaWNlKGtleSwgMSk7XG4gICAgcmV0dXJuXG4gIH1cbiAgdmFyIG9iID0gKHRhcmdldCkuX19vYl9fO1xuICBpZiAodGFyZ2V0Ll9pc1Z1ZSB8fCAob2IgJiYgb2Iudm1Db3VudCkpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oXG4gICAgICAnQXZvaWQgZGVsZXRpbmcgcHJvcGVydGllcyBvbiBhIFZ1ZSBpbnN0YW5jZSBvciBpdHMgcm9vdCAkZGF0YSAnICtcbiAgICAgICctIGp1c3Qgc2V0IGl0IHRvIG51bGwuJ1xuICAgICk7XG4gICAgcmV0dXJuXG4gIH1cbiAgaWYgKCFoYXNPd24odGFyZ2V0LCBrZXkpKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgZGVsZXRlIHRhcmdldFtrZXldO1xuICBpZiAoIW9iKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgb2IuZGVwLm5vdGlmeSgpO1xufVxuXG4vKipcbiAqIENvbGxlY3QgZGVwZW5kZW5jaWVzIG9uIGFycmF5IGVsZW1lbnRzIHdoZW4gdGhlIGFycmF5IGlzIHRvdWNoZWQsIHNpbmNlXG4gKiB3ZSBjYW5ub3QgaW50ZXJjZXB0IGFycmF5IGVsZW1lbnQgYWNjZXNzIGxpa2UgcHJvcGVydHkgZ2V0dGVycy5cbiAqL1xuZnVuY3Rpb24gZGVwZW5kQXJyYXkgKHZhbHVlKSB7XG4gIGZvciAodmFyIGUgPSAodm9pZCAwKSwgaSA9IDAsIGwgPSB2YWx1ZS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBlID0gdmFsdWVbaV07XG4gICAgZSAmJiBlLl9fb2JfXyAmJiBlLl9fb2JfXy5kZXAuZGVwZW5kKCk7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoZSkpIHtcbiAgICAgIGRlcGVuZEFycmF5KGUpO1xuICAgIH1cbiAgfVxufVxuXG4vKiAgKi9cblxuLyoqXG4gKiBPcHRpb24gb3ZlcndyaXRpbmcgc3RyYXRlZ2llcyBhcmUgZnVuY3Rpb25zIHRoYXQgaGFuZGxlXG4gKiBob3cgdG8gbWVyZ2UgYSBwYXJlbnQgb3B0aW9uIHZhbHVlIGFuZCBhIGNoaWxkIG9wdGlvblxuICogdmFsdWUgaW50byB0aGUgZmluYWwgdmFsdWUuXG4gKi9cbnZhciBzdHJhdHMgPSBjb25maWcub3B0aW9uTWVyZ2VTdHJhdGVnaWVzO1xuXG4vKipcbiAqIE9wdGlvbnMgd2l0aCByZXN0cmljdGlvbnNcbiAqL1xuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgc3RyYXRzLmVsID0gc3RyYXRzLnByb3BzRGF0YSA9IGZ1bmN0aW9uIChwYXJlbnQsIGNoaWxkLCB2bSwga2V5KSB7XG4gICAgaWYgKCF2bSkge1xuICAgICAgd2FybihcbiAgICAgICAgXCJvcHRpb24gXFxcIlwiICsga2V5ICsgXCJcXFwiIGNhbiBvbmx5IGJlIHVzZWQgZHVyaW5nIGluc3RhbmNlIFwiICtcbiAgICAgICAgJ2NyZWF0aW9uIHdpdGggdGhlIGBuZXdgIGtleXdvcmQuJ1xuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIGRlZmF1bHRTdHJhdChwYXJlbnQsIGNoaWxkKVxuICB9O1xufVxuXG4vKipcbiAqIEhlbHBlciB0aGF0IHJlY3Vyc2l2ZWx5IG1lcmdlcyB0d28gZGF0YSBvYmplY3RzIHRvZ2V0aGVyLlxuICovXG5mdW5jdGlvbiBtZXJnZURhdGEgKHRvLCBmcm9tKSB7XG4gIGlmICghZnJvbSkgeyByZXR1cm4gdG8gfVxuICB2YXIga2V5LCB0b1ZhbCwgZnJvbVZhbDtcblxuICB2YXIga2V5cyA9IGhhc1N5bWJvbFxuICAgID8gUmVmbGVjdC5vd25LZXlzKGZyb20pXG4gICAgOiBPYmplY3Qua2V5cyhmcm9tKTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICBrZXkgPSBrZXlzW2ldO1xuICAgIC8vIGluIGNhc2UgdGhlIG9iamVjdCBpcyBhbHJlYWR5IG9ic2VydmVkLi4uXG4gICAgaWYgKGtleSA9PT0gJ19fb2JfXycpIHsgY29udGludWUgfVxuICAgIHRvVmFsID0gdG9ba2V5XTtcbiAgICBmcm9tVmFsID0gZnJvbVtrZXldO1xuICAgIGlmICghaGFzT3duKHRvLCBrZXkpKSB7XG4gICAgICBzZXQodG8sIGtleSwgZnJvbVZhbCk7XG4gICAgfSBlbHNlIGlmIChcbiAgICAgIHRvVmFsICE9PSBmcm9tVmFsICYmXG4gICAgICBpc1BsYWluT2JqZWN0KHRvVmFsKSAmJlxuICAgICAgaXNQbGFpbk9iamVjdChmcm9tVmFsKVxuICAgICkge1xuICAgICAgbWVyZ2VEYXRhKHRvVmFsLCBmcm9tVmFsKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRvXG59XG5cbi8qKlxuICogRGF0YVxuICovXG5mdW5jdGlvbiBtZXJnZURhdGFPckZuIChcbiAgcGFyZW50VmFsLFxuICBjaGlsZFZhbCxcbiAgdm1cbikge1xuICBpZiAoIXZtKSB7XG4gICAgLy8gaW4gYSBWdWUuZXh0ZW5kIG1lcmdlLCBib3RoIHNob3VsZCBiZSBmdW5jdGlvbnNcbiAgICBpZiAoIWNoaWxkVmFsKSB7XG4gICAgICByZXR1cm4gcGFyZW50VmFsXG4gICAgfVxuICAgIGlmICghcGFyZW50VmFsKSB7XG4gICAgICByZXR1cm4gY2hpbGRWYWxcbiAgICB9XG4gICAgLy8gd2hlbiBwYXJlbnRWYWwgJiBjaGlsZFZhbCBhcmUgYm90aCBwcmVzZW50LFxuICAgIC8vIHdlIG5lZWQgdG8gcmV0dXJuIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHRoZVxuICAgIC8vIG1lcmdlZCByZXN1bHQgb2YgYm90aCBmdW5jdGlvbnMuLi4gbm8gbmVlZCB0b1xuICAgIC8vIGNoZWNrIGlmIHBhcmVudFZhbCBpcyBhIGZ1bmN0aW9uIGhlcmUgYmVjYXVzZVxuICAgIC8vIGl0IGhhcyB0byBiZSBhIGZ1bmN0aW9uIHRvIHBhc3MgcHJldmlvdXMgbWVyZ2VzLlxuICAgIHJldHVybiBmdW5jdGlvbiBtZXJnZWREYXRhRm4gKCkge1xuICAgICAgcmV0dXJuIG1lcmdlRGF0YShcbiAgICAgICAgdHlwZW9mIGNoaWxkVmFsID09PSAnZnVuY3Rpb24nID8gY2hpbGRWYWwuY2FsbCh0aGlzLCB0aGlzKSA6IGNoaWxkVmFsLFxuICAgICAgICB0eXBlb2YgcGFyZW50VmFsID09PSAnZnVuY3Rpb24nID8gcGFyZW50VmFsLmNhbGwodGhpcywgdGhpcykgOiBwYXJlbnRWYWxcbiAgICAgIClcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIG1lcmdlZEluc3RhbmNlRGF0YUZuICgpIHtcbiAgICAgIC8vIGluc3RhbmNlIG1lcmdlXG4gICAgICB2YXIgaW5zdGFuY2VEYXRhID0gdHlwZW9mIGNoaWxkVmFsID09PSAnZnVuY3Rpb24nXG4gICAgICAgID8gY2hpbGRWYWwuY2FsbCh2bSwgdm0pXG4gICAgICAgIDogY2hpbGRWYWw7XG4gICAgICB2YXIgZGVmYXVsdERhdGEgPSB0eXBlb2YgcGFyZW50VmFsID09PSAnZnVuY3Rpb24nXG4gICAgICAgID8gcGFyZW50VmFsLmNhbGwodm0sIHZtKVxuICAgICAgICA6IHBhcmVudFZhbDtcbiAgICAgIGlmIChpbnN0YW5jZURhdGEpIHtcbiAgICAgICAgcmV0dXJuIG1lcmdlRGF0YShpbnN0YW5jZURhdGEsIGRlZmF1bHREYXRhKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGRlZmF1bHREYXRhXG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbnN0cmF0cy5kYXRhID0gZnVuY3Rpb24gKFxuICBwYXJlbnRWYWwsXG4gIGNoaWxkVmFsLFxuICB2bVxuKSB7XG4gIGlmICghdm0pIHtcbiAgICBpZiAoY2hpbGRWYWwgJiYgdHlwZW9mIGNoaWxkVmFsICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oXG4gICAgICAgICdUaGUgXCJkYXRhXCIgb3B0aW9uIHNob3VsZCBiZSBhIGZ1bmN0aW9uICcgK1xuICAgICAgICAndGhhdCByZXR1cm5zIGEgcGVyLWluc3RhbmNlIHZhbHVlIGluIGNvbXBvbmVudCAnICtcbiAgICAgICAgJ2RlZmluaXRpb25zLicsXG4gICAgICAgIHZtXG4gICAgICApO1xuXG4gICAgICByZXR1cm4gcGFyZW50VmFsXG4gICAgfVxuICAgIHJldHVybiBtZXJnZURhdGFPckZuKHBhcmVudFZhbCwgY2hpbGRWYWwpXG4gIH1cblxuICByZXR1cm4gbWVyZ2VEYXRhT3JGbihwYXJlbnRWYWwsIGNoaWxkVmFsLCB2bSlcbn07XG5cbi8qKlxuICogSG9va3MgYW5kIHByb3BzIGFyZSBtZXJnZWQgYXMgYXJyYXlzLlxuICovXG5mdW5jdGlvbiBtZXJnZUhvb2sgKFxuICBwYXJlbnRWYWwsXG4gIGNoaWxkVmFsXG4pIHtcbiAgdmFyIHJlcyA9IGNoaWxkVmFsXG4gICAgPyBwYXJlbnRWYWxcbiAgICAgID8gcGFyZW50VmFsLmNvbmNhdChjaGlsZFZhbClcbiAgICAgIDogQXJyYXkuaXNBcnJheShjaGlsZFZhbClcbiAgICAgICAgPyBjaGlsZFZhbFxuICAgICAgICA6IFtjaGlsZFZhbF1cbiAgICA6IHBhcmVudFZhbDtcbiAgcmV0dXJuIHJlc1xuICAgID8gZGVkdXBlSG9va3MocmVzKVxuICAgIDogcmVzXG59XG5cbmZ1bmN0aW9uIGRlZHVwZUhvb2tzIChob29rcykge1xuICB2YXIgcmVzID0gW107XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgaG9va3MubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAocmVzLmluZGV4T2YoaG9va3NbaV0pID09PSAtMSkge1xuICAgICAgcmVzLnB1c2goaG9va3NbaV0pO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbkxJRkVDWUNMRV9IT09LUy5mb3JFYWNoKGZ1bmN0aW9uIChob29rKSB7XG4gIHN0cmF0c1tob29rXSA9IG1lcmdlSG9vaztcbn0pO1xuXG4vKipcbiAqIEFzc2V0c1xuICpcbiAqIFdoZW4gYSB2bSBpcyBwcmVzZW50IChpbnN0YW5jZSBjcmVhdGlvbiksIHdlIG5lZWQgdG8gZG9cbiAqIGEgdGhyZWUtd2F5IG1lcmdlIGJldHdlZW4gY29uc3RydWN0b3Igb3B0aW9ucywgaW5zdGFuY2VcbiAqIG9wdGlvbnMgYW5kIHBhcmVudCBvcHRpb25zLlxuICovXG5mdW5jdGlvbiBtZXJnZUFzc2V0cyAoXG4gIHBhcmVudFZhbCxcbiAgY2hpbGRWYWwsXG4gIHZtLFxuICBrZXlcbikge1xuICB2YXIgcmVzID0gT2JqZWN0LmNyZWF0ZShwYXJlbnRWYWwgfHwgbnVsbCk7XG4gIGlmIChjaGlsZFZhbCkge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgYXNzZXJ0T2JqZWN0VHlwZShrZXksIGNoaWxkVmFsLCB2bSk7XG4gICAgcmV0dXJuIGV4dGVuZChyZXMsIGNoaWxkVmFsKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiByZXNcbiAgfVxufVxuXG5BU1NFVF9UWVBFUy5mb3JFYWNoKGZ1bmN0aW9uICh0eXBlKSB7XG4gIHN0cmF0c1t0eXBlICsgJ3MnXSA9IG1lcmdlQXNzZXRzO1xufSk7XG5cbi8qKlxuICogV2F0Y2hlcnMuXG4gKlxuICogV2F0Y2hlcnMgaGFzaGVzIHNob3VsZCBub3Qgb3ZlcndyaXRlIG9uZVxuICogYW5vdGhlciwgc28gd2UgbWVyZ2UgdGhlbSBhcyBhcnJheXMuXG4gKi9cbnN0cmF0cy53YXRjaCA9IGZ1bmN0aW9uIChcbiAgcGFyZW50VmFsLFxuICBjaGlsZFZhbCxcbiAgdm0sXG4gIGtleVxuKSB7XG4gIC8vIHdvcmsgYXJvdW5kIEZpcmVmb3gncyBPYmplY3QucHJvdG90eXBlLndhdGNoLi4uXG4gIGlmIChwYXJlbnRWYWwgPT09IG5hdGl2ZVdhdGNoKSB7IHBhcmVudFZhbCA9IHVuZGVmaW5lZDsgfVxuICBpZiAoY2hpbGRWYWwgPT09IG5hdGl2ZVdhdGNoKSB7IGNoaWxkVmFsID0gdW5kZWZpbmVkOyB9XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoIWNoaWxkVmFsKSB7IHJldHVybiBPYmplY3QuY3JlYXRlKHBhcmVudFZhbCB8fCBudWxsKSB9XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgYXNzZXJ0T2JqZWN0VHlwZShrZXksIGNoaWxkVmFsLCB2bSk7XG4gIH1cbiAgaWYgKCFwYXJlbnRWYWwpIHsgcmV0dXJuIGNoaWxkVmFsIH1cbiAgdmFyIHJldCA9IHt9O1xuICBleHRlbmQocmV0LCBwYXJlbnRWYWwpO1xuICBmb3IgKHZhciBrZXkkMSBpbiBjaGlsZFZhbCkge1xuICAgIHZhciBwYXJlbnQgPSByZXRba2V5JDFdO1xuICAgIHZhciBjaGlsZCA9IGNoaWxkVmFsW2tleSQxXTtcbiAgICBpZiAocGFyZW50ICYmICFBcnJheS5pc0FycmF5KHBhcmVudCkpIHtcbiAgICAgIHBhcmVudCA9IFtwYXJlbnRdO1xuICAgIH1cbiAgICByZXRba2V5JDFdID0gcGFyZW50XG4gICAgICA/IHBhcmVudC5jb25jYXQoY2hpbGQpXG4gICAgICA6IEFycmF5LmlzQXJyYXkoY2hpbGQpID8gY2hpbGQgOiBbY2hpbGRdO1xuICB9XG4gIHJldHVybiByZXRcbn07XG5cbi8qKlxuICogT3RoZXIgb2JqZWN0IGhhc2hlcy5cbiAqL1xuc3RyYXRzLnByb3BzID1cbnN0cmF0cy5tZXRob2RzID1cbnN0cmF0cy5pbmplY3QgPVxuc3RyYXRzLmNvbXB1dGVkID0gZnVuY3Rpb24gKFxuICBwYXJlbnRWYWwsXG4gIGNoaWxkVmFsLFxuICB2bSxcbiAga2V5XG4pIHtcbiAgaWYgKGNoaWxkVmFsICYmIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBhc3NlcnRPYmplY3RUeXBlKGtleSwgY2hpbGRWYWwsIHZtKTtcbiAgfVxuICBpZiAoIXBhcmVudFZhbCkgeyByZXR1cm4gY2hpbGRWYWwgfVxuICB2YXIgcmV0ID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgZXh0ZW5kKHJldCwgcGFyZW50VmFsKTtcbiAgaWYgKGNoaWxkVmFsKSB7IGV4dGVuZChyZXQsIGNoaWxkVmFsKTsgfVxuICByZXR1cm4gcmV0XG59O1xuc3RyYXRzLnByb3ZpZGUgPSBtZXJnZURhdGFPckZuO1xuXG4vKipcbiAqIERlZmF1bHQgc3RyYXRlZ3kuXG4gKi9cbnZhciBkZWZhdWx0U3RyYXQgPSBmdW5jdGlvbiAocGFyZW50VmFsLCBjaGlsZFZhbCkge1xuICByZXR1cm4gY2hpbGRWYWwgPT09IHVuZGVmaW5lZFxuICAgID8gcGFyZW50VmFsXG4gICAgOiBjaGlsZFZhbFxufTtcblxuLyoqXG4gKiBWYWxpZGF0ZSBjb21wb25lbnQgbmFtZXNcbiAqL1xuZnVuY3Rpb24gY2hlY2tDb21wb25lbnRzIChvcHRpb25zKSB7XG4gIGZvciAodmFyIGtleSBpbiBvcHRpb25zLmNvbXBvbmVudHMpIHtcbiAgICB2YWxpZGF0ZUNvbXBvbmVudE5hbWUoa2V5KTtcbiAgfVxufVxuXG5mdW5jdGlvbiB2YWxpZGF0ZUNvbXBvbmVudE5hbWUgKG5hbWUpIHtcbiAgaWYgKCFuZXcgUmVnRXhwKChcIl5bYS16QS1aXVtcXFxcLVxcXFwuMC05X1wiICsgKHVuaWNvZGVSZWdFeHAuc291cmNlKSArIFwiXSokXCIpKS50ZXN0KG5hbWUpKSB7XG4gICAgd2FybihcbiAgICAgICdJbnZhbGlkIGNvbXBvbmVudCBuYW1lOiBcIicgKyBuYW1lICsgJ1wiLiBDb21wb25lbnQgbmFtZXMgJyArXG4gICAgICAnc2hvdWxkIGNvbmZvcm0gdG8gdmFsaWQgY3VzdG9tIGVsZW1lbnQgbmFtZSBpbiBodG1sNSBzcGVjaWZpY2F0aW9uLidcbiAgICApO1xuICB9XG4gIGlmIChpc0J1aWx0SW5UYWcobmFtZSkgfHwgY29uZmlnLmlzUmVzZXJ2ZWRUYWcobmFtZSkpIHtcbiAgICB3YXJuKFxuICAgICAgJ0RvIG5vdCB1c2UgYnVpbHQtaW4gb3IgcmVzZXJ2ZWQgSFRNTCBlbGVtZW50cyBhcyBjb21wb25lbnQgJyArXG4gICAgICAnaWQ6ICcgKyBuYW1lXG4gICAgKTtcbiAgfVxufVxuXG4vKipcbiAqIEVuc3VyZSBhbGwgcHJvcHMgb3B0aW9uIHN5bnRheCBhcmUgbm9ybWFsaXplZCBpbnRvIHRoZVxuICogT2JqZWN0LWJhc2VkIGZvcm1hdC5cbiAqL1xuZnVuY3Rpb24gbm9ybWFsaXplUHJvcHMgKG9wdGlvbnMsIHZtKSB7XG4gIHZhciBwcm9wcyA9IG9wdGlvbnMucHJvcHM7XG4gIGlmICghcHJvcHMpIHsgcmV0dXJuIH1cbiAgdmFyIHJlcyA9IHt9O1xuICB2YXIgaSwgdmFsLCBuYW1lO1xuICBpZiAoQXJyYXkuaXNBcnJheShwcm9wcykpIHtcbiAgICBpID0gcHJvcHMubGVuZ3RoO1xuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgIHZhbCA9IHByb3BzW2ldO1xuICAgICAgaWYgKHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIG5hbWUgPSBjYW1lbGl6ZSh2YWwpO1xuICAgICAgICByZXNbbmFtZV0gPSB7IHR5cGU6IG51bGwgfTtcbiAgICAgIH0gZWxzZSBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICB3YXJuKCdwcm9wcyBtdXN0IGJlIHN0cmluZ3Mgd2hlbiB1c2luZyBhcnJheSBzeW50YXguJyk7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2UgaWYgKGlzUGxhaW5PYmplY3QocHJvcHMpKSB7XG4gICAgZm9yICh2YXIga2V5IGluIHByb3BzKSB7XG4gICAgICB2YWwgPSBwcm9wc1trZXldO1xuICAgICAgbmFtZSA9IGNhbWVsaXplKGtleSk7XG4gICAgICByZXNbbmFtZV0gPSBpc1BsYWluT2JqZWN0KHZhbClcbiAgICAgICAgPyB2YWxcbiAgICAgICAgOiB7IHR5cGU6IHZhbCB9O1xuICAgIH1cbiAgfSBlbHNlIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgd2FybihcbiAgICAgIFwiSW52YWxpZCB2YWx1ZSBmb3Igb3B0aW9uIFxcXCJwcm9wc1xcXCI6IGV4cGVjdGVkIGFuIEFycmF5IG9yIGFuIE9iamVjdCwgXCIgK1xuICAgICAgXCJidXQgZ290IFwiICsgKHRvUmF3VHlwZShwcm9wcykpICsgXCIuXCIsXG4gICAgICB2bVxuICAgICk7XG4gIH1cbiAgb3B0aW9ucy5wcm9wcyA9IHJlcztcbn1cblxuLyoqXG4gKiBOb3JtYWxpemUgYWxsIGluamVjdGlvbnMgaW50byBPYmplY3QtYmFzZWQgZm9ybWF0XG4gKi9cbmZ1bmN0aW9uIG5vcm1hbGl6ZUluamVjdCAob3B0aW9ucywgdm0pIHtcbiAgdmFyIGluamVjdCA9IG9wdGlvbnMuaW5qZWN0O1xuICBpZiAoIWluamVjdCkgeyByZXR1cm4gfVxuICB2YXIgbm9ybWFsaXplZCA9IG9wdGlvbnMuaW5qZWN0ID0ge307XG4gIGlmIChBcnJheS5pc0FycmF5KGluamVjdCkpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGluamVjdC5sZW5ndGg7IGkrKykge1xuICAgICAgbm9ybWFsaXplZFtpbmplY3RbaV1dID0geyBmcm9tOiBpbmplY3RbaV0gfTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoaXNQbGFpbk9iamVjdChpbmplY3QpKSB7XG4gICAgZm9yICh2YXIga2V5IGluIGluamVjdCkge1xuICAgICAgdmFyIHZhbCA9IGluamVjdFtrZXldO1xuICAgICAgbm9ybWFsaXplZFtrZXldID0gaXNQbGFpbk9iamVjdCh2YWwpXG4gICAgICAgID8gZXh0ZW5kKHsgZnJvbToga2V5IH0sIHZhbClcbiAgICAgICAgOiB7IGZyb206IHZhbCB9O1xuICAgIH1cbiAgfSBlbHNlIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgd2FybihcbiAgICAgIFwiSW52YWxpZCB2YWx1ZSBmb3Igb3B0aW9uIFxcXCJpbmplY3RcXFwiOiBleHBlY3RlZCBhbiBBcnJheSBvciBhbiBPYmplY3QsIFwiICtcbiAgICAgIFwiYnV0IGdvdCBcIiArICh0b1Jhd1R5cGUoaW5qZWN0KSkgKyBcIi5cIixcbiAgICAgIHZtXG4gICAgKTtcbiAgfVxufVxuXG4vKipcbiAqIE5vcm1hbGl6ZSByYXcgZnVuY3Rpb24gZGlyZWN0aXZlcyBpbnRvIG9iamVjdCBmb3JtYXQuXG4gKi9cbmZ1bmN0aW9uIG5vcm1hbGl6ZURpcmVjdGl2ZXMgKG9wdGlvbnMpIHtcbiAgdmFyIGRpcnMgPSBvcHRpb25zLmRpcmVjdGl2ZXM7XG4gIGlmIChkaXJzKSB7XG4gICAgZm9yICh2YXIga2V5IGluIGRpcnMpIHtcbiAgICAgIHZhciBkZWYkJDEgPSBkaXJzW2tleV07XG4gICAgICBpZiAodHlwZW9mIGRlZiQkMSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBkaXJzW2tleV0gPSB7IGJpbmQ6IGRlZiQkMSwgdXBkYXRlOiBkZWYkJDEgfTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gYXNzZXJ0T2JqZWN0VHlwZSAobmFtZSwgdmFsdWUsIHZtKSB7XG4gIGlmICghaXNQbGFpbk9iamVjdCh2YWx1ZSkpIHtcbiAgICB3YXJuKFxuICAgICAgXCJJbnZhbGlkIHZhbHVlIGZvciBvcHRpb24gXFxcIlwiICsgbmFtZSArIFwiXFxcIjogZXhwZWN0ZWQgYW4gT2JqZWN0LCBcIiArXG4gICAgICBcImJ1dCBnb3QgXCIgKyAodG9SYXdUeXBlKHZhbHVlKSkgKyBcIi5cIixcbiAgICAgIHZtXG4gICAgKTtcbiAgfVxufVxuXG4vKipcbiAqIE1lcmdlIHR3byBvcHRpb24gb2JqZWN0cyBpbnRvIGEgbmV3IG9uZS5cbiAqIENvcmUgdXRpbGl0eSB1c2VkIGluIGJvdGggaW5zdGFudGlhdGlvbiBhbmQgaW5oZXJpdGFuY2UuXG4gKi9cbmZ1bmN0aW9uIG1lcmdlT3B0aW9ucyAoXG4gIHBhcmVudCxcbiAgY2hpbGQsXG4gIHZtXG4pIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBjaGVja0NvbXBvbmVudHMoY2hpbGQpO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBjaGlsZCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNoaWxkID0gY2hpbGQub3B0aW9ucztcbiAgfVxuXG4gIG5vcm1hbGl6ZVByb3BzKGNoaWxkLCB2bSk7XG4gIG5vcm1hbGl6ZUluamVjdChjaGlsZCwgdm0pO1xuICBub3JtYWxpemVEaXJlY3RpdmVzKGNoaWxkKTtcblxuICAvLyBBcHBseSBleHRlbmRzIGFuZCBtaXhpbnMgb24gdGhlIGNoaWxkIG9wdGlvbnMsXG4gIC8vIGJ1dCBvbmx5IGlmIGl0IGlzIGEgcmF3IG9wdGlvbnMgb2JqZWN0IHRoYXQgaXNuJ3RcbiAgLy8gdGhlIHJlc3VsdCBvZiBhbm90aGVyIG1lcmdlT3B0aW9ucyBjYWxsLlxuICAvLyBPbmx5IG1lcmdlZCBvcHRpb25zIGhhcyB0aGUgX2Jhc2UgcHJvcGVydHkuXG4gIGlmICghY2hpbGQuX2Jhc2UpIHtcbiAgICBpZiAoY2hpbGQuZXh0ZW5kcykge1xuICAgICAgcGFyZW50ID0gbWVyZ2VPcHRpb25zKHBhcmVudCwgY2hpbGQuZXh0ZW5kcywgdm0pO1xuICAgIH1cbiAgICBpZiAoY2hpbGQubWl4aW5zKSB7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGNoaWxkLm1peGlucy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgcGFyZW50ID0gbWVyZ2VPcHRpb25zKHBhcmVudCwgY2hpbGQubWl4aW5zW2ldLCB2bSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdmFyIG9wdGlvbnMgPSB7fTtcbiAgdmFyIGtleTtcbiAgZm9yIChrZXkgaW4gcGFyZW50KSB7XG4gICAgbWVyZ2VGaWVsZChrZXkpO1xuICB9XG4gIGZvciAoa2V5IGluIGNoaWxkKSB7XG4gICAgaWYgKCFoYXNPd24ocGFyZW50LCBrZXkpKSB7XG4gICAgICBtZXJnZUZpZWxkKGtleSk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIG1lcmdlRmllbGQgKGtleSkge1xuICAgIHZhciBzdHJhdCA9IHN0cmF0c1trZXldIHx8IGRlZmF1bHRTdHJhdDtcbiAgICBvcHRpb25zW2tleV0gPSBzdHJhdChwYXJlbnRba2V5XSwgY2hpbGRba2V5XSwgdm0sIGtleSk7XG4gIH1cbiAgcmV0dXJuIG9wdGlvbnNcbn1cblxuLyoqXG4gKiBSZXNvbHZlIGFuIGFzc2V0LlxuICogVGhpcyBmdW5jdGlvbiBpcyB1c2VkIGJlY2F1c2UgY2hpbGQgaW5zdGFuY2VzIG5lZWQgYWNjZXNzXG4gKiB0byBhc3NldHMgZGVmaW5lZCBpbiBpdHMgYW5jZXN0b3IgY2hhaW4uXG4gKi9cbmZ1bmN0aW9uIHJlc29sdmVBc3NldCAoXG4gIG9wdGlvbnMsXG4gIHR5cGUsXG4gIGlkLFxuICB3YXJuTWlzc2luZ1xuKSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAodHlwZW9mIGlkICE9PSAnc3RyaW5nJykge1xuICAgIHJldHVyblxuICB9XG4gIHZhciBhc3NldHMgPSBvcHRpb25zW3R5cGVdO1xuICAvLyBjaGVjayBsb2NhbCByZWdpc3RyYXRpb24gdmFyaWF0aW9ucyBmaXJzdFxuICBpZiAoaGFzT3duKGFzc2V0cywgaWQpKSB7IHJldHVybiBhc3NldHNbaWRdIH1cbiAgdmFyIGNhbWVsaXplZElkID0gY2FtZWxpemUoaWQpO1xuICBpZiAoaGFzT3duKGFzc2V0cywgY2FtZWxpemVkSWQpKSB7IHJldHVybiBhc3NldHNbY2FtZWxpemVkSWRdIH1cbiAgdmFyIFBhc2NhbENhc2VJZCA9IGNhcGl0YWxpemUoY2FtZWxpemVkSWQpO1xuICBpZiAoaGFzT3duKGFzc2V0cywgUGFzY2FsQ2FzZUlkKSkgeyByZXR1cm4gYXNzZXRzW1Bhc2NhbENhc2VJZF0gfVxuICAvLyBmYWxsYmFjayB0byBwcm90b3R5cGUgY2hhaW5cbiAgdmFyIHJlcyA9IGFzc2V0c1tpZF0gfHwgYXNzZXRzW2NhbWVsaXplZElkXSB8fCBhc3NldHNbUGFzY2FsQ2FzZUlkXTtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2Fybk1pc3NpbmcgJiYgIXJlcykge1xuICAgIHdhcm4oXG4gICAgICAnRmFpbGVkIHRvIHJlc29sdmUgJyArIHR5cGUuc2xpY2UoMCwgLTEpICsgJzogJyArIGlkLFxuICAgICAgb3B0aW9uc1xuICAgICk7XG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG4vKiAgKi9cblxuXG5cbmZ1bmN0aW9uIHZhbGlkYXRlUHJvcCAoXG4gIGtleSxcbiAgcHJvcE9wdGlvbnMsXG4gIHByb3BzRGF0YSxcbiAgdm1cbikge1xuICB2YXIgcHJvcCA9IHByb3BPcHRpb25zW2tleV07XG4gIHZhciBhYnNlbnQgPSAhaGFzT3duKHByb3BzRGF0YSwga2V5KTtcbiAgdmFyIHZhbHVlID0gcHJvcHNEYXRhW2tleV07XG4gIC8vIGJvb2xlYW4gY2FzdGluZ1xuICB2YXIgYm9vbGVhbkluZGV4ID0gZ2V0VHlwZUluZGV4KEJvb2xlYW4sIHByb3AudHlwZSk7XG4gIGlmIChib29sZWFuSW5kZXggPiAtMSkge1xuICAgIGlmIChhYnNlbnQgJiYgIWhhc093bihwcm9wLCAnZGVmYXVsdCcpKSB7XG4gICAgICB2YWx1ZSA9IGZhbHNlO1xuICAgIH0gZWxzZSBpZiAodmFsdWUgPT09ICcnIHx8IHZhbHVlID09PSBoeXBoZW5hdGUoa2V5KSkge1xuICAgICAgLy8gb25seSBjYXN0IGVtcHR5IHN0cmluZyAvIHNhbWUgbmFtZSB0byBib29sZWFuIGlmXG4gICAgICAvLyBib29sZWFuIGhhcyBoaWdoZXIgcHJpb3JpdHlcbiAgICAgIHZhciBzdHJpbmdJbmRleCA9IGdldFR5cGVJbmRleChTdHJpbmcsIHByb3AudHlwZSk7XG4gICAgICBpZiAoc3RyaW5nSW5kZXggPCAwIHx8IGJvb2xlYW5JbmRleCA8IHN0cmluZ0luZGV4KSB7XG4gICAgICAgIHZhbHVlID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgLy8gY2hlY2sgZGVmYXVsdCB2YWx1ZVxuICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgIHZhbHVlID0gZ2V0UHJvcERlZmF1bHRWYWx1ZSh2bSwgcHJvcCwga2V5KTtcbiAgICAvLyBzaW5jZSB0aGUgZGVmYXVsdCB2YWx1ZSBpcyBhIGZyZXNoIGNvcHksXG4gICAgLy8gbWFrZSBzdXJlIHRvIG9ic2VydmUgaXQuXG4gICAgdmFyIHByZXZTaG91bGRPYnNlcnZlID0gc2hvdWxkT2JzZXJ2ZTtcbiAgICB0b2dnbGVPYnNlcnZpbmcodHJ1ZSk7XG4gICAgb2JzZXJ2ZSh2YWx1ZSk7XG4gICAgdG9nZ2xlT2JzZXJ2aW5nKHByZXZTaG91bGRPYnNlcnZlKTtcbiAgfVxuICBpZiAoXG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJlxuICAgIC8vIHNraXAgdmFsaWRhdGlvbiBmb3Igd2VleCByZWN5Y2xlLWxpc3QgY2hpbGQgY29tcG9uZW50IHByb3BzXG4gICAgIShmYWxzZSlcbiAgKSB7XG4gICAgYXNzZXJ0UHJvcChwcm9wLCBrZXksIHZhbHVlLCB2bSwgYWJzZW50KTtcbiAgfVxuICByZXR1cm4gdmFsdWVcbn1cblxuLyoqXG4gKiBHZXQgdGhlIGRlZmF1bHQgdmFsdWUgb2YgYSBwcm9wLlxuICovXG5mdW5jdGlvbiBnZXRQcm9wRGVmYXVsdFZhbHVlICh2bSwgcHJvcCwga2V5KSB7XG4gIC8vIG5vIGRlZmF1bHQsIHJldHVybiB1bmRlZmluZWRcbiAgaWYgKCFoYXNPd24ocHJvcCwgJ2RlZmF1bHQnKSkge1xuICAgIHJldHVybiB1bmRlZmluZWRcbiAgfVxuICB2YXIgZGVmID0gcHJvcC5kZWZhdWx0O1xuICAvLyB3YXJuIGFnYWluc3Qgbm9uLWZhY3RvcnkgZGVmYXVsdHMgZm9yIE9iamVjdCAmIEFycmF5XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGlzT2JqZWN0KGRlZikpIHtcbiAgICB3YXJuKFxuICAgICAgJ0ludmFsaWQgZGVmYXVsdCB2YWx1ZSBmb3IgcHJvcCBcIicgKyBrZXkgKyAnXCI6ICcgK1xuICAgICAgJ1Byb3BzIHdpdGggdHlwZSBPYmplY3QvQXJyYXkgbXVzdCB1c2UgYSBmYWN0b3J5IGZ1bmN0aW9uICcgK1xuICAgICAgJ3RvIHJldHVybiB0aGUgZGVmYXVsdCB2YWx1ZS4nLFxuICAgICAgdm1cbiAgICApO1xuICB9XG4gIC8vIHRoZSByYXcgcHJvcCB2YWx1ZSB3YXMgYWxzbyB1bmRlZmluZWQgZnJvbSBwcmV2aW91cyByZW5kZXIsXG4gIC8vIHJldHVybiBwcmV2aW91cyBkZWZhdWx0IHZhbHVlIHRvIGF2b2lkIHVubmVjZXNzYXJ5IHdhdGNoZXIgdHJpZ2dlclxuICBpZiAodm0gJiYgdm0uJG9wdGlvbnMucHJvcHNEYXRhICYmXG4gICAgdm0uJG9wdGlvbnMucHJvcHNEYXRhW2tleV0gPT09IHVuZGVmaW5lZCAmJlxuICAgIHZtLl9wcm9wc1trZXldICE9PSB1bmRlZmluZWRcbiAgKSB7XG4gICAgcmV0dXJuIHZtLl9wcm9wc1trZXldXG4gIH1cbiAgLy8gY2FsbCBmYWN0b3J5IGZ1bmN0aW9uIGZvciBub24tRnVuY3Rpb24gdHlwZXNcbiAgLy8gYSB2YWx1ZSBpcyBGdW5jdGlvbiBpZiBpdHMgcHJvdG90eXBlIGlzIGZ1bmN0aW9uIGV2ZW4gYWNyb3NzIGRpZmZlcmVudCBleGVjdXRpb24gY29udGV4dFxuICByZXR1cm4gdHlwZW9mIGRlZiA9PT0gJ2Z1bmN0aW9uJyAmJiBnZXRUeXBlKHByb3AudHlwZSkgIT09ICdGdW5jdGlvbidcbiAgICA/IGRlZi5jYWxsKHZtKVxuICAgIDogZGVmXG59XG5cbi8qKlxuICogQXNzZXJ0IHdoZXRoZXIgYSBwcm9wIGlzIHZhbGlkLlxuICovXG5mdW5jdGlvbiBhc3NlcnRQcm9wIChcbiAgcHJvcCxcbiAgbmFtZSxcbiAgdmFsdWUsXG4gIHZtLFxuICBhYnNlbnRcbikge1xuICBpZiAocHJvcC5yZXF1aXJlZCAmJiBhYnNlbnQpIHtcbiAgICB3YXJuKFxuICAgICAgJ01pc3NpbmcgcmVxdWlyZWQgcHJvcDogXCInICsgbmFtZSArICdcIicsXG4gICAgICB2bVxuICAgICk7XG4gICAgcmV0dXJuXG4gIH1cbiAgaWYgKHZhbHVlID09IG51bGwgJiYgIXByb3AucmVxdWlyZWQpIHtcbiAgICByZXR1cm5cbiAgfVxuICB2YXIgdHlwZSA9IHByb3AudHlwZTtcbiAgdmFyIHZhbGlkID0gIXR5cGUgfHwgdHlwZSA9PT0gdHJ1ZTtcbiAgdmFyIGV4cGVjdGVkVHlwZXMgPSBbXTtcbiAgaWYgKHR5cGUpIHtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkodHlwZSkpIHtcbiAgICAgIHR5cGUgPSBbdHlwZV07XG4gICAgfVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdHlwZS5sZW5ndGggJiYgIXZhbGlkOyBpKyspIHtcbiAgICAgIHZhciBhc3NlcnRlZFR5cGUgPSBhc3NlcnRUeXBlKHZhbHVlLCB0eXBlW2ldLCB2bSk7XG4gICAgICBleHBlY3RlZFR5cGVzLnB1c2goYXNzZXJ0ZWRUeXBlLmV4cGVjdGVkVHlwZSB8fCAnJyk7XG4gICAgICB2YWxpZCA9IGFzc2VydGVkVHlwZS52YWxpZDtcbiAgICB9XG4gIH1cblxuICB2YXIgaGF2ZUV4cGVjdGVkVHlwZXMgPSBleHBlY3RlZFR5cGVzLnNvbWUoZnVuY3Rpb24gKHQpIHsgcmV0dXJuIHQ7IH0pO1xuICBpZiAoIXZhbGlkICYmIGhhdmVFeHBlY3RlZFR5cGVzKSB7XG4gICAgd2FybihcbiAgICAgIGdldEludmFsaWRUeXBlTWVzc2FnZShuYW1lLCB2YWx1ZSwgZXhwZWN0ZWRUeXBlcyksXG4gICAgICB2bVxuICAgICk7XG4gICAgcmV0dXJuXG4gIH1cbiAgdmFyIHZhbGlkYXRvciA9IHByb3AudmFsaWRhdG9yO1xuICBpZiAodmFsaWRhdG9yKSB7XG4gICAgaWYgKCF2YWxpZGF0b3IodmFsdWUpKSB7XG4gICAgICB3YXJuKFxuICAgICAgICAnSW52YWxpZCBwcm9wOiBjdXN0b20gdmFsaWRhdG9yIGNoZWNrIGZhaWxlZCBmb3IgcHJvcCBcIicgKyBuYW1lICsgJ1wiLicsXG4gICAgICAgIHZtXG4gICAgICApO1xuICAgIH1cbiAgfVxufVxuXG52YXIgc2ltcGxlQ2hlY2tSRSA9IC9eKFN0cmluZ3xOdW1iZXJ8Qm9vbGVhbnxGdW5jdGlvbnxTeW1ib2x8QmlnSW50KSQvO1xuXG5mdW5jdGlvbiBhc3NlcnRUeXBlICh2YWx1ZSwgdHlwZSwgdm0pIHtcbiAgdmFyIHZhbGlkO1xuICB2YXIgZXhwZWN0ZWRUeXBlID0gZ2V0VHlwZSh0eXBlKTtcbiAgaWYgKHNpbXBsZUNoZWNrUkUudGVzdChleHBlY3RlZFR5cGUpKSB7XG4gICAgdmFyIHQgPSB0eXBlb2YgdmFsdWU7XG4gICAgdmFsaWQgPSB0ID09PSBleHBlY3RlZFR5cGUudG9Mb3dlckNhc2UoKTtcbiAgICAvLyBmb3IgcHJpbWl0aXZlIHdyYXBwZXIgb2JqZWN0c1xuICAgIGlmICghdmFsaWQgJiYgdCA9PT0gJ29iamVjdCcpIHtcbiAgICAgIHZhbGlkID0gdmFsdWUgaW5zdGFuY2VvZiB0eXBlO1xuICAgIH1cbiAgfSBlbHNlIGlmIChleHBlY3RlZFR5cGUgPT09ICdPYmplY3QnKSB7XG4gICAgdmFsaWQgPSBpc1BsYWluT2JqZWN0KHZhbHVlKTtcbiAgfSBlbHNlIGlmIChleHBlY3RlZFR5cGUgPT09ICdBcnJheScpIHtcbiAgICB2YWxpZCA9IEFycmF5LmlzQXJyYXkodmFsdWUpO1xuICB9IGVsc2Uge1xuICAgIHRyeSB7XG4gICAgICB2YWxpZCA9IHZhbHVlIGluc3RhbmNlb2YgdHlwZTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICB3YXJuKCdJbnZhbGlkIHByb3AgdHlwZTogXCInICsgU3RyaW5nKHR5cGUpICsgJ1wiIGlzIG5vdCBhIGNvbnN0cnVjdG9yJywgdm0pO1xuICAgICAgdmFsaWQgPSBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHtcbiAgICB2YWxpZDogdmFsaWQsXG4gICAgZXhwZWN0ZWRUeXBlOiBleHBlY3RlZFR5cGVcbiAgfVxufVxuXG52YXIgZnVuY3Rpb25UeXBlQ2hlY2tSRSA9IC9eXFxzKmZ1bmN0aW9uIChcXHcrKS87XG5cbi8qKlxuICogVXNlIGZ1bmN0aW9uIHN0cmluZyBuYW1lIHRvIGNoZWNrIGJ1aWx0LWluIHR5cGVzLFxuICogYmVjYXVzZSBhIHNpbXBsZSBlcXVhbGl0eSBjaGVjayB3aWxsIGZhaWwgd2hlbiBydW5uaW5nXG4gKiBhY3Jvc3MgZGlmZmVyZW50IHZtcyAvIGlmcmFtZXMuXG4gKi9cbmZ1bmN0aW9uIGdldFR5cGUgKGZuKSB7XG4gIHZhciBtYXRjaCA9IGZuICYmIGZuLnRvU3RyaW5nKCkubWF0Y2goZnVuY3Rpb25UeXBlQ2hlY2tSRSk7XG4gIHJldHVybiBtYXRjaCA/IG1hdGNoWzFdIDogJydcbn1cblxuZnVuY3Rpb24gaXNTYW1lVHlwZSAoYSwgYikge1xuICByZXR1cm4gZ2V0VHlwZShhKSA9PT0gZ2V0VHlwZShiKVxufVxuXG5mdW5jdGlvbiBnZXRUeXBlSW5kZXggKHR5cGUsIGV4cGVjdGVkVHlwZXMpIHtcbiAgaWYgKCFBcnJheS5pc0FycmF5KGV4cGVjdGVkVHlwZXMpKSB7XG4gICAgcmV0dXJuIGlzU2FtZVR5cGUoZXhwZWN0ZWRUeXBlcywgdHlwZSkgPyAwIDogLTFcbiAgfVxuICBmb3IgKHZhciBpID0gMCwgbGVuID0gZXhwZWN0ZWRUeXBlcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIGlmIChpc1NhbWVUeXBlKGV4cGVjdGVkVHlwZXNbaV0sIHR5cGUpKSB7XG4gICAgICByZXR1cm4gaVxuICAgIH1cbiAgfVxuICByZXR1cm4gLTFcbn1cblxuZnVuY3Rpb24gZ2V0SW52YWxpZFR5cGVNZXNzYWdlIChuYW1lLCB2YWx1ZSwgZXhwZWN0ZWRUeXBlcykge1xuICB2YXIgbWVzc2FnZSA9IFwiSW52YWxpZCBwcm9wOiB0eXBlIGNoZWNrIGZhaWxlZCBmb3IgcHJvcCBcXFwiXCIgKyBuYW1lICsgXCJcXFwiLlwiICtcbiAgICBcIiBFeHBlY3RlZCBcIiArIChleHBlY3RlZFR5cGVzLm1hcChjYXBpdGFsaXplKS5qb2luKCcsICcpKTtcbiAgdmFyIGV4cGVjdGVkVHlwZSA9IGV4cGVjdGVkVHlwZXNbMF07XG4gIHZhciByZWNlaXZlZFR5cGUgPSB0b1Jhd1R5cGUodmFsdWUpO1xuICAvLyBjaGVjayBpZiB3ZSBuZWVkIHRvIHNwZWNpZnkgZXhwZWN0ZWQgdmFsdWVcbiAgaWYgKFxuICAgIGV4cGVjdGVkVHlwZXMubGVuZ3RoID09PSAxICYmXG4gICAgaXNFeHBsaWNhYmxlKGV4cGVjdGVkVHlwZSkgJiZcbiAgICBpc0V4cGxpY2FibGUodHlwZW9mIHZhbHVlKSAmJlxuICAgICFpc0Jvb2xlYW4oZXhwZWN0ZWRUeXBlLCByZWNlaXZlZFR5cGUpXG4gICkge1xuICAgIG1lc3NhZ2UgKz0gXCIgd2l0aCB2YWx1ZSBcIiArIChzdHlsZVZhbHVlKHZhbHVlLCBleHBlY3RlZFR5cGUpKTtcbiAgfVxuICBtZXNzYWdlICs9IFwiLCBnb3QgXCIgKyByZWNlaXZlZFR5cGUgKyBcIiBcIjtcbiAgLy8gY2hlY2sgaWYgd2UgbmVlZCB0byBzcGVjaWZ5IHJlY2VpdmVkIHZhbHVlXG4gIGlmIChpc0V4cGxpY2FibGUocmVjZWl2ZWRUeXBlKSkge1xuICAgIG1lc3NhZ2UgKz0gXCJ3aXRoIHZhbHVlIFwiICsgKHN0eWxlVmFsdWUodmFsdWUsIHJlY2VpdmVkVHlwZSkpICsgXCIuXCI7XG4gIH1cbiAgcmV0dXJuIG1lc3NhZ2Vcbn1cblxuZnVuY3Rpb24gc3R5bGVWYWx1ZSAodmFsdWUsIHR5cGUpIHtcbiAgaWYgKHR5cGUgPT09ICdTdHJpbmcnKSB7XG4gICAgcmV0dXJuIChcIlxcXCJcIiArIHZhbHVlICsgXCJcXFwiXCIpXG4gIH0gZWxzZSBpZiAodHlwZSA9PT0gJ051bWJlcicpIHtcbiAgICByZXR1cm4gKFwiXCIgKyAoTnVtYmVyKHZhbHVlKSkpXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIChcIlwiICsgdmFsdWUpXG4gIH1cbn1cblxudmFyIEVYUExJQ0FCTEVfVFlQRVMgPSBbJ3N0cmluZycsICdudW1iZXInLCAnYm9vbGVhbiddO1xuZnVuY3Rpb24gaXNFeHBsaWNhYmxlICh2YWx1ZSkge1xuICByZXR1cm4gRVhQTElDQUJMRV9UWVBFUy5zb21lKGZ1bmN0aW9uIChlbGVtKSB7IHJldHVybiB2YWx1ZS50b0xvd2VyQ2FzZSgpID09PSBlbGVtOyB9KVxufVxuXG5mdW5jdGlvbiBpc0Jvb2xlYW4gKCkge1xuICB2YXIgYXJncyA9IFtdLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICB3aGlsZSAoIGxlbi0tICkgYXJnc1sgbGVuIF0gPSBhcmd1bWVudHNbIGxlbiBdO1xuXG4gIHJldHVybiBhcmdzLnNvbWUoZnVuY3Rpb24gKGVsZW0pIHsgcmV0dXJuIGVsZW0udG9Mb3dlckNhc2UoKSA9PT0gJ2Jvb2xlYW4nOyB9KVxufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gaGFuZGxlRXJyb3IgKGVyciwgdm0sIGluZm8pIHtcbiAgLy8gRGVhY3RpdmF0ZSBkZXBzIHRyYWNraW5nIHdoaWxlIHByb2Nlc3NpbmcgZXJyb3IgaGFuZGxlciB0byBhdm9pZCBwb3NzaWJsZSBpbmZpbml0ZSByZW5kZXJpbmcuXG4gIC8vIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL3Z1ZWpzL3Z1ZXgvaXNzdWVzLzE1MDVcbiAgcHVzaFRhcmdldCgpO1xuICB0cnkge1xuICAgIGlmICh2bSkge1xuICAgICAgdmFyIGN1ciA9IHZtO1xuICAgICAgd2hpbGUgKChjdXIgPSBjdXIuJHBhcmVudCkpIHtcbiAgICAgICAgdmFyIGhvb2tzID0gY3VyLiRvcHRpb25zLmVycm9yQ2FwdHVyZWQ7XG4gICAgICAgIGlmIChob29rcykge1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaG9va3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIHZhciBjYXB0dXJlID0gaG9va3NbaV0uY2FsbChjdXIsIGVyciwgdm0sIGluZm8pID09PSBmYWxzZTtcbiAgICAgICAgICAgICAgaWYgKGNhcHR1cmUpIHsgcmV0dXJuIH1cbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgZ2xvYmFsSGFuZGxlRXJyb3IoZSwgY3VyLCAnZXJyb3JDYXB0dXJlZCBob29rJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGdsb2JhbEhhbmRsZUVycm9yKGVyciwgdm0sIGluZm8pO1xuICB9IGZpbmFsbHkge1xuICAgIHBvcFRhcmdldCgpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGludm9rZVdpdGhFcnJvckhhbmRsaW5nIChcbiAgaGFuZGxlcixcbiAgY29udGV4dCxcbiAgYXJncyxcbiAgdm0sXG4gIGluZm9cbikge1xuICB2YXIgcmVzO1xuICB0cnkge1xuICAgIHJlcyA9IGFyZ3MgPyBoYW5kbGVyLmFwcGx5KGNvbnRleHQsIGFyZ3MpIDogaGFuZGxlci5jYWxsKGNvbnRleHQpO1xuICAgIGlmIChyZXMgJiYgIXJlcy5faXNWdWUgJiYgaXNQcm9taXNlKHJlcykgJiYgIXJlcy5faGFuZGxlZCkge1xuICAgICAgcmVzLmNhdGNoKGZ1bmN0aW9uIChlKSB7IHJldHVybiBoYW5kbGVFcnJvcihlLCB2bSwgaW5mbyArIFwiIChQcm9taXNlL2FzeW5jKVwiKTsgfSk7XG4gICAgICAvLyBpc3N1ZSAjOTUxMVxuICAgICAgLy8gYXZvaWQgY2F0Y2ggdHJpZ2dlcmluZyBtdWx0aXBsZSB0aW1lcyB3aGVuIG5lc3RlZCBjYWxsc1xuICAgICAgcmVzLl9oYW5kbGVkID0gdHJ1ZTtcbiAgICB9XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBoYW5kbGVFcnJvcihlLCB2bSwgaW5mbyk7XG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5mdW5jdGlvbiBnbG9iYWxIYW5kbGVFcnJvciAoZXJyLCB2bSwgaW5mbykge1xuICBpZiAoY29uZmlnLmVycm9ySGFuZGxlcikge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gY29uZmlnLmVycm9ySGFuZGxlci5jYWxsKG51bGwsIGVyciwgdm0sIGluZm8pXG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgLy8gaWYgdGhlIHVzZXIgaW50ZW50aW9uYWxseSB0aHJvd3MgdGhlIG9yaWdpbmFsIGVycm9yIGluIHRoZSBoYW5kbGVyLFxuICAgICAgLy8gZG8gbm90IGxvZyBpdCB0d2ljZVxuICAgICAgaWYgKGUgIT09IGVycikge1xuICAgICAgICBsb2dFcnJvcihlLCBudWxsLCAnY29uZmlnLmVycm9ySGFuZGxlcicpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBsb2dFcnJvcihlcnIsIHZtLCBpbmZvKTtcbn1cblxuZnVuY3Rpb24gbG9nRXJyb3IgKGVyciwgdm0sIGluZm8pIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICB3YXJuKChcIkVycm9yIGluIFwiICsgaW5mbyArIFwiOiBcXFwiXCIgKyAoZXJyLnRvU3RyaW5nKCkpICsgXCJcXFwiXCIpLCB2bSk7XG4gIH1cbiAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgaWYgKChpbkJyb3dzZXIgfHwgaW5XZWV4KSAmJiB0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBjb25zb2xlLmVycm9yKGVycik7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgZXJyXG4gIH1cbn1cblxuLyogICovXG5cbnZhciBpc1VzaW5nTWljcm9UYXNrID0gZmFsc2U7XG5cbnZhciBjYWxsYmFja3MgPSBbXTtcbnZhciBwZW5kaW5nID0gZmFsc2U7XG5cbmZ1bmN0aW9uIGZsdXNoQ2FsbGJhY2tzICgpIHtcbiAgcGVuZGluZyA9IGZhbHNlO1xuICB2YXIgY29waWVzID0gY2FsbGJhY2tzLnNsaWNlKDApO1xuICBjYWxsYmFja3MubGVuZ3RoID0gMDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb3BpZXMubGVuZ3RoOyBpKyspIHtcbiAgICBjb3BpZXNbaV0oKTtcbiAgfVxufVxuXG4vLyBIZXJlIHdlIGhhdmUgYXN5bmMgZGVmZXJyaW5nIHdyYXBwZXJzIHVzaW5nIG1pY3JvdGFza3MuXG4vLyBJbiAyLjUgd2UgdXNlZCAobWFjcm8pIHRhc2tzIChpbiBjb21iaW5hdGlvbiB3aXRoIG1pY3JvdGFza3MpLlxuLy8gSG93ZXZlciwgaXQgaGFzIHN1YnRsZSBwcm9ibGVtcyB3aGVuIHN0YXRlIGlzIGNoYW5nZWQgcmlnaHQgYmVmb3JlIHJlcGFpbnRcbi8vIChlLmcuICM2ODEzLCBvdXQtaW4gdHJhbnNpdGlvbnMpLlxuLy8gQWxzbywgdXNpbmcgKG1hY3JvKSB0YXNrcyBpbiBldmVudCBoYW5kbGVyIHdvdWxkIGNhdXNlIHNvbWUgd2VpcmQgYmVoYXZpb3JzXG4vLyB0aGF0IGNhbm5vdCBiZSBjaXJjdW12ZW50ZWQgKGUuZy4gIzcxMDksICM3MTUzLCAjNzU0NiwgIzc4MzQsICM4MTA5KS5cbi8vIFNvIHdlIG5vdyB1c2UgbWljcm90YXNrcyBldmVyeXdoZXJlLCBhZ2Fpbi5cbi8vIEEgbWFqb3IgZHJhd2JhY2sgb2YgdGhpcyB0cmFkZW9mZiBpcyB0aGF0IHRoZXJlIGFyZSBzb21lIHNjZW5hcmlvc1xuLy8gd2hlcmUgbWljcm90YXNrcyBoYXZlIHRvbyBoaWdoIGEgcHJpb3JpdHkgYW5kIGZpcmUgaW4gYmV0d2VlbiBzdXBwb3NlZGx5XG4vLyBzZXF1ZW50aWFsIGV2ZW50cyAoZS5nLiAjNDUyMSwgIzY2OTAsIHdoaWNoIGhhdmUgd29ya2Fyb3VuZHMpXG4vLyBvciBldmVuIGJldHdlZW4gYnViYmxpbmcgb2YgdGhlIHNhbWUgZXZlbnQgKCM2NTY2KS5cbnZhciB0aW1lckZ1bmM7XG5cbi8vIFRoZSBuZXh0VGljayBiZWhhdmlvciBsZXZlcmFnZXMgdGhlIG1pY3JvdGFzayBxdWV1ZSwgd2hpY2ggY2FuIGJlIGFjY2Vzc2VkXG4vLyB2aWEgZWl0aGVyIG5hdGl2ZSBQcm9taXNlLnRoZW4gb3IgTXV0YXRpb25PYnNlcnZlci5cbi8vIE11dGF0aW9uT2JzZXJ2ZXIgaGFzIHdpZGVyIHN1cHBvcnQsIGhvd2V2ZXIgaXQgaXMgc2VyaW91c2x5IGJ1Z2dlZCBpblxuLy8gVUlXZWJWaWV3IGluIGlPUyA+PSA5LjMuMyB3aGVuIHRyaWdnZXJlZCBpbiB0b3VjaCBldmVudCBoYW5kbGVycy4gSXRcbi8vIGNvbXBsZXRlbHkgc3RvcHMgd29ya2luZyBhZnRlciB0cmlnZ2VyaW5nIGEgZmV3IHRpbWVzLi4uIHNvLCBpZiBuYXRpdmVcbi8vIFByb21pc2UgaXMgYXZhaWxhYmxlLCB3ZSB3aWxsIHVzZSBpdDpcbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0LCAkZmxvdy1kaXNhYmxlLWxpbmUgKi9cbmlmICh0eXBlb2YgUHJvbWlzZSAhPT0gJ3VuZGVmaW5lZCcgJiYgaXNOYXRpdmUoUHJvbWlzZSkpIHtcbiAgdmFyIHAgPSBQcm9taXNlLnJlc29sdmUoKTtcbiAgdGltZXJGdW5jID0gZnVuY3Rpb24gKCkge1xuICAgIHAudGhlbihmbHVzaENhbGxiYWNrcyk7XG4gICAgLy8gSW4gcHJvYmxlbWF0aWMgVUlXZWJWaWV3cywgUHJvbWlzZS50aGVuIGRvZXNuJ3QgY29tcGxldGVseSBicmVhaywgYnV0XG4gICAgLy8gaXQgY2FuIGdldCBzdHVjayBpbiBhIHdlaXJkIHN0YXRlIHdoZXJlIGNhbGxiYWNrcyBhcmUgcHVzaGVkIGludG8gdGhlXG4gICAgLy8gbWljcm90YXNrIHF1ZXVlIGJ1dCB0aGUgcXVldWUgaXNuJ3QgYmVpbmcgZmx1c2hlZCwgdW50aWwgdGhlIGJyb3dzZXJcbiAgICAvLyBuZWVkcyB0byBkbyBzb21lIG90aGVyIHdvcmssIGUuZy4gaGFuZGxlIGEgdGltZXIuIFRoZXJlZm9yZSB3ZSBjYW5cbiAgICAvLyBcImZvcmNlXCIgdGhlIG1pY3JvdGFzayBxdWV1ZSB0byBiZSBmbHVzaGVkIGJ5IGFkZGluZyBhbiBlbXB0eSB0aW1lci5cbiAgICBpZiAoaXNJT1MpIHsgc2V0VGltZW91dChub29wKTsgfVxuICB9O1xuICBpc1VzaW5nTWljcm9UYXNrID0gdHJ1ZTtcbn0gZWxzZSBpZiAoIWlzSUUgJiYgdHlwZW9mIE11dGF0aW9uT2JzZXJ2ZXIgIT09ICd1bmRlZmluZWQnICYmIChcbiAgaXNOYXRpdmUoTXV0YXRpb25PYnNlcnZlcikgfHxcbiAgLy8gUGhhbnRvbUpTIGFuZCBpT1MgNy54XG4gIE11dGF0aW9uT2JzZXJ2ZXIudG9TdHJpbmcoKSA9PT0gJ1tvYmplY3QgTXV0YXRpb25PYnNlcnZlckNvbnN0cnVjdG9yXSdcbikpIHtcbiAgLy8gVXNlIE11dGF0aW9uT2JzZXJ2ZXIgd2hlcmUgbmF0aXZlIFByb21pc2UgaXMgbm90IGF2YWlsYWJsZSxcbiAgLy8gZS5nLiBQaGFudG9tSlMsIGlPUzcsIEFuZHJvaWQgNC40XG4gIC8vICgjNjQ2NiBNdXRhdGlvbk9ic2VydmVyIGlzIHVucmVsaWFibGUgaW4gSUUxMSlcbiAgdmFyIGNvdW50ZXIgPSAxO1xuICB2YXIgb2JzZXJ2ZXIgPSBuZXcgTXV0YXRpb25PYnNlcnZlcihmbHVzaENhbGxiYWNrcyk7XG4gIHZhciB0ZXh0Tm9kZSA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKFN0cmluZyhjb3VudGVyKSk7XG4gIG9ic2VydmVyLm9ic2VydmUodGV4dE5vZGUsIHtcbiAgICBjaGFyYWN0ZXJEYXRhOiB0cnVlXG4gIH0pO1xuICB0aW1lckZ1bmMgPSBmdW5jdGlvbiAoKSB7XG4gICAgY291bnRlciA9IChjb3VudGVyICsgMSkgJSAyO1xuICAgIHRleHROb2RlLmRhdGEgPSBTdHJpbmcoY291bnRlcik7XG4gIH07XG4gIGlzVXNpbmdNaWNyb1Rhc2sgPSB0cnVlO1xufSBlbHNlIGlmICh0eXBlb2Ygc2V0SW1tZWRpYXRlICE9PSAndW5kZWZpbmVkJyAmJiBpc05hdGl2ZShzZXRJbW1lZGlhdGUpKSB7XG4gIC8vIEZhbGxiYWNrIHRvIHNldEltbWVkaWF0ZS5cbiAgLy8gVGVjaG5pY2FsbHkgaXQgbGV2ZXJhZ2VzIHRoZSAobWFjcm8pIHRhc2sgcXVldWUsXG4gIC8vIGJ1dCBpdCBpcyBzdGlsbCBhIGJldHRlciBjaG9pY2UgdGhhbiBzZXRUaW1lb3V0LlxuICB0aW1lckZ1bmMgPSBmdW5jdGlvbiAoKSB7XG4gICAgc2V0SW1tZWRpYXRlKGZsdXNoQ2FsbGJhY2tzKTtcbiAgfTtcbn0gZWxzZSB7XG4gIC8vIEZhbGxiYWNrIHRvIHNldFRpbWVvdXQuXG4gIHRpbWVyRnVuYyA9IGZ1bmN0aW9uICgpIHtcbiAgICBzZXRUaW1lb3V0KGZsdXNoQ2FsbGJhY2tzLCAwKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gbmV4dFRpY2sgKGNiLCBjdHgpIHtcbiAgdmFyIF9yZXNvbHZlO1xuICBjYWxsYmFja3MucHVzaChmdW5jdGlvbiAoKSB7XG4gICAgaWYgKGNiKSB7XG4gICAgICB0cnkge1xuICAgICAgICBjYi5jYWxsKGN0eCk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGhhbmRsZUVycm9yKGUsIGN0eCwgJ25leHRUaWNrJyk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChfcmVzb2x2ZSkge1xuICAgICAgX3Jlc29sdmUoY3R4KTtcbiAgICB9XG4gIH0pO1xuICBpZiAoIXBlbmRpbmcpIHtcbiAgICBwZW5kaW5nID0gdHJ1ZTtcbiAgICB0aW1lckZ1bmMoKTtcbiAgfVxuICAvLyAkZmxvdy1kaXNhYmxlLWxpbmVcbiAgaWYgKCFjYiAmJiB0eXBlb2YgUHJvbWlzZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUpIHtcbiAgICAgIF9yZXNvbHZlID0gcmVzb2x2ZTtcbiAgICB9KVxuICB9XG59XG5cbi8qICAqL1xuXG4vKiBub3QgdHlwZSBjaGVja2luZyB0aGlzIGZpbGUgYmVjYXVzZSBmbG93IGRvZXNuJ3QgcGxheSB3ZWxsIHdpdGggUHJveHkgKi9cblxudmFyIGluaXRQcm94eTtcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgdmFyIGFsbG93ZWRHbG9iYWxzID0gbWFrZU1hcChcbiAgICAnSW5maW5pdHksdW5kZWZpbmVkLE5hTixpc0Zpbml0ZSxpc05hTiwnICtcbiAgICAncGFyc2VGbG9hdCxwYXJzZUludCxkZWNvZGVVUkksZGVjb2RlVVJJQ29tcG9uZW50LGVuY29kZVVSSSxlbmNvZGVVUklDb21wb25lbnQsJyArXG4gICAgJ01hdGgsTnVtYmVyLERhdGUsQXJyYXksT2JqZWN0LEJvb2xlYW4sU3RyaW5nLFJlZ0V4cCxNYXAsU2V0LEpTT04sSW50bCxCaWdJbnQsJyArXG4gICAgJ3JlcXVpcmUnIC8vIGZvciBXZWJwYWNrL0Jyb3dzZXJpZnlcbiAgKTtcblxuICB2YXIgd2Fybk5vblByZXNlbnQgPSBmdW5jdGlvbiAodGFyZ2V0LCBrZXkpIHtcbiAgICB3YXJuKFxuICAgICAgXCJQcm9wZXJ0eSBvciBtZXRob2QgXFxcIlwiICsga2V5ICsgXCJcXFwiIGlzIG5vdCBkZWZpbmVkIG9uIHRoZSBpbnN0YW5jZSBidXQgXCIgK1xuICAgICAgJ3JlZmVyZW5jZWQgZHVyaW5nIHJlbmRlci4gTWFrZSBzdXJlIHRoYXQgdGhpcyBwcm9wZXJ0eSBpcyByZWFjdGl2ZSwgJyArXG4gICAgICAnZWl0aGVyIGluIHRoZSBkYXRhIG9wdGlvbiwgb3IgZm9yIGNsYXNzLWJhc2VkIGNvbXBvbmVudHMsIGJ5ICcgK1xuICAgICAgJ2luaXRpYWxpemluZyB0aGUgcHJvcGVydHkuICcgK1xuICAgICAgJ1NlZTogaHR0cHM6Ly92dWVqcy5vcmcvdjIvZ3VpZGUvcmVhY3Rpdml0eS5odG1sI0RlY2xhcmluZy1SZWFjdGl2ZS1Qcm9wZXJ0aWVzLicsXG4gICAgICB0YXJnZXRcbiAgICApO1xuICB9O1xuXG4gIHZhciB3YXJuUmVzZXJ2ZWRQcmVmaXggPSBmdW5jdGlvbiAodGFyZ2V0LCBrZXkpIHtcbiAgICB3YXJuKFxuICAgICAgXCJQcm9wZXJ0eSBcXFwiXCIgKyBrZXkgKyBcIlxcXCIgbXVzdCBiZSBhY2Nlc3NlZCB3aXRoIFxcXCIkZGF0YS5cIiArIGtleSArIFwiXFxcIiBiZWNhdXNlIFwiICtcbiAgICAgICdwcm9wZXJ0aWVzIHN0YXJ0aW5nIHdpdGggXCIkXCIgb3IgXCJfXCIgYXJlIG5vdCBwcm94aWVkIGluIHRoZSBWdWUgaW5zdGFuY2UgdG8gJyArXG4gICAgICAncHJldmVudCBjb25mbGljdHMgd2l0aCBWdWUgaW50ZXJuYWxzLiAnICtcbiAgICAgICdTZWU6IGh0dHBzOi8vdnVlanMub3JnL3YyL2FwaS8jZGF0YScsXG4gICAgICB0YXJnZXRcbiAgICApO1xuICB9O1xuXG4gIHZhciBoYXNQcm94eSA9XG4gICAgdHlwZW9mIFByb3h5ICE9PSAndW5kZWZpbmVkJyAmJiBpc05hdGl2ZShQcm94eSk7XG5cbiAgaWYgKGhhc1Byb3h5KSB7XG4gICAgdmFyIGlzQnVpbHRJbk1vZGlmaWVyID0gbWFrZU1hcCgnc3RvcCxwcmV2ZW50LHNlbGYsY3RybCxzaGlmdCxhbHQsbWV0YSxleGFjdCcpO1xuICAgIGNvbmZpZy5rZXlDb2RlcyA9IG5ldyBQcm94eShjb25maWcua2V5Q29kZXMsIHtcbiAgICAgIHNldDogZnVuY3Rpb24gc2V0ICh0YXJnZXQsIGtleSwgdmFsdWUpIHtcbiAgICAgICAgaWYgKGlzQnVpbHRJbk1vZGlmaWVyKGtleSkpIHtcbiAgICAgICAgICB3YXJuKChcIkF2b2lkIG92ZXJ3cml0aW5nIGJ1aWx0LWluIG1vZGlmaWVyIGluIGNvbmZpZy5rZXlDb2RlczogLlwiICsga2V5KSk7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGFyZ2V0W2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICB2YXIgaGFzSGFuZGxlciA9IHtcbiAgICBoYXM6IGZ1bmN0aW9uIGhhcyAodGFyZ2V0LCBrZXkpIHtcbiAgICAgIHZhciBoYXMgPSBrZXkgaW4gdGFyZ2V0O1xuICAgICAgdmFyIGlzQWxsb3dlZCA9IGFsbG93ZWRHbG9iYWxzKGtleSkgfHxcbiAgICAgICAgKHR5cGVvZiBrZXkgPT09ICdzdHJpbmcnICYmIGtleS5jaGFyQXQoMCkgPT09ICdfJyAmJiAhKGtleSBpbiB0YXJnZXQuJGRhdGEpKTtcbiAgICAgIGlmICghaGFzICYmICFpc0FsbG93ZWQpIHtcbiAgICAgICAgaWYgKGtleSBpbiB0YXJnZXQuJGRhdGEpIHsgd2FyblJlc2VydmVkUHJlZml4KHRhcmdldCwga2V5KTsgfVxuICAgICAgICBlbHNlIHsgd2Fybk5vblByZXNlbnQodGFyZ2V0LCBrZXkpOyB9XG4gICAgICB9XG4gICAgICByZXR1cm4gaGFzIHx8ICFpc0FsbG93ZWRcbiAgICB9XG4gIH07XG5cbiAgdmFyIGdldEhhbmRsZXIgPSB7XG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQgKHRhcmdldCwga2V5KSB7XG4gICAgICBpZiAodHlwZW9mIGtleSA9PT0gJ3N0cmluZycgJiYgIShrZXkgaW4gdGFyZ2V0KSkge1xuICAgICAgICBpZiAoa2V5IGluIHRhcmdldC4kZGF0YSkgeyB3YXJuUmVzZXJ2ZWRQcmVmaXgodGFyZ2V0LCBrZXkpOyB9XG4gICAgICAgIGVsc2UgeyB3YXJuTm9uUHJlc2VudCh0YXJnZXQsIGtleSk7IH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0YXJnZXRba2V5XVxuICAgIH1cbiAgfTtcblxuICBpbml0UHJveHkgPSBmdW5jdGlvbiBpbml0UHJveHkgKHZtKSB7XG4gICAgaWYgKGhhc1Byb3h5KSB7XG4gICAgICAvLyBkZXRlcm1pbmUgd2hpY2ggcHJveHkgaGFuZGxlciB0byB1c2VcbiAgICAgIHZhciBvcHRpb25zID0gdm0uJG9wdGlvbnM7XG4gICAgICB2YXIgaGFuZGxlcnMgPSBvcHRpb25zLnJlbmRlciAmJiBvcHRpb25zLnJlbmRlci5fd2l0aFN0cmlwcGVkXG4gICAgICAgID8gZ2V0SGFuZGxlclxuICAgICAgICA6IGhhc0hhbmRsZXI7XG4gICAgICB2bS5fcmVuZGVyUHJveHkgPSBuZXcgUHJveHkodm0sIGhhbmRsZXJzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdm0uX3JlbmRlclByb3h5ID0gdm07XG4gICAgfVxuICB9O1xufVxuXG4vKiAgKi9cblxudmFyIHNlZW5PYmplY3RzID0gbmV3IF9TZXQoKTtcblxuLyoqXG4gKiBSZWN1cnNpdmVseSB0cmF2ZXJzZSBhbiBvYmplY3QgdG8gZXZva2UgYWxsIGNvbnZlcnRlZFxuICogZ2V0dGVycywgc28gdGhhdCBldmVyeSBuZXN0ZWQgcHJvcGVydHkgaW5zaWRlIHRoZSBvYmplY3RcbiAqIGlzIGNvbGxlY3RlZCBhcyBhIFwiZGVlcFwiIGRlcGVuZGVuY3kuXG4gKi9cbmZ1bmN0aW9uIHRyYXZlcnNlICh2YWwpIHtcbiAgX3RyYXZlcnNlKHZhbCwgc2Vlbk9iamVjdHMpO1xuICBzZWVuT2JqZWN0cy5jbGVhcigpO1xufVxuXG5mdW5jdGlvbiBfdHJhdmVyc2UgKHZhbCwgc2Vlbikge1xuICB2YXIgaSwga2V5cztcbiAgdmFyIGlzQSA9IEFycmF5LmlzQXJyYXkodmFsKTtcbiAgaWYgKCghaXNBICYmICFpc09iamVjdCh2YWwpKSB8fCBPYmplY3QuaXNGcm96ZW4odmFsKSB8fCB2YWwgaW5zdGFuY2VvZiBWTm9kZSkge1xuICAgIHJldHVyblxuICB9XG4gIGlmICh2YWwuX19vYl9fKSB7XG4gICAgdmFyIGRlcElkID0gdmFsLl9fb2JfXy5kZXAuaWQ7XG4gICAgaWYgKHNlZW4uaGFzKGRlcElkKSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIHNlZW4uYWRkKGRlcElkKTtcbiAgfVxuICBpZiAoaXNBKSB7XG4gICAgaSA9IHZhbC5sZW5ndGg7XG4gICAgd2hpbGUgKGktLSkgeyBfdHJhdmVyc2UodmFsW2ldLCBzZWVuKTsgfVxuICB9IGVsc2Uge1xuICAgIGtleXMgPSBPYmplY3Qua2V5cyh2YWwpO1xuICAgIGkgPSBrZXlzLmxlbmd0aDtcbiAgICB3aGlsZSAoaS0tKSB7IF90cmF2ZXJzZSh2YWxba2V5c1tpXV0sIHNlZW4pOyB9XG4gIH1cbn1cblxudmFyIG1hcms7XG52YXIgbWVhc3VyZTtcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgdmFyIHBlcmYgPSBpbkJyb3dzZXIgJiYgd2luZG93LnBlcmZvcm1hbmNlO1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKFxuICAgIHBlcmYgJiZcbiAgICBwZXJmLm1hcmsgJiZcbiAgICBwZXJmLm1lYXN1cmUgJiZcbiAgICBwZXJmLmNsZWFyTWFya3MgJiZcbiAgICBwZXJmLmNsZWFyTWVhc3VyZXNcbiAgKSB7XG4gICAgbWFyayA9IGZ1bmN0aW9uICh0YWcpIHsgcmV0dXJuIHBlcmYubWFyayh0YWcpOyB9O1xuICAgIG1lYXN1cmUgPSBmdW5jdGlvbiAobmFtZSwgc3RhcnRUYWcsIGVuZFRhZykge1xuICAgICAgcGVyZi5tZWFzdXJlKG5hbWUsIHN0YXJ0VGFnLCBlbmRUYWcpO1xuICAgICAgcGVyZi5jbGVhck1hcmtzKHN0YXJ0VGFnKTtcbiAgICAgIHBlcmYuY2xlYXJNYXJrcyhlbmRUYWcpO1xuICAgICAgLy8gcGVyZi5jbGVhck1lYXN1cmVzKG5hbWUpXG4gICAgfTtcbiAgfVxufVxuXG4vKiAgKi9cblxudmFyIG5vcm1hbGl6ZUV2ZW50ID0gY2FjaGVkKGZ1bmN0aW9uIChuYW1lKSB7XG4gIHZhciBwYXNzaXZlID0gbmFtZS5jaGFyQXQoMCkgPT09ICcmJztcbiAgbmFtZSA9IHBhc3NpdmUgPyBuYW1lLnNsaWNlKDEpIDogbmFtZTtcbiAgdmFyIG9uY2UkJDEgPSBuYW1lLmNoYXJBdCgwKSA9PT0gJ34nOyAvLyBQcmVmaXhlZCBsYXN0LCBjaGVja2VkIGZpcnN0XG4gIG5hbWUgPSBvbmNlJCQxID8gbmFtZS5zbGljZSgxKSA6IG5hbWU7XG4gIHZhciBjYXB0dXJlID0gbmFtZS5jaGFyQXQoMCkgPT09ICchJztcbiAgbmFtZSA9IGNhcHR1cmUgPyBuYW1lLnNsaWNlKDEpIDogbmFtZTtcbiAgcmV0dXJuIHtcbiAgICBuYW1lOiBuYW1lLFxuICAgIG9uY2U6IG9uY2UkJDEsXG4gICAgY2FwdHVyZTogY2FwdHVyZSxcbiAgICBwYXNzaXZlOiBwYXNzaXZlXG4gIH1cbn0pO1xuXG5mdW5jdGlvbiBjcmVhdGVGbkludm9rZXIgKGZucywgdm0pIHtcbiAgZnVuY3Rpb24gaW52b2tlciAoKSB7XG4gICAgdmFyIGFyZ3VtZW50cyQxID0gYXJndW1lbnRzO1xuXG4gICAgdmFyIGZucyA9IGludm9rZXIuZm5zO1xuICAgIGlmIChBcnJheS5pc0FycmF5KGZucykpIHtcbiAgICAgIHZhciBjbG9uZWQgPSBmbnMuc2xpY2UoKTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2xvbmVkLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGludm9rZVdpdGhFcnJvckhhbmRsaW5nKGNsb25lZFtpXSwgbnVsbCwgYXJndW1lbnRzJDEsIHZtLCBcInYtb24gaGFuZGxlclwiKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gcmV0dXJuIGhhbmRsZXIgcmV0dXJuIHZhbHVlIGZvciBzaW5nbGUgaGFuZGxlcnNcbiAgICAgIHJldHVybiBpbnZva2VXaXRoRXJyb3JIYW5kbGluZyhmbnMsIG51bGwsIGFyZ3VtZW50cywgdm0sIFwidi1vbiBoYW5kbGVyXCIpXG4gICAgfVxuICB9XG4gIGludm9rZXIuZm5zID0gZm5zO1xuICByZXR1cm4gaW52b2tlclxufVxuXG5mdW5jdGlvbiB1cGRhdGVMaXN0ZW5lcnMgKFxuICBvbixcbiAgb2xkT24sXG4gIGFkZCxcbiAgcmVtb3ZlJCQxLFxuICBjcmVhdGVPbmNlSGFuZGxlcixcbiAgdm1cbikge1xuICB2YXIgbmFtZSwgZGVmJCQxLCBjdXIsIG9sZCwgZXZlbnQ7XG4gIGZvciAobmFtZSBpbiBvbikge1xuICAgIGRlZiQkMSA9IGN1ciA9IG9uW25hbWVdO1xuICAgIG9sZCA9IG9sZE9uW25hbWVdO1xuICAgIGV2ZW50ID0gbm9ybWFsaXplRXZlbnQobmFtZSk7XG4gICAgaWYgKGlzVW5kZWYoY3VyKSkge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKFxuICAgICAgICBcIkludmFsaWQgaGFuZGxlciBmb3IgZXZlbnQgXFxcIlwiICsgKGV2ZW50Lm5hbWUpICsgXCJcXFwiOiBnb3QgXCIgKyBTdHJpbmcoY3VyKSxcbiAgICAgICAgdm1cbiAgICAgICk7XG4gICAgfSBlbHNlIGlmIChpc1VuZGVmKG9sZCkpIHtcbiAgICAgIGlmIChpc1VuZGVmKGN1ci5mbnMpKSB7XG4gICAgICAgIGN1ciA9IG9uW25hbWVdID0gY3JlYXRlRm5JbnZva2VyKGN1ciwgdm0pO1xuICAgICAgfVxuICAgICAgaWYgKGlzVHJ1ZShldmVudC5vbmNlKSkge1xuICAgICAgICBjdXIgPSBvbltuYW1lXSA9IGNyZWF0ZU9uY2VIYW5kbGVyKGV2ZW50Lm5hbWUsIGN1ciwgZXZlbnQuY2FwdHVyZSk7XG4gICAgICB9XG4gICAgICBhZGQoZXZlbnQubmFtZSwgY3VyLCBldmVudC5jYXB0dXJlLCBldmVudC5wYXNzaXZlLCBldmVudC5wYXJhbXMpO1xuICAgIH0gZWxzZSBpZiAoY3VyICE9PSBvbGQpIHtcbiAgICAgIG9sZC5mbnMgPSBjdXI7XG4gICAgICBvbltuYW1lXSA9IG9sZDtcbiAgICB9XG4gIH1cbiAgZm9yIChuYW1lIGluIG9sZE9uKSB7XG4gICAgaWYgKGlzVW5kZWYob25bbmFtZV0pKSB7XG4gICAgICBldmVudCA9IG5vcm1hbGl6ZUV2ZW50KG5hbWUpO1xuICAgICAgcmVtb3ZlJCQxKGV2ZW50Lm5hbWUsIG9sZE9uW25hbWVdLCBldmVudC5jYXB0dXJlKTtcbiAgICB9XG4gIH1cbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIG1lcmdlVk5vZGVIb29rIChkZWYsIGhvb2tLZXksIGhvb2spIHtcbiAgaWYgKGRlZiBpbnN0YW5jZW9mIFZOb2RlKSB7XG4gICAgZGVmID0gZGVmLmRhdGEuaG9vayB8fCAoZGVmLmRhdGEuaG9vayA9IHt9KTtcbiAgfVxuICB2YXIgaW52b2tlcjtcbiAgdmFyIG9sZEhvb2sgPSBkZWZbaG9va0tleV07XG5cbiAgZnVuY3Rpb24gd3JhcHBlZEhvb2sgKCkge1xuICAgIGhvb2suYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAvLyBpbXBvcnRhbnQ6IHJlbW92ZSBtZXJnZWQgaG9vayB0byBlbnN1cmUgaXQncyBjYWxsZWQgb25seSBvbmNlXG4gICAgLy8gYW5kIHByZXZlbnQgbWVtb3J5IGxlYWtcbiAgICByZW1vdmUoaW52b2tlci5mbnMsIHdyYXBwZWRIb29rKTtcbiAgfVxuXG4gIGlmIChpc1VuZGVmKG9sZEhvb2spKSB7XG4gICAgLy8gbm8gZXhpc3RpbmcgaG9va1xuICAgIGludm9rZXIgPSBjcmVhdGVGbkludm9rZXIoW3dyYXBwZWRIb29rXSk7XG4gIH0gZWxzZSB7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKGlzRGVmKG9sZEhvb2suZm5zKSAmJiBpc1RydWUob2xkSG9vay5tZXJnZWQpKSB7XG4gICAgICAvLyBhbHJlYWR5IGEgbWVyZ2VkIGludm9rZXJcbiAgICAgIGludm9rZXIgPSBvbGRIb29rO1xuICAgICAgaW52b2tlci5mbnMucHVzaCh3cmFwcGVkSG9vayk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGV4aXN0aW5nIHBsYWluIGhvb2tcbiAgICAgIGludm9rZXIgPSBjcmVhdGVGbkludm9rZXIoW29sZEhvb2ssIHdyYXBwZWRIb29rXSk7XG4gICAgfVxuICB9XG5cbiAgaW52b2tlci5tZXJnZWQgPSB0cnVlO1xuICBkZWZbaG9va0tleV0gPSBpbnZva2VyO1xufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gZXh0cmFjdFByb3BzRnJvbVZOb2RlRGF0YSAoXG4gIGRhdGEsXG4gIEN0b3IsXG4gIHRhZ1xuKSB7XG4gIC8vIHdlIGFyZSBvbmx5IGV4dHJhY3RpbmcgcmF3IHZhbHVlcyBoZXJlLlxuICAvLyB2YWxpZGF0aW9uIGFuZCBkZWZhdWx0IHZhbHVlcyBhcmUgaGFuZGxlZCBpbiB0aGUgY2hpbGRcbiAgLy8gY29tcG9uZW50IGl0c2VsZi5cbiAgdmFyIHByb3BPcHRpb25zID0gQ3Rvci5vcHRpb25zLnByb3BzO1xuICBpZiAoaXNVbmRlZihwcm9wT3B0aW9ucykpIHtcbiAgICByZXR1cm5cbiAgfVxuICB2YXIgcmVzID0ge307XG4gIHZhciBhdHRycyA9IGRhdGEuYXR0cnM7XG4gIHZhciBwcm9wcyA9IGRhdGEucHJvcHM7XG4gIGlmIChpc0RlZihhdHRycykgfHwgaXNEZWYocHJvcHMpKSB7XG4gICAgZm9yICh2YXIga2V5IGluIHByb3BPcHRpb25zKSB7XG4gICAgICB2YXIgYWx0S2V5ID0gaHlwaGVuYXRlKGtleSk7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICB2YXIga2V5SW5Mb3dlckNhc2UgPSBrZXkudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgaWYgKFxuICAgICAgICAgIGtleSAhPT0ga2V5SW5Mb3dlckNhc2UgJiZcbiAgICAgICAgICBhdHRycyAmJiBoYXNPd24oYXR0cnMsIGtleUluTG93ZXJDYXNlKVxuICAgICAgICApIHtcbiAgICAgICAgICB0aXAoXG4gICAgICAgICAgICBcIlByb3AgXFxcIlwiICsga2V5SW5Mb3dlckNhc2UgKyBcIlxcXCIgaXMgcGFzc2VkIHRvIGNvbXBvbmVudCBcIiArXG4gICAgICAgICAgICAoZm9ybWF0Q29tcG9uZW50TmFtZSh0YWcgfHwgQ3RvcikpICsgXCIsIGJ1dCB0aGUgZGVjbGFyZWQgcHJvcCBuYW1lIGlzXCIgK1xuICAgICAgICAgICAgXCIgXFxcIlwiICsga2V5ICsgXCJcXFwiLiBcIiArXG4gICAgICAgICAgICBcIk5vdGUgdGhhdCBIVE1MIGF0dHJpYnV0ZXMgYXJlIGNhc2UtaW5zZW5zaXRpdmUgYW5kIGNhbWVsQ2FzZWQgXCIgK1xuICAgICAgICAgICAgXCJwcm9wcyBuZWVkIHRvIHVzZSB0aGVpciBrZWJhYi1jYXNlIGVxdWl2YWxlbnRzIHdoZW4gdXNpbmcgaW4tRE9NIFwiICtcbiAgICAgICAgICAgIFwidGVtcGxhdGVzLiBZb3Ugc2hvdWxkIHByb2JhYmx5IHVzZSBcXFwiXCIgKyBhbHRLZXkgKyBcIlxcXCIgaW5zdGVhZCBvZiBcXFwiXCIgKyBrZXkgKyBcIlxcXCIuXCJcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjaGVja1Byb3AocmVzLCBwcm9wcywga2V5LCBhbHRLZXksIHRydWUpIHx8XG4gICAgICBjaGVja1Byb3AocmVzLCBhdHRycywga2V5LCBhbHRLZXksIGZhbHNlKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5mdW5jdGlvbiBjaGVja1Byb3AgKFxuICByZXMsXG4gIGhhc2gsXG4gIGtleSxcbiAgYWx0S2V5LFxuICBwcmVzZXJ2ZVxuKSB7XG4gIGlmIChpc0RlZihoYXNoKSkge1xuICAgIGlmIChoYXNPd24oaGFzaCwga2V5KSkge1xuICAgICAgcmVzW2tleV0gPSBoYXNoW2tleV07XG4gICAgICBpZiAoIXByZXNlcnZlKSB7XG4gICAgICAgIGRlbGV0ZSBoYXNoW2tleV07XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH0gZWxzZSBpZiAoaGFzT3duKGhhc2gsIGFsdEtleSkpIHtcbiAgICAgIHJlc1trZXldID0gaGFzaFthbHRLZXldO1xuICAgICAgaWYgKCFwcmVzZXJ2ZSkge1xuICAgICAgICBkZWxldGUgaGFzaFthbHRLZXldO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlXG59XG5cbi8qICAqL1xuXG4vLyBUaGUgdGVtcGxhdGUgY29tcGlsZXIgYXR0ZW1wdHMgdG8gbWluaW1pemUgdGhlIG5lZWQgZm9yIG5vcm1hbGl6YXRpb24gYnlcbi8vIHN0YXRpY2FsbHkgYW5hbHl6aW5nIHRoZSB0ZW1wbGF0ZSBhdCBjb21waWxlIHRpbWUuXG4vL1xuLy8gRm9yIHBsYWluIEhUTUwgbWFya3VwLCBub3JtYWxpemF0aW9uIGNhbiBiZSBjb21wbGV0ZWx5IHNraXBwZWQgYmVjYXVzZSB0aGVcbi8vIGdlbmVyYXRlZCByZW5kZXIgZnVuY3Rpb24gaXMgZ3VhcmFudGVlZCB0byByZXR1cm4gQXJyYXk8Vk5vZGU+LiBUaGVyZSBhcmVcbi8vIHR3byBjYXNlcyB3aGVyZSBleHRyYSBub3JtYWxpemF0aW9uIGlzIG5lZWRlZDpcblxuLy8gMS4gV2hlbiB0aGUgY2hpbGRyZW4gY29udGFpbnMgY29tcG9uZW50cyAtIGJlY2F1c2UgYSBmdW5jdGlvbmFsIGNvbXBvbmVudFxuLy8gbWF5IHJldHVybiBhbiBBcnJheSBpbnN0ZWFkIG9mIGEgc2luZ2xlIHJvb3QuIEluIHRoaXMgY2FzZSwganVzdCBhIHNpbXBsZVxuLy8gbm9ybWFsaXphdGlvbiBpcyBuZWVkZWQgLSBpZiBhbnkgY2hpbGQgaXMgYW4gQXJyYXksIHdlIGZsYXR0ZW4gdGhlIHdob2xlXG4vLyB0aGluZyB3aXRoIEFycmF5LnByb3RvdHlwZS5jb25jYXQuIEl0IGlzIGd1YXJhbnRlZWQgdG8gYmUgb25seSAxLWxldmVsIGRlZXBcbi8vIGJlY2F1c2UgZnVuY3Rpb25hbCBjb21wb25lbnRzIGFscmVhZHkgbm9ybWFsaXplIHRoZWlyIG93biBjaGlsZHJlbi5cbmZ1bmN0aW9uIHNpbXBsZU5vcm1hbGl6ZUNoaWxkcmVuIChjaGlsZHJlbikge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoY2hpbGRyZW5baV0pKSB7XG4gICAgICByZXR1cm4gQXJyYXkucHJvdG90eXBlLmNvbmNhdC5hcHBseShbXSwgY2hpbGRyZW4pXG4gICAgfVxuICB9XG4gIHJldHVybiBjaGlsZHJlblxufVxuXG4vLyAyLiBXaGVuIHRoZSBjaGlsZHJlbiBjb250YWlucyBjb25zdHJ1Y3RzIHRoYXQgYWx3YXlzIGdlbmVyYXRlZCBuZXN0ZWQgQXJyYXlzLFxuLy8gZS5nLiA8dGVtcGxhdGU+LCA8c2xvdD4sIHYtZm9yLCBvciB3aGVuIHRoZSBjaGlsZHJlbiBpcyBwcm92aWRlZCBieSB1c2VyXG4vLyB3aXRoIGhhbmQtd3JpdHRlbiByZW5kZXIgZnVuY3Rpb25zIC8gSlNYLiBJbiBzdWNoIGNhc2VzIGEgZnVsbCBub3JtYWxpemF0aW9uXG4vLyBpcyBuZWVkZWQgdG8gY2F0ZXIgdG8gYWxsIHBvc3NpYmxlIHR5cGVzIG9mIGNoaWxkcmVuIHZhbHVlcy5cbmZ1bmN0aW9uIG5vcm1hbGl6ZUNoaWxkcmVuIChjaGlsZHJlbikge1xuICByZXR1cm4gaXNQcmltaXRpdmUoY2hpbGRyZW4pXG4gICAgPyBbY3JlYXRlVGV4dFZOb2RlKGNoaWxkcmVuKV1cbiAgICA6IEFycmF5LmlzQXJyYXkoY2hpbGRyZW4pXG4gICAgICA/IG5vcm1hbGl6ZUFycmF5Q2hpbGRyZW4oY2hpbGRyZW4pXG4gICAgICA6IHVuZGVmaW5lZFxufVxuXG5mdW5jdGlvbiBpc1RleHROb2RlIChub2RlKSB7XG4gIHJldHVybiBpc0RlZihub2RlKSAmJiBpc0RlZihub2RlLnRleHQpICYmIGlzRmFsc2Uobm9kZS5pc0NvbW1lbnQpXG59XG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZUFycmF5Q2hpbGRyZW4gKGNoaWxkcmVuLCBuZXN0ZWRJbmRleCkge1xuICB2YXIgcmVzID0gW107XG4gIHZhciBpLCBjLCBsYXN0SW5kZXgsIGxhc3Q7XG4gIGZvciAoaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgIGMgPSBjaGlsZHJlbltpXTtcbiAgICBpZiAoaXNVbmRlZihjKSB8fCB0eXBlb2YgYyA9PT0gJ2Jvb2xlYW4nKSB7IGNvbnRpbnVlIH1cbiAgICBsYXN0SW5kZXggPSByZXMubGVuZ3RoIC0gMTtcbiAgICBsYXN0ID0gcmVzW2xhc3RJbmRleF07XG4gICAgLy8gIG5lc3RlZFxuICAgIGlmIChBcnJheS5pc0FycmF5KGMpKSB7XG4gICAgICBpZiAoYy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGMgPSBub3JtYWxpemVBcnJheUNoaWxkcmVuKGMsICgobmVzdGVkSW5kZXggfHwgJycpICsgXCJfXCIgKyBpKSk7XG4gICAgICAgIC8vIG1lcmdlIGFkamFjZW50IHRleHQgbm9kZXNcbiAgICAgICAgaWYgKGlzVGV4dE5vZGUoY1swXSkgJiYgaXNUZXh0Tm9kZShsYXN0KSkge1xuICAgICAgICAgIHJlc1tsYXN0SW5kZXhdID0gY3JlYXRlVGV4dFZOb2RlKGxhc3QudGV4dCArIChjWzBdKS50ZXh0KTtcbiAgICAgICAgICBjLnNoaWZ0KCk7XG4gICAgICAgIH1cbiAgICAgICAgcmVzLnB1c2guYXBwbHkocmVzLCBjKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGlzUHJpbWl0aXZlKGMpKSB7XG4gICAgICBpZiAoaXNUZXh0Tm9kZShsYXN0KSkge1xuICAgICAgICAvLyBtZXJnZSBhZGphY2VudCB0ZXh0IG5vZGVzXG4gICAgICAgIC8vIHRoaXMgaXMgbmVjZXNzYXJ5IGZvciBTU1IgaHlkcmF0aW9uIGJlY2F1c2UgdGV4dCBub2RlcyBhcmVcbiAgICAgICAgLy8gZXNzZW50aWFsbHkgbWVyZ2VkIHdoZW4gcmVuZGVyZWQgdG8gSFRNTCBzdHJpbmdzXG4gICAgICAgIHJlc1tsYXN0SW5kZXhdID0gY3JlYXRlVGV4dFZOb2RlKGxhc3QudGV4dCArIGMpO1xuICAgICAgfSBlbHNlIGlmIChjICE9PSAnJykge1xuICAgICAgICAvLyBjb252ZXJ0IHByaW1pdGl2ZSB0byB2bm9kZVxuICAgICAgICByZXMucHVzaChjcmVhdGVUZXh0Vk5vZGUoYykpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoaXNUZXh0Tm9kZShjKSAmJiBpc1RleHROb2RlKGxhc3QpKSB7XG4gICAgICAgIC8vIG1lcmdlIGFkamFjZW50IHRleHQgbm9kZXNcbiAgICAgICAgcmVzW2xhc3RJbmRleF0gPSBjcmVhdGVUZXh0Vk5vZGUobGFzdC50ZXh0ICsgYy50ZXh0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGRlZmF1bHQga2V5IGZvciBuZXN0ZWQgYXJyYXkgY2hpbGRyZW4gKGxpa2VseSBnZW5lcmF0ZWQgYnkgdi1mb3IpXG4gICAgICAgIGlmIChpc1RydWUoY2hpbGRyZW4uX2lzVkxpc3QpICYmXG4gICAgICAgICAgaXNEZWYoYy50YWcpICYmXG4gICAgICAgICAgaXNVbmRlZihjLmtleSkgJiZcbiAgICAgICAgICBpc0RlZihuZXN0ZWRJbmRleCkpIHtcbiAgICAgICAgICBjLmtleSA9IFwiX192bGlzdFwiICsgbmVzdGVkSW5kZXggKyBcIl9cIiArIGkgKyBcIl9fXCI7XG4gICAgICAgIH1cbiAgICAgICAgcmVzLnB1c2goYyk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGluaXRQcm92aWRlICh2bSkge1xuICB2YXIgcHJvdmlkZSA9IHZtLiRvcHRpb25zLnByb3ZpZGU7XG4gIGlmIChwcm92aWRlKSB7XG4gICAgdm0uX3Byb3ZpZGVkID0gdHlwZW9mIHByb3ZpZGUgPT09ICdmdW5jdGlvbidcbiAgICAgID8gcHJvdmlkZS5jYWxsKHZtKVxuICAgICAgOiBwcm92aWRlO1xuICB9XG59XG5cbmZ1bmN0aW9uIGluaXRJbmplY3Rpb25zICh2bSkge1xuICB2YXIgcmVzdWx0ID0gcmVzb2x2ZUluamVjdCh2bS4kb3B0aW9ucy5pbmplY3QsIHZtKTtcbiAgaWYgKHJlc3VsdCkge1xuICAgIHRvZ2dsZU9ic2VydmluZyhmYWxzZSk7XG4gICAgT2JqZWN0LmtleXMocmVzdWx0KS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICBkZWZpbmVSZWFjdGl2ZSQkMSh2bSwga2V5LCByZXN1bHRba2V5XSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHdhcm4oXG4gICAgICAgICAgICBcIkF2b2lkIG11dGF0aW5nIGFuIGluamVjdGVkIHZhbHVlIGRpcmVjdGx5IHNpbmNlIHRoZSBjaGFuZ2VzIHdpbGwgYmUgXCIgK1xuICAgICAgICAgICAgXCJvdmVyd3JpdHRlbiB3aGVuZXZlciB0aGUgcHJvdmlkZWQgY29tcG9uZW50IHJlLXJlbmRlcnMuIFwiICtcbiAgICAgICAgICAgIFwiaW5qZWN0aW9uIGJlaW5nIG11dGF0ZWQ6IFxcXCJcIiArIGtleSArIFwiXFxcIlwiLFxuICAgICAgICAgICAgdm1cbiAgICAgICAgICApO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRlZmluZVJlYWN0aXZlJCQxKHZtLCBrZXksIHJlc3VsdFtrZXldKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICB0b2dnbGVPYnNlcnZpbmcodHJ1ZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVzb2x2ZUluamVjdCAoaW5qZWN0LCB2bSkge1xuICBpZiAoaW5qZWN0KSB7XG4gICAgLy8gaW5qZWN0IGlzIDphbnkgYmVjYXVzZSBmbG93IGlzIG5vdCBzbWFydCBlbm91Z2ggdG8gZmlndXJlIG91dCBjYWNoZWRcbiAgICB2YXIgcmVzdWx0ID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB2YXIga2V5cyA9IGhhc1N5bWJvbFxuICAgICAgPyBSZWZsZWN0Lm93bktleXMoaW5qZWN0KVxuICAgICAgOiBPYmplY3Qua2V5cyhpbmplY3QpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIga2V5ID0ga2V5c1tpXTtcbiAgICAgIC8vICM2NTc0IGluIGNhc2UgdGhlIGluamVjdCBvYmplY3QgaXMgb2JzZXJ2ZWQuLi5cbiAgICAgIGlmIChrZXkgPT09ICdfX29iX18nKSB7IGNvbnRpbnVlIH1cbiAgICAgIHZhciBwcm92aWRlS2V5ID0gaW5qZWN0W2tleV0uZnJvbTtcbiAgICAgIHZhciBzb3VyY2UgPSB2bTtcbiAgICAgIHdoaWxlIChzb3VyY2UpIHtcbiAgICAgICAgaWYgKHNvdXJjZS5fcHJvdmlkZWQgJiYgaGFzT3duKHNvdXJjZS5fcHJvdmlkZWQsIHByb3ZpZGVLZXkpKSB7XG4gICAgICAgICAgcmVzdWx0W2tleV0gPSBzb3VyY2UuX3Byb3ZpZGVkW3Byb3ZpZGVLZXldO1xuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgICAgc291cmNlID0gc291cmNlLiRwYXJlbnQ7XG4gICAgICB9XG4gICAgICBpZiAoIXNvdXJjZSkge1xuICAgICAgICBpZiAoJ2RlZmF1bHQnIGluIGluamVjdFtrZXldKSB7XG4gICAgICAgICAgdmFyIHByb3ZpZGVEZWZhdWx0ID0gaW5qZWN0W2tleV0uZGVmYXVsdDtcbiAgICAgICAgICByZXN1bHRba2V5XSA9IHR5cGVvZiBwcm92aWRlRGVmYXVsdCA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgICAgICAgPyBwcm92aWRlRGVmYXVsdC5jYWxsKHZtKVxuICAgICAgICAgICAgOiBwcm92aWRlRGVmYXVsdDtcbiAgICAgICAgfSBlbHNlIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgd2FybigoXCJJbmplY3Rpb24gXFxcIlwiICsga2V5ICsgXCJcXFwiIG5vdCBmb3VuZFwiKSwgdm0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHRcbiAgfVxufVxuXG4vKiAgKi9cblxuXG5cbi8qKlxuICogUnVudGltZSBoZWxwZXIgZm9yIHJlc29sdmluZyByYXcgY2hpbGRyZW4gVk5vZGVzIGludG8gYSBzbG90IG9iamVjdC5cbiAqL1xuZnVuY3Rpb24gcmVzb2x2ZVNsb3RzIChcbiAgY2hpbGRyZW4sXG4gIGNvbnRleHRcbikge1xuICBpZiAoIWNoaWxkcmVuIHx8ICFjaGlsZHJlbi5sZW5ndGgpIHtcbiAgICByZXR1cm4ge31cbiAgfVxuICB2YXIgc2xvdHMgPSB7fTtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBjaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICB2YXIgY2hpbGQgPSBjaGlsZHJlbltpXTtcbiAgICB2YXIgZGF0YSA9IGNoaWxkLmRhdGE7XG4gICAgLy8gcmVtb3ZlIHNsb3QgYXR0cmlidXRlIGlmIHRoZSBub2RlIGlzIHJlc29sdmVkIGFzIGEgVnVlIHNsb3Qgbm9kZVxuICAgIGlmIChkYXRhICYmIGRhdGEuYXR0cnMgJiYgZGF0YS5hdHRycy5zbG90KSB7XG4gICAgICBkZWxldGUgZGF0YS5hdHRycy5zbG90O1xuICAgIH1cbiAgICAvLyBuYW1lZCBzbG90cyBzaG91bGQgb25seSBiZSByZXNwZWN0ZWQgaWYgdGhlIHZub2RlIHdhcyByZW5kZXJlZCBpbiB0aGVcbiAgICAvLyBzYW1lIGNvbnRleHQuXG4gICAgaWYgKChjaGlsZC5jb250ZXh0ID09PSBjb250ZXh0IHx8IGNoaWxkLmZuQ29udGV4dCA9PT0gY29udGV4dCkgJiZcbiAgICAgIGRhdGEgJiYgZGF0YS5zbG90ICE9IG51bGxcbiAgICApIHtcbiAgICAgIHZhciBuYW1lID0gZGF0YS5zbG90O1xuICAgICAgdmFyIHNsb3QgPSAoc2xvdHNbbmFtZV0gfHwgKHNsb3RzW25hbWVdID0gW10pKTtcbiAgICAgIGlmIChjaGlsZC50YWcgPT09ICd0ZW1wbGF0ZScpIHtcbiAgICAgICAgc2xvdC5wdXNoLmFwcGx5KHNsb3QsIGNoaWxkLmNoaWxkcmVuIHx8IFtdKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNsb3QucHVzaChjaGlsZCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIChzbG90cy5kZWZhdWx0IHx8IChzbG90cy5kZWZhdWx0ID0gW10pKS5wdXNoKGNoaWxkKTtcbiAgICB9XG4gIH1cbiAgLy8gaWdub3JlIHNsb3RzIHRoYXQgY29udGFpbnMgb25seSB3aGl0ZXNwYWNlXG4gIGZvciAodmFyIG5hbWUkMSBpbiBzbG90cykge1xuICAgIGlmIChzbG90c1tuYW1lJDFdLmV2ZXJ5KGlzV2hpdGVzcGFjZSkpIHtcbiAgICAgIGRlbGV0ZSBzbG90c1tuYW1lJDFdO1xuICAgIH1cbiAgfVxuICByZXR1cm4gc2xvdHNcbn1cblxuZnVuY3Rpb24gaXNXaGl0ZXNwYWNlIChub2RlKSB7XG4gIHJldHVybiAobm9kZS5pc0NvbW1lbnQgJiYgIW5vZGUuYXN5bmNGYWN0b3J5KSB8fCBub2RlLnRleHQgPT09ICcgJ1xufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gaXNBc3luY1BsYWNlaG9sZGVyIChub2RlKSB7XG4gIHJldHVybiBub2RlLmlzQ29tbWVudCAmJiBub2RlLmFzeW5jRmFjdG9yeVxufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gbm9ybWFsaXplU2NvcGVkU2xvdHMgKFxuICBzbG90cyxcbiAgbm9ybWFsU2xvdHMsXG4gIHByZXZTbG90c1xuKSB7XG4gIHZhciByZXM7XG4gIHZhciBoYXNOb3JtYWxTbG90cyA9IE9iamVjdC5rZXlzKG5vcm1hbFNsb3RzKS5sZW5ndGggPiAwO1xuICB2YXIgaXNTdGFibGUgPSBzbG90cyA/ICEhc2xvdHMuJHN0YWJsZSA6ICFoYXNOb3JtYWxTbG90cztcbiAgdmFyIGtleSA9IHNsb3RzICYmIHNsb3RzLiRrZXk7XG4gIGlmICghc2xvdHMpIHtcbiAgICByZXMgPSB7fTtcbiAgfSBlbHNlIGlmIChzbG90cy5fbm9ybWFsaXplZCkge1xuICAgIC8vIGZhc3QgcGF0aCAxOiBjaGlsZCBjb21wb25lbnQgcmUtcmVuZGVyIG9ubHksIHBhcmVudCBkaWQgbm90IGNoYW5nZVxuICAgIHJldHVybiBzbG90cy5fbm9ybWFsaXplZFxuICB9IGVsc2UgaWYgKFxuICAgIGlzU3RhYmxlICYmXG4gICAgcHJldlNsb3RzICYmXG4gICAgcHJldlNsb3RzICE9PSBlbXB0eU9iamVjdCAmJlxuICAgIGtleSA9PT0gcHJldlNsb3RzLiRrZXkgJiZcbiAgICAhaGFzTm9ybWFsU2xvdHMgJiZcbiAgICAhcHJldlNsb3RzLiRoYXNOb3JtYWxcbiAgKSB7XG4gICAgLy8gZmFzdCBwYXRoIDI6IHN0YWJsZSBzY29wZWQgc2xvdHMgdy8gbm8gbm9ybWFsIHNsb3RzIHRvIHByb3h5LFxuICAgIC8vIG9ubHkgbmVlZCB0byBub3JtYWxpemUgb25jZVxuICAgIHJldHVybiBwcmV2U2xvdHNcbiAgfSBlbHNlIHtcbiAgICByZXMgPSB7fTtcbiAgICBmb3IgKHZhciBrZXkkMSBpbiBzbG90cykge1xuICAgICAgaWYgKHNsb3RzW2tleSQxXSAmJiBrZXkkMVswXSAhPT0gJyQnKSB7XG4gICAgICAgIHJlc1trZXkkMV0gPSBub3JtYWxpemVTY29wZWRTbG90KG5vcm1hbFNsb3RzLCBrZXkkMSwgc2xvdHNba2V5JDFdKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgLy8gZXhwb3NlIG5vcm1hbCBzbG90cyBvbiBzY29wZWRTbG90c1xuICBmb3IgKHZhciBrZXkkMiBpbiBub3JtYWxTbG90cykge1xuICAgIGlmICghKGtleSQyIGluIHJlcykpIHtcbiAgICAgIHJlc1trZXkkMl0gPSBwcm94eU5vcm1hbFNsb3Qobm9ybWFsU2xvdHMsIGtleSQyKTtcbiAgICB9XG4gIH1cbiAgLy8gYXZvcmlheiBzZWVtcyB0byBtb2NrIGEgbm9uLWV4dGVuc2libGUgJHNjb3BlZFNsb3RzIG9iamVjdFxuICAvLyBhbmQgd2hlbiB0aGF0IGlzIHBhc3NlZCBkb3duIHRoaXMgd291bGQgY2F1c2UgYW4gZXJyb3JcbiAgaWYgKHNsb3RzICYmIE9iamVjdC5pc0V4dGVuc2libGUoc2xvdHMpKSB7XG4gICAgKHNsb3RzKS5fbm9ybWFsaXplZCA9IHJlcztcbiAgfVxuICBkZWYocmVzLCAnJHN0YWJsZScsIGlzU3RhYmxlKTtcbiAgZGVmKHJlcywgJyRrZXknLCBrZXkpO1xuICBkZWYocmVzLCAnJGhhc05vcm1hbCcsIGhhc05vcm1hbFNsb3RzKTtcbiAgcmV0dXJuIHJlc1xufVxuXG5mdW5jdGlvbiBub3JtYWxpemVTY29wZWRTbG90KG5vcm1hbFNsb3RzLCBrZXksIGZuKSB7XG4gIHZhciBub3JtYWxpemVkID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciByZXMgPSBhcmd1bWVudHMubGVuZ3RoID8gZm4uYXBwbHkobnVsbCwgYXJndW1lbnRzKSA6IGZuKHt9KTtcbiAgICByZXMgPSByZXMgJiYgdHlwZW9mIHJlcyA9PT0gJ29iamVjdCcgJiYgIUFycmF5LmlzQXJyYXkocmVzKVxuICAgICAgPyBbcmVzXSAvLyBzaW5nbGUgdm5vZGVcbiAgICAgIDogbm9ybWFsaXplQ2hpbGRyZW4ocmVzKTtcbiAgICB2YXIgdm5vZGUgPSByZXMgJiYgcmVzWzBdO1xuICAgIHJldHVybiByZXMgJiYgKFxuICAgICAgIXZub2RlIHx8XG4gICAgICAocmVzLmxlbmd0aCA9PT0gMSAmJiB2bm9kZS5pc0NvbW1lbnQgJiYgIWlzQXN5bmNQbGFjZWhvbGRlcih2bm9kZSkpIC8vICM5NjU4LCAjMTAzOTFcbiAgICApID8gdW5kZWZpbmVkXG4gICAgICA6IHJlc1xuICB9O1xuICAvLyB0aGlzIGlzIGEgc2xvdCB1c2luZyB0aGUgbmV3IHYtc2xvdCBzeW50YXggd2l0aG91dCBzY29wZS4gYWx0aG91Z2ggaXQgaXNcbiAgLy8gY29tcGlsZWQgYXMgYSBzY29wZWQgc2xvdCwgcmVuZGVyIGZuIHVzZXJzIHdvdWxkIGV4cGVjdCBpdCB0byBiZSBwcmVzZW50XG4gIC8vIG9uIHRoaXMuJHNsb3RzIGJlY2F1c2UgdGhlIHVzYWdlIGlzIHNlbWFudGljYWxseSBhIG5vcm1hbCBzbG90LlxuICBpZiAoZm4ucHJveHkpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobm9ybWFsU2xvdHMsIGtleSwge1xuICAgICAgZ2V0OiBub3JtYWxpemVkLFxuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICB9XG4gIHJldHVybiBub3JtYWxpemVkXG59XG5cbmZ1bmN0aW9uIHByb3h5Tm9ybWFsU2xvdChzbG90cywga2V5KSB7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7IHJldHVybiBzbG90c1trZXldOyB9XG59XG5cbi8qICAqL1xuXG4vKipcbiAqIFJ1bnRpbWUgaGVscGVyIGZvciByZW5kZXJpbmcgdi1mb3IgbGlzdHMuXG4gKi9cbmZ1bmN0aW9uIHJlbmRlckxpc3QgKFxuICB2YWwsXG4gIHJlbmRlclxuKSB7XG4gIHZhciByZXQsIGksIGwsIGtleXMsIGtleTtcbiAgaWYgKEFycmF5LmlzQXJyYXkodmFsKSB8fCB0eXBlb2YgdmFsID09PSAnc3RyaW5nJykge1xuICAgIHJldCA9IG5ldyBBcnJheSh2YWwubGVuZ3RoKTtcbiAgICBmb3IgKGkgPSAwLCBsID0gdmFsLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgcmV0W2ldID0gcmVuZGVyKHZhbFtpXSwgaSk7XG4gICAgfVxuICB9IGVsc2UgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XG4gICAgcmV0ID0gbmV3IEFycmF5KHZhbCk7XG4gICAgZm9yIChpID0gMDsgaSA8IHZhbDsgaSsrKSB7XG4gICAgICByZXRbaV0gPSByZW5kZXIoaSArIDEsIGkpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChpc09iamVjdCh2YWwpKSB7XG4gICAgaWYgKGhhc1N5bWJvbCAmJiB2YWxbU3ltYm9sLml0ZXJhdG9yXSkge1xuICAgICAgcmV0ID0gW107XG4gICAgICB2YXIgaXRlcmF0b3IgPSB2YWxbU3ltYm9sLml0ZXJhdG9yXSgpO1xuICAgICAgdmFyIHJlc3VsdCA9IGl0ZXJhdG9yLm5leHQoKTtcbiAgICAgIHdoaWxlICghcmVzdWx0LmRvbmUpIHtcbiAgICAgICAgcmV0LnB1c2gocmVuZGVyKHJlc3VsdC52YWx1ZSwgcmV0Lmxlbmd0aCkpO1xuICAgICAgICByZXN1bHQgPSBpdGVyYXRvci5uZXh0KCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGtleXMgPSBPYmplY3Qua2V5cyh2YWwpO1xuICAgICAgcmV0ID0gbmV3IEFycmF5KGtleXMubGVuZ3RoKTtcbiAgICAgIGZvciAoaSA9IDAsIGwgPSBrZXlzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICBrZXkgPSBrZXlzW2ldO1xuICAgICAgICByZXRbaV0gPSByZW5kZXIodmFsW2tleV0sIGtleSwgaSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGlmICghaXNEZWYocmV0KSkge1xuICAgIHJldCA9IFtdO1xuICB9XG4gIChyZXQpLl9pc1ZMaXN0ID0gdHJ1ZTtcbiAgcmV0dXJuIHJldFxufVxuXG4vKiAgKi9cblxuLyoqXG4gKiBSdW50aW1lIGhlbHBlciBmb3IgcmVuZGVyaW5nIDxzbG90PlxuICovXG5mdW5jdGlvbiByZW5kZXJTbG90IChcbiAgbmFtZSxcbiAgZmFsbGJhY2tSZW5kZXIsXG4gIHByb3BzLFxuICBiaW5kT2JqZWN0XG4pIHtcbiAgdmFyIHNjb3BlZFNsb3RGbiA9IHRoaXMuJHNjb3BlZFNsb3RzW25hbWVdO1xuICB2YXIgbm9kZXM7XG4gIGlmIChzY29wZWRTbG90Rm4pIHtcbiAgICAvLyBzY29wZWQgc2xvdFxuICAgIHByb3BzID0gcHJvcHMgfHwge307XG4gICAgaWYgKGJpbmRPYmplY3QpIHtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmICFpc09iamVjdChiaW5kT2JqZWN0KSkge1xuICAgICAgICB3YXJuKCdzbG90IHYtYmluZCB3aXRob3V0IGFyZ3VtZW50IGV4cGVjdHMgYW4gT2JqZWN0JywgdGhpcyk7XG4gICAgICB9XG4gICAgICBwcm9wcyA9IGV4dGVuZChleHRlbmQoe30sIGJpbmRPYmplY3QpLCBwcm9wcyk7XG4gICAgfVxuICAgIG5vZGVzID1cbiAgICAgIHNjb3BlZFNsb3RGbihwcm9wcykgfHxcbiAgICAgICh0eXBlb2YgZmFsbGJhY2tSZW5kZXIgPT09ICdmdW5jdGlvbicgPyBmYWxsYmFja1JlbmRlcigpIDogZmFsbGJhY2tSZW5kZXIpO1xuICB9IGVsc2Uge1xuICAgIG5vZGVzID1cbiAgICAgIHRoaXMuJHNsb3RzW25hbWVdIHx8XG4gICAgICAodHlwZW9mIGZhbGxiYWNrUmVuZGVyID09PSAnZnVuY3Rpb24nID8gZmFsbGJhY2tSZW5kZXIoKSA6IGZhbGxiYWNrUmVuZGVyKTtcbiAgfVxuXG4gIHZhciB0YXJnZXQgPSBwcm9wcyAmJiBwcm9wcy5zbG90O1xuICBpZiAodGFyZ2V0KSB7XG4gICAgcmV0dXJuIHRoaXMuJGNyZWF0ZUVsZW1lbnQoJ3RlbXBsYXRlJywgeyBzbG90OiB0YXJnZXQgfSwgbm9kZXMpXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG5vZGVzXG4gIH1cbn1cblxuLyogICovXG5cbi8qKlxuICogUnVudGltZSBoZWxwZXIgZm9yIHJlc29sdmluZyBmaWx0ZXJzXG4gKi9cbmZ1bmN0aW9uIHJlc29sdmVGaWx0ZXIgKGlkKSB7XG4gIHJldHVybiByZXNvbHZlQXNzZXQodGhpcy4kb3B0aW9ucywgJ2ZpbHRlcnMnLCBpZCwgdHJ1ZSkgfHwgaWRlbnRpdHlcbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGlzS2V5Tm90TWF0Y2ggKGV4cGVjdCwgYWN0dWFsKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGV4cGVjdCkpIHtcbiAgICByZXR1cm4gZXhwZWN0LmluZGV4T2YoYWN0dWFsKSA9PT0gLTFcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZXhwZWN0ICE9PSBhY3R1YWxcbiAgfVxufVxuXG4vKipcbiAqIFJ1bnRpbWUgaGVscGVyIGZvciBjaGVja2luZyBrZXlDb2RlcyBmcm9tIGNvbmZpZy5cbiAqIGV4cG9zZWQgYXMgVnVlLnByb3RvdHlwZS5fa1xuICogcGFzc2luZyBpbiBldmVudEtleU5hbWUgYXMgbGFzdCBhcmd1bWVudCBzZXBhcmF0ZWx5IGZvciBiYWNrd2FyZHMgY29tcGF0XG4gKi9cbmZ1bmN0aW9uIGNoZWNrS2V5Q29kZXMgKFxuICBldmVudEtleUNvZGUsXG4gIGtleSxcbiAgYnVpbHRJbktleUNvZGUsXG4gIGV2ZW50S2V5TmFtZSxcbiAgYnVpbHRJbktleU5hbWVcbikge1xuICB2YXIgbWFwcGVkS2V5Q29kZSA9IGNvbmZpZy5rZXlDb2Rlc1trZXldIHx8IGJ1aWx0SW5LZXlDb2RlO1xuICBpZiAoYnVpbHRJbktleU5hbWUgJiYgZXZlbnRLZXlOYW1lICYmICFjb25maWcua2V5Q29kZXNba2V5XSkge1xuICAgIHJldHVybiBpc0tleU5vdE1hdGNoKGJ1aWx0SW5LZXlOYW1lLCBldmVudEtleU5hbWUpXG4gIH0gZWxzZSBpZiAobWFwcGVkS2V5Q29kZSkge1xuICAgIHJldHVybiBpc0tleU5vdE1hdGNoKG1hcHBlZEtleUNvZGUsIGV2ZW50S2V5Q29kZSlcbiAgfSBlbHNlIGlmIChldmVudEtleU5hbWUpIHtcbiAgICByZXR1cm4gaHlwaGVuYXRlKGV2ZW50S2V5TmFtZSkgIT09IGtleVxuICB9XG4gIHJldHVybiBldmVudEtleUNvZGUgPT09IHVuZGVmaW5lZFxufVxuXG4vKiAgKi9cblxuLyoqXG4gKiBSdW50aW1lIGhlbHBlciBmb3IgbWVyZ2luZyB2LWJpbmQ9XCJvYmplY3RcIiBpbnRvIGEgVk5vZGUncyBkYXRhLlxuICovXG5mdW5jdGlvbiBiaW5kT2JqZWN0UHJvcHMgKFxuICBkYXRhLFxuICB0YWcsXG4gIHZhbHVlLFxuICBhc1Byb3AsXG4gIGlzU3luY1xuKSB7XG4gIGlmICh2YWx1ZSkge1xuICAgIGlmICghaXNPYmplY3QodmFsdWUpKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oXG4gICAgICAgICd2LWJpbmQgd2l0aG91dCBhcmd1bWVudCBleHBlY3RzIGFuIE9iamVjdCBvciBBcnJheSB2YWx1ZScsXG4gICAgICAgIHRoaXNcbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICB2YWx1ZSA9IHRvT2JqZWN0KHZhbHVlKTtcbiAgICAgIH1cbiAgICAgIHZhciBoYXNoO1xuICAgICAgdmFyIGxvb3AgPSBmdW5jdGlvbiAoIGtleSApIHtcbiAgICAgICAgaWYgKFxuICAgICAgICAgIGtleSA9PT0gJ2NsYXNzJyB8fFxuICAgICAgICAgIGtleSA9PT0gJ3N0eWxlJyB8fFxuICAgICAgICAgIGlzUmVzZXJ2ZWRBdHRyaWJ1dGUoa2V5KVxuICAgICAgICApIHtcbiAgICAgICAgICBoYXNoID0gZGF0YTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgdHlwZSA9IGRhdGEuYXR0cnMgJiYgZGF0YS5hdHRycy50eXBlO1xuICAgICAgICAgIGhhc2ggPSBhc1Byb3AgfHwgY29uZmlnLm11c3RVc2VQcm9wKHRhZywgdHlwZSwga2V5KVxuICAgICAgICAgICAgPyBkYXRhLmRvbVByb3BzIHx8IChkYXRhLmRvbVByb3BzID0ge30pXG4gICAgICAgICAgICA6IGRhdGEuYXR0cnMgfHwgKGRhdGEuYXR0cnMgPSB7fSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGNhbWVsaXplZEtleSA9IGNhbWVsaXplKGtleSk7XG4gICAgICAgIHZhciBoeXBoZW5hdGVkS2V5ID0gaHlwaGVuYXRlKGtleSk7XG4gICAgICAgIGlmICghKGNhbWVsaXplZEtleSBpbiBoYXNoKSAmJiAhKGh5cGhlbmF0ZWRLZXkgaW4gaGFzaCkpIHtcbiAgICAgICAgICBoYXNoW2tleV0gPSB2YWx1ZVtrZXldO1xuXG4gICAgICAgICAgaWYgKGlzU3luYykge1xuICAgICAgICAgICAgdmFyIG9uID0gZGF0YS5vbiB8fCAoZGF0YS5vbiA9IHt9KTtcbiAgICAgICAgICAgIG9uWyhcInVwZGF0ZTpcIiArIGtleSldID0gZnVuY3Rpb24gKCRldmVudCkge1xuICAgICAgICAgICAgICB2YWx1ZVtrZXldID0gJGV2ZW50O1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIGZvciAodmFyIGtleSBpbiB2YWx1ZSkgbG9vcCgga2V5ICk7XG4gICAgfVxuICB9XG4gIHJldHVybiBkYXRhXG59XG5cbi8qICAqL1xuXG4vKipcbiAqIFJ1bnRpbWUgaGVscGVyIGZvciByZW5kZXJpbmcgc3RhdGljIHRyZWVzLlxuICovXG5mdW5jdGlvbiByZW5kZXJTdGF0aWMgKFxuICBpbmRleCxcbiAgaXNJbkZvclxuKSB7XG4gIHZhciBjYWNoZWQgPSB0aGlzLl9zdGF0aWNUcmVlcyB8fCAodGhpcy5fc3RhdGljVHJlZXMgPSBbXSk7XG4gIHZhciB0cmVlID0gY2FjaGVkW2luZGV4XTtcbiAgLy8gaWYgaGFzIGFscmVhZHktcmVuZGVyZWQgc3RhdGljIHRyZWUgYW5kIG5vdCBpbnNpZGUgdi1mb3IsXG4gIC8vIHdlIGNhbiByZXVzZSB0aGUgc2FtZSB0cmVlLlxuICBpZiAodHJlZSAmJiAhaXNJbkZvcikge1xuICAgIHJldHVybiB0cmVlXG4gIH1cbiAgLy8gb3RoZXJ3aXNlLCByZW5kZXIgYSBmcmVzaCB0cmVlLlxuICB0cmVlID0gY2FjaGVkW2luZGV4XSA9IHRoaXMuJG9wdGlvbnMuc3RhdGljUmVuZGVyRm5zW2luZGV4XS5jYWxsKFxuICAgIHRoaXMuX3JlbmRlclByb3h5LFxuICAgIG51bGwsXG4gICAgdGhpcyAvLyBmb3IgcmVuZGVyIGZucyBnZW5lcmF0ZWQgZm9yIGZ1bmN0aW9uYWwgY29tcG9uZW50IHRlbXBsYXRlc1xuICApO1xuICBtYXJrU3RhdGljKHRyZWUsIChcIl9fc3RhdGljX19cIiArIGluZGV4KSwgZmFsc2UpO1xuICByZXR1cm4gdHJlZVxufVxuXG4vKipcbiAqIFJ1bnRpbWUgaGVscGVyIGZvciB2LW9uY2UuXG4gKiBFZmZlY3RpdmVseSBpdCBtZWFucyBtYXJraW5nIHRoZSBub2RlIGFzIHN0YXRpYyB3aXRoIGEgdW5pcXVlIGtleS5cbiAqL1xuZnVuY3Rpb24gbWFya09uY2UgKFxuICB0cmVlLFxuICBpbmRleCxcbiAga2V5XG4pIHtcbiAgbWFya1N0YXRpYyh0cmVlLCAoXCJfX29uY2VfX1wiICsgaW5kZXggKyAoa2V5ID8gKFwiX1wiICsga2V5KSA6IFwiXCIpKSwgdHJ1ZSk7XG4gIHJldHVybiB0cmVlXG59XG5cbmZ1bmN0aW9uIG1hcmtTdGF0aWMgKFxuICB0cmVlLFxuICBrZXksXG4gIGlzT25jZVxuKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KHRyZWUpKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0cmVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAodHJlZVtpXSAmJiB0eXBlb2YgdHJlZVtpXSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgbWFya1N0YXRpY05vZGUodHJlZVtpXSwgKGtleSArIFwiX1wiICsgaSksIGlzT25jZSk7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIG1hcmtTdGF0aWNOb2RlKHRyZWUsIGtleSwgaXNPbmNlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBtYXJrU3RhdGljTm9kZSAobm9kZSwga2V5LCBpc09uY2UpIHtcbiAgbm9kZS5pc1N0YXRpYyA9IHRydWU7XG4gIG5vZGUua2V5ID0ga2V5O1xuICBub2RlLmlzT25jZSA9IGlzT25jZTtcbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGJpbmRPYmplY3RMaXN0ZW5lcnMgKGRhdGEsIHZhbHVlKSB7XG4gIGlmICh2YWx1ZSkge1xuICAgIGlmICghaXNQbGFpbk9iamVjdCh2YWx1ZSkpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybihcbiAgICAgICAgJ3Ytb24gd2l0aG91dCBhcmd1bWVudCBleHBlY3RzIGFuIE9iamVjdCB2YWx1ZScsXG4gICAgICAgIHRoaXNcbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBvbiA9IGRhdGEub24gPSBkYXRhLm9uID8gZXh0ZW5kKHt9LCBkYXRhLm9uKSA6IHt9O1xuICAgICAgZm9yICh2YXIga2V5IGluIHZhbHVlKSB7XG4gICAgICAgIHZhciBleGlzdGluZyA9IG9uW2tleV07XG4gICAgICAgIHZhciBvdXJzID0gdmFsdWVba2V5XTtcbiAgICAgICAgb25ba2V5XSA9IGV4aXN0aW5nID8gW10uY29uY2F0KGV4aXN0aW5nLCBvdXJzKSA6IG91cnM7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBkYXRhXG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiByZXNvbHZlU2NvcGVkU2xvdHMgKFxuICBmbnMsIC8vIHNlZSBmbG93L3Zub2RlXG4gIHJlcyxcbiAgLy8gdGhlIGZvbGxvd2luZyBhcmUgYWRkZWQgaW4gMi42XG4gIGhhc0R5bmFtaWNLZXlzLFxuICBjb250ZW50SGFzaEtleVxuKSB7XG4gIHJlcyA9IHJlcyB8fCB7ICRzdGFibGU6ICFoYXNEeW5hbWljS2V5cyB9O1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGZucy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBzbG90ID0gZm5zW2ldO1xuICAgIGlmIChBcnJheS5pc0FycmF5KHNsb3QpKSB7XG4gICAgICByZXNvbHZlU2NvcGVkU2xvdHMoc2xvdCwgcmVzLCBoYXNEeW5hbWljS2V5cyk7XG4gICAgfSBlbHNlIGlmIChzbG90KSB7XG4gICAgICAvLyBtYXJrZXIgZm9yIHJldmVyc2UgcHJveHlpbmcgdi1zbG90IHdpdGhvdXQgc2NvcGUgb24gdGhpcy4kc2xvdHNcbiAgICAgIGlmIChzbG90LnByb3h5KSB7XG4gICAgICAgIHNsb3QuZm4ucHJveHkgPSB0cnVlO1xuICAgICAgfVxuICAgICAgcmVzW3Nsb3Qua2V5XSA9IHNsb3QuZm47XG4gICAgfVxuICB9XG4gIGlmIChjb250ZW50SGFzaEtleSkge1xuICAgIChyZXMpLiRrZXkgPSBjb250ZW50SGFzaEtleTtcbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBiaW5kRHluYW1pY0tleXMgKGJhc2VPYmosIHZhbHVlcykge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHZhbHVlcy5sZW5ndGg7IGkgKz0gMikge1xuICAgIHZhciBrZXkgPSB2YWx1ZXNbaV07XG4gICAgaWYgKHR5cGVvZiBrZXkgPT09ICdzdHJpbmcnICYmIGtleSkge1xuICAgICAgYmFzZU9ialt2YWx1ZXNbaV1dID0gdmFsdWVzW2kgKyAxXTtcbiAgICB9IGVsc2UgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYga2V5ICE9PSAnJyAmJiBrZXkgIT09IG51bGwpIHtcbiAgICAgIC8vIG51bGwgaXMgYSBzcGVjaWFsIHZhbHVlIGZvciBleHBsaWNpdGx5IHJlbW92aW5nIGEgYmluZGluZ1xuICAgICAgd2FybihcbiAgICAgICAgKFwiSW52YWxpZCB2YWx1ZSBmb3IgZHluYW1pYyBkaXJlY3RpdmUgYXJndW1lbnQgKGV4cGVjdGVkIHN0cmluZyBvciBudWxsKTogXCIgKyBrZXkpLFxuICAgICAgICB0aGlzXG4gICAgICApO1xuICAgIH1cbiAgfVxuICByZXR1cm4gYmFzZU9ialxufVxuXG4vLyBoZWxwZXIgdG8gZHluYW1pY2FsbHkgYXBwZW5kIG1vZGlmaWVyIHJ1bnRpbWUgbWFya2VycyB0byBldmVudCBuYW1lcy5cbi8vIGVuc3VyZSBvbmx5IGFwcGVuZCB3aGVuIHZhbHVlIGlzIGFscmVhZHkgc3RyaW5nLCBvdGhlcndpc2UgaXQgd2lsbCBiZSBjYXN0XG4vLyB0byBzdHJpbmcgYW5kIGNhdXNlIHRoZSB0eXBlIGNoZWNrIHRvIG1pc3MuXG5mdW5jdGlvbiBwcmVwZW5kTW9kaWZpZXIgKHZhbHVlLCBzeW1ib2wpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgPyBzeW1ib2wgKyB2YWx1ZSA6IHZhbHVlXG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBpbnN0YWxsUmVuZGVySGVscGVycyAodGFyZ2V0KSB7XG4gIHRhcmdldC5fbyA9IG1hcmtPbmNlO1xuICB0YXJnZXQuX24gPSB0b051bWJlcjtcbiAgdGFyZ2V0Ll9zID0gdG9TdHJpbmc7XG4gIHRhcmdldC5fbCA9IHJlbmRlckxpc3Q7XG4gIHRhcmdldC5fdCA9IHJlbmRlclNsb3Q7XG4gIHRhcmdldC5fcSA9IGxvb3NlRXF1YWw7XG4gIHRhcmdldC5faSA9IGxvb3NlSW5kZXhPZjtcbiAgdGFyZ2V0Ll9tID0gcmVuZGVyU3RhdGljO1xuICB0YXJnZXQuX2YgPSByZXNvbHZlRmlsdGVyO1xuICB0YXJnZXQuX2sgPSBjaGVja0tleUNvZGVzO1xuICB0YXJnZXQuX2IgPSBiaW5kT2JqZWN0UHJvcHM7XG4gIHRhcmdldC5fdiA9IGNyZWF0ZVRleHRWTm9kZTtcbiAgdGFyZ2V0Ll9lID0gY3JlYXRlRW1wdHlWTm9kZTtcbiAgdGFyZ2V0Ll91ID0gcmVzb2x2ZVNjb3BlZFNsb3RzO1xuICB0YXJnZXQuX2cgPSBiaW5kT2JqZWN0TGlzdGVuZXJzO1xuICB0YXJnZXQuX2QgPSBiaW5kRHluYW1pY0tleXM7XG4gIHRhcmdldC5fcCA9IHByZXBlbmRNb2RpZmllcjtcbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIEZ1bmN0aW9uYWxSZW5kZXJDb250ZXh0IChcbiAgZGF0YSxcbiAgcHJvcHMsXG4gIGNoaWxkcmVuLFxuICBwYXJlbnQsXG4gIEN0b3Jcbikge1xuICB2YXIgdGhpcyQxID0gdGhpcztcblxuICB2YXIgb3B0aW9ucyA9IEN0b3Iub3B0aW9ucztcbiAgLy8gZW5zdXJlIHRoZSBjcmVhdGVFbGVtZW50IGZ1bmN0aW9uIGluIGZ1bmN0aW9uYWwgY29tcG9uZW50c1xuICAvLyBnZXRzIGEgdW5pcXVlIGNvbnRleHQgLSB0aGlzIGlzIG5lY2Vzc2FyeSBmb3IgY29ycmVjdCBuYW1lZCBzbG90IGNoZWNrXG4gIHZhciBjb250ZXh0Vm07XG4gIGlmIChoYXNPd24ocGFyZW50LCAnX3VpZCcpKSB7XG4gICAgY29udGV4dFZtID0gT2JqZWN0LmNyZWF0ZShwYXJlbnQpO1xuICAgIC8vICRmbG93LWRpc2FibGUtbGluZVxuICAgIGNvbnRleHRWbS5fb3JpZ2luYWwgPSBwYXJlbnQ7XG4gIH0gZWxzZSB7XG4gICAgLy8gdGhlIGNvbnRleHQgdm0gcGFzc2VkIGluIGlzIGEgZnVuY3Rpb25hbCBjb250ZXh0IGFzIHdlbGwuXG4gICAgLy8gaW4gdGhpcyBjYXNlIHdlIHdhbnQgdG8gbWFrZSBzdXJlIHdlIGFyZSBhYmxlIHRvIGdldCBhIGhvbGQgdG8gdGhlXG4gICAgLy8gcmVhbCBjb250ZXh0IGluc3RhbmNlLlxuICAgIGNvbnRleHRWbSA9IHBhcmVudDtcbiAgICAvLyAkZmxvdy1kaXNhYmxlLWxpbmVcbiAgICBwYXJlbnQgPSBwYXJlbnQuX29yaWdpbmFsO1xuICB9XG4gIHZhciBpc0NvbXBpbGVkID0gaXNUcnVlKG9wdGlvbnMuX2NvbXBpbGVkKTtcbiAgdmFyIG5lZWROb3JtYWxpemF0aW9uID0gIWlzQ29tcGlsZWQ7XG5cbiAgdGhpcy5kYXRhID0gZGF0YTtcbiAgdGhpcy5wcm9wcyA9IHByb3BzO1xuICB0aGlzLmNoaWxkcmVuID0gY2hpbGRyZW47XG4gIHRoaXMucGFyZW50ID0gcGFyZW50O1xuICB0aGlzLmxpc3RlbmVycyA9IGRhdGEub24gfHwgZW1wdHlPYmplY3Q7XG4gIHRoaXMuaW5qZWN0aW9ucyA9IHJlc29sdmVJbmplY3Qob3B0aW9ucy5pbmplY3QsIHBhcmVudCk7XG4gIHRoaXMuc2xvdHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCF0aGlzJDEuJHNsb3RzKSB7XG4gICAgICBub3JtYWxpemVTY29wZWRTbG90cyhcbiAgICAgICAgZGF0YS5zY29wZWRTbG90cyxcbiAgICAgICAgdGhpcyQxLiRzbG90cyA9IHJlc29sdmVTbG90cyhjaGlsZHJlbiwgcGFyZW50KVxuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMkMS4kc2xvdHNcbiAgfTtcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ3Njb3BlZFNsb3RzJywgKHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0ICgpIHtcbiAgICAgIHJldHVybiBub3JtYWxpemVTY29wZWRTbG90cyhkYXRhLnNjb3BlZFNsb3RzLCB0aGlzLnNsb3RzKCkpXG4gICAgfVxuICB9KSk7XG5cbiAgLy8gc3VwcG9ydCBmb3IgY29tcGlsZWQgZnVuY3Rpb25hbCB0ZW1wbGF0ZVxuICBpZiAoaXNDb21waWxlZCkge1xuICAgIC8vIGV4cG9zaW5nICRvcHRpb25zIGZvciByZW5kZXJTdGF0aWMoKVxuICAgIHRoaXMuJG9wdGlvbnMgPSBvcHRpb25zO1xuICAgIC8vIHByZS1yZXNvbHZlIHNsb3RzIGZvciByZW5kZXJTbG90KClcbiAgICB0aGlzLiRzbG90cyA9IHRoaXMuc2xvdHMoKTtcbiAgICB0aGlzLiRzY29wZWRTbG90cyA9IG5vcm1hbGl6ZVNjb3BlZFNsb3RzKGRhdGEuc2NvcGVkU2xvdHMsIHRoaXMuJHNsb3RzKTtcbiAgfVxuXG4gIGlmIChvcHRpb25zLl9zY29wZUlkKSB7XG4gICAgdGhpcy5fYyA9IGZ1bmN0aW9uIChhLCBiLCBjLCBkKSB7XG4gICAgICB2YXIgdm5vZGUgPSBjcmVhdGVFbGVtZW50KGNvbnRleHRWbSwgYSwgYiwgYywgZCwgbmVlZE5vcm1hbGl6YXRpb24pO1xuICAgICAgaWYgKHZub2RlICYmICFBcnJheS5pc0FycmF5KHZub2RlKSkge1xuICAgICAgICB2bm9kZS5mblNjb3BlSWQgPSBvcHRpb25zLl9zY29wZUlkO1xuICAgICAgICB2bm9kZS5mbkNvbnRleHQgPSBwYXJlbnQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gdm5vZGVcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIHRoaXMuX2MgPSBmdW5jdGlvbiAoYSwgYiwgYywgZCkgeyByZXR1cm4gY3JlYXRlRWxlbWVudChjb250ZXh0Vm0sIGEsIGIsIGMsIGQsIG5lZWROb3JtYWxpemF0aW9uKTsgfTtcbiAgfVxufVxuXG5pbnN0YWxsUmVuZGVySGVscGVycyhGdW5jdGlvbmFsUmVuZGVyQ29udGV4dC5wcm90b3R5cGUpO1xuXG5mdW5jdGlvbiBjcmVhdGVGdW5jdGlvbmFsQ29tcG9uZW50IChcbiAgQ3RvcixcbiAgcHJvcHNEYXRhLFxuICBkYXRhLFxuICBjb250ZXh0Vm0sXG4gIGNoaWxkcmVuXG4pIHtcbiAgdmFyIG9wdGlvbnMgPSBDdG9yLm9wdGlvbnM7XG4gIHZhciBwcm9wcyA9IHt9O1xuICB2YXIgcHJvcE9wdGlvbnMgPSBvcHRpb25zLnByb3BzO1xuICBpZiAoaXNEZWYocHJvcE9wdGlvbnMpKSB7XG4gICAgZm9yICh2YXIga2V5IGluIHByb3BPcHRpb25zKSB7XG4gICAgICBwcm9wc1trZXldID0gdmFsaWRhdGVQcm9wKGtleSwgcHJvcE9wdGlvbnMsIHByb3BzRGF0YSB8fCBlbXB0eU9iamVjdCk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmIChpc0RlZihkYXRhLmF0dHJzKSkgeyBtZXJnZVByb3BzKHByb3BzLCBkYXRhLmF0dHJzKTsgfVxuICAgIGlmIChpc0RlZihkYXRhLnByb3BzKSkgeyBtZXJnZVByb3BzKHByb3BzLCBkYXRhLnByb3BzKTsgfVxuICB9XG5cbiAgdmFyIHJlbmRlckNvbnRleHQgPSBuZXcgRnVuY3Rpb25hbFJlbmRlckNvbnRleHQoXG4gICAgZGF0YSxcbiAgICBwcm9wcyxcbiAgICBjaGlsZHJlbixcbiAgICBjb250ZXh0Vm0sXG4gICAgQ3RvclxuICApO1xuXG4gIHZhciB2bm9kZSA9IG9wdGlvbnMucmVuZGVyLmNhbGwobnVsbCwgcmVuZGVyQ29udGV4dC5fYywgcmVuZGVyQ29udGV4dCk7XG5cbiAgaWYgKHZub2RlIGluc3RhbmNlb2YgVk5vZGUpIHtcbiAgICByZXR1cm4gY2xvbmVBbmRNYXJrRnVuY3Rpb25hbFJlc3VsdCh2bm9kZSwgZGF0YSwgcmVuZGVyQ29udGV4dC5wYXJlbnQsIG9wdGlvbnMsIHJlbmRlckNvbnRleHQpXG4gIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheSh2bm9kZSkpIHtcbiAgICB2YXIgdm5vZGVzID0gbm9ybWFsaXplQ2hpbGRyZW4odm5vZGUpIHx8IFtdO1xuICAgIHZhciByZXMgPSBuZXcgQXJyYXkodm5vZGVzLmxlbmd0aCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2bm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHJlc1tpXSA9IGNsb25lQW5kTWFya0Z1bmN0aW9uYWxSZXN1bHQodm5vZGVzW2ldLCBkYXRhLCByZW5kZXJDb250ZXh0LnBhcmVudCwgb3B0aW9ucywgcmVuZGVyQ29udGV4dCk7XG4gICAgfVxuICAgIHJldHVybiByZXNcbiAgfVxufVxuXG5mdW5jdGlvbiBjbG9uZUFuZE1hcmtGdW5jdGlvbmFsUmVzdWx0ICh2bm9kZSwgZGF0YSwgY29udGV4dFZtLCBvcHRpb25zLCByZW5kZXJDb250ZXh0KSB7XG4gIC8vICM3ODE3IGNsb25lIG5vZGUgYmVmb3JlIHNldHRpbmcgZm5Db250ZXh0LCBvdGhlcndpc2UgaWYgdGhlIG5vZGUgaXMgcmV1c2VkXG4gIC8vIChlLmcuIGl0IHdhcyBmcm9tIGEgY2FjaGVkIG5vcm1hbCBzbG90KSB0aGUgZm5Db250ZXh0IGNhdXNlcyBuYW1lZCBzbG90c1xuICAvLyB0aGF0IHNob3VsZCBub3QgYmUgbWF0Y2hlZCB0byBtYXRjaC5cbiAgdmFyIGNsb25lID0gY2xvbmVWTm9kZSh2bm9kZSk7XG4gIGNsb25lLmZuQ29udGV4dCA9IGNvbnRleHRWbTtcbiAgY2xvbmUuZm5PcHRpb25zID0gb3B0aW9ucztcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAoY2xvbmUuZGV2dG9vbHNNZXRhID0gY2xvbmUuZGV2dG9vbHNNZXRhIHx8IHt9KS5yZW5kZXJDb250ZXh0ID0gcmVuZGVyQ29udGV4dDtcbiAgfVxuICBpZiAoZGF0YS5zbG90KSB7XG4gICAgKGNsb25lLmRhdGEgfHwgKGNsb25lLmRhdGEgPSB7fSkpLnNsb3QgPSBkYXRhLnNsb3Q7XG4gIH1cbiAgcmV0dXJuIGNsb25lXG59XG5cbmZ1bmN0aW9uIG1lcmdlUHJvcHMgKHRvLCBmcm9tKSB7XG4gIGZvciAodmFyIGtleSBpbiBmcm9tKSB7XG4gICAgdG9bY2FtZWxpemUoa2V5KV0gPSBmcm9tW2tleV07XG4gIH1cbn1cblxuLyogICovXG5cbi8qICAqL1xuXG4vKiAgKi9cblxuLyogICovXG5cbi8vIGlubGluZSBob29rcyB0byBiZSBpbnZva2VkIG9uIGNvbXBvbmVudCBWTm9kZXMgZHVyaW5nIHBhdGNoXG52YXIgY29tcG9uZW50Vk5vZGVIb29rcyA9IHtcbiAgaW5pdDogZnVuY3Rpb24gaW5pdCAodm5vZGUsIGh5ZHJhdGluZykge1xuICAgIGlmIChcbiAgICAgIHZub2RlLmNvbXBvbmVudEluc3RhbmNlICYmXG4gICAgICAhdm5vZGUuY29tcG9uZW50SW5zdGFuY2UuX2lzRGVzdHJveWVkICYmXG4gICAgICB2bm9kZS5kYXRhLmtlZXBBbGl2ZVxuICAgICkge1xuICAgICAgLy8ga2VwdC1hbGl2ZSBjb21wb25lbnRzLCB0cmVhdCBhcyBhIHBhdGNoXG4gICAgICB2YXIgbW91bnRlZE5vZGUgPSB2bm9kZTsgLy8gd29yayBhcm91bmQgZmxvd1xuICAgICAgY29tcG9uZW50Vk5vZGVIb29rcy5wcmVwYXRjaChtb3VudGVkTm9kZSwgbW91bnRlZE5vZGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgY2hpbGQgPSB2bm9kZS5jb21wb25lbnRJbnN0YW5jZSA9IGNyZWF0ZUNvbXBvbmVudEluc3RhbmNlRm9yVm5vZGUoXG4gICAgICAgIHZub2RlLFxuICAgICAgICBhY3RpdmVJbnN0YW5jZVxuICAgICAgKTtcbiAgICAgIGNoaWxkLiRtb3VudChoeWRyYXRpbmcgPyB2bm9kZS5lbG0gOiB1bmRlZmluZWQsIGh5ZHJhdGluZyk7XG4gICAgfVxuICB9LFxuXG4gIHByZXBhdGNoOiBmdW5jdGlvbiBwcmVwYXRjaCAob2xkVm5vZGUsIHZub2RlKSB7XG4gICAgdmFyIG9wdGlvbnMgPSB2bm9kZS5jb21wb25lbnRPcHRpb25zO1xuICAgIHZhciBjaGlsZCA9IHZub2RlLmNvbXBvbmVudEluc3RhbmNlID0gb2xkVm5vZGUuY29tcG9uZW50SW5zdGFuY2U7XG4gICAgdXBkYXRlQ2hpbGRDb21wb25lbnQoXG4gICAgICBjaGlsZCxcbiAgICAgIG9wdGlvbnMucHJvcHNEYXRhLCAvLyB1cGRhdGVkIHByb3BzXG4gICAgICBvcHRpb25zLmxpc3RlbmVycywgLy8gdXBkYXRlZCBsaXN0ZW5lcnNcbiAgICAgIHZub2RlLCAvLyBuZXcgcGFyZW50IHZub2RlXG4gICAgICBvcHRpb25zLmNoaWxkcmVuIC8vIG5ldyBjaGlsZHJlblxuICAgICk7XG4gIH0sXG5cbiAgaW5zZXJ0OiBmdW5jdGlvbiBpbnNlcnQgKHZub2RlKSB7XG4gICAgdmFyIGNvbnRleHQgPSB2bm9kZS5jb250ZXh0O1xuICAgIHZhciBjb21wb25lbnRJbnN0YW5jZSA9IHZub2RlLmNvbXBvbmVudEluc3RhbmNlO1xuICAgIGlmICghY29tcG9uZW50SW5zdGFuY2UuX2lzTW91bnRlZCkge1xuICAgICAgY29tcG9uZW50SW5zdGFuY2UuX2lzTW91bnRlZCA9IHRydWU7XG4gICAgICBjYWxsSG9vayhjb21wb25lbnRJbnN0YW5jZSwgJ21vdW50ZWQnKTtcbiAgICB9XG4gICAgaWYgKHZub2RlLmRhdGEua2VlcEFsaXZlKSB7XG4gICAgICBpZiAoY29udGV4dC5faXNNb3VudGVkKSB7XG4gICAgICAgIC8vIHZ1ZS1yb3V0ZXIjMTIxMlxuICAgICAgICAvLyBEdXJpbmcgdXBkYXRlcywgYSBrZXB0LWFsaXZlIGNvbXBvbmVudCdzIGNoaWxkIGNvbXBvbmVudHMgbWF5XG4gICAgICAgIC8vIGNoYW5nZSwgc28gZGlyZWN0bHkgd2Fsa2luZyB0aGUgdHJlZSBoZXJlIG1heSBjYWxsIGFjdGl2YXRlZCBob29rc1xuICAgICAgICAvLyBvbiBpbmNvcnJlY3QgY2hpbGRyZW4uIEluc3RlYWQgd2UgcHVzaCB0aGVtIGludG8gYSBxdWV1ZSB3aGljaCB3aWxsXG4gICAgICAgIC8vIGJlIHByb2Nlc3NlZCBhZnRlciB0aGUgd2hvbGUgcGF0Y2ggcHJvY2VzcyBlbmRlZC5cbiAgICAgICAgcXVldWVBY3RpdmF0ZWRDb21wb25lbnQoY29tcG9uZW50SW5zdGFuY2UpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYWN0aXZhdGVDaGlsZENvbXBvbmVudChjb21wb25lbnRJbnN0YW5jZSwgdHJ1ZSAvKiBkaXJlY3QgKi8pO1xuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICBkZXN0cm95OiBmdW5jdGlvbiBkZXN0cm95ICh2bm9kZSkge1xuICAgIHZhciBjb21wb25lbnRJbnN0YW5jZSA9IHZub2RlLmNvbXBvbmVudEluc3RhbmNlO1xuICAgIGlmICghY29tcG9uZW50SW5zdGFuY2UuX2lzRGVzdHJveWVkKSB7XG4gICAgICBpZiAoIXZub2RlLmRhdGEua2VlcEFsaXZlKSB7XG4gICAgICAgIGNvbXBvbmVudEluc3RhbmNlLiRkZXN0cm95KCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkZWFjdGl2YXRlQ2hpbGRDb21wb25lbnQoY29tcG9uZW50SW5zdGFuY2UsIHRydWUgLyogZGlyZWN0ICovKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbnZhciBob29rc1RvTWVyZ2UgPSBPYmplY3Qua2V5cyhjb21wb25lbnRWTm9kZUhvb2tzKTtcblxuZnVuY3Rpb24gY3JlYXRlQ29tcG9uZW50IChcbiAgQ3RvcixcbiAgZGF0YSxcbiAgY29udGV4dCxcbiAgY2hpbGRyZW4sXG4gIHRhZ1xuKSB7XG4gIGlmIChpc1VuZGVmKEN0b3IpKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICB2YXIgYmFzZUN0b3IgPSBjb250ZXh0LiRvcHRpb25zLl9iYXNlO1xuXG4gIC8vIHBsYWluIG9wdGlvbnMgb2JqZWN0OiB0dXJuIGl0IGludG8gYSBjb25zdHJ1Y3RvclxuICBpZiAoaXNPYmplY3QoQ3RvcikpIHtcbiAgICBDdG9yID0gYmFzZUN0b3IuZXh0ZW5kKEN0b3IpO1xuICB9XG5cbiAgLy8gaWYgYXQgdGhpcyBzdGFnZSBpdCdzIG5vdCBhIGNvbnN0cnVjdG9yIG9yIGFuIGFzeW5jIGNvbXBvbmVudCBmYWN0b3J5LFxuICAvLyByZWplY3QuXG4gIGlmICh0eXBlb2YgQ3RvciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICB3YXJuKChcIkludmFsaWQgQ29tcG9uZW50IGRlZmluaXRpb246IFwiICsgKFN0cmluZyhDdG9yKSkpLCBjb250ZXh0KTtcbiAgICB9XG4gICAgcmV0dXJuXG4gIH1cblxuICAvLyBhc3luYyBjb21wb25lbnRcbiAgdmFyIGFzeW5jRmFjdG9yeTtcbiAgaWYgKGlzVW5kZWYoQ3Rvci5jaWQpKSB7XG4gICAgYXN5bmNGYWN0b3J5ID0gQ3RvcjtcbiAgICBDdG9yID0gcmVzb2x2ZUFzeW5jQ29tcG9uZW50KGFzeW5jRmFjdG9yeSwgYmFzZUN0b3IpO1xuICAgIGlmIChDdG9yID09PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIHJldHVybiBhIHBsYWNlaG9sZGVyIG5vZGUgZm9yIGFzeW5jIGNvbXBvbmVudCwgd2hpY2ggaXMgcmVuZGVyZWRcbiAgICAgIC8vIGFzIGEgY29tbWVudCBub2RlIGJ1dCBwcmVzZXJ2ZXMgYWxsIHRoZSByYXcgaW5mb3JtYXRpb24gZm9yIHRoZSBub2RlLlxuICAgICAgLy8gdGhlIGluZm9ybWF0aW9uIHdpbGwgYmUgdXNlZCBmb3IgYXN5bmMgc2VydmVyLXJlbmRlcmluZyBhbmQgaHlkcmF0aW9uLlxuICAgICAgcmV0dXJuIGNyZWF0ZUFzeW5jUGxhY2Vob2xkZXIoXG4gICAgICAgIGFzeW5jRmFjdG9yeSxcbiAgICAgICAgZGF0YSxcbiAgICAgICAgY29udGV4dCxcbiAgICAgICAgY2hpbGRyZW4sXG4gICAgICAgIHRhZ1xuICAgICAgKVxuICAgIH1cbiAgfVxuXG4gIGRhdGEgPSBkYXRhIHx8IHt9O1xuXG4gIC8vIHJlc29sdmUgY29uc3RydWN0b3Igb3B0aW9ucyBpbiBjYXNlIGdsb2JhbCBtaXhpbnMgYXJlIGFwcGxpZWQgYWZ0ZXJcbiAgLy8gY29tcG9uZW50IGNvbnN0cnVjdG9yIGNyZWF0aW9uXG4gIHJlc29sdmVDb25zdHJ1Y3Rvck9wdGlvbnMoQ3Rvcik7XG5cbiAgLy8gdHJhbnNmb3JtIGNvbXBvbmVudCB2LW1vZGVsIGRhdGEgaW50byBwcm9wcyAmIGV2ZW50c1xuICBpZiAoaXNEZWYoZGF0YS5tb2RlbCkpIHtcbiAgICB0cmFuc2Zvcm1Nb2RlbChDdG9yLm9wdGlvbnMsIGRhdGEpO1xuICB9XG5cbiAgLy8gZXh0cmFjdCBwcm9wc1xuICB2YXIgcHJvcHNEYXRhID0gZXh0cmFjdFByb3BzRnJvbVZOb2RlRGF0YShkYXRhLCBDdG9yLCB0YWcpO1xuXG4gIC8vIGZ1bmN0aW9uYWwgY29tcG9uZW50XG4gIGlmIChpc1RydWUoQ3Rvci5vcHRpb25zLmZ1bmN0aW9uYWwpKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUZ1bmN0aW9uYWxDb21wb25lbnQoQ3RvciwgcHJvcHNEYXRhLCBkYXRhLCBjb250ZXh0LCBjaGlsZHJlbilcbiAgfVxuXG4gIC8vIGV4dHJhY3QgbGlzdGVuZXJzLCBzaW5jZSB0aGVzZSBuZWVkcyB0byBiZSB0cmVhdGVkIGFzXG4gIC8vIGNoaWxkIGNvbXBvbmVudCBsaXN0ZW5lcnMgaW5zdGVhZCBvZiBET00gbGlzdGVuZXJzXG4gIHZhciBsaXN0ZW5lcnMgPSBkYXRhLm9uO1xuICAvLyByZXBsYWNlIHdpdGggbGlzdGVuZXJzIHdpdGggLm5hdGl2ZSBtb2RpZmllclxuICAvLyBzbyBpdCBnZXRzIHByb2Nlc3NlZCBkdXJpbmcgcGFyZW50IGNvbXBvbmVudCBwYXRjaC5cbiAgZGF0YS5vbiA9IGRhdGEubmF0aXZlT247XG5cbiAgaWYgKGlzVHJ1ZShDdG9yLm9wdGlvbnMuYWJzdHJhY3QpKSB7XG4gICAgLy8gYWJzdHJhY3QgY29tcG9uZW50cyBkbyBub3Qga2VlcCBhbnl0aGluZ1xuICAgIC8vIG90aGVyIHRoYW4gcHJvcHMgJiBsaXN0ZW5lcnMgJiBzbG90XG5cbiAgICAvLyB3b3JrIGFyb3VuZCBmbG93XG4gICAgdmFyIHNsb3QgPSBkYXRhLnNsb3Q7XG4gICAgZGF0YSA9IHt9O1xuICAgIGlmIChzbG90KSB7XG4gICAgICBkYXRhLnNsb3QgPSBzbG90O1xuICAgIH1cbiAgfVxuXG4gIC8vIGluc3RhbGwgY29tcG9uZW50IG1hbmFnZW1lbnQgaG9va3Mgb250byB0aGUgcGxhY2Vob2xkZXIgbm9kZVxuICBpbnN0YWxsQ29tcG9uZW50SG9va3MoZGF0YSk7XG5cbiAgLy8gcmV0dXJuIGEgcGxhY2Vob2xkZXIgdm5vZGVcbiAgdmFyIG5hbWUgPSBDdG9yLm9wdGlvbnMubmFtZSB8fCB0YWc7XG4gIHZhciB2bm9kZSA9IG5ldyBWTm9kZShcbiAgICAoXCJ2dWUtY29tcG9uZW50LVwiICsgKEN0b3IuY2lkKSArIChuYW1lID8gKFwiLVwiICsgbmFtZSkgOiAnJykpLFxuICAgIGRhdGEsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIGNvbnRleHQsXG4gICAgeyBDdG9yOiBDdG9yLCBwcm9wc0RhdGE6IHByb3BzRGF0YSwgbGlzdGVuZXJzOiBsaXN0ZW5lcnMsIHRhZzogdGFnLCBjaGlsZHJlbjogY2hpbGRyZW4gfSxcbiAgICBhc3luY0ZhY3RvcnlcbiAgKTtcblxuICByZXR1cm4gdm5vZGVcbn1cblxuZnVuY3Rpb24gY3JlYXRlQ29tcG9uZW50SW5zdGFuY2VGb3JWbm9kZSAoXG4gIC8vIHdlIGtub3cgaXQncyBNb3VudGVkQ29tcG9uZW50Vk5vZGUgYnV0IGZsb3cgZG9lc24ndFxuICB2bm9kZSxcbiAgLy8gYWN0aXZlSW5zdGFuY2UgaW4gbGlmZWN5Y2xlIHN0YXRlXG4gIHBhcmVudFxuKSB7XG4gIHZhciBvcHRpb25zID0ge1xuICAgIF9pc0NvbXBvbmVudDogdHJ1ZSxcbiAgICBfcGFyZW50Vm5vZGU6IHZub2RlLFxuICAgIHBhcmVudDogcGFyZW50XG4gIH07XG4gIC8vIGNoZWNrIGlubGluZS10ZW1wbGF0ZSByZW5kZXIgZnVuY3Rpb25zXG4gIHZhciBpbmxpbmVUZW1wbGF0ZSA9IHZub2RlLmRhdGEuaW5saW5lVGVtcGxhdGU7XG4gIGlmIChpc0RlZihpbmxpbmVUZW1wbGF0ZSkpIHtcbiAgICBvcHRpb25zLnJlbmRlciA9IGlubGluZVRlbXBsYXRlLnJlbmRlcjtcbiAgICBvcHRpb25zLnN0YXRpY1JlbmRlckZucyA9IGlubGluZVRlbXBsYXRlLnN0YXRpY1JlbmRlckZucztcbiAgfVxuICByZXR1cm4gbmV3IHZub2RlLmNvbXBvbmVudE9wdGlvbnMuQ3RvcihvcHRpb25zKVxufVxuXG5mdW5jdGlvbiBpbnN0YWxsQ29tcG9uZW50SG9va3MgKGRhdGEpIHtcbiAgdmFyIGhvb2tzID0gZGF0YS5ob29rIHx8IChkYXRhLmhvb2sgPSB7fSk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgaG9va3NUb01lcmdlLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGtleSA9IGhvb2tzVG9NZXJnZVtpXTtcbiAgICB2YXIgZXhpc3RpbmcgPSBob29rc1trZXldO1xuICAgIHZhciB0b01lcmdlID0gY29tcG9uZW50Vk5vZGVIb29rc1trZXldO1xuICAgIGlmIChleGlzdGluZyAhPT0gdG9NZXJnZSAmJiAhKGV4aXN0aW5nICYmIGV4aXN0aW5nLl9tZXJnZWQpKSB7XG4gICAgICBob29rc1trZXldID0gZXhpc3RpbmcgPyBtZXJnZUhvb2skMSh0b01lcmdlLCBleGlzdGluZykgOiB0b01lcmdlO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBtZXJnZUhvb2skMSAoZjEsIGYyKSB7XG4gIHZhciBtZXJnZWQgPSBmdW5jdGlvbiAoYSwgYikge1xuICAgIC8vIGZsb3cgY29tcGxhaW5zIGFib3V0IGV4dHJhIGFyZ3Mgd2hpY2ggaXMgd2h5IHdlIHVzZSBhbnlcbiAgICBmMShhLCBiKTtcbiAgICBmMihhLCBiKTtcbiAgfTtcbiAgbWVyZ2VkLl9tZXJnZWQgPSB0cnVlO1xuICByZXR1cm4gbWVyZ2VkXG59XG5cbi8vIHRyYW5zZm9ybSBjb21wb25lbnQgdi1tb2RlbCBpbmZvICh2YWx1ZSBhbmQgY2FsbGJhY2spIGludG9cbi8vIHByb3AgYW5kIGV2ZW50IGhhbmRsZXIgcmVzcGVjdGl2ZWx5LlxuZnVuY3Rpb24gdHJhbnNmb3JtTW9kZWwgKG9wdGlvbnMsIGRhdGEpIHtcbiAgdmFyIHByb3AgPSAob3B0aW9ucy5tb2RlbCAmJiBvcHRpb25zLm1vZGVsLnByb3ApIHx8ICd2YWx1ZSc7XG4gIHZhciBldmVudCA9IChvcHRpb25zLm1vZGVsICYmIG9wdGlvbnMubW9kZWwuZXZlbnQpIHx8ICdpbnB1dCdcbiAgOyhkYXRhLmF0dHJzIHx8IChkYXRhLmF0dHJzID0ge30pKVtwcm9wXSA9IGRhdGEubW9kZWwudmFsdWU7XG4gIHZhciBvbiA9IGRhdGEub24gfHwgKGRhdGEub24gPSB7fSk7XG4gIHZhciBleGlzdGluZyA9IG9uW2V2ZW50XTtcbiAgdmFyIGNhbGxiYWNrID0gZGF0YS5tb2RlbC5jYWxsYmFjaztcbiAgaWYgKGlzRGVmKGV4aXN0aW5nKSkge1xuICAgIGlmIChcbiAgICAgIEFycmF5LmlzQXJyYXkoZXhpc3RpbmcpXG4gICAgICAgID8gZXhpc3RpbmcuaW5kZXhPZihjYWxsYmFjaykgPT09IC0xXG4gICAgICAgIDogZXhpc3RpbmcgIT09IGNhbGxiYWNrXG4gICAgKSB7XG4gICAgICBvbltldmVudF0gPSBbY2FsbGJhY2tdLmNvbmNhdChleGlzdGluZyk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIG9uW2V2ZW50XSA9IGNhbGxiYWNrO1xuICB9XG59XG5cbi8qICAqL1xuXG52YXIgU0lNUExFX05PUk1BTElaRSA9IDE7XG52YXIgQUxXQVlTX05PUk1BTElaRSA9IDI7XG5cbi8vIHdyYXBwZXIgZnVuY3Rpb24gZm9yIHByb3ZpZGluZyBhIG1vcmUgZmxleGlibGUgaW50ZXJmYWNlXG4vLyB3aXRob3V0IGdldHRpbmcgeWVsbGVkIGF0IGJ5IGZsb3dcbmZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnQgKFxuICBjb250ZXh0LFxuICB0YWcsXG4gIGRhdGEsXG4gIGNoaWxkcmVuLFxuICBub3JtYWxpemF0aW9uVHlwZSxcbiAgYWx3YXlzTm9ybWFsaXplXG4pIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoZGF0YSkgfHwgaXNQcmltaXRpdmUoZGF0YSkpIHtcbiAgICBub3JtYWxpemF0aW9uVHlwZSA9IGNoaWxkcmVuO1xuICAgIGNoaWxkcmVuID0gZGF0YTtcbiAgICBkYXRhID0gdW5kZWZpbmVkO1xuICB9XG4gIGlmIChpc1RydWUoYWx3YXlzTm9ybWFsaXplKSkge1xuICAgIG5vcm1hbGl6YXRpb25UeXBlID0gQUxXQVlTX05PUk1BTElaRTtcbiAgfVxuICByZXR1cm4gX2NyZWF0ZUVsZW1lbnQoY29udGV4dCwgdGFnLCBkYXRhLCBjaGlsZHJlbiwgbm9ybWFsaXphdGlvblR5cGUpXG59XG5cbmZ1bmN0aW9uIF9jcmVhdGVFbGVtZW50IChcbiAgY29udGV4dCxcbiAgdGFnLFxuICBkYXRhLFxuICBjaGlsZHJlbixcbiAgbm9ybWFsaXphdGlvblR5cGVcbikge1xuICBpZiAoaXNEZWYoZGF0YSkgJiYgaXNEZWYoKGRhdGEpLl9fb2JfXykpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oXG4gICAgICBcIkF2b2lkIHVzaW5nIG9ic2VydmVkIGRhdGEgb2JqZWN0IGFzIHZub2RlIGRhdGE6IFwiICsgKEpTT04uc3RyaW5naWZ5KGRhdGEpKSArIFwiXFxuXCIgK1xuICAgICAgJ0Fsd2F5cyBjcmVhdGUgZnJlc2ggdm5vZGUgZGF0YSBvYmplY3RzIGluIGVhY2ggcmVuZGVyIScsXG4gICAgICBjb250ZXh0XG4gICAgKTtcbiAgICByZXR1cm4gY3JlYXRlRW1wdHlWTm9kZSgpXG4gIH1cbiAgLy8gb2JqZWN0IHN5bnRheCBpbiB2LWJpbmRcbiAgaWYgKGlzRGVmKGRhdGEpICYmIGlzRGVmKGRhdGEuaXMpKSB7XG4gICAgdGFnID0gZGF0YS5pcztcbiAgfVxuICBpZiAoIXRhZykge1xuICAgIC8vIGluIGNhc2Ugb2YgY29tcG9uZW50IDppcyBzZXQgdG8gZmFsc3kgdmFsdWVcbiAgICByZXR1cm4gY3JlYXRlRW1wdHlWTm9kZSgpXG4gIH1cbiAgLy8gd2FybiBhZ2FpbnN0IG5vbi1wcmltaXRpdmUga2V5XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmXG4gICAgaXNEZWYoZGF0YSkgJiYgaXNEZWYoZGF0YS5rZXkpICYmICFpc1ByaW1pdGl2ZShkYXRhLmtleSlcbiAgKSB7XG4gICAge1xuICAgICAgd2FybihcbiAgICAgICAgJ0F2b2lkIHVzaW5nIG5vbi1wcmltaXRpdmUgdmFsdWUgYXMga2V5LCAnICtcbiAgICAgICAgJ3VzZSBzdHJpbmcvbnVtYmVyIHZhbHVlIGluc3RlYWQuJyxcbiAgICAgICAgY29udGV4dFxuICAgICAgKTtcbiAgICB9XG4gIH1cbiAgLy8gc3VwcG9ydCBzaW5nbGUgZnVuY3Rpb24gY2hpbGRyZW4gYXMgZGVmYXVsdCBzY29wZWQgc2xvdFxuICBpZiAoQXJyYXkuaXNBcnJheShjaGlsZHJlbikgJiZcbiAgICB0eXBlb2YgY2hpbGRyZW5bMF0gPT09ICdmdW5jdGlvbidcbiAgKSB7XG4gICAgZGF0YSA9IGRhdGEgfHwge307XG4gICAgZGF0YS5zY29wZWRTbG90cyA9IHsgZGVmYXVsdDogY2hpbGRyZW5bMF0gfTtcbiAgICBjaGlsZHJlbi5sZW5ndGggPSAwO1xuICB9XG4gIGlmIChub3JtYWxpemF0aW9uVHlwZSA9PT0gQUxXQVlTX05PUk1BTElaRSkge1xuICAgIGNoaWxkcmVuID0gbm9ybWFsaXplQ2hpbGRyZW4oY2hpbGRyZW4pO1xuICB9IGVsc2UgaWYgKG5vcm1hbGl6YXRpb25UeXBlID09PSBTSU1QTEVfTk9STUFMSVpFKSB7XG4gICAgY2hpbGRyZW4gPSBzaW1wbGVOb3JtYWxpemVDaGlsZHJlbihjaGlsZHJlbik7XG4gIH1cbiAgdmFyIHZub2RlLCBucztcbiAgaWYgKHR5cGVvZiB0YWcgPT09ICdzdHJpbmcnKSB7XG4gICAgdmFyIEN0b3I7XG4gICAgbnMgPSAoY29udGV4dC4kdm5vZGUgJiYgY29udGV4dC4kdm5vZGUubnMpIHx8IGNvbmZpZy5nZXRUYWdOYW1lc3BhY2UodGFnKTtcbiAgICBpZiAoY29uZmlnLmlzUmVzZXJ2ZWRUYWcodGFnKSkge1xuICAgICAgLy8gcGxhdGZvcm0gYnVpbHQtaW4gZWxlbWVudHNcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGlzRGVmKGRhdGEpICYmIGlzRGVmKGRhdGEubmF0aXZlT24pICYmIGRhdGEudGFnICE9PSAnY29tcG9uZW50Jykge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgIChcIlRoZSAubmF0aXZlIG1vZGlmaWVyIGZvciB2LW9uIGlzIG9ubHkgdmFsaWQgb24gY29tcG9uZW50cyBidXQgaXQgd2FzIHVzZWQgb24gPFwiICsgdGFnICsgXCI+LlwiKSxcbiAgICAgICAgICBjb250ZXh0XG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICB2bm9kZSA9IG5ldyBWTm9kZShcbiAgICAgICAgY29uZmlnLnBhcnNlUGxhdGZvcm1UYWdOYW1lKHRhZyksIGRhdGEsIGNoaWxkcmVuLFxuICAgICAgICB1bmRlZmluZWQsIHVuZGVmaW5lZCwgY29udGV4dFxuICAgICAgKTtcbiAgICB9IGVsc2UgaWYgKCghZGF0YSB8fCAhZGF0YS5wcmUpICYmIGlzRGVmKEN0b3IgPSByZXNvbHZlQXNzZXQoY29udGV4dC4kb3B0aW9ucywgJ2NvbXBvbmVudHMnLCB0YWcpKSkge1xuICAgICAgLy8gY29tcG9uZW50XG4gICAgICB2bm9kZSA9IGNyZWF0ZUNvbXBvbmVudChDdG9yLCBkYXRhLCBjb250ZXh0LCBjaGlsZHJlbiwgdGFnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gdW5rbm93biBvciB1bmxpc3RlZCBuYW1lc3BhY2VkIGVsZW1lbnRzXG4gICAgICAvLyBjaGVjayBhdCBydW50aW1lIGJlY2F1c2UgaXQgbWF5IGdldCBhc3NpZ25lZCBhIG5hbWVzcGFjZSB3aGVuIGl0c1xuICAgICAgLy8gcGFyZW50IG5vcm1hbGl6ZXMgY2hpbGRyZW5cbiAgICAgIHZub2RlID0gbmV3IFZOb2RlKFxuICAgICAgICB0YWcsIGRhdGEsIGNoaWxkcmVuLFxuICAgICAgICB1bmRlZmluZWQsIHVuZGVmaW5lZCwgY29udGV4dFxuICAgICAgKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gZGlyZWN0IGNvbXBvbmVudCBvcHRpb25zIC8gY29uc3RydWN0b3JcbiAgICB2bm9kZSA9IGNyZWF0ZUNvbXBvbmVudCh0YWcsIGRhdGEsIGNvbnRleHQsIGNoaWxkcmVuKTtcbiAgfVxuICBpZiAoQXJyYXkuaXNBcnJheSh2bm9kZSkpIHtcbiAgICByZXR1cm4gdm5vZGVcbiAgfSBlbHNlIGlmIChpc0RlZih2bm9kZSkpIHtcbiAgICBpZiAoaXNEZWYobnMpKSB7IGFwcGx5TlModm5vZGUsIG5zKTsgfVxuICAgIGlmIChpc0RlZihkYXRhKSkgeyByZWdpc3RlckRlZXBCaW5kaW5ncyhkYXRhKTsgfVxuICAgIHJldHVybiB2bm9kZVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBjcmVhdGVFbXB0eVZOb2RlKClcbiAgfVxufVxuXG5mdW5jdGlvbiBhcHBseU5TICh2bm9kZSwgbnMsIGZvcmNlKSB7XG4gIHZub2RlLm5zID0gbnM7XG4gIGlmICh2bm9kZS50YWcgPT09ICdmb3JlaWduT2JqZWN0Jykge1xuICAgIC8vIHVzZSBkZWZhdWx0IG5hbWVzcGFjZSBpbnNpZGUgZm9yZWlnbk9iamVjdFxuICAgIG5zID0gdW5kZWZpbmVkO1xuICAgIGZvcmNlID0gdHJ1ZTtcbiAgfVxuICBpZiAoaXNEZWYodm5vZGUuY2hpbGRyZW4pKSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSB2bm9kZS5jaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIHZhciBjaGlsZCA9IHZub2RlLmNoaWxkcmVuW2ldO1xuICAgICAgaWYgKGlzRGVmKGNoaWxkLnRhZykgJiYgKFxuICAgICAgICBpc1VuZGVmKGNoaWxkLm5zKSB8fCAoaXNUcnVlKGZvcmNlKSAmJiBjaGlsZC50YWcgIT09ICdzdmcnKSkpIHtcbiAgICAgICAgYXBwbHlOUyhjaGlsZCwgbnMsIGZvcmNlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLy8gcmVmICM1MzE4XG4vLyBuZWNlc3NhcnkgdG8gZW5zdXJlIHBhcmVudCByZS1yZW5kZXIgd2hlbiBkZWVwIGJpbmRpbmdzIGxpa2UgOnN0eWxlIGFuZFxuLy8gOmNsYXNzIGFyZSB1c2VkIG9uIHNsb3Qgbm9kZXNcbmZ1bmN0aW9uIHJlZ2lzdGVyRGVlcEJpbmRpbmdzIChkYXRhKSB7XG4gIGlmIChpc09iamVjdChkYXRhLnN0eWxlKSkge1xuICAgIHRyYXZlcnNlKGRhdGEuc3R5bGUpO1xuICB9XG4gIGlmIChpc09iamVjdChkYXRhLmNsYXNzKSkge1xuICAgIHRyYXZlcnNlKGRhdGEuY2xhc3MpO1xuICB9XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBpbml0UmVuZGVyICh2bSkge1xuICB2bS5fdm5vZGUgPSBudWxsOyAvLyB0aGUgcm9vdCBvZiB0aGUgY2hpbGQgdHJlZVxuICB2bS5fc3RhdGljVHJlZXMgPSBudWxsOyAvLyB2LW9uY2UgY2FjaGVkIHRyZWVzXG4gIHZhciBvcHRpb25zID0gdm0uJG9wdGlvbnM7XG4gIHZhciBwYXJlbnRWbm9kZSA9IHZtLiR2bm9kZSA9IG9wdGlvbnMuX3BhcmVudFZub2RlOyAvLyB0aGUgcGxhY2Vob2xkZXIgbm9kZSBpbiBwYXJlbnQgdHJlZVxuICB2YXIgcmVuZGVyQ29udGV4dCA9IHBhcmVudFZub2RlICYmIHBhcmVudFZub2RlLmNvbnRleHQ7XG4gIHZtLiRzbG90cyA9IHJlc29sdmVTbG90cyhvcHRpb25zLl9yZW5kZXJDaGlsZHJlbiwgcmVuZGVyQ29udGV4dCk7XG4gIHZtLiRzY29wZWRTbG90cyA9IGVtcHR5T2JqZWN0O1xuICAvLyBiaW5kIHRoZSBjcmVhdGVFbGVtZW50IGZuIHRvIHRoaXMgaW5zdGFuY2VcbiAgLy8gc28gdGhhdCB3ZSBnZXQgcHJvcGVyIHJlbmRlciBjb250ZXh0IGluc2lkZSBpdC5cbiAgLy8gYXJncyBvcmRlcjogdGFnLCBkYXRhLCBjaGlsZHJlbiwgbm9ybWFsaXphdGlvblR5cGUsIGFsd2F5c05vcm1hbGl6ZVxuICAvLyBpbnRlcm5hbCB2ZXJzaW9uIGlzIHVzZWQgYnkgcmVuZGVyIGZ1bmN0aW9ucyBjb21waWxlZCBmcm9tIHRlbXBsYXRlc1xuICB2bS5fYyA9IGZ1bmN0aW9uIChhLCBiLCBjLCBkKSB7IHJldHVybiBjcmVhdGVFbGVtZW50KHZtLCBhLCBiLCBjLCBkLCBmYWxzZSk7IH07XG4gIC8vIG5vcm1hbGl6YXRpb24gaXMgYWx3YXlzIGFwcGxpZWQgZm9yIHRoZSBwdWJsaWMgdmVyc2lvbiwgdXNlZCBpblxuICAvLyB1c2VyLXdyaXR0ZW4gcmVuZGVyIGZ1bmN0aW9ucy5cbiAgdm0uJGNyZWF0ZUVsZW1lbnQgPSBmdW5jdGlvbiAoYSwgYiwgYywgZCkgeyByZXR1cm4gY3JlYXRlRWxlbWVudCh2bSwgYSwgYiwgYywgZCwgdHJ1ZSk7IH07XG5cbiAgLy8gJGF0dHJzICYgJGxpc3RlbmVycyBhcmUgZXhwb3NlZCBmb3IgZWFzaWVyIEhPQyBjcmVhdGlvbi5cbiAgLy8gdGhleSBuZWVkIHRvIGJlIHJlYWN0aXZlIHNvIHRoYXQgSE9DcyB1c2luZyB0aGVtIGFyZSBhbHdheXMgdXBkYXRlZFxuICB2YXIgcGFyZW50RGF0YSA9IHBhcmVudFZub2RlICYmIHBhcmVudFZub2RlLmRhdGE7XG5cbiAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBkZWZpbmVSZWFjdGl2ZSQkMSh2bSwgJyRhdHRycycsIHBhcmVudERhdGEgJiYgcGFyZW50RGF0YS5hdHRycyB8fCBlbXB0eU9iamVjdCwgZnVuY3Rpb24gKCkge1xuICAgICAgIWlzVXBkYXRpbmdDaGlsZENvbXBvbmVudCAmJiB3YXJuKFwiJGF0dHJzIGlzIHJlYWRvbmx5LlwiLCB2bSk7XG4gICAgfSwgdHJ1ZSk7XG4gICAgZGVmaW5lUmVhY3RpdmUkJDEodm0sICckbGlzdGVuZXJzJywgb3B0aW9ucy5fcGFyZW50TGlzdGVuZXJzIHx8IGVtcHR5T2JqZWN0LCBmdW5jdGlvbiAoKSB7XG4gICAgICAhaXNVcGRhdGluZ0NoaWxkQ29tcG9uZW50ICYmIHdhcm4oXCIkbGlzdGVuZXJzIGlzIHJlYWRvbmx5LlwiLCB2bSk7XG4gICAgfSwgdHJ1ZSk7XG4gIH0gZWxzZSB7XG4gICAgZGVmaW5lUmVhY3RpdmUkJDEodm0sICckYXR0cnMnLCBwYXJlbnREYXRhICYmIHBhcmVudERhdGEuYXR0cnMgfHwgZW1wdHlPYmplY3QsIG51bGwsIHRydWUpO1xuICAgIGRlZmluZVJlYWN0aXZlJCQxKHZtLCAnJGxpc3RlbmVycycsIG9wdGlvbnMuX3BhcmVudExpc3RlbmVycyB8fCBlbXB0eU9iamVjdCwgbnVsbCwgdHJ1ZSk7XG4gIH1cbn1cblxudmFyIGN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZSA9IG51bGw7XG5cbmZ1bmN0aW9uIHJlbmRlck1peGluIChWdWUpIHtcbiAgLy8gaW5zdGFsbCBydW50aW1lIGNvbnZlbmllbmNlIGhlbHBlcnNcbiAgaW5zdGFsbFJlbmRlckhlbHBlcnMoVnVlLnByb3RvdHlwZSk7XG5cbiAgVnVlLnByb3RvdHlwZS4kbmV4dFRpY2sgPSBmdW5jdGlvbiAoZm4pIHtcbiAgICByZXR1cm4gbmV4dFRpY2soZm4sIHRoaXMpXG4gIH07XG5cbiAgVnVlLnByb3RvdHlwZS5fcmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciB2bSA9IHRoaXM7XG4gICAgdmFyIHJlZiA9IHZtLiRvcHRpb25zO1xuICAgIHZhciByZW5kZXIgPSByZWYucmVuZGVyO1xuICAgIHZhciBfcGFyZW50Vm5vZGUgPSByZWYuX3BhcmVudFZub2RlO1xuXG4gICAgaWYgKF9wYXJlbnRWbm9kZSkge1xuICAgICAgdm0uJHNjb3BlZFNsb3RzID0gbm9ybWFsaXplU2NvcGVkU2xvdHMoXG4gICAgICAgIF9wYXJlbnRWbm9kZS5kYXRhLnNjb3BlZFNsb3RzLFxuICAgICAgICB2bS4kc2xvdHMsXG4gICAgICAgIHZtLiRzY29wZWRTbG90c1xuICAgICAgKTtcbiAgICB9XG5cbiAgICAvLyBzZXQgcGFyZW50IHZub2RlLiB0aGlzIGFsbG93cyByZW5kZXIgZnVuY3Rpb25zIHRvIGhhdmUgYWNjZXNzXG4gICAgLy8gdG8gdGhlIGRhdGEgb24gdGhlIHBsYWNlaG9sZGVyIG5vZGUuXG4gICAgdm0uJHZub2RlID0gX3BhcmVudFZub2RlO1xuICAgIC8vIHJlbmRlciBzZWxmXG4gICAgdmFyIHZub2RlO1xuICAgIHRyeSB7XG4gICAgICAvLyBUaGVyZSdzIG5vIG5lZWQgdG8gbWFpbnRhaW4gYSBzdGFjayBiZWNhdXNlIGFsbCByZW5kZXIgZm5zIGFyZSBjYWxsZWRcbiAgICAgIC8vIHNlcGFyYXRlbHkgZnJvbSBvbmUgYW5vdGhlci4gTmVzdGVkIGNvbXBvbmVudCdzIHJlbmRlciBmbnMgYXJlIGNhbGxlZFxuICAgICAgLy8gd2hlbiBwYXJlbnQgY29tcG9uZW50IGlzIHBhdGNoZWQuXG4gICAgICBjdXJyZW50UmVuZGVyaW5nSW5zdGFuY2UgPSB2bTtcbiAgICAgIHZub2RlID0gcmVuZGVyLmNhbGwodm0uX3JlbmRlclByb3h5LCB2bS4kY3JlYXRlRWxlbWVudCk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgaGFuZGxlRXJyb3IoZSwgdm0sIFwicmVuZGVyXCIpO1xuICAgICAgLy8gcmV0dXJuIGVycm9yIHJlbmRlciByZXN1bHQsXG4gICAgICAvLyBvciBwcmV2aW91cyB2bm9kZSB0byBwcmV2ZW50IHJlbmRlciBlcnJvciBjYXVzaW5nIGJsYW5rIGNvbXBvbmVudFxuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHZtLiRvcHRpb25zLnJlbmRlckVycm9yKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgdm5vZGUgPSB2bS4kb3B0aW9ucy5yZW5kZXJFcnJvci5jYWxsKHZtLl9yZW5kZXJQcm94eSwgdm0uJGNyZWF0ZUVsZW1lbnQsIGUpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgaGFuZGxlRXJyb3IoZSwgdm0sIFwicmVuZGVyRXJyb3JcIik7XG4gICAgICAgICAgdm5vZGUgPSB2bS5fdm5vZGU7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZub2RlID0gdm0uX3Zub2RlO1xuICAgICAgfVxuICAgIH0gZmluYWxseSB7XG4gICAgICBjdXJyZW50UmVuZGVyaW5nSW5zdGFuY2UgPSBudWxsO1xuICAgIH1cbiAgICAvLyBpZiB0aGUgcmV0dXJuZWQgYXJyYXkgY29udGFpbnMgb25seSBhIHNpbmdsZSBub2RlLCBhbGxvdyBpdFxuICAgIGlmIChBcnJheS5pc0FycmF5KHZub2RlKSAmJiB2bm9kZS5sZW5ndGggPT09IDEpIHtcbiAgICAgIHZub2RlID0gdm5vZGVbMF07XG4gICAgfVxuICAgIC8vIHJldHVybiBlbXB0eSB2bm9kZSBpbiBjYXNlIHRoZSByZW5kZXIgZnVuY3Rpb24gZXJyb3JlZCBvdXRcbiAgICBpZiAoISh2bm9kZSBpbnN0YW5jZW9mIFZOb2RlKSkge1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgQXJyYXkuaXNBcnJheSh2bm9kZSkpIHtcbiAgICAgICAgd2FybihcbiAgICAgICAgICAnTXVsdGlwbGUgcm9vdCBub2RlcyByZXR1cm5lZCBmcm9tIHJlbmRlciBmdW5jdGlvbi4gUmVuZGVyIGZ1bmN0aW9uICcgK1xuICAgICAgICAgICdzaG91bGQgcmV0dXJuIGEgc2luZ2xlIHJvb3Qgbm9kZS4nLFxuICAgICAgICAgIHZtXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICB2bm9kZSA9IGNyZWF0ZUVtcHR5Vk5vZGUoKTtcbiAgICB9XG4gICAgLy8gc2V0IHBhcmVudFxuICAgIHZub2RlLnBhcmVudCA9IF9wYXJlbnRWbm9kZTtcbiAgICByZXR1cm4gdm5vZGVcbiAgfTtcbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGVuc3VyZUN0b3IgKGNvbXAsIGJhc2UpIHtcbiAgaWYgKFxuICAgIGNvbXAuX19lc01vZHVsZSB8fFxuICAgIChoYXNTeW1ib2wgJiYgY29tcFtTeW1ib2wudG9TdHJpbmdUYWddID09PSAnTW9kdWxlJylcbiAgKSB7XG4gICAgY29tcCA9IGNvbXAuZGVmYXVsdDtcbiAgfVxuICByZXR1cm4gaXNPYmplY3QoY29tcClcbiAgICA/IGJhc2UuZXh0ZW5kKGNvbXApXG4gICAgOiBjb21wXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUFzeW5jUGxhY2Vob2xkZXIgKFxuICBmYWN0b3J5LFxuICBkYXRhLFxuICBjb250ZXh0LFxuICBjaGlsZHJlbixcbiAgdGFnXG4pIHtcbiAgdmFyIG5vZGUgPSBjcmVhdGVFbXB0eVZOb2RlKCk7XG4gIG5vZGUuYXN5bmNGYWN0b3J5ID0gZmFjdG9yeTtcbiAgbm9kZS5hc3luY01ldGEgPSB7IGRhdGE6IGRhdGEsIGNvbnRleHQ6IGNvbnRleHQsIGNoaWxkcmVuOiBjaGlsZHJlbiwgdGFnOiB0YWcgfTtcbiAgcmV0dXJuIG5vZGVcbn1cblxuZnVuY3Rpb24gcmVzb2x2ZUFzeW5jQ29tcG9uZW50IChcbiAgZmFjdG9yeSxcbiAgYmFzZUN0b3Jcbikge1xuICBpZiAoaXNUcnVlKGZhY3RvcnkuZXJyb3IpICYmIGlzRGVmKGZhY3RvcnkuZXJyb3JDb21wKSkge1xuICAgIHJldHVybiBmYWN0b3J5LmVycm9yQ29tcFxuICB9XG5cbiAgaWYgKGlzRGVmKGZhY3RvcnkucmVzb2x2ZWQpKSB7XG4gICAgcmV0dXJuIGZhY3RvcnkucmVzb2x2ZWRcbiAgfVxuXG4gIHZhciBvd25lciA9IGN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZTtcbiAgaWYgKG93bmVyICYmIGlzRGVmKGZhY3Rvcnkub3duZXJzKSAmJiBmYWN0b3J5Lm93bmVycy5pbmRleE9mKG93bmVyKSA9PT0gLTEpIHtcbiAgICAvLyBhbHJlYWR5IHBlbmRpbmdcbiAgICBmYWN0b3J5Lm93bmVycy5wdXNoKG93bmVyKTtcbiAgfVxuXG4gIGlmIChpc1RydWUoZmFjdG9yeS5sb2FkaW5nKSAmJiBpc0RlZihmYWN0b3J5LmxvYWRpbmdDb21wKSkge1xuICAgIHJldHVybiBmYWN0b3J5LmxvYWRpbmdDb21wXG4gIH1cblxuICBpZiAob3duZXIgJiYgIWlzRGVmKGZhY3Rvcnkub3duZXJzKSkge1xuICAgIHZhciBvd25lcnMgPSBmYWN0b3J5Lm93bmVycyA9IFtvd25lcl07XG4gICAgdmFyIHN5bmMgPSB0cnVlO1xuICAgIHZhciB0aW1lckxvYWRpbmcgPSBudWxsO1xuICAgIHZhciB0aW1lclRpbWVvdXQgPSBudWxsXG5cbiAgICA7KG93bmVyKS4kb24oJ2hvb2s6ZGVzdHJveWVkJywgZnVuY3Rpb24gKCkgeyByZXR1cm4gcmVtb3ZlKG93bmVycywgb3duZXIpOyB9KTtcblxuICAgIHZhciBmb3JjZVJlbmRlciA9IGZ1bmN0aW9uIChyZW5kZXJDb21wbGV0ZWQpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gb3duZXJzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAob3duZXJzW2ldKS4kZm9yY2VVcGRhdGUoKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHJlbmRlckNvbXBsZXRlZCkge1xuICAgICAgICBvd25lcnMubGVuZ3RoID0gMDtcbiAgICAgICAgaWYgKHRpbWVyTG9hZGluZyAhPT0gbnVsbCkge1xuICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lckxvYWRpbmcpO1xuICAgICAgICAgIHRpbWVyTG9hZGluZyA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRpbWVyVGltZW91dCAhPT0gbnVsbCkge1xuICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lclRpbWVvdXQpO1xuICAgICAgICAgIHRpbWVyVGltZW91dCA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIHJlc29sdmUgPSBvbmNlKGZ1bmN0aW9uIChyZXMpIHtcbiAgICAgIC8vIGNhY2hlIHJlc29sdmVkXG4gICAgICBmYWN0b3J5LnJlc29sdmVkID0gZW5zdXJlQ3RvcihyZXMsIGJhc2VDdG9yKTtcbiAgICAgIC8vIGludm9rZSBjYWxsYmFja3Mgb25seSBpZiB0aGlzIGlzIG5vdCBhIHN5bmNocm9ub3VzIHJlc29sdmVcbiAgICAgIC8vIChhc3luYyByZXNvbHZlcyBhcmUgc2hpbW1lZCBhcyBzeW5jaHJvbm91cyBkdXJpbmcgU1NSKVxuICAgICAgaWYgKCFzeW5jKSB7XG4gICAgICAgIGZvcmNlUmVuZGVyKHRydWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb3duZXJzLmxlbmd0aCA9IDA7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICB2YXIgcmVqZWN0ID0gb25jZShmdW5jdGlvbiAocmVhc29uKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oXG4gICAgICAgIFwiRmFpbGVkIHRvIHJlc29sdmUgYXN5bmMgY29tcG9uZW50OiBcIiArIChTdHJpbmcoZmFjdG9yeSkpICtcbiAgICAgICAgKHJlYXNvbiA/IChcIlxcblJlYXNvbjogXCIgKyByZWFzb24pIDogJycpXG4gICAgICApO1xuICAgICAgaWYgKGlzRGVmKGZhY3RvcnkuZXJyb3JDb21wKSkge1xuICAgICAgICBmYWN0b3J5LmVycm9yID0gdHJ1ZTtcbiAgICAgICAgZm9yY2VSZW5kZXIodHJ1ZSk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICB2YXIgcmVzID0gZmFjdG9yeShyZXNvbHZlLCByZWplY3QpO1xuXG4gICAgaWYgKGlzT2JqZWN0KHJlcykpIHtcbiAgICAgIGlmIChpc1Byb21pc2UocmVzKSkge1xuICAgICAgICAvLyAoKSA9PiBQcm9taXNlXG4gICAgICAgIGlmIChpc1VuZGVmKGZhY3RvcnkucmVzb2x2ZWQpKSB7XG4gICAgICAgICAgcmVzLnRoZW4ocmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChpc1Byb21pc2UocmVzLmNvbXBvbmVudCkpIHtcbiAgICAgICAgcmVzLmNvbXBvbmVudC50aGVuKHJlc29sdmUsIHJlamVjdCk7XG5cbiAgICAgICAgaWYgKGlzRGVmKHJlcy5lcnJvcikpIHtcbiAgICAgICAgICBmYWN0b3J5LmVycm9yQ29tcCA9IGVuc3VyZUN0b3IocmVzLmVycm9yLCBiYXNlQ3Rvcik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNEZWYocmVzLmxvYWRpbmcpKSB7XG4gICAgICAgICAgZmFjdG9yeS5sb2FkaW5nQ29tcCA9IGVuc3VyZUN0b3IocmVzLmxvYWRpbmcsIGJhc2VDdG9yKTtcbiAgICAgICAgICBpZiAocmVzLmRlbGF5ID09PSAwKSB7XG4gICAgICAgICAgICBmYWN0b3J5LmxvYWRpbmcgPSB0cnVlO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aW1lckxvYWRpbmcgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgdGltZXJMb2FkaW5nID0gbnVsbDtcbiAgICAgICAgICAgICAgaWYgKGlzVW5kZWYoZmFjdG9yeS5yZXNvbHZlZCkgJiYgaXNVbmRlZihmYWN0b3J5LmVycm9yKSkge1xuICAgICAgICAgICAgICAgIGZhY3RvcnkubG9hZGluZyA9IHRydWU7XG4gICAgICAgICAgICAgICAgZm9yY2VSZW5kZXIoZmFsc2UpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCByZXMuZGVsYXkgfHwgMjAwKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNEZWYocmVzLnRpbWVvdXQpKSB7XG4gICAgICAgICAgdGltZXJUaW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aW1lclRpbWVvdXQgPSBudWxsO1xuICAgICAgICAgICAgaWYgKGlzVW5kZWYoZmFjdG9yeS5yZXNvbHZlZCkpIHtcbiAgICAgICAgICAgICAgcmVqZWN0KFxuICAgICAgICAgICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbidcbiAgICAgICAgICAgICAgICAgID8gKFwidGltZW91dCAoXCIgKyAocmVzLnRpbWVvdXQpICsgXCJtcylcIilcbiAgICAgICAgICAgICAgICAgIDogbnVsbFxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sIHJlcy50aW1lb3V0KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHN5bmMgPSBmYWxzZTtcbiAgICAvLyByZXR1cm4gaW4gY2FzZSByZXNvbHZlZCBzeW5jaHJvbm91c2x5XG4gICAgcmV0dXJuIGZhY3RvcnkubG9hZGluZ1xuICAgICAgPyBmYWN0b3J5LmxvYWRpbmdDb21wXG4gICAgICA6IGZhY3RvcnkucmVzb2x2ZWRcbiAgfVxufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gZ2V0Rmlyc3RDb21wb25lbnRDaGlsZCAoY2hpbGRyZW4pIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoY2hpbGRyZW4pKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGMgPSBjaGlsZHJlbltpXTtcbiAgICAgIGlmIChpc0RlZihjKSAmJiAoaXNEZWYoYy5jb21wb25lbnRPcHRpb25zKSB8fCBpc0FzeW5jUGxhY2Vob2xkZXIoYykpKSB7XG4gICAgICAgIHJldHVybiBjXG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8qICAqL1xuXG4vKiAgKi9cblxuZnVuY3Rpb24gaW5pdEV2ZW50cyAodm0pIHtcbiAgdm0uX2V2ZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIHZtLl9oYXNIb29rRXZlbnQgPSBmYWxzZTtcbiAgLy8gaW5pdCBwYXJlbnQgYXR0YWNoZWQgZXZlbnRzXG4gIHZhciBsaXN0ZW5lcnMgPSB2bS4kb3B0aW9ucy5fcGFyZW50TGlzdGVuZXJzO1xuICBpZiAobGlzdGVuZXJzKSB7XG4gICAgdXBkYXRlQ29tcG9uZW50TGlzdGVuZXJzKHZtLCBsaXN0ZW5lcnMpO1xuICB9XG59XG5cbnZhciB0YXJnZXQ7XG5cbmZ1bmN0aW9uIGFkZCAoZXZlbnQsIGZuKSB7XG4gIHRhcmdldC4kb24oZXZlbnQsIGZuKTtcbn1cblxuZnVuY3Rpb24gcmVtb3ZlJDEgKGV2ZW50LCBmbikge1xuICB0YXJnZXQuJG9mZihldmVudCwgZm4pO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVPbmNlSGFuZGxlciAoZXZlbnQsIGZuKSB7XG4gIHZhciBfdGFyZ2V0ID0gdGFyZ2V0O1xuICByZXR1cm4gZnVuY3Rpb24gb25jZUhhbmRsZXIgKCkge1xuICAgIHZhciByZXMgPSBmbi5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgIGlmIChyZXMgIT09IG51bGwpIHtcbiAgICAgIF90YXJnZXQuJG9mZihldmVudCwgb25jZUhhbmRsZXIpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiB1cGRhdGVDb21wb25lbnRMaXN0ZW5lcnMgKFxuICB2bSxcbiAgbGlzdGVuZXJzLFxuICBvbGRMaXN0ZW5lcnNcbikge1xuICB0YXJnZXQgPSB2bTtcbiAgdXBkYXRlTGlzdGVuZXJzKGxpc3RlbmVycywgb2xkTGlzdGVuZXJzIHx8IHt9LCBhZGQsIHJlbW92ZSQxLCBjcmVhdGVPbmNlSGFuZGxlciwgdm0pO1xuICB0YXJnZXQgPSB1bmRlZmluZWQ7XG59XG5cbmZ1bmN0aW9uIGV2ZW50c01peGluIChWdWUpIHtcbiAgdmFyIGhvb2tSRSA9IC9eaG9vazovO1xuICBWdWUucHJvdG90eXBlLiRvbiA9IGZ1bmN0aW9uIChldmVudCwgZm4pIHtcbiAgICB2YXIgdm0gPSB0aGlzO1xuICAgIGlmIChBcnJheS5pc0FycmF5KGV2ZW50KSkge1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBldmVudC5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgdm0uJG9uKGV2ZW50W2ldLCBmbik7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICh2bS5fZXZlbnRzW2V2ZW50XSB8fCAodm0uX2V2ZW50c1tldmVudF0gPSBbXSkpLnB1c2goZm4pO1xuICAgICAgLy8gb3B0aW1pemUgaG9vazpldmVudCBjb3N0IGJ5IHVzaW5nIGEgYm9vbGVhbiBmbGFnIG1hcmtlZCBhdCByZWdpc3RyYXRpb25cbiAgICAgIC8vIGluc3RlYWQgb2YgYSBoYXNoIGxvb2t1cFxuICAgICAgaWYgKGhvb2tSRS50ZXN0KGV2ZW50KSkge1xuICAgICAgICB2bS5faGFzSG9va0V2ZW50ID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHZtXG4gIH07XG5cbiAgVnVlLnByb3RvdHlwZS4kb25jZSA9IGZ1bmN0aW9uIChldmVudCwgZm4pIHtcbiAgICB2YXIgdm0gPSB0aGlzO1xuICAgIGZ1bmN0aW9uIG9uICgpIHtcbiAgICAgIHZtLiRvZmYoZXZlbnQsIG9uKTtcbiAgICAgIGZuLmFwcGx5KHZtLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBvbi5mbiA9IGZuO1xuICAgIHZtLiRvbihldmVudCwgb24pO1xuICAgIHJldHVybiB2bVxuICB9O1xuXG4gIFZ1ZS5wcm90b3R5cGUuJG9mZiA9IGZ1bmN0aW9uIChldmVudCwgZm4pIHtcbiAgICB2YXIgdm0gPSB0aGlzO1xuICAgIC8vIGFsbFxuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgdm0uX2V2ZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICByZXR1cm4gdm1cbiAgICB9XG4gICAgLy8gYXJyYXkgb2YgZXZlbnRzXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoZXZlbnQpKSB7XG4gICAgICBmb3IgKHZhciBpJDEgPSAwLCBsID0gZXZlbnQubGVuZ3RoOyBpJDEgPCBsOyBpJDErKykge1xuICAgICAgICB2bS4kb2ZmKGV2ZW50W2kkMV0sIGZuKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB2bVxuICAgIH1cbiAgICAvLyBzcGVjaWZpYyBldmVudFxuICAgIHZhciBjYnMgPSB2bS5fZXZlbnRzW2V2ZW50XTtcbiAgICBpZiAoIWNicykge1xuICAgICAgcmV0dXJuIHZtXG4gICAgfVxuICAgIGlmICghZm4pIHtcbiAgICAgIHZtLl9ldmVudHNbZXZlbnRdID0gbnVsbDtcbiAgICAgIHJldHVybiB2bVxuICAgIH1cbiAgICAvLyBzcGVjaWZpYyBoYW5kbGVyXG4gICAgdmFyIGNiO1xuICAgIHZhciBpID0gY2JzLmxlbmd0aDtcbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICBjYiA9IGNic1tpXTtcbiAgICAgIGlmIChjYiA9PT0gZm4gfHwgY2IuZm4gPT09IGZuKSB7XG4gICAgICAgIGNicy5zcGxpY2UoaSwgMSk7XG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB2bVxuICB9O1xuXG4gIFZ1ZS5wcm90b3R5cGUuJGVtaXQgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICB2YXIgdm0gPSB0aGlzO1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICB2YXIgbG93ZXJDYXNlRXZlbnQgPSBldmVudC50b0xvd2VyQ2FzZSgpO1xuICAgICAgaWYgKGxvd2VyQ2FzZUV2ZW50ICE9PSBldmVudCAmJiB2bS5fZXZlbnRzW2xvd2VyQ2FzZUV2ZW50XSkge1xuICAgICAgICB0aXAoXG4gICAgICAgICAgXCJFdmVudCBcXFwiXCIgKyBsb3dlckNhc2VFdmVudCArIFwiXFxcIiBpcyBlbWl0dGVkIGluIGNvbXBvbmVudCBcIiArXG4gICAgICAgICAgKGZvcm1hdENvbXBvbmVudE5hbWUodm0pKSArIFwiIGJ1dCB0aGUgaGFuZGxlciBpcyByZWdpc3RlcmVkIGZvciBcXFwiXCIgKyBldmVudCArIFwiXFxcIi4gXCIgK1xuICAgICAgICAgIFwiTm90ZSB0aGF0IEhUTUwgYXR0cmlidXRlcyBhcmUgY2FzZS1pbnNlbnNpdGl2ZSBhbmQgeW91IGNhbm5vdCB1c2UgXCIgK1xuICAgICAgICAgIFwidi1vbiB0byBsaXN0ZW4gdG8gY2FtZWxDYXNlIGV2ZW50cyB3aGVuIHVzaW5nIGluLURPTSB0ZW1wbGF0ZXMuIFwiICtcbiAgICAgICAgICBcIllvdSBzaG91bGQgcHJvYmFibHkgdXNlIFxcXCJcIiArIChoeXBoZW5hdGUoZXZlbnQpKSArIFwiXFxcIiBpbnN0ZWFkIG9mIFxcXCJcIiArIGV2ZW50ICsgXCJcXFwiLlwiXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICAgIHZhciBjYnMgPSB2bS5fZXZlbnRzW2V2ZW50XTtcbiAgICBpZiAoY2JzKSB7XG4gICAgICBjYnMgPSBjYnMubGVuZ3RoID4gMSA/IHRvQXJyYXkoY2JzKSA6IGNicztcbiAgICAgIHZhciBhcmdzID0gdG9BcnJheShhcmd1bWVudHMsIDEpO1xuICAgICAgdmFyIGluZm8gPSBcImV2ZW50IGhhbmRsZXIgZm9yIFxcXCJcIiArIGV2ZW50ICsgXCJcXFwiXCI7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGNicy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgaW52b2tlV2l0aEVycm9ySGFuZGxpbmcoY2JzW2ldLCB2bSwgYXJncywgdm0sIGluZm8pO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdm1cbiAgfTtcbn1cblxuLyogICovXG5cbnZhciBhY3RpdmVJbnN0YW5jZSA9IG51bGw7XG52YXIgaXNVcGRhdGluZ0NoaWxkQ29tcG9uZW50ID0gZmFsc2U7XG5cbmZ1bmN0aW9uIHNldEFjdGl2ZUluc3RhbmNlKHZtKSB7XG4gIHZhciBwcmV2QWN0aXZlSW5zdGFuY2UgPSBhY3RpdmVJbnN0YW5jZTtcbiAgYWN0aXZlSW5zdGFuY2UgPSB2bTtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICBhY3RpdmVJbnN0YW5jZSA9IHByZXZBY3RpdmVJbnN0YW5jZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpbml0TGlmZWN5Y2xlICh2bSkge1xuICB2YXIgb3B0aW9ucyA9IHZtLiRvcHRpb25zO1xuXG4gIC8vIGxvY2F0ZSBmaXJzdCBub24tYWJzdHJhY3QgcGFyZW50XG4gIHZhciBwYXJlbnQgPSBvcHRpb25zLnBhcmVudDtcbiAgaWYgKHBhcmVudCAmJiAhb3B0aW9ucy5hYnN0cmFjdCkge1xuICAgIHdoaWxlIChwYXJlbnQuJG9wdGlvbnMuYWJzdHJhY3QgJiYgcGFyZW50LiRwYXJlbnQpIHtcbiAgICAgIHBhcmVudCA9IHBhcmVudC4kcGFyZW50O1xuICAgIH1cbiAgICBwYXJlbnQuJGNoaWxkcmVuLnB1c2godm0pO1xuICB9XG5cbiAgdm0uJHBhcmVudCA9IHBhcmVudDtcbiAgdm0uJHJvb3QgPSBwYXJlbnQgPyBwYXJlbnQuJHJvb3QgOiB2bTtcblxuICB2bS4kY2hpbGRyZW4gPSBbXTtcbiAgdm0uJHJlZnMgPSB7fTtcblxuICB2bS5fd2F0Y2hlciA9IG51bGw7XG4gIHZtLl9pbmFjdGl2ZSA9IG51bGw7XG4gIHZtLl9kaXJlY3RJbmFjdGl2ZSA9IGZhbHNlO1xuICB2bS5faXNNb3VudGVkID0gZmFsc2U7XG4gIHZtLl9pc0Rlc3Ryb3llZCA9IGZhbHNlO1xuICB2bS5faXNCZWluZ0Rlc3Ryb3llZCA9IGZhbHNlO1xufVxuXG5mdW5jdGlvbiBsaWZlY3ljbGVNaXhpbiAoVnVlKSB7XG4gIFZ1ZS5wcm90b3R5cGUuX3VwZGF0ZSA9IGZ1bmN0aW9uICh2bm9kZSwgaHlkcmF0aW5nKSB7XG4gICAgdmFyIHZtID0gdGhpcztcbiAgICB2YXIgcHJldkVsID0gdm0uJGVsO1xuICAgIHZhciBwcmV2Vm5vZGUgPSB2bS5fdm5vZGU7XG4gICAgdmFyIHJlc3RvcmVBY3RpdmVJbnN0YW5jZSA9IHNldEFjdGl2ZUluc3RhbmNlKHZtKTtcbiAgICB2bS5fdm5vZGUgPSB2bm9kZTtcbiAgICAvLyBWdWUucHJvdG90eXBlLl9fcGF0Y2hfXyBpcyBpbmplY3RlZCBpbiBlbnRyeSBwb2ludHNcbiAgICAvLyBiYXNlZCBvbiB0aGUgcmVuZGVyaW5nIGJhY2tlbmQgdXNlZC5cbiAgICBpZiAoIXByZXZWbm9kZSkge1xuICAgICAgLy8gaW5pdGlhbCByZW5kZXJcbiAgICAgIHZtLiRlbCA9IHZtLl9fcGF0Y2hfXyh2bS4kZWwsIHZub2RlLCBoeWRyYXRpbmcsIGZhbHNlIC8qIHJlbW92ZU9ubHkgKi8pO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyB1cGRhdGVzXG4gICAgICB2bS4kZWwgPSB2bS5fX3BhdGNoX18ocHJldlZub2RlLCB2bm9kZSk7XG4gICAgfVxuICAgIHJlc3RvcmVBY3RpdmVJbnN0YW5jZSgpO1xuICAgIC8vIHVwZGF0ZSBfX3Z1ZV9fIHJlZmVyZW5jZVxuICAgIGlmIChwcmV2RWwpIHtcbiAgICAgIHByZXZFbC5fX3Z1ZV9fID0gbnVsbDtcbiAgICB9XG4gICAgaWYgKHZtLiRlbCkge1xuICAgICAgdm0uJGVsLl9fdnVlX18gPSB2bTtcbiAgICB9XG4gICAgLy8gaWYgcGFyZW50IGlzIGFuIEhPQywgdXBkYXRlIGl0cyAkZWwgYXMgd2VsbFxuICAgIGlmICh2bS4kdm5vZGUgJiYgdm0uJHBhcmVudCAmJiB2bS4kdm5vZGUgPT09IHZtLiRwYXJlbnQuX3Zub2RlKSB7XG4gICAgICB2bS4kcGFyZW50LiRlbCA9IHZtLiRlbDtcbiAgICB9XG4gICAgLy8gdXBkYXRlZCBob29rIGlzIGNhbGxlZCBieSB0aGUgc2NoZWR1bGVyIHRvIGVuc3VyZSB0aGF0IGNoaWxkcmVuIGFyZVxuICAgIC8vIHVwZGF0ZWQgaW4gYSBwYXJlbnQncyB1cGRhdGVkIGhvb2suXG4gIH07XG5cbiAgVnVlLnByb3RvdHlwZS4kZm9yY2VVcGRhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHZtID0gdGhpcztcbiAgICBpZiAodm0uX3dhdGNoZXIpIHtcbiAgICAgIHZtLl93YXRjaGVyLnVwZGF0ZSgpO1xuICAgIH1cbiAgfTtcblxuICBWdWUucHJvdG90eXBlLiRkZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciB2bSA9IHRoaXM7XG4gICAgaWYgKHZtLl9pc0JlaW5nRGVzdHJveWVkKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgY2FsbEhvb2sodm0sICdiZWZvcmVEZXN0cm95Jyk7XG4gICAgdm0uX2lzQmVpbmdEZXN0cm95ZWQgPSB0cnVlO1xuICAgIC8vIHJlbW92ZSBzZWxmIGZyb20gcGFyZW50XG4gICAgdmFyIHBhcmVudCA9IHZtLiRwYXJlbnQ7XG4gICAgaWYgKHBhcmVudCAmJiAhcGFyZW50Ll9pc0JlaW5nRGVzdHJveWVkICYmICF2bS4kb3B0aW9ucy5hYnN0cmFjdCkge1xuICAgICAgcmVtb3ZlKHBhcmVudC4kY2hpbGRyZW4sIHZtKTtcbiAgICB9XG4gICAgLy8gdGVhcmRvd24gd2F0Y2hlcnNcbiAgICBpZiAodm0uX3dhdGNoZXIpIHtcbiAgICAgIHZtLl93YXRjaGVyLnRlYXJkb3duKCk7XG4gICAgfVxuICAgIHZhciBpID0gdm0uX3dhdGNoZXJzLmxlbmd0aDtcbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICB2bS5fd2F0Y2hlcnNbaV0udGVhcmRvd24oKTtcbiAgICB9XG4gICAgLy8gcmVtb3ZlIHJlZmVyZW5jZSBmcm9tIGRhdGEgb2JcbiAgICAvLyBmcm96ZW4gb2JqZWN0IG1heSBub3QgaGF2ZSBvYnNlcnZlci5cbiAgICBpZiAodm0uX2RhdGEuX19vYl9fKSB7XG4gICAgICB2bS5fZGF0YS5fX29iX18udm1Db3VudC0tO1xuICAgIH1cbiAgICAvLyBjYWxsIHRoZSBsYXN0IGhvb2suLi5cbiAgICB2bS5faXNEZXN0cm95ZWQgPSB0cnVlO1xuICAgIC8vIGludm9rZSBkZXN0cm95IGhvb2tzIG9uIGN1cnJlbnQgcmVuZGVyZWQgdHJlZVxuICAgIHZtLl9fcGF0Y2hfXyh2bS5fdm5vZGUsIG51bGwpO1xuICAgIC8vIGZpcmUgZGVzdHJveWVkIGhvb2tcbiAgICBjYWxsSG9vayh2bSwgJ2Rlc3Ryb3llZCcpO1xuICAgIC8vIHR1cm4gb2ZmIGFsbCBpbnN0YW5jZSBsaXN0ZW5lcnMuXG4gICAgdm0uJG9mZigpO1xuICAgIC8vIHJlbW92ZSBfX3Z1ZV9fIHJlZmVyZW5jZVxuICAgIGlmICh2bS4kZWwpIHtcbiAgICAgIHZtLiRlbC5fX3Z1ZV9fID0gbnVsbDtcbiAgICB9XG4gICAgLy8gcmVsZWFzZSBjaXJjdWxhciByZWZlcmVuY2UgKCM2NzU5KVxuICAgIGlmICh2bS4kdm5vZGUpIHtcbiAgICAgIHZtLiR2bm9kZS5wYXJlbnQgPSBudWxsO1xuICAgIH1cbiAgfTtcbn1cblxuZnVuY3Rpb24gbW91bnRDb21wb25lbnQgKFxuICB2bSxcbiAgZWwsXG4gIGh5ZHJhdGluZ1xuKSB7XG4gIHZtLiRlbCA9IGVsO1xuICBpZiAoIXZtLiRvcHRpb25zLnJlbmRlcikge1xuICAgIHZtLiRvcHRpb25zLnJlbmRlciA9IGNyZWF0ZUVtcHR5Vk5vZGU7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgaWYgKCh2bS4kb3B0aW9ucy50ZW1wbGF0ZSAmJiB2bS4kb3B0aW9ucy50ZW1wbGF0ZS5jaGFyQXQoMCkgIT09ICcjJykgfHxcbiAgICAgICAgdm0uJG9wdGlvbnMuZWwgfHwgZWwpIHtcbiAgICAgICAgd2FybihcbiAgICAgICAgICAnWW91IGFyZSB1c2luZyB0aGUgcnVudGltZS1vbmx5IGJ1aWxkIG9mIFZ1ZSB3aGVyZSB0aGUgdGVtcGxhdGUgJyArXG4gICAgICAgICAgJ2NvbXBpbGVyIGlzIG5vdCBhdmFpbGFibGUuIEVpdGhlciBwcmUtY29tcGlsZSB0aGUgdGVtcGxhdGVzIGludG8gJyArXG4gICAgICAgICAgJ3JlbmRlciBmdW5jdGlvbnMsIG9yIHVzZSB0aGUgY29tcGlsZXItaW5jbHVkZWQgYnVpbGQuJyxcbiAgICAgICAgICB2bVxuICAgICAgICApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgd2FybihcbiAgICAgICAgICAnRmFpbGVkIHRvIG1vdW50IGNvbXBvbmVudDogdGVtcGxhdGUgb3IgcmVuZGVyIGZ1bmN0aW9uIG5vdCBkZWZpbmVkLicsXG4gICAgICAgICAgdm1cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgY2FsbEhvb2sodm0sICdiZWZvcmVNb3VudCcpO1xuXG4gIHZhciB1cGRhdGVDb21wb25lbnQ7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBjb25maWcucGVyZm9ybWFuY2UgJiYgbWFyaykge1xuICAgIHVwZGF0ZUNvbXBvbmVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBuYW1lID0gdm0uX25hbWU7XG4gICAgICB2YXIgaWQgPSB2bS5fdWlkO1xuICAgICAgdmFyIHN0YXJ0VGFnID0gXCJ2dWUtcGVyZi1zdGFydDpcIiArIGlkO1xuICAgICAgdmFyIGVuZFRhZyA9IFwidnVlLXBlcmYtZW5kOlwiICsgaWQ7XG5cbiAgICAgIG1hcmsoc3RhcnRUYWcpO1xuICAgICAgdmFyIHZub2RlID0gdm0uX3JlbmRlcigpO1xuICAgICAgbWFyayhlbmRUYWcpO1xuICAgICAgbWVhc3VyZSgoXCJ2dWUgXCIgKyBuYW1lICsgXCIgcmVuZGVyXCIpLCBzdGFydFRhZywgZW5kVGFnKTtcblxuICAgICAgbWFyayhzdGFydFRhZyk7XG4gICAgICB2bS5fdXBkYXRlKHZub2RlLCBoeWRyYXRpbmcpO1xuICAgICAgbWFyayhlbmRUYWcpO1xuICAgICAgbWVhc3VyZSgoXCJ2dWUgXCIgKyBuYW1lICsgXCIgcGF0Y2hcIiksIHN0YXJ0VGFnLCBlbmRUYWcpO1xuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgdXBkYXRlQ29tcG9uZW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgdm0uX3VwZGF0ZSh2bS5fcmVuZGVyKCksIGh5ZHJhdGluZyk7XG4gICAgfTtcbiAgfVxuXG4gIC8vIHdlIHNldCB0aGlzIHRvIHZtLl93YXRjaGVyIGluc2lkZSB0aGUgd2F0Y2hlcidzIGNvbnN0cnVjdG9yXG4gIC8vIHNpbmNlIHRoZSB3YXRjaGVyJ3MgaW5pdGlhbCBwYXRjaCBtYXkgY2FsbCAkZm9yY2VVcGRhdGUgKGUuZy4gaW5zaWRlIGNoaWxkXG4gIC8vIGNvbXBvbmVudCdzIG1vdW50ZWQgaG9vayksIHdoaWNoIHJlbGllcyBvbiB2bS5fd2F0Y2hlciBiZWluZyBhbHJlYWR5IGRlZmluZWRcbiAgbmV3IFdhdGNoZXIodm0sIHVwZGF0ZUNvbXBvbmVudCwgbm9vcCwge1xuICAgIGJlZm9yZTogZnVuY3Rpb24gYmVmb3JlICgpIHtcbiAgICAgIGlmICh2bS5faXNNb3VudGVkICYmICF2bS5faXNEZXN0cm95ZWQpIHtcbiAgICAgICAgY2FsbEhvb2sodm0sICdiZWZvcmVVcGRhdGUnKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHRydWUgLyogaXNSZW5kZXJXYXRjaGVyICovKTtcbiAgaHlkcmF0aW5nID0gZmFsc2U7XG5cbiAgLy8gbWFudWFsbHkgbW91bnRlZCBpbnN0YW5jZSwgY2FsbCBtb3VudGVkIG9uIHNlbGZcbiAgLy8gbW91bnRlZCBpcyBjYWxsZWQgZm9yIHJlbmRlci1jcmVhdGVkIGNoaWxkIGNvbXBvbmVudHMgaW4gaXRzIGluc2VydGVkIGhvb2tcbiAgaWYgKHZtLiR2bm9kZSA9PSBudWxsKSB7XG4gICAgdm0uX2lzTW91bnRlZCA9IHRydWU7XG4gICAgY2FsbEhvb2sodm0sICdtb3VudGVkJyk7XG4gIH1cbiAgcmV0dXJuIHZtXG59XG5cbmZ1bmN0aW9uIHVwZGF0ZUNoaWxkQ29tcG9uZW50IChcbiAgdm0sXG4gIHByb3BzRGF0YSxcbiAgbGlzdGVuZXJzLFxuICBwYXJlbnRWbm9kZSxcbiAgcmVuZGVyQ2hpbGRyZW5cbikge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGlzVXBkYXRpbmdDaGlsZENvbXBvbmVudCA9IHRydWU7XG4gIH1cblxuICAvLyBkZXRlcm1pbmUgd2hldGhlciBjb21wb25lbnQgaGFzIHNsb3QgY2hpbGRyZW5cbiAgLy8gd2UgbmVlZCB0byBkbyB0aGlzIGJlZm9yZSBvdmVyd3JpdGluZyAkb3B0aW9ucy5fcmVuZGVyQ2hpbGRyZW4uXG5cbiAgLy8gY2hlY2sgaWYgdGhlcmUgYXJlIGR5bmFtaWMgc2NvcGVkU2xvdHMgKGhhbmQtd3JpdHRlbiBvciBjb21waWxlZCBidXQgd2l0aFxuICAvLyBkeW5hbWljIHNsb3QgbmFtZXMpLiBTdGF0aWMgc2NvcGVkIHNsb3RzIGNvbXBpbGVkIGZyb20gdGVtcGxhdGUgaGFzIHRoZVxuICAvLyBcIiRzdGFibGVcIiBtYXJrZXIuXG4gIHZhciBuZXdTY29wZWRTbG90cyA9IHBhcmVudFZub2RlLmRhdGEuc2NvcGVkU2xvdHM7XG4gIHZhciBvbGRTY29wZWRTbG90cyA9IHZtLiRzY29wZWRTbG90cztcbiAgdmFyIGhhc0R5bmFtaWNTY29wZWRTbG90ID0gISEoXG4gICAgKG5ld1Njb3BlZFNsb3RzICYmICFuZXdTY29wZWRTbG90cy4kc3RhYmxlKSB8fFxuICAgIChvbGRTY29wZWRTbG90cyAhPT0gZW1wdHlPYmplY3QgJiYgIW9sZFNjb3BlZFNsb3RzLiRzdGFibGUpIHx8XG4gICAgKG5ld1Njb3BlZFNsb3RzICYmIHZtLiRzY29wZWRTbG90cy4ka2V5ICE9PSBuZXdTY29wZWRTbG90cy4ka2V5KSB8fFxuICAgICghbmV3U2NvcGVkU2xvdHMgJiYgdm0uJHNjb3BlZFNsb3RzLiRrZXkpXG4gICk7XG5cbiAgLy8gQW55IHN0YXRpYyBzbG90IGNoaWxkcmVuIGZyb20gdGhlIHBhcmVudCBtYXkgaGF2ZSBjaGFuZ2VkIGR1cmluZyBwYXJlbnQnc1xuICAvLyB1cGRhdGUuIER5bmFtaWMgc2NvcGVkIHNsb3RzIG1heSBhbHNvIGhhdmUgY2hhbmdlZC4gSW4gc3VjaCBjYXNlcywgYSBmb3JjZWRcbiAgLy8gdXBkYXRlIGlzIG5lY2Vzc2FyeSB0byBlbnN1cmUgY29ycmVjdG5lc3MuXG4gIHZhciBuZWVkc0ZvcmNlVXBkYXRlID0gISEoXG4gICAgcmVuZGVyQ2hpbGRyZW4gfHwgICAgICAgICAgICAgICAvLyBoYXMgbmV3IHN0YXRpYyBzbG90c1xuICAgIHZtLiRvcHRpb25zLl9yZW5kZXJDaGlsZHJlbiB8fCAgLy8gaGFzIG9sZCBzdGF0aWMgc2xvdHNcbiAgICBoYXNEeW5hbWljU2NvcGVkU2xvdFxuICApO1xuXG4gIHZtLiRvcHRpb25zLl9wYXJlbnRWbm9kZSA9IHBhcmVudFZub2RlO1xuICB2bS4kdm5vZGUgPSBwYXJlbnRWbm9kZTsgLy8gdXBkYXRlIHZtJ3MgcGxhY2Vob2xkZXIgbm9kZSB3aXRob3V0IHJlLXJlbmRlclxuXG4gIGlmICh2bS5fdm5vZGUpIHsgLy8gdXBkYXRlIGNoaWxkIHRyZWUncyBwYXJlbnRcbiAgICB2bS5fdm5vZGUucGFyZW50ID0gcGFyZW50Vm5vZGU7XG4gIH1cbiAgdm0uJG9wdGlvbnMuX3JlbmRlckNoaWxkcmVuID0gcmVuZGVyQ2hpbGRyZW47XG5cbiAgLy8gdXBkYXRlICRhdHRycyBhbmQgJGxpc3RlbmVycyBoYXNoXG4gIC8vIHRoZXNlIGFyZSBhbHNvIHJlYWN0aXZlIHNvIHRoZXkgbWF5IHRyaWdnZXIgY2hpbGQgdXBkYXRlIGlmIHRoZSBjaGlsZFxuICAvLyB1c2VkIHRoZW0gZHVyaW5nIHJlbmRlclxuICB2bS4kYXR0cnMgPSBwYXJlbnRWbm9kZS5kYXRhLmF0dHJzIHx8IGVtcHR5T2JqZWN0O1xuICB2bS4kbGlzdGVuZXJzID0gbGlzdGVuZXJzIHx8IGVtcHR5T2JqZWN0O1xuXG4gIC8vIHVwZGF0ZSBwcm9wc1xuICBpZiAocHJvcHNEYXRhICYmIHZtLiRvcHRpb25zLnByb3BzKSB7XG4gICAgdG9nZ2xlT2JzZXJ2aW5nKGZhbHNlKTtcbiAgICB2YXIgcHJvcHMgPSB2bS5fcHJvcHM7XG4gICAgdmFyIHByb3BLZXlzID0gdm0uJG9wdGlvbnMuX3Byb3BLZXlzIHx8IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcEtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBrZXkgPSBwcm9wS2V5c1tpXTtcbiAgICAgIHZhciBwcm9wT3B0aW9ucyA9IHZtLiRvcHRpb25zLnByb3BzOyAvLyB3dGYgZmxvdz9cbiAgICAgIHByb3BzW2tleV0gPSB2YWxpZGF0ZVByb3Aoa2V5LCBwcm9wT3B0aW9ucywgcHJvcHNEYXRhLCB2bSk7XG4gICAgfVxuICAgIHRvZ2dsZU9ic2VydmluZyh0cnVlKTtcbiAgICAvLyBrZWVwIGEgY29weSBvZiByYXcgcHJvcHNEYXRhXG4gICAgdm0uJG9wdGlvbnMucHJvcHNEYXRhID0gcHJvcHNEYXRhO1xuICB9XG5cbiAgLy8gdXBkYXRlIGxpc3RlbmVyc1xuICBsaXN0ZW5lcnMgPSBsaXN0ZW5lcnMgfHwgZW1wdHlPYmplY3Q7XG4gIHZhciBvbGRMaXN0ZW5lcnMgPSB2bS4kb3B0aW9ucy5fcGFyZW50TGlzdGVuZXJzO1xuICB2bS4kb3B0aW9ucy5fcGFyZW50TGlzdGVuZXJzID0gbGlzdGVuZXJzO1xuICB1cGRhdGVDb21wb25lbnRMaXN0ZW5lcnModm0sIGxpc3RlbmVycywgb2xkTGlzdGVuZXJzKTtcblxuICAvLyByZXNvbHZlIHNsb3RzICsgZm9yY2UgdXBkYXRlIGlmIGhhcyBjaGlsZHJlblxuICBpZiAobmVlZHNGb3JjZVVwZGF0ZSkge1xuICAgIHZtLiRzbG90cyA9IHJlc29sdmVTbG90cyhyZW5kZXJDaGlsZHJlbiwgcGFyZW50Vm5vZGUuY29udGV4dCk7XG4gICAgdm0uJGZvcmNlVXBkYXRlKCk7XG4gIH1cblxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGlzVXBkYXRpbmdDaGlsZENvbXBvbmVudCA9IGZhbHNlO1xuICB9XG59XG5cbmZ1bmN0aW9uIGlzSW5JbmFjdGl2ZVRyZWUgKHZtKSB7XG4gIHdoaWxlICh2bSAmJiAodm0gPSB2bS4kcGFyZW50KSkge1xuICAgIGlmICh2bS5faW5hY3RpdmUpIHsgcmV0dXJuIHRydWUgfVxuICB9XG4gIHJldHVybiBmYWxzZVxufVxuXG5mdW5jdGlvbiBhY3RpdmF0ZUNoaWxkQ29tcG9uZW50ICh2bSwgZGlyZWN0KSB7XG4gIGlmIChkaXJlY3QpIHtcbiAgICB2bS5fZGlyZWN0SW5hY3RpdmUgPSBmYWxzZTtcbiAgICBpZiAoaXNJbkluYWN0aXZlVHJlZSh2bSkpIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgfSBlbHNlIGlmICh2bS5fZGlyZWN0SW5hY3RpdmUpIHtcbiAgICByZXR1cm5cbiAgfVxuICBpZiAodm0uX2luYWN0aXZlIHx8IHZtLl9pbmFjdGl2ZSA9PT0gbnVsbCkge1xuICAgIHZtLl9pbmFjdGl2ZSA9IGZhbHNlO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdm0uJGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICBhY3RpdmF0ZUNoaWxkQ29tcG9uZW50KHZtLiRjaGlsZHJlbltpXSk7XG4gICAgfVxuICAgIGNhbGxIb29rKHZtLCAnYWN0aXZhdGVkJyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZGVhY3RpdmF0ZUNoaWxkQ29tcG9uZW50ICh2bSwgZGlyZWN0KSB7XG4gIGlmIChkaXJlY3QpIHtcbiAgICB2bS5fZGlyZWN0SW5hY3RpdmUgPSB0cnVlO1xuICAgIGlmIChpc0luSW5hY3RpdmVUcmVlKHZtKSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICB9XG4gIGlmICghdm0uX2luYWN0aXZlKSB7XG4gICAgdm0uX2luYWN0aXZlID0gdHJ1ZTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZtLiRjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgZGVhY3RpdmF0ZUNoaWxkQ29tcG9uZW50KHZtLiRjaGlsZHJlbltpXSk7XG4gICAgfVxuICAgIGNhbGxIb29rKHZtLCAnZGVhY3RpdmF0ZWQnKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjYWxsSG9vayAodm0sIGhvb2spIHtcbiAgLy8gIzc1NzMgZGlzYWJsZSBkZXAgY29sbGVjdGlvbiB3aGVuIGludm9raW5nIGxpZmVjeWNsZSBob29rc1xuICBwdXNoVGFyZ2V0KCk7XG4gIHZhciBoYW5kbGVycyA9IHZtLiRvcHRpb25zW2hvb2tdO1xuICB2YXIgaW5mbyA9IGhvb2sgKyBcIiBob29rXCI7XG4gIGlmIChoYW5kbGVycykge1xuICAgIGZvciAodmFyIGkgPSAwLCBqID0gaGFuZGxlcnMubGVuZ3RoOyBpIDwgajsgaSsrKSB7XG4gICAgICBpbnZva2VXaXRoRXJyb3JIYW5kbGluZyhoYW5kbGVyc1tpXSwgdm0sIG51bGwsIHZtLCBpbmZvKTtcbiAgICB9XG4gIH1cbiAgaWYgKHZtLl9oYXNIb29rRXZlbnQpIHtcbiAgICB2bS4kZW1pdCgnaG9vazonICsgaG9vayk7XG4gIH1cbiAgcG9wVGFyZ2V0KCk7XG59XG5cbi8qICAqL1xuXG52YXIgTUFYX1VQREFURV9DT1VOVCA9IDEwMDtcblxudmFyIHF1ZXVlID0gW107XG52YXIgYWN0aXZhdGVkQ2hpbGRyZW4gPSBbXTtcbnZhciBoYXMgPSB7fTtcbnZhciBjaXJjdWxhciA9IHt9O1xudmFyIHdhaXRpbmcgPSBmYWxzZTtcbnZhciBmbHVzaGluZyA9IGZhbHNlO1xudmFyIGluZGV4ID0gMDtcblxuLyoqXG4gKiBSZXNldCB0aGUgc2NoZWR1bGVyJ3Mgc3RhdGUuXG4gKi9cbmZ1bmN0aW9uIHJlc2V0U2NoZWR1bGVyU3RhdGUgKCkge1xuICBpbmRleCA9IHF1ZXVlLmxlbmd0aCA9IGFjdGl2YXRlZENoaWxkcmVuLmxlbmd0aCA9IDA7XG4gIGhhcyA9IHt9O1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGNpcmN1bGFyID0ge307XG4gIH1cbiAgd2FpdGluZyA9IGZsdXNoaW5nID0gZmFsc2U7XG59XG5cbi8vIEFzeW5jIGVkZ2UgY2FzZSAjNjU2NiByZXF1aXJlcyBzYXZpbmcgdGhlIHRpbWVzdGFtcCB3aGVuIGV2ZW50IGxpc3RlbmVycyBhcmVcbi8vIGF0dGFjaGVkLiBIb3dldmVyLCBjYWxsaW5nIHBlcmZvcm1hbmNlLm5vdygpIGhhcyBhIHBlcmYgb3ZlcmhlYWQgZXNwZWNpYWxseVxuLy8gaWYgdGhlIHBhZ2UgaGFzIHRob3VzYW5kcyBvZiBldmVudCBsaXN0ZW5lcnMuIEluc3RlYWQsIHdlIHRha2UgYSB0aW1lc3RhbXBcbi8vIGV2ZXJ5IHRpbWUgdGhlIHNjaGVkdWxlciBmbHVzaGVzIGFuZCB1c2UgdGhhdCBmb3IgYWxsIGV2ZW50IGxpc3RlbmVyc1xuLy8gYXR0YWNoZWQgZHVyaW5nIHRoYXQgZmx1c2guXG52YXIgY3VycmVudEZsdXNoVGltZXN0YW1wID0gMDtcblxuLy8gQXN5bmMgZWRnZSBjYXNlIGZpeCByZXF1aXJlcyBzdG9yaW5nIGFuIGV2ZW50IGxpc3RlbmVyJ3MgYXR0YWNoIHRpbWVzdGFtcC5cbnZhciBnZXROb3cgPSBEYXRlLm5vdztcblxuLy8gRGV0ZXJtaW5lIHdoYXQgZXZlbnQgdGltZXN0YW1wIHRoZSBicm93c2VyIGlzIHVzaW5nLiBBbm5veWluZ2x5LCB0aGVcbi8vIHRpbWVzdGFtcCBjYW4gZWl0aGVyIGJlIGhpLXJlcyAocmVsYXRpdmUgdG8gcGFnZSBsb2FkKSBvciBsb3ctcmVzXG4vLyAocmVsYXRpdmUgdG8gVU5JWCBlcG9jaCksIHNvIGluIG9yZGVyIHRvIGNvbXBhcmUgdGltZSB3ZSBoYXZlIHRvIHVzZSB0aGVcbi8vIHNhbWUgdGltZXN0YW1wIHR5cGUgd2hlbiBzYXZpbmcgdGhlIGZsdXNoIHRpbWVzdGFtcC5cbi8vIEFsbCBJRSB2ZXJzaW9ucyB1c2UgbG93LXJlcyBldmVudCB0aW1lc3RhbXBzLCBhbmQgaGF2ZSBwcm9ibGVtYXRpYyBjbG9ja1xuLy8gaW1wbGVtZW50YXRpb25zICgjOTYzMilcbmlmIChpbkJyb3dzZXIgJiYgIWlzSUUpIHtcbiAgdmFyIHBlcmZvcm1hbmNlID0gd2luZG93LnBlcmZvcm1hbmNlO1xuICBpZiAoXG4gICAgcGVyZm9ybWFuY2UgJiZcbiAgICB0eXBlb2YgcGVyZm9ybWFuY2Uubm93ID09PSAnZnVuY3Rpb24nICYmXG4gICAgZ2V0Tm93KCkgPiBkb2N1bWVudC5jcmVhdGVFdmVudCgnRXZlbnQnKS50aW1lU3RhbXBcbiAgKSB7XG4gICAgLy8gaWYgdGhlIGV2ZW50IHRpbWVzdGFtcCwgYWx0aG91Z2ggZXZhbHVhdGVkIEFGVEVSIHRoZSBEYXRlLm5vdygpLCBpc1xuICAgIC8vIHNtYWxsZXIgdGhhbiBpdCwgaXQgbWVhbnMgdGhlIGV2ZW50IGlzIHVzaW5nIGEgaGktcmVzIHRpbWVzdGFtcCxcbiAgICAvLyBhbmQgd2UgbmVlZCB0byB1c2UgdGhlIGhpLXJlcyB2ZXJzaW9uIGZvciBldmVudCBsaXN0ZW5lciB0aW1lc3RhbXBzIGFzXG4gICAgLy8gd2VsbC5cbiAgICBnZXROb3cgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBwZXJmb3JtYW5jZS5ub3coKTsgfTtcbiAgfVxufVxuXG4vKipcbiAqIEZsdXNoIGJvdGggcXVldWVzIGFuZCBydW4gdGhlIHdhdGNoZXJzLlxuICovXG5mdW5jdGlvbiBmbHVzaFNjaGVkdWxlclF1ZXVlICgpIHtcbiAgY3VycmVudEZsdXNoVGltZXN0YW1wID0gZ2V0Tm93KCk7XG4gIGZsdXNoaW5nID0gdHJ1ZTtcbiAgdmFyIHdhdGNoZXIsIGlkO1xuXG4gIC8vIFNvcnQgcXVldWUgYmVmb3JlIGZsdXNoLlxuICAvLyBUaGlzIGVuc3VyZXMgdGhhdDpcbiAgLy8gMS4gQ29tcG9uZW50cyBhcmUgdXBkYXRlZCBmcm9tIHBhcmVudCB0byBjaGlsZC4gKGJlY2F1c2UgcGFyZW50IGlzIGFsd2F5c1xuICAvLyAgICBjcmVhdGVkIGJlZm9yZSB0aGUgY2hpbGQpXG4gIC8vIDIuIEEgY29tcG9uZW50J3MgdXNlciB3YXRjaGVycyBhcmUgcnVuIGJlZm9yZSBpdHMgcmVuZGVyIHdhdGNoZXIgKGJlY2F1c2VcbiAgLy8gICAgdXNlciB3YXRjaGVycyBhcmUgY3JlYXRlZCBiZWZvcmUgdGhlIHJlbmRlciB3YXRjaGVyKVxuICAvLyAzLiBJZiBhIGNvbXBvbmVudCBpcyBkZXN0cm95ZWQgZHVyaW5nIGEgcGFyZW50IGNvbXBvbmVudCdzIHdhdGNoZXIgcnVuLFxuICAvLyAgICBpdHMgd2F0Y2hlcnMgY2FuIGJlIHNraXBwZWQuXG4gIHF1ZXVlLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHsgcmV0dXJuIGEuaWQgLSBiLmlkOyB9KTtcblxuICAvLyBkbyBub3QgY2FjaGUgbGVuZ3RoIGJlY2F1c2UgbW9yZSB3YXRjaGVycyBtaWdodCBiZSBwdXNoZWRcbiAgLy8gYXMgd2UgcnVuIGV4aXN0aW5nIHdhdGNoZXJzXG4gIGZvciAoaW5kZXggPSAwOyBpbmRleCA8IHF1ZXVlLmxlbmd0aDsgaW5kZXgrKykge1xuICAgIHdhdGNoZXIgPSBxdWV1ZVtpbmRleF07XG4gICAgaWYgKHdhdGNoZXIuYmVmb3JlKSB7XG4gICAgICB3YXRjaGVyLmJlZm9yZSgpO1xuICAgIH1cbiAgICBpZCA9IHdhdGNoZXIuaWQ7XG4gICAgaGFzW2lkXSA9IG51bGw7XG4gICAgd2F0Y2hlci5ydW4oKTtcbiAgICAvLyBpbiBkZXYgYnVpbGQsIGNoZWNrIGFuZCBzdG9wIGNpcmN1bGFyIHVwZGF0ZXMuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgaGFzW2lkXSAhPSBudWxsKSB7XG4gICAgICBjaXJjdWxhcltpZF0gPSAoY2lyY3VsYXJbaWRdIHx8IDApICsgMTtcbiAgICAgIGlmIChjaXJjdWxhcltpZF0gPiBNQVhfVVBEQVRFX0NPVU5UKSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgJ1lvdSBtYXkgaGF2ZSBhbiBpbmZpbml0ZSB1cGRhdGUgbG9vcCAnICsgKFxuICAgICAgICAgICAgd2F0Y2hlci51c2VyXG4gICAgICAgICAgICAgID8gKFwiaW4gd2F0Y2hlciB3aXRoIGV4cHJlc3Npb24gXFxcIlwiICsgKHdhdGNoZXIuZXhwcmVzc2lvbikgKyBcIlxcXCJcIilcbiAgICAgICAgICAgICAgOiBcImluIGEgY29tcG9uZW50IHJlbmRlciBmdW5jdGlvbi5cIlxuICAgICAgICAgICksXG4gICAgICAgICAgd2F0Y2hlci52bVxuICAgICAgICApO1xuICAgICAgICBicmVha1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIGtlZXAgY29waWVzIG9mIHBvc3QgcXVldWVzIGJlZm9yZSByZXNldHRpbmcgc3RhdGVcbiAgdmFyIGFjdGl2YXRlZFF1ZXVlID0gYWN0aXZhdGVkQ2hpbGRyZW4uc2xpY2UoKTtcbiAgdmFyIHVwZGF0ZWRRdWV1ZSA9IHF1ZXVlLnNsaWNlKCk7XG5cbiAgcmVzZXRTY2hlZHVsZXJTdGF0ZSgpO1xuXG4gIC8vIGNhbGwgY29tcG9uZW50IHVwZGF0ZWQgYW5kIGFjdGl2YXRlZCBob29rc1xuICBjYWxsQWN0aXZhdGVkSG9va3MoYWN0aXZhdGVkUXVldWUpO1xuICBjYWxsVXBkYXRlZEhvb2tzKHVwZGF0ZWRRdWV1ZSk7XG5cbiAgLy8gZGV2dG9vbCBob29rXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoZGV2dG9vbHMgJiYgY29uZmlnLmRldnRvb2xzKSB7XG4gICAgZGV2dG9vbHMuZW1pdCgnZmx1c2gnKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjYWxsVXBkYXRlZEhvb2tzIChxdWV1ZSkge1xuICB2YXIgaSA9IHF1ZXVlLmxlbmd0aDtcbiAgd2hpbGUgKGktLSkge1xuICAgIHZhciB3YXRjaGVyID0gcXVldWVbaV07XG4gICAgdmFyIHZtID0gd2F0Y2hlci52bTtcbiAgICBpZiAodm0uX3dhdGNoZXIgPT09IHdhdGNoZXIgJiYgdm0uX2lzTW91bnRlZCAmJiAhdm0uX2lzRGVzdHJveWVkKSB7XG4gICAgICBjYWxsSG9vayh2bSwgJ3VwZGF0ZWQnKTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBRdWV1ZSBhIGtlcHQtYWxpdmUgY29tcG9uZW50IHRoYXQgd2FzIGFjdGl2YXRlZCBkdXJpbmcgcGF0Y2guXG4gKiBUaGUgcXVldWUgd2lsbCBiZSBwcm9jZXNzZWQgYWZ0ZXIgdGhlIGVudGlyZSB0cmVlIGhhcyBiZWVuIHBhdGNoZWQuXG4gKi9cbmZ1bmN0aW9uIHF1ZXVlQWN0aXZhdGVkQ29tcG9uZW50ICh2bSkge1xuICAvLyBzZXR0aW5nIF9pbmFjdGl2ZSB0byBmYWxzZSBoZXJlIHNvIHRoYXQgYSByZW5kZXIgZnVuY3Rpb24gY2FuXG4gIC8vIHJlbHkgb24gY2hlY2tpbmcgd2hldGhlciBpdCdzIGluIGFuIGluYWN0aXZlIHRyZWUgKGUuZy4gcm91dGVyLXZpZXcpXG4gIHZtLl9pbmFjdGl2ZSA9IGZhbHNlO1xuICBhY3RpdmF0ZWRDaGlsZHJlbi5wdXNoKHZtKTtcbn1cblxuZnVuY3Rpb24gY2FsbEFjdGl2YXRlZEhvb2tzIChxdWV1ZSkge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHF1ZXVlLmxlbmd0aDsgaSsrKSB7XG4gICAgcXVldWVbaV0uX2luYWN0aXZlID0gdHJ1ZTtcbiAgICBhY3RpdmF0ZUNoaWxkQ29tcG9uZW50KHF1ZXVlW2ldLCB0cnVlIC8qIHRydWUgKi8pO1xuICB9XG59XG5cbi8qKlxuICogUHVzaCBhIHdhdGNoZXIgaW50byB0aGUgd2F0Y2hlciBxdWV1ZS5cbiAqIEpvYnMgd2l0aCBkdXBsaWNhdGUgSURzIHdpbGwgYmUgc2tpcHBlZCB1bmxlc3MgaXQnc1xuICogcHVzaGVkIHdoZW4gdGhlIHF1ZXVlIGlzIGJlaW5nIGZsdXNoZWQuXG4gKi9cbmZ1bmN0aW9uIHF1ZXVlV2F0Y2hlciAod2F0Y2hlcikge1xuICB2YXIgaWQgPSB3YXRjaGVyLmlkO1xuICBpZiAoaGFzW2lkXSA9PSBudWxsKSB7XG4gICAgaGFzW2lkXSA9IHRydWU7XG4gICAgaWYgKCFmbHVzaGluZykge1xuICAgICAgcXVldWUucHVzaCh3YXRjaGVyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gaWYgYWxyZWFkeSBmbHVzaGluZywgc3BsaWNlIHRoZSB3YXRjaGVyIGJhc2VkIG9uIGl0cyBpZFxuICAgICAgLy8gaWYgYWxyZWFkeSBwYXN0IGl0cyBpZCwgaXQgd2lsbCBiZSBydW4gbmV4dCBpbW1lZGlhdGVseS5cbiAgICAgIHZhciBpID0gcXVldWUubGVuZ3RoIC0gMTtcbiAgICAgIHdoaWxlIChpID4gaW5kZXggJiYgcXVldWVbaV0uaWQgPiB3YXRjaGVyLmlkKSB7XG4gICAgICAgIGktLTtcbiAgICAgIH1cbiAgICAgIHF1ZXVlLnNwbGljZShpICsgMSwgMCwgd2F0Y2hlcik7XG4gICAgfVxuICAgIC8vIHF1ZXVlIHRoZSBmbHVzaFxuICAgIGlmICghd2FpdGluZykge1xuICAgICAgd2FpdGluZyA9IHRydWU7XG5cbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmICFjb25maWcuYXN5bmMpIHtcbiAgICAgICAgZmx1c2hTY2hlZHVsZXJRdWV1ZSgpO1xuICAgICAgICByZXR1cm5cbiAgICAgIH1cbiAgICAgIG5leHRUaWNrKGZsdXNoU2NoZWR1bGVyUXVldWUpO1xuICAgIH1cbiAgfVxufVxuXG4vKiAgKi9cblxuXG5cbnZhciB1aWQkMiA9IDA7XG5cbi8qKlxuICogQSB3YXRjaGVyIHBhcnNlcyBhbiBleHByZXNzaW9uLCBjb2xsZWN0cyBkZXBlbmRlbmNpZXMsXG4gKiBhbmQgZmlyZXMgY2FsbGJhY2sgd2hlbiB0aGUgZXhwcmVzc2lvbiB2YWx1ZSBjaGFuZ2VzLlxuICogVGhpcyBpcyB1c2VkIGZvciBib3RoIHRoZSAkd2F0Y2goKSBhcGkgYW5kIGRpcmVjdGl2ZXMuXG4gKi9cbnZhciBXYXRjaGVyID0gZnVuY3Rpb24gV2F0Y2hlciAoXG4gIHZtLFxuICBleHBPckZuLFxuICBjYixcbiAgb3B0aW9ucyxcbiAgaXNSZW5kZXJXYXRjaGVyXG4pIHtcbiAgdGhpcy52bSA9IHZtO1xuICBpZiAoaXNSZW5kZXJXYXRjaGVyKSB7XG4gICAgdm0uX3dhdGNoZXIgPSB0aGlzO1xuICB9XG4gIHZtLl93YXRjaGVycy5wdXNoKHRoaXMpO1xuICAvLyBvcHRpb25zXG4gIGlmIChvcHRpb25zKSB7XG4gICAgdGhpcy5kZWVwID0gISFvcHRpb25zLmRlZXA7XG4gICAgdGhpcy51c2VyID0gISFvcHRpb25zLnVzZXI7XG4gICAgdGhpcy5sYXp5ID0gISFvcHRpb25zLmxhenk7XG4gICAgdGhpcy5zeW5jID0gISFvcHRpb25zLnN5bmM7XG4gICAgdGhpcy5iZWZvcmUgPSBvcHRpb25zLmJlZm9yZTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLmRlZXAgPSB0aGlzLnVzZXIgPSB0aGlzLmxhenkgPSB0aGlzLnN5bmMgPSBmYWxzZTtcbiAgfVxuICB0aGlzLmNiID0gY2I7XG4gIHRoaXMuaWQgPSArK3VpZCQyOyAvLyB1aWQgZm9yIGJhdGNoaW5nXG4gIHRoaXMuYWN0aXZlID0gdHJ1ZTtcbiAgdGhpcy5kaXJ0eSA9IHRoaXMubGF6eTsgLy8gZm9yIGxhenkgd2F0Y2hlcnNcbiAgdGhpcy5kZXBzID0gW107XG4gIHRoaXMubmV3RGVwcyA9IFtdO1xuICB0aGlzLmRlcElkcyA9IG5ldyBfU2V0KCk7XG4gIHRoaXMubmV3RGVwSWRzID0gbmV3IF9TZXQoKTtcbiAgdGhpcy5leHByZXNzaW9uID0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJ1xuICAgID8gZXhwT3JGbi50b1N0cmluZygpXG4gICAgOiAnJztcbiAgLy8gcGFyc2UgZXhwcmVzc2lvbiBmb3IgZ2V0dGVyXG4gIGlmICh0eXBlb2YgZXhwT3JGbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHRoaXMuZ2V0dGVyID0gZXhwT3JGbjtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLmdldHRlciA9IHBhcnNlUGF0aChleHBPckZuKTtcbiAgICBpZiAoIXRoaXMuZ2V0dGVyKSB7XG4gICAgICB0aGlzLmdldHRlciA9IG5vb3A7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oXG4gICAgICAgIFwiRmFpbGVkIHdhdGNoaW5nIHBhdGg6IFxcXCJcIiArIGV4cE9yRm4gKyBcIlxcXCIgXCIgK1xuICAgICAgICAnV2F0Y2hlciBvbmx5IGFjY2VwdHMgc2ltcGxlIGRvdC1kZWxpbWl0ZWQgcGF0aHMuICcgK1xuICAgICAgICAnRm9yIGZ1bGwgY29udHJvbCwgdXNlIGEgZnVuY3Rpb24gaW5zdGVhZC4nLFxuICAgICAgICB2bVxuICAgICAgKTtcbiAgICB9XG4gIH1cbiAgdGhpcy52YWx1ZSA9IHRoaXMubGF6eVxuICAgID8gdW5kZWZpbmVkXG4gICAgOiB0aGlzLmdldCgpO1xufTtcblxuLyoqXG4gKiBFdmFsdWF0ZSB0aGUgZ2V0dGVyLCBhbmQgcmUtY29sbGVjdCBkZXBlbmRlbmNpZXMuXG4gKi9cbldhdGNoZXIucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIGdldCAoKSB7XG4gIHB1c2hUYXJnZXQodGhpcyk7XG4gIHZhciB2YWx1ZTtcbiAgdmFyIHZtID0gdGhpcy52bTtcbiAgdHJ5IHtcbiAgICB2YWx1ZSA9IHRoaXMuZ2V0dGVyLmNhbGwodm0sIHZtKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIGlmICh0aGlzLnVzZXIpIHtcbiAgICAgIGhhbmRsZUVycm9yKGUsIHZtLCAoXCJnZXR0ZXIgZm9yIHdhdGNoZXIgXFxcIlwiICsgKHRoaXMuZXhwcmVzc2lvbikgKyBcIlxcXCJcIikpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBlXG4gICAgfVxuICB9IGZpbmFsbHkge1xuICAgIC8vIFwidG91Y2hcIiBldmVyeSBwcm9wZXJ0eSBzbyB0aGV5IGFyZSBhbGwgdHJhY2tlZCBhc1xuICAgIC8vIGRlcGVuZGVuY2llcyBmb3IgZGVlcCB3YXRjaGluZ1xuICAgIGlmICh0aGlzLmRlZXApIHtcbiAgICAgIHRyYXZlcnNlKHZhbHVlKTtcbiAgICB9XG4gICAgcG9wVGFyZ2V0KCk7XG4gICAgdGhpcy5jbGVhbnVwRGVwcygpO1xuICB9XG4gIHJldHVybiB2YWx1ZVxufTtcblxuLyoqXG4gKiBBZGQgYSBkZXBlbmRlbmN5IHRvIHRoaXMgZGlyZWN0aXZlLlxuICovXG5XYXRjaGVyLnByb3RvdHlwZS5hZGREZXAgPSBmdW5jdGlvbiBhZGREZXAgKGRlcCkge1xuICB2YXIgaWQgPSBkZXAuaWQ7XG4gIGlmICghdGhpcy5uZXdEZXBJZHMuaGFzKGlkKSkge1xuICAgIHRoaXMubmV3RGVwSWRzLmFkZChpZCk7XG4gICAgdGhpcy5uZXdEZXBzLnB1c2goZGVwKTtcbiAgICBpZiAoIXRoaXMuZGVwSWRzLmhhcyhpZCkpIHtcbiAgICAgIGRlcC5hZGRTdWIodGhpcyk7XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIENsZWFuIHVwIGZvciBkZXBlbmRlbmN5IGNvbGxlY3Rpb24uXG4gKi9cbldhdGNoZXIucHJvdG90eXBlLmNsZWFudXBEZXBzID0gZnVuY3Rpb24gY2xlYW51cERlcHMgKCkge1xuICB2YXIgaSA9IHRoaXMuZGVwcy5sZW5ndGg7XG4gIHdoaWxlIChpLS0pIHtcbiAgICB2YXIgZGVwID0gdGhpcy5kZXBzW2ldO1xuICAgIGlmICghdGhpcy5uZXdEZXBJZHMuaGFzKGRlcC5pZCkpIHtcbiAgICAgIGRlcC5yZW1vdmVTdWIodGhpcyk7XG4gICAgfVxuICB9XG4gIHZhciB0bXAgPSB0aGlzLmRlcElkcztcbiAgdGhpcy5kZXBJZHMgPSB0aGlzLm5ld0RlcElkcztcbiAgdGhpcy5uZXdEZXBJZHMgPSB0bXA7XG4gIHRoaXMubmV3RGVwSWRzLmNsZWFyKCk7XG4gIHRtcCA9IHRoaXMuZGVwcztcbiAgdGhpcy5kZXBzID0gdGhpcy5uZXdEZXBzO1xuICB0aGlzLm5ld0RlcHMgPSB0bXA7XG4gIHRoaXMubmV3RGVwcy5sZW5ndGggPSAwO1xufTtcblxuLyoqXG4gKiBTdWJzY3JpYmVyIGludGVyZmFjZS5cbiAqIFdpbGwgYmUgY2FsbGVkIHdoZW4gYSBkZXBlbmRlbmN5IGNoYW5nZXMuXG4gKi9cbldhdGNoZXIucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIHVwZGF0ZSAoKSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gIGlmICh0aGlzLmxhenkpIHtcbiAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcbiAgfSBlbHNlIGlmICh0aGlzLnN5bmMpIHtcbiAgICB0aGlzLnJ1bigpO1xuICB9IGVsc2Uge1xuICAgIHF1ZXVlV2F0Y2hlcih0aGlzKTtcbiAgfVxufTtcblxuLyoqXG4gKiBTY2hlZHVsZXIgam9iIGludGVyZmFjZS5cbiAqIFdpbGwgYmUgY2FsbGVkIGJ5IHRoZSBzY2hlZHVsZXIuXG4gKi9cbldhdGNoZXIucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uIHJ1biAoKSB7XG4gIGlmICh0aGlzLmFjdGl2ZSkge1xuICAgIHZhciB2YWx1ZSA9IHRoaXMuZ2V0KCk7XG4gICAgaWYgKFxuICAgICAgdmFsdWUgIT09IHRoaXMudmFsdWUgfHxcbiAgICAgIC8vIERlZXAgd2F0Y2hlcnMgYW5kIHdhdGNoZXJzIG9uIE9iamVjdC9BcnJheXMgc2hvdWxkIGZpcmUgZXZlblxuICAgICAgLy8gd2hlbiB0aGUgdmFsdWUgaXMgdGhlIHNhbWUsIGJlY2F1c2UgdGhlIHZhbHVlIG1heVxuICAgICAgLy8gaGF2ZSBtdXRhdGVkLlxuICAgICAgaXNPYmplY3QodmFsdWUpIHx8XG4gICAgICB0aGlzLmRlZXBcbiAgICApIHtcbiAgICAgIC8vIHNldCBuZXcgdmFsdWVcbiAgICAgIHZhciBvbGRWYWx1ZSA9IHRoaXMudmFsdWU7XG4gICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICBpZiAodGhpcy51c2VyKSB7XG4gICAgICAgIHZhciBpbmZvID0gXCJjYWxsYmFjayBmb3Igd2F0Y2hlciBcXFwiXCIgKyAodGhpcy5leHByZXNzaW9uKSArIFwiXFxcIlwiO1xuICAgICAgICBpbnZva2VXaXRoRXJyb3JIYW5kbGluZyh0aGlzLmNiLCB0aGlzLnZtLCBbdmFsdWUsIG9sZFZhbHVlXSwgdGhpcy52bSwgaW5mbyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmNiLmNhbGwodGhpcy52bSwgdmFsdWUsIG9sZFZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogRXZhbHVhdGUgdGhlIHZhbHVlIG9mIHRoZSB3YXRjaGVyLlxuICogVGhpcyBvbmx5IGdldHMgY2FsbGVkIGZvciBsYXp5IHdhdGNoZXJzLlxuICovXG5XYXRjaGVyLnByb3RvdHlwZS5ldmFsdWF0ZSA9IGZ1bmN0aW9uIGV2YWx1YXRlICgpIHtcbiAgdGhpcy52YWx1ZSA9IHRoaXMuZ2V0KCk7XG4gIHRoaXMuZGlydHkgPSBmYWxzZTtcbn07XG5cbi8qKlxuICogRGVwZW5kIG9uIGFsbCBkZXBzIGNvbGxlY3RlZCBieSB0aGlzIHdhdGNoZXIuXG4gKi9cbldhdGNoZXIucHJvdG90eXBlLmRlcGVuZCA9IGZ1bmN0aW9uIGRlcGVuZCAoKSB7XG4gIHZhciBpID0gdGhpcy5kZXBzLmxlbmd0aDtcbiAgd2hpbGUgKGktLSkge1xuICAgIHRoaXMuZGVwc1tpXS5kZXBlbmQoKTtcbiAgfVxufTtcblxuLyoqXG4gKiBSZW1vdmUgc2VsZiBmcm9tIGFsbCBkZXBlbmRlbmNpZXMnIHN1YnNjcmliZXIgbGlzdC5cbiAqL1xuV2F0Y2hlci5wcm90b3R5cGUudGVhcmRvd24gPSBmdW5jdGlvbiB0ZWFyZG93biAoKSB7XG4gIGlmICh0aGlzLmFjdGl2ZSkge1xuICAgIC8vIHJlbW92ZSBzZWxmIGZyb20gdm0ncyB3YXRjaGVyIGxpc3RcbiAgICAvLyB0aGlzIGlzIGEgc29tZXdoYXQgZXhwZW5zaXZlIG9wZXJhdGlvbiBzbyB3ZSBza2lwIGl0XG4gICAgLy8gaWYgdGhlIHZtIGlzIGJlaW5nIGRlc3Ryb3llZC5cbiAgICBpZiAoIXRoaXMudm0uX2lzQmVpbmdEZXN0cm95ZWQpIHtcbiAgICAgIHJlbW92ZSh0aGlzLnZtLl93YXRjaGVycywgdGhpcyk7XG4gICAgfVxuICAgIHZhciBpID0gdGhpcy5kZXBzLmxlbmd0aDtcbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICB0aGlzLmRlcHNbaV0ucmVtb3ZlU3ViKHRoaXMpO1xuICAgIH1cbiAgICB0aGlzLmFjdGl2ZSA9IGZhbHNlO1xuICB9XG59O1xuXG4vKiAgKi9cblxudmFyIHNoYXJlZFByb3BlcnR5RGVmaW5pdGlvbiA9IHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgY29uZmlndXJhYmxlOiB0cnVlLFxuICBnZXQ6IG5vb3AsXG4gIHNldDogbm9vcFxufTtcblxuZnVuY3Rpb24gcHJveHkgKHRhcmdldCwgc291cmNlS2V5LCBrZXkpIHtcbiAgc2hhcmVkUHJvcGVydHlEZWZpbml0aW9uLmdldCA9IGZ1bmN0aW9uIHByb3h5R2V0dGVyICgpIHtcbiAgICByZXR1cm4gdGhpc1tzb3VyY2VLZXldW2tleV1cbiAgfTtcbiAgc2hhcmVkUHJvcGVydHlEZWZpbml0aW9uLnNldCA9IGZ1bmN0aW9uIHByb3h5U2V0dGVyICh2YWwpIHtcbiAgICB0aGlzW3NvdXJjZUtleV1ba2V5XSA9IHZhbDtcbiAgfTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBzaGFyZWRQcm9wZXJ0eURlZmluaXRpb24pO1xufVxuXG5mdW5jdGlvbiBpbml0U3RhdGUgKHZtKSB7XG4gIHZtLl93YXRjaGVycyA9IFtdO1xuICB2YXIgb3B0cyA9IHZtLiRvcHRpb25zO1xuICBpZiAob3B0cy5wcm9wcykgeyBpbml0UHJvcHModm0sIG9wdHMucHJvcHMpOyB9XG4gIGlmIChvcHRzLm1ldGhvZHMpIHsgaW5pdE1ldGhvZHModm0sIG9wdHMubWV0aG9kcyk7IH1cbiAgaWYgKG9wdHMuZGF0YSkge1xuICAgIGluaXREYXRhKHZtKTtcbiAgfSBlbHNlIHtcbiAgICBvYnNlcnZlKHZtLl9kYXRhID0ge30sIHRydWUgLyogYXNSb290RGF0YSAqLyk7XG4gIH1cbiAgaWYgKG9wdHMuY29tcHV0ZWQpIHsgaW5pdENvbXB1dGVkKHZtLCBvcHRzLmNvbXB1dGVkKTsgfVxuICBpZiAob3B0cy53YXRjaCAmJiBvcHRzLndhdGNoICE9PSBuYXRpdmVXYXRjaCkge1xuICAgIGluaXRXYXRjaCh2bSwgb3B0cy53YXRjaCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaW5pdFByb3BzICh2bSwgcHJvcHNPcHRpb25zKSB7XG4gIHZhciBwcm9wc0RhdGEgPSB2bS4kb3B0aW9ucy5wcm9wc0RhdGEgfHwge307XG4gIHZhciBwcm9wcyA9IHZtLl9wcm9wcyA9IHt9O1xuICAvLyBjYWNoZSBwcm9wIGtleXMgc28gdGhhdCBmdXR1cmUgcHJvcHMgdXBkYXRlcyBjYW4gaXRlcmF0ZSB1c2luZyBBcnJheVxuICAvLyBpbnN0ZWFkIG9mIGR5bmFtaWMgb2JqZWN0IGtleSBlbnVtZXJhdGlvbi5cbiAgdmFyIGtleXMgPSB2bS4kb3B0aW9ucy5fcHJvcEtleXMgPSBbXTtcbiAgdmFyIGlzUm9vdCA9ICF2bS4kcGFyZW50O1xuICAvLyByb290IGluc3RhbmNlIHByb3BzIHNob3VsZCBiZSBjb252ZXJ0ZWRcbiAgaWYgKCFpc1Jvb3QpIHtcbiAgICB0b2dnbGVPYnNlcnZpbmcoZmFsc2UpO1xuICB9XG4gIHZhciBsb29wID0gZnVuY3Rpb24gKCBrZXkgKSB7XG4gICAga2V5cy5wdXNoKGtleSk7XG4gICAgdmFyIHZhbHVlID0gdmFsaWRhdGVQcm9wKGtleSwgcHJvcHNPcHRpb25zLCBwcm9wc0RhdGEsIHZtKTtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICB2YXIgaHlwaGVuYXRlZEtleSA9IGh5cGhlbmF0ZShrZXkpO1xuICAgICAgaWYgKGlzUmVzZXJ2ZWRBdHRyaWJ1dGUoaHlwaGVuYXRlZEtleSkgfHxcbiAgICAgICAgICBjb25maWcuaXNSZXNlcnZlZEF0dHIoaHlwaGVuYXRlZEtleSkpIHtcbiAgICAgICAgd2FybihcbiAgICAgICAgICAoXCJcXFwiXCIgKyBoeXBoZW5hdGVkS2V5ICsgXCJcXFwiIGlzIGEgcmVzZXJ2ZWQgYXR0cmlidXRlIGFuZCBjYW5ub3QgYmUgdXNlZCBhcyBjb21wb25lbnQgcHJvcC5cIiksXG4gICAgICAgICAgdm1cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGRlZmluZVJlYWN0aXZlJCQxKHByb3BzLCBrZXksIHZhbHVlLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghaXNSb290ICYmICFpc1VwZGF0aW5nQ2hpbGRDb21wb25lbnQpIHtcbiAgICAgICAgICB3YXJuKFxuICAgICAgICAgICAgXCJBdm9pZCBtdXRhdGluZyBhIHByb3AgZGlyZWN0bHkgc2luY2UgdGhlIHZhbHVlIHdpbGwgYmUgXCIgK1xuICAgICAgICAgICAgXCJvdmVyd3JpdHRlbiB3aGVuZXZlciB0aGUgcGFyZW50IGNvbXBvbmVudCByZS1yZW5kZXJzLiBcIiArXG4gICAgICAgICAgICBcIkluc3RlYWQsIHVzZSBhIGRhdGEgb3IgY29tcHV0ZWQgcHJvcGVydHkgYmFzZWQgb24gdGhlIHByb3AncyBcIiArXG4gICAgICAgICAgICBcInZhbHVlLiBQcm9wIGJlaW5nIG11dGF0ZWQ6IFxcXCJcIiArIGtleSArIFwiXFxcIlwiLFxuICAgICAgICAgICAgdm1cbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGVmaW5lUmVhY3RpdmUkJDEocHJvcHMsIGtleSwgdmFsdWUpO1xuICAgIH1cbiAgICAvLyBzdGF0aWMgcHJvcHMgYXJlIGFscmVhZHkgcHJveGllZCBvbiB0aGUgY29tcG9uZW50J3MgcHJvdG90eXBlXG4gICAgLy8gZHVyaW5nIFZ1ZS5leHRlbmQoKS4gV2Ugb25seSBuZWVkIHRvIHByb3h5IHByb3BzIGRlZmluZWQgYXRcbiAgICAvLyBpbnN0YW50aWF0aW9uIGhlcmUuXG4gICAgaWYgKCEoa2V5IGluIHZtKSkge1xuICAgICAgcHJveHkodm0sIFwiX3Byb3BzXCIsIGtleSk7XG4gICAgfVxuICB9O1xuXG4gIGZvciAodmFyIGtleSBpbiBwcm9wc09wdGlvbnMpIGxvb3AoIGtleSApO1xuICB0b2dnbGVPYnNlcnZpbmcodHJ1ZSk7XG59XG5cbmZ1bmN0aW9uIGluaXREYXRhICh2bSkge1xuICB2YXIgZGF0YSA9IHZtLiRvcHRpb25zLmRhdGE7XG4gIGRhdGEgPSB2bS5fZGF0YSA9IHR5cGVvZiBkYXRhID09PSAnZnVuY3Rpb24nXG4gICAgPyBnZXREYXRhKGRhdGEsIHZtKVxuICAgIDogZGF0YSB8fCB7fTtcbiAgaWYgKCFpc1BsYWluT2JqZWN0KGRhdGEpKSB7XG4gICAgZGF0YSA9IHt9O1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybihcbiAgICAgICdkYXRhIGZ1bmN0aW9ucyBzaG91bGQgcmV0dXJuIGFuIG9iamVjdDpcXG4nICtcbiAgICAgICdodHRwczovL3Z1ZWpzLm9yZy92Mi9ndWlkZS9jb21wb25lbnRzLmh0bWwjZGF0YS1NdXN0LUJlLWEtRnVuY3Rpb24nLFxuICAgICAgdm1cbiAgICApO1xuICB9XG4gIC8vIHByb3h5IGRhdGEgb24gaW5zdGFuY2VcbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhkYXRhKTtcbiAgdmFyIHByb3BzID0gdm0uJG9wdGlvbnMucHJvcHM7XG4gIHZhciBtZXRob2RzID0gdm0uJG9wdGlvbnMubWV0aG9kcztcbiAgdmFyIGkgPSBrZXlzLmxlbmd0aDtcbiAgd2hpbGUgKGktLSkge1xuICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBpZiAobWV0aG9kcyAmJiBoYXNPd24obWV0aG9kcywga2V5KSkge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgIChcIk1ldGhvZCBcXFwiXCIgKyBrZXkgKyBcIlxcXCIgaGFzIGFscmVhZHkgYmVlbiBkZWZpbmVkIGFzIGEgZGF0YSBwcm9wZXJ0eS5cIiksXG4gICAgICAgICAgdm1cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHByb3BzICYmIGhhc093bihwcm9wcywga2V5KSkge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKFxuICAgICAgICBcIlRoZSBkYXRhIHByb3BlcnR5IFxcXCJcIiArIGtleSArIFwiXFxcIiBpcyBhbHJlYWR5IGRlY2xhcmVkIGFzIGEgcHJvcC4gXCIgK1xuICAgICAgICBcIlVzZSBwcm9wIGRlZmF1bHQgdmFsdWUgaW5zdGVhZC5cIixcbiAgICAgICAgdm1cbiAgICAgICk7XG4gICAgfSBlbHNlIGlmICghaXNSZXNlcnZlZChrZXkpKSB7XG4gICAgICBwcm94eSh2bSwgXCJfZGF0YVwiLCBrZXkpO1xuICAgIH1cbiAgfVxuICAvLyBvYnNlcnZlIGRhdGFcbiAgb2JzZXJ2ZShkYXRhLCB0cnVlIC8qIGFzUm9vdERhdGEgKi8pO1xufVxuXG5mdW5jdGlvbiBnZXREYXRhIChkYXRhLCB2bSkge1xuICAvLyAjNzU3MyBkaXNhYmxlIGRlcCBjb2xsZWN0aW9uIHdoZW4gaW52b2tpbmcgZGF0YSBnZXR0ZXJzXG4gIHB1c2hUYXJnZXQoKTtcbiAgdHJ5IHtcbiAgICByZXR1cm4gZGF0YS5jYWxsKHZtLCB2bSlcbiAgfSBjYXRjaCAoZSkge1xuICAgIGhhbmRsZUVycm9yKGUsIHZtLCBcImRhdGEoKVwiKTtcbiAgICByZXR1cm4ge31cbiAgfSBmaW5hbGx5IHtcbiAgICBwb3BUYXJnZXQoKTtcbiAgfVxufVxuXG52YXIgY29tcHV0ZWRXYXRjaGVyT3B0aW9ucyA9IHsgbGF6eTogdHJ1ZSB9O1xuXG5mdW5jdGlvbiBpbml0Q29tcHV0ZWQgKHZtLCBjb21wdXRlZCkge1xuICAvLyAkZmxvdy1kaXNhYmxlLWxpbmVcbiAgdmFyIHdhdGNoZXJzID0gdm0uX2NvbXB1dGVkV2F0Y2hlcnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAvLyBjb21wdXRlZCBwcm9wZXJ0aWVzIGFyZSBqdXN0IGdldHRlcnMgZHVyaW5nIFNTUlxuICB2YXIgaXNTU1IgPSBpc1NlcnZlclJlbmRlcmluZygpO1xuXG4gIGZvciAodmFyIGtleSBpbiBjb21wdXRlZCkge1xuICAgIHZhciB1c2VyRGVmID0gY29tcHV0ZWRba2V5XTtcbiAgICB2YXIgZ2V0dGVyID0gdHlwZW9mIHVzZXJEZWYgPT09ICdmdW5jdGlvbicgPyB1c2VyRGVmIDogdXNlckRlZi5nZXQ7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgZ2V0dGVyID09IG51bGwpIHtcbiAgICAgIHdhcm4oXG4gICAgICAgIChcIkdldHRlciBpcyBtaXNzaW5nIGZvciBjb21wdXRlZCBwcm9wZXJ0eSBcXFwiXCIgKyBrZXkgKyBcIlxcXCIuXCIpLFxuICAgICAgICB2bVxuICAgICAgKTtcbiAgICB9XG5cbiAgICBpZiAoIWlzU1NSKSB7XG4gICAgICAvLyBjcmVhdGUgaW50ZXJuYWwgd2F0Y2hlciBmb3IgdGhlIGNvbXB1dGVkIHByb3BlcnR5LlxuICAgICAgd2F0Y2hlcnNba2V5XSA9IG5ldyBXYXRjaGVyKFxuICAgICAgICB2bSxcbiAgICAgICAgZ2V0dGVyIHx8IG5vb3AsXG4gICAgICAgIG5vb3AsXG4gICAgICAgIGNvbXB1dGVkV2F0Y2hlck9wdGlvbnNcbiAgICAgICk7XG4gICAgfVxuXG4gICAgLy8gY29tcG9uZW50LWRlZmluZWQgY29tcHV0ZWQgcHJvcGVydGllcyBhcmUgYWxyZWFkeSBkZWZpbmVkIG9uIHRoZVxuICAgIC8vIGNvbXBvbmVudCBwcm90b3R5cGUuIFdlIG9ubHkgbmVlZCB0byBkZWZpbmUgY29tcHV0ZWQgcHJvcGVydGllcyBkZWZpbmVkXG4gICAgLy8gYXQgaW5zdGFudGlhdGlvbiBoZXJlLlxuICAgIGlmICghKGtleSBpbiB2bSkpIHtcbiAgICAgIGRlZmluZUNvbXB1dGVkKHZtLCBrZXksIHVzZXJEZWYpO1xuICAgIH0gZWxzZSBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgaWYgKGtleSBpbiB2bS4kZGF0YSkge1xuICAgICAgICB3YXJuKChcIlRoZSBjb21wdXRlZCBwcm9wZXJ0eSBcXFwiXCIgKyBrZXkgKyBcIlxcXCIgaXMgYWxyZWFkeSBkZWZpbmVkIGluIGRhdGEuXCIpLCB2bSk7XG4gICAgICB9IGVsc2UgaWYgKHZtLiRvcHRpb25zLnByb3BzICYmIGtleSBpbiB2bS4kb3B0aW9ucy5wcm9wcykge1xuICAgICAgICB3YXJuKChcIlRoZSBjb21wdXRlZCBwcm9wZXJ0eSBcXFwiXCIgKyBrZXkgKyBcIlxcXCIgaXMgYWxyZWFkeSBkZWZpbmVkIGFzIGEgcHJvcC5cIiksIHZtKTtcbiAgICAgIH0gZWxzZSBpZiAodm0uJG9wdGlvbnMubWV0aG9kcyAmJiBrZXkgaW4gdm0uJG9wdGlvbnMubWV0aG9kcykge1xuICAgICAgICB3YXJuKChcIlRoZSBjb21wdXRlZCBwcm9wZXJ0eSBcXFwiXCIgKyBrZXkgKyBcIlxcXCIgaXMgYWxyZWFkeSBkZWZpbmVkIGFzIGEgbWV0aG9kLlwiKSwgdm0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBkZWZpbmVDb21wdXRlZCAoXG4gIHRhcmdldCxcbiAga2V5LFxuICB1c2VyRGVmXG4pIHtcbiAgdmFyIHNob3VsZENhY2hlID0gIWlzU2VydmVyUmVuZGVyaW5nKCk7XG4gIGlmICh0eXBlb2YgdXNlckRlZiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHNoYXJlZFByb3BlcnR5RGVmaW5pdGlvbi5nZXQgPSBzaG91bGRDYWNoZVxuICAgICAgPyBjcmVhdGVDb21wdXRlZEdldHRlcihrZXkpXG4gICAgICA6IGNyZWF0ZUdldHRlckludm9rZXIodXNlckRlZik7XG4gICAgc2hhcmVkUHJvcGVydHlEZWZpbml0aW9uLnNldCA9IG5vb3A7XG4gIH0gZWxzZSB7XG4gICAgc2hhcmVkUHJvcGVydHlEZWZpbml0aW9uLmdldCA9IHVzZXJEZWYuZ2V0XG4gICAgICA/IHNob3VsZENhY2hlICYmIHVzZXJEZWYuY2FjaGUgIT09IGZhbHNlXG4gICAgICAgID8gY3JlYXRlQ29tcHV0ZWRHZXR0ZXIoa2V5KVxuICAgICAgICA6IGNyZWF0ZUdldHRlckludm9rZXIodXNlckRlZi5nZXQpXG4gICAgICA6IG5vb3A7XG4gICAgc2hhcmVkUHJvcGVydHlEZWZpbml0aW9uLnNldCA9IHVzZXJEZWYuc2V0IHx8IG5vb3A7XG4gIH1cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiZcbiAgICAgIHNoYXJlZFByb3BlcnR5RGVmaW5pdGlvbi5zZXQgPT09IG5vb3ApIHtcbiAgICBzaGFyZWRQcm9wZXJ0eURlZmluaXRpb24uc2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgd2FybihcbiAgICAgICAgKFwiQ29tcHV0ZWQgcHJvcGVydHkgXFxcIlwiICsga2V5ICsgXCJcXFwiIHdhcyBhc3NpZ25lZCB0byBidXQgaXQgaGFzIG5vIHNldHRlci5cIiksXG4gICAgICAgIHRoaXNcbiAgICAgICk7XG4gICAgfTtcbiAgfVxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHNoYXJlZFByb3BlcnR5RGVmaW5pdGlvbik7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUNvbXB1dGVkR2V0dGVyIChrZXkpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIGNvbXB1dGVkR2V0dGVyICgpIHtcbiAgICB2YXIgd2F0Y2hlciA9IHRoaXMuX2NvbXB1dGVkV2F0Y2hlcnMgJiYgdGhpcy5fY29tcHV0ZWRXYXRjaGVyc1trZXldO1xuICAgIGlmICh3YXRjaGVyKSB7XG4gICAgICBpZiAod2F0Y2hlci5kaXJ0eSkge1xuICAgICAgICB3YXRjaGVyLmV2YWx1YXRlKCk7XG4gICAgICB9XG4gICAgICBpZiAoRGVwLnRhcmdldCkge1xuICAgICAgICB3YXRjaGVyLmRlcGVuZCgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHdhdGNoZXIudmFsdWVcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY3JlYXRlR2V0dGVySW52b2tlcihmbikge1xuICByZXR1cm4gZnVuY3Rpb24gY29tcHV0ZWRHZXR0ZXIgKCkge1xuICAgIHJldHVybiBmbi5jYWxsKHRoaXMsIHRoaXMpXG4gIH1cbn1cblxuZnVuY3Rpb24gaW5pdE1ldGhvZHMgKHZtLCBtZXRob2RzKSB7XG4gIHZhciBwcm9wcyA9IHZtLiRvcHRpb25zLnByb3BzO1xuICBmb3IgKHZhciBrZXkgaW4gbWV0aG9kcykge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBpZiAodHlwZW9mIG1ldGhvZHNba2V5XSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgIFwiTWV0aG9kIFxcXCJcIiArIGtleSArIFwiXFxcIiBoYXMgdHlwZSBcXFwiXCIgKyAodHlwZW9mIG1ldGhvZHNba2V5XSkgKyBcIlxcXCIgaW4gdGhlIGNvbXBvbmVudCBkZWZpbml0aW9uLiBcIiArXG4gICAgICAgICAgXCJEaWQgeW91IHJlZmVyZW5jZSB0aGUgZnVuY3Rpb24gY29ycmVjdGx5P1wiLFxuICAgICAgICAgIHZtXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBpZiAocHJvcHMgJiYgaGFzT3duKHByb3BzLCBrZXkpKSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgKFwiTWV0aG9kIFxcXCJcIiArIGtleSArIFwiXFxcIiBoYXMgYWxyZWFkeSBiZWVuIGRlZmluZWQgYXMgYSBwcm9wLlwiKSxcbiAgICAgICAgICB2bVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgaWYgKChrZXkgaW4gdm0pICYmIGlzUmVzZXJ2ZWQoa2V5KSkge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgIFwiTWV0aG9kIFxcXCJcIiArIGtleSArIFwiXFxcIiBjb25mbGljdHMgd2l0aCBhbiBleGlzdGluZyBWdWUgaW5zdGFuY2UgbWV0aG9kLiBcIiArXG4gICAgICAgICAgXCJBdm9pZCBkZWZpbmluZyBjb21wb25lbnQgbWV0aG9kcyB0aGF0IHN0YXJ0IHdpdGggXyBvciAkLlwiXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICAgIHZtW2tleV0gPSB0eXBlb2YgbWV0aG9kc1trZXldICE9PSAnZnVuY3Rpb24nID8gbm9vcCA6IGJpbmQobWV0aG9kc1trZXldLCB2bSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaW5pdFdhdGNoICh2bSwgd2F0Y2gpIHtcbiAgZm9yICh2YXIga2V5IGluIHdhdGNoKSB7XG4gICAgdmFyIGhhbmRsZXIgPSB3YXRjaFtrZXldO1xuICAgIGlmIChBcnJheS5pc0FycmF5KGhhbmRsZXIpKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGhhbmRsZXIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY3JlYXRlV2F0Y2hlcih2bSwga2V5LCBoYW5kbGVyW2ldKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY3JlYXRlV2F0Y2hlcih2bSwga2V5LCBoYW5kbGVyKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY3JlYXRlV2F0Y2hlciAoXG4gIHZtLFxuICBleHBPckZuLFxuICBoYW5kbGVyLFxuICBvcHRpb25zXG4pIHtcbiAgaWYgKGlzUGxhaW5PYmplY3QoaGFuZGxlcikpIHtcbiAgICBvcHRpb25zID0gaGFuZGxlcjtcbiAgICBoYW5kbGVyID0gaGFuZGxlci5oYW5kbGVyO1xuICB9XG4gIGlmICh0eXBlb2YgaGFuZGxlciA9PT0gJ3N0cmluZycpIHtcbiAgICBoYW5kbGVyID0gdm1baGFuZGxlcl07XG4gIH1cbiAgcmV0dXJuIHZtLiR3YXRjaChleHBPckZuLCBoYW5kbGVyLCBvcHRpb25zKVxufVxuXG5mdW5jdGlvbiBzdGF0ZU1peGluIChWdWUpIHtcbiAgLy8gZmxvdyBzb21laG93IGhhcyBwcm9ibGVtcyB3aXRoIGRpcmVjdGx5IGRlY2xhcmVkIGRlZmluaXRpb24gb2JqZWN0XG4gIC8vIHdoZW4gdXNpbmcgT2JqZWN0LmRlZmluZVByb3BlcnR5LCBzbyB3ZSBoYXZlIHRvIHByb2NlZHVyYWxseSBidWlsZCB1cFxuICAvLyB0aGUgb2JqZWN0IGhlcmUuXG4gIHZhciBkYXRhRGVmID0ge307XG4gIGRhdGFEZWYuZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fZGF0YSB9O1xuICB2YXIgcHJvcHNEZWYgPSB7fTtcbiAgcHJvcHNEZWYuZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fcHJvcHMgfTtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBkYXRhRGVmLnNldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHdhcm4oXG4gICAgICAgICdBdm9pZCByZXBsYWNpbmcgaW5zdGFuY2Ugcm9vdCAkZGF0YS4gJyArXG4gICAgICAgICdVc2UgbmVzdGVkIGRhdGEgcHJvcGVydGllcyBpbnN0ZWFkLicsXG4gICAgICAgIHRoaXNcbiAgICAgICk7XG4gICAgfTtcbiAgICBwcm9wc0RlZi5zZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB3YXJuKFwiJHByb3BzIGlzIHJlYWRvbmx5LlwiLCB0aGlzKTtcbiAgICB9O1xuICB9XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShWdWUucHJvdG90eXBlLCAnJGRhdGEnLCBkYXRhRGVmKTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFZ1ZS5wcm90b3R5cGUsICckcHJvcHMnLCBwcm9wc0RlZik7XG5cbiAgVnVlLnByb3RvdHlwZS4kc2V0ID0gc2V0O1xuICBWdWUucHJvdG90eXBlLiRkZWxldGUgPSBkZWw7XG5cbiAgVnVlLnByb3RvdHlwZS4kd2F0Y2ggPSBmdW5jdGlvbiAoXG4gICAgZXhwT3JGbixcbiAgICBjYixcbiAgICBvcHRpb25zXG4gICkge1xuICAgIHZhciB2bSA9IHRoaXM7XG4gICAgaWYgKGlzUGxhaW5PYmplY3QoY2IpKSB7XG4gICAgICByZXR1cm4gY3JlYXRlV2F0Y2hlcih2bSwgZXhwT3JGbiwgY2IsIG9wdGlvbnMpXG4gICAgfVxuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIG9wdGlvbnMudXNlciA9IHRydWU7XG4gICAgdmFyIHdhdGNoZXIgPSBuZXcgV2F0Y2hlcih2bSwgZXhwT3JGbiwgY2IsIG9wdGlvbnMpO1xuICAgIGlmIChvcHRpb25zLmltbWVkaWF0ZSkge1xuICAgICAgdmFyIGluZm8gPSBcImNhbGxiYWNrIGZvciBpbW1lZGlhdGUgd2F0Y2hlciBcXFwiXCIgKyAod2F0Y2hlci5leHByZXNzaW9uKSArIFwiXFxcIlwiO1xuICAgICAgcHVzaFRhcmdldCgpO1xuICAgICAgaW52b2tlV2l0aEVycm9ySGFuZGxpbmcoY2IsIHZtLCBbd2F0Y2hlci52YWx1ZV0sIHZtLCBpbmZvKTtcbiAgICAgIHBvcFRhcmdldCgpO1xuICAgIH1cbiAgICByZXR1cm4gZnVuY3Rpb24gdW53YXRjaEZuICgpIHtcbiAgICAgIHdhdGNoZXIudGVhcmRvd24oKTtcbiAgICB9XG4gIH07XG59XG5cbi8qICAqL1xuXG52YXIgdWlkJDMgPSAwO1xuXG5mdW5jdGlvbiBpbml0TWl4aW4gKFZ1ZSkge1xuICBWdWUucHJvdG90eXBlLl9pbml0ID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICB2YXIgdm0gPSB0aGlzO1xuICAgIC8vIGEgdWlkXG4gICAgdm0uX3VpZCA9IHVpZCQzKys7XG5cbiAgICB2YXIgc3RhcnRUYWcsIGVuZFRhZztcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBjb25maWcucGVyZm9ybWFuY2UgJiYgbWFyaykge1xuICAgICAgc3RhcnRUYWcgPSBcInZ1ZS1wZXJmLXN0YXJ0OlwiICsgKHZtLl91aWQpO1xuICAgICAgZW5kVGFnID0gXCJ2dWUtcGVyZi1lbmQ6XCIgKyAodm0uX3VpZCk7XG4gICAgICBtYXJrKHN0YXJ0VGFnKTtcbiAgICB9XG5cbiAgICAvLyBhIGZsYWcgdG8gYXZvaWQgdGhpcyBiZWluZyBvYnNlcnZlZFxuICAgIHZtLl9pc1Z1ZSA9IHRydWU7XG4gICAgLy8gbWVyZ2Ugb3B0aW9uc1xuICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMuX2lzQ29tcG9uZW50KSB7XG4gICAgICAvLyBvcHRpbWl6ZSBpbnRlcm5hbCBjb21wb25lbnQgaW5zdGFudGlhdGlvblxuICAgICAgLy8gc2luY2UgZHluYW1pYyBvcHRpb25zIG1lcmdpbmcgaXMgcHJldHR5IHNsb3csIGFuZCBub25lIG9mIHRoZVxuICAgICAgLy8gaW50ZXJuYWwgY29tcG9uZW50IG9wdGlvbnMgbmVlZHMgc3BlY2lhbCB0cmVhdG1lbnQuXG4gICAgICBpbml0SW50ZXJuYWxDb21wb25lbnQodm0sIG9wdGlvbnMpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2bS4kb3B0aW9ucyA9IG1lcmdlT3B0aW9ucyhcbiAgICAgICAgcmVzb2x2ZUNvbnN0cnVjdG9yT3B0aW9ucyh2bS5jb25zdHJ1Y3RvciksXG4gICAgICAgIG9wdGlvbnMgfHwge30sXG4gICAgICAgIHZtXG4gICAgICApO1xuICAgIH1cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBpbml0UHJveHkodm0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB2bS5fcmVuZGVyUHJveHkgPSB2bTtcbiAgICB9XG4gICAgLy8gZXhwb3NlIHJlYWwgc2VsZlxuICAgIHZtLl9zZWxmID0gdm07XG4gICAgaW5pdExpZmVjeWNsZSh2bSk7XG4gICAgaW5pdEV2ZW50cyh2bSk7XG4gICAgaW5pdFJlbmRlcih2bSk7XG4gICAgY2FsbEhvb2sodm0sICdiZWZvcmVDcmVhdGUnKTtcbiAgICBpbml0SW5qZWN0aW9ucyh2bSk7IC8vIHJlc29sdmUgaW5qZWN0aW9ucyBiZWZvcmUgZGF0YS9wcm9wc1xuICAgIGluaXRTdGF0ZSh2bSk7XG4gICAgaW5pdFByb3ZpZGUodm0pOyAvLyByZXNvbHZlIHByb3ZpZGUgYWZ0ZXIgZGF0YS9wcm9wc1xuICAgIGNhbGxIb29rKHZtLCAnY3JlYXRlZCcpO1xuXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgY29uZmlnLnBlcmZvcm1hbmNlICYmIG1hcmspIHtcbiAgICAgIHZtLl9uYW1lID0gZm9ybWF0Q29tcG9uZW50TmFtZSh2bSwgZmFsc2UpO1xuICAgICAgbWFyayhlbmRUYWcpO1xuICAgICAgbWVhc3VyZSgoXCJ2dWUgXCIgKyAodm0uX25hbWUpICsgXCIgaW5pdFwiKSwgc3RhcnRUYWcsIGVuZFRhZyk7XG4gICAgfVxuXG4gICAgaWYgKHZtLiRvcHRpb25zLmVsKSB7XG4gICAgICB2bS4kbW91bnQodm0uJG9wdGlvbnMuZWwpO1xuICAgIH1cbiAgfTtcbn1cblxuZnVuY3Rpb24gaW5pdEludGVybmFsQ29tcG9uZW50ICh2bSwgb3B0aW9ucykge1xuICB2YXIgb3B0cyA9IHZtLiRvcHRpb25zID0gT2JqZWN0LmNyZWF0ZSh2bS5jb25zdHJ1Y3Rvci5vcHRpb25zKTtcbiAgLy8gZG9pbmcgdGhpcyBiZWNhdXNlIGl0J3MgZmFzdGVyIHRoYW4gZHluYW1pYyBlbnVtZXJhdGlvbi5cbiAgdmFyIHBhcmVudFZub2RlID0gb3B0aW9ucy5fcGFyZW50Vm5vZGU7XG4gIG9wdHMucGFyZW50ID0gb3B0aW9ucy5wYXJlbnQ7XG4gIG9wdHMuX3BhcmVudFZub2RlID0gcGFyZW50Vm5vZGU7XG5cbiAgdmFyIHZub2RlQ29tcG9uZW50T3B0aW9ucyA9IHBhcmVudFZub2RlLmNvbXBvbmVudE9wdGlvbnM7XG4gIG9wdHMucHJvcHNEYXRhID0gdm5vZGVDb21wb25lbnRPcHRpb25zLnByb3BzRGF0YTtcbiAgb3B0cy5fcGFyZW50TGlzdGVuZXJzID0gdm5vZGVDb21wb25lbnRPcHRpb25zLmxpc3RlbmVycztcbiAgb3B0cy5fcmVuZGVyQ2hpbGRyZW4gPSB2bm9kZUNvbXBvbmVudE9wdGlvbnMuY2hpbGRyZW47XG4gIG9wdHMuX2NvbXBvbmVudFRhZyA9IHZub2RlQ29tcG9uZW50T3B0aW9ucy50YWc7XG5cbiAgaWYgKG9wdGlvbnMucmVuZGVyKSB7XG4gICAgb3B0cy5yZW5kZXIgPSBvcHRpb25zLnJlbmRlcjtcbiAgICBvcHRzLnN0YXRpY1JlbmRlckZucyA9IG9wdGlvbnMuc3RhdGljUmVuZGVyRm5zO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlc29sdmVDb25zdHJ1Y3Rvck9wdGlvbnMgKEN0b3IpIHtcbiAgdmFyIG9wdGlvbnMgPSBDdG9yLm9wdGlvbnM7XG4gIGlmIChDdG9yLnN1cGVyKSB7XG4gICAgdmFyIHN1cGVyT3B0aW9ucyA9IHJlc29sdmVDb25zdHJ1Y3Rvck9wdGlvbnMoQ3Rvci5zdXBlcik7XG4gICAgdmFyIGNhY2hlZFN1cGVyT3B0aW9ucyA9IEN0b3Iuc3VwZXJPcHRpb25zO1xuICAgIGlmIChzdXBlck9wdGlvbnMgIT09IGNhY2hlZFN1cGVyT3B0aW9ucykge1xuICAgICAgLy8gc3VwZXIgb3B0aW9uIGNoYW5nZWQsXG4gICAgICAvLyBuZWVkIHRvIHJlc29sdmUgbmV3IG9wdGlvbnMuXG4gICAgICBDdG9yLnN1cGVyT3B0aW9ucyA9IHN1cGVyT3B0aW9ucztcbiAgICAgIC8vIGNoZWNrIGlmIHRoZXJlIGFyZSBhbnkgbGF0ZS1tb2RpZmllZC9hdHRhY2hlZCBvcHRpb25zICgjNDk3NilcbiAgICAgIHZhciBtb2RpZmllZE9wdGlvbnMgPSByZXNvbHZlTW9kaWZpZWRPcHRpb25zKEN0b3IpO1xuICAgICAgLy8gdXBkYXRlIGJhc2UgZXh0ZW5kIG9wdGlvbnNcbiAgICAgIGlmIChtb2RpZmllZE9wdGlvbnMpIHtcbiAgICAgICAgZXh0ZW5kKEN0b3IuZXh0ZW5kT3B0aW9ucywgbW9kaWZpZWRPcHRpb25zKTtcbiAgICAgIH1cbiAgICAgIG9wdGlvbnMgPSBDdG9yLm9wdGlvbnMgPSBtZXJnZU9wdGlvbnMoc3VwZXJPcHRpb25zLCBDdG9yLmV4dGVuZE9wdGlvbnMpO1xuICAgICAgaWYgKG9wdGlvbnMubmFtZSkge1xuICAgICAgICBvcHRpb25zLmNvbXBvbmVudHNbb3B0aW9ucy5uYW1lXSA9IEN0b3I7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBvcHRpb25zXG59XG5cbmZ1bmN0aW9uIHJlc29sdmVNb2RpZmllZE9wdGlvbnMgKEN0b3IpIHtcbiAgdmFyIG1vZGlmaWVkO1xuICB2YXIgbGF0ZXN0ID0gQ3Rvci5vcHRpb25zO1xuICB2YXIgc2VhbGVkID0gQ3Rvci5zZWFsZWRPcHRpb25zO1xuICBmb3IgKHZhciBrZXkgaW4gbGF0ZXN0KSB7XG4gICAgaWYgKGxhdGVzdFtrZXldICE9PSBzZWFsZWRba2V5XSkge1xuICAgICAgaWYgKCFtb2RpZmllZCkgeyBtb2RpZmllZCA9IHt9OyB9XG4gICAgICBtb2RpZmllZFtrZXldID0gbGF0ZXN0W2tleV07XG4gICAgfVxuICB9XG4gIHJldHVybiBtb2RpZmllZFxufVxuXG5mdW5jdGlvbiBWdWUgKG9wdGlvbnMpIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiZcbiAgICAhKHRoaXMgaW5zdGFuY2VvZiBWdWUpXG4gICkge1xuICAgIHdhcm4oJ1Z1ZSBpcyBhIGNvbnN0cnVjdG9yIGFuZCBzaG91bGQgYmUgY2FsbGVkIHdpdGggdGhlIGBuZXdgIGtleXdvcmQnKTtcbiAgfVxuICB0aGlzLl9pbml0KG9wdGlvbnMpO1xufVxuXG5pbml0TWl4aW4oVnVlKTtcbnN0YXRlTWl4aW4oVnVlKTtcbmV2ZW50c01peGluKFZ1ZSk7XG5saWZlY3ljbGVNaXhpbihWdWUpO1xucmVuZGVyTWl4aW4oVnVlKTtcblxuLyogICovXG5cbmZ1bmN0aW9uIGluaXRVc2UgKFZ1ZSkge1xuICBWdWUudXNlID0gZnVuY3Rpb24gKHBsdWdpbikge1xuICAgIHZhciBpbnN0YWxsZWRQbHVnaW5zID0gKHRoaXMuX2luc3RhbGxlZFBsdWdpbnMgfHwgKHRoaXMuX2luc3RhbGxlZFBsdWdpbnMgPSBbXSkpO1xuICAgIGlmIChpbnN0YWxsZWRQbHVnaW5zLmluZGV4T2YocGx1Z2luKSA+IC0xKSB7XG4gICAgICByZXR1cm4gdGhpc1xuICAgIH1cblxuICAgIC8vIGFkZGl0aW9uYWwgcGFyYW1ldGVyc1xuICAgIHZhciBhcmdzID0gdG9BcnJheShhcmd1bWVudHMsIDEpO1xuICAgIGFyZ3MudW5zaGlmdCh0aGlzKTtcbiAgICBpZiAodHlwZW9mIHBsdWdpbi5pbnN0YWxsID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBwbHVnaW4uaW5zdGFsbC5hcHBseShwbHVnaW4sIGFyZ3MpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIHBsdWdpbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcGx1Z2luLmFwcGx5KG51bGwsIGFyZ3MpO1xuICAgIH1cbiAgICBpbnN0YWxsZWRQbHVnaW5zLnB1c2gocGx1Z2luKTtcbiAgICByZXR1cm4gdGhpc1xuICB9O1xufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gaW5pdE1peGluJDEgKFZ1ZSkge1xuICBWdWUubWl4aW4gPSBmdW5jdGlvbiAobWl4aW4pIHtcbiAgICB0aGlzLm9wdGlvbnMgPSBtZXJnZU9wdGlvbnModGhpcy5vcHRpb25zLCBtaXhpbik7XG4gICAgcmV0dXJuIHRoaXNcbiAgfTtcbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGluaXRFeHRlbmQgKFZ1ZSkge1xuICAvKipcbiAgICogRWFjaCBpbnN0YW5jZSBjb25zdHJ1Y3RvciwgaW5jbHVkaW5nIFZ1ZSwgaGFzIGEgdW5pcXVlXG4gICAqIGNpZC4gVGhpcyBlbmFibGVzIHVzIHRvIGNyZWF0ZSB3cmFwcGVkIFwiY2hpbGRcbiAgICogY29uc3RydWN0b3JzXCIgZm9yIHByb3RvdHlwYWwgaW5oZXJpdGFuY2UgYW5kIGNhY2hlIHRoZW0uXG4gICAqL1xuICBWdWUuY2lkID0gMDtcbiAgdmFyIGNpZCA9IDE7XG5cbiAgLyoqXG4gICAqIENsYXNzIGluaGVyaXRhbmNlXG4gICAqL1xuICBWdWUuZXh0ZW5kID0gZnVuY3Rpb24gKGV4dGVuZE9wdGlvbnMpIHtcbiAgICBleHRlbmRPcHRpb25zID0gZXh0ZW5kT3B0aW9ucyB8fCB7fTtcbiAgICB2YXIgU3VwZXIgPSB0aGlzO1xuICAgIHZhciBTdXBlcklkID0gU3VwZXIuY2lkO1xuICAgIHZhciBjYWNoZWRDdG9ycyA9IGV4dGVuZE9wdGlvbnMuX0N0b3IgfHwgKGV4dGVuZE9wdGlvbnMuX0N0b3IgPSB7fSk7XG4gICAgaWYgKGNhY2hlZEN0b3JzW1N1cGVySWRdKSB7XG4gICAgICByZXR1cm4gY2FjaGVkQ3RvcnNbU3VwZXJJZF1cbiAgICB9XG5cbiAgICB2YXIgbmFtZSA9IGV4dGVuZE9wdGlvbnMubmFtZSB8fCBTdXBlci5vcHRpb25zLm5hbWU7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgbmFtZSkge1xuICAgICAgdmFsaWRhdGVDb21wb25lbnROYW1lKG5hbWUpO1xuICAgIH1cblxuICAgIHZhciBTdWIgPSBmdW5jdGlvbiBWdWVDb21wb25lbnQgKG9wdGlvbnMpIHtcbiAgICAgIHRoaXMuX2luaXQob3B0aW9ucyk7XG4gICAgfTtcbiAgICBTdWIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShTdXBlci5wcm90b3R5cGUpO1xuICAgIFN1Yi5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBTdWI7XG4gICAgU3ViLmNpZCA9IGNpZCsrO1xuICAgIFN1Yi5vcHRpb25zID0gbWVyZ2VPcHRpb25zKFxuICAgICAgU3VwZXIub3B0aW9ucyxcbiAgICAgIGV4dGVuZE9wdGlvbnNcbiAgICApO1xuICAgIFN1Ylsnc3VwZXInXSA9IFN1cGVyO1xuXG4gICAgLy8gRm9yIHByb3BzIGFuZCBjb21wdXRlZCBwcm9wZXJ0aWVzLCB3ZSBkZWZpbmUgdGhlIHByb3h5IGdldHRlcnMgb25cbiAgICAvLyB0aGUgVnVlIGluc3RhbmNlcyBhdCBleHRlbnNpb24gdGltZSwgb24gdGhlIGV4dGVuZGVkIHByb3RvdHlwZS4gVGhpc1xuICAgIC8vIGF2b2lkcyBPYmplY3QuZGVmaW5lUHJvcGVydHkgY2FsbHMgZm9yIGVhY2ggaW5zdGFuY2UgY3JlYXRlZC5cbiAgICBpZiAoU3ViLm9wdGlvbnMucHJvcHMpIHtcbiAgICAgIGluaXRQcm9wcyQxKFN1Yik7XG4gICAgfVxuICAgIGlmIChTdWIub3B0aW9ucy5jb21wdXRlZCkge1xuICAgICAgaW5pdENvbXB1dGVkJDEoU3ViKTtcbiAgICB9XG5cbiAgICAvLyBhbGxvdyBmdXJ0aGVyIGV4dGVuc2lvbi9taXhpbi9wbHVnaW4gdXNhZ2VcbiAgICBTdWIuZXh0ZW5kID0gU3VwZXIuZXh0ZW5kO1xuICAgIFN1Yi5taXhpbiA9IFN1cGVyLm1peGluO1xuICAgIFN1Yi51c2UgPSBTdXBlci51c2U7XG5cbiAgICAvLyBjcmVhdGUgYXNzZXQgcmVnaXN0ZXJzLCBzbyBleHRlbmRlZCBjbGFzc2VzXG4gICAgLy8gY2FuIGhhdmUgdGhlaXIgcHJpdmF0ZSBhc3NldHMgdG9vLlxuICAgIEFTU0VUX1RZUEVTLmZvckVhY2goZnVuY3Rpb24gKHR5cGUpIHtcbiAgICAgIFN1Ylt0eXBlXSA9IFN1cGVyW3R5cGVdO1xuICAgIH0pO1xuICAgIC8vIGVuYWJsZSByZWN1cnNpdmUgc2VsZi1sb29rdXBcbiAgICBpZiAobmFtZSkge1xuICAgICAgU3ViLm9wdGlvbnMuY29tcG9uZW50c1tuYW1lXSA9IFN1YjtcbiAgICB9XG5cbiAgICAvLyBrZWVwIGEgcmVmZXJlbmNlIHRvIHRoZSBzdXBlciBvcHRpb25zIGF0IGV4dGVuc2lvbiB0aW1lLlxuICAgIC8vIGxhdGVyIGF0IGluc3RhbnRpYXRpb24gd2UgY2FuIGNoZWNrIGlmIFN1cGVyJ3Mgb3B0aW9ucyBoYXZlXG4gICAgLy8gYmVlbiB1cGRhdGVkLlxuICAgIFN1Yi5zdXBlck9wdGlvbnMgPSBTdXBlci5vcHRpb25zO1xuICAgIFN1Yi5leHRlbmRPcHRpb25zID0gZXh0ZW5kT3B0aW9ucztcbiAgICBTdWIuc2VhbGVkT3B0aW9ucyA9IGV4dGVuZCh7fSwgU3ViLm9wdGlvbnMpO1xuXG4gICAgLy8gY2FjaGUgY29uc3RydWN0b3JcbiAgICBjYWNoZWRDdG9yc1tTdXBlcklkXSA9IFN1YjtcbiAgICByZXR1cm4gU3ViXG4gIH07XG59XG5cbmZ1bmN0aW9uIGluaXRQcm9wcyQxIChDb21wKSB7XG4gIHZhciBwcm9wcyA9IENvbXAub3B0aW9ucy5wcm9wcztcbiAgZm9yICh2YXIga2V5IGluIHByb3BzKSB7XG4gICAgcHJveHkoQ29tcC5wcm90b3R5cGUsIFwiX3Byb3BzXCIsIGtleSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaW5pdENvbXB1dGVkJDEgKENvbXApIHtcbiAgdmFyIGNvbXB1dGVkID0gQ29tcC5vcHRpb25zLmNvbXB1dGVkO1xuICBmb3IgKHZhciBrZXkgaW4gY29tcHV0ZWQpIHtcbiAgICBkZWZpbmVDb21wdXRlZChDb21wLnByb3RvdHlwZSwga2V5LCBjb21wdXRlZFtrZXldKTtcbiAgfVxufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gaW5pdEFzc2V0UmVnaXN0ZXJzIChWdWUpIHtcbiAgLyoqXG4gICAqIENyZWF0ZSBhc3NldCByZWdpc3RyYXRpb24gbWV0aG9kcy5cbiAgICovXG4gIEFTU0VUX1RZUEVTLmZvckVhY2goZnVuY3Rpb24gKHR5cGUpIHtcbiAgICBWdWVbdHlwZV0gPSBmdW5jdGlvbiAoXG4gICAgICBpZCxcbiAgICAgIGRlZmluaXRpb25cbiAgICApIHtcbiAgICAgIGlmICghZGVmaW5pdGlvbikge1xuICAgICAgICByZXR1cm4gdGhpcy5vcHRpb25zW3R5cGUgKyAncyddW2lkXVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHR5cGUgPT09ICdjb21wb25lbnQnKSB7XG4gICAgICAgICAgdmFsaWRhdGVDb21wb25lbnROYW1lKGlkKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZSA9PT0gJ2NvbXBvbmVudCcgJiYgaXNQbGFpbk9iamVjdChkZWZpbml0aW9uKSkge1xuICAgICAgICAgIGRlZmluaXRpb24ubmFtZSA9IGRlZmluaXRpb24ubmFtZSB8fCBpZDtcbiAgICAgICAgICBkZWZpbml0aW9uID0gdGhpcy5vcHRpb25zLl9iYXNlLmV4dGVuZChkZWZpbml0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZSA9PT0gJ2RpcmVjdGl2ZScgJiYgdHlwZW9mIGRlZmluaXRpb24gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICBkZWZpbml0aW9uID0geyBiaW5kOiBkZWZpbml0aW9uLCB1cGRhdGU6IGRlZmluaXRpb24gfTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm9wdGlvbnNbdHlwZSArICdzJ11baWRdID0gZGVmaW5pdGlvbjtcbiAgICAgICAgcmV0dXJuIGRlZmluaXRpb25cbiAgICAgIH1cbiAgICB9O1xuICB9KTtcbn1cblxuLyogICovXG5cblxuXG5cblxuZnVuY3Rpb24gZ2V0Q29tcG9uZW50TmFtZSAob3B0cykge1xuICByZXR1cm4gb3B0cyAmJiAob3B0cy5DdG9yLm9wdGlvbnMubmFtZSB8fCBvcHRzLnRhZylcbn1cblxuZnVuY3Rpb24gbWF0Y2hlcyAocGF0dGVybiwgbmFtZSkge1xuICBpZiAoQXJyYXkuaXNBcnJheShwYXR0ZXJuKSkge1xuICAgIHJldHVybiBwYXR0ZXJuLmluZGV4T2YobmFtZSkgPiAtMVxuICB9IGVsc2UgaWYgKHR5cGVvZiBwYXR0ZXJuID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBwYXR0ZXJuLnNwbGl0KCcsJykuaW5kZXhPZihuYW1lKSA+IC0xXG4gIH0gZWxzZSBpZiAoaXNSZWdFeHAocGF0dGVybikpIHtcbiAgICByZXR1cm4gcGF0dGVybi50ZXN0KG5hbWUpXG4gIH1cbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgcmV0dXJuIGZhbHNlXG59XG5cbmZ1bmN0aW9uIHBydW5lQ2FjaGUgKGtlZXBBbGl2ZUluc3RhbmNlLCBmaWx0ZXIpIHtcbiAgdmFyIGNhY2hlID0ga2VlcEFsaXZlSW5zdGFuY2UuY2FjaGU7XG4gIHZhciBrZXlzID0ga2VlcEFsaXZlSW5zdGFuY2Uua2V5cztcbiAgdmFyIF92bm9kZSA9IGtlZXBBbGl2ZUluc3RhbmNlLl92bm9kZTtcbiAgZm9yICh2YXIga2V5IGluIGNhY2hlKSB7XG4gICAgdmFyIGVudHJ5ID0gY2FjaGVba2V5XTtcbiAgICBpZiAoZW50cnkpIHtcbiAgICAgIHZhciBuYW1lID0gZW50cnkubmFtZTtcbiAgICAgIGlmIChuYW1lICYmICFmaWx0ZXIobmFtZSkpIHtcbiAgICAgICAgcHJ1bmVDYWNoZUVudHJ5KGNhY2hlLCBrZXksIGtleXMsIF92bm9kZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHBydW5lQ2FjaGVFbnRyeSAoXG4gIGNhY2hlLFxuICBrZXksXG4gIGtleXMsXG4gIGN1cnJlbnRcbikge1xuICB2YXIgZW50cnkgPSBjYWNoZVtrZXldO1xuICBpZiAoZW50cnkgJiYgKCFjdXJyZW50IHx8IGVudHJ5LnRhZyAhPT0gY3VycmVudC50YWcpKSB7XG4gICAgZW50cnkuY29tcG9uZW50SW5zdGFuY2UuJGRlc3Ryb3koKTtcbiAgfVxuICBjYWNoZVtrZXldID0gbnVsbDtcbiAgcmVtb3ZlKGtleXMsIGtleSk7XG59XG5cbnZhciBwYXR0ZXJuVHlwZXMgPSBbU3RyaW5nLCBSZWdFeHAsIEFycmF5XTtcblxudmFyIEtlZXBBbGl2ZSA9IHtcbiAgbmFtZTogJ2tlZXAtYWxpdmUnLFxuICBhYnN0cmFjdDogdHJ1ZSxcblxuICBwcm9wczoge1xuICAgIGluY2x1ZGU6IHBhdHRlcm5UeXBlcyxcbiAgICBleGNsdWRlOiBwYXR0ZXJuVHlwZXMsXG4gICAgbWF4OiBbU3RyaW5nLCBOdW1iZXJdXG4gIH0sXG5cbiAgbWV0aG9kczoge1xuICAgIGNhY2hlVk5vZGU6IGZ1bmN0aW9uIGNhY2hlVk5vZGUoKSB7XG4gICAgICB2YXIgcmVmID0gdGhpcztcbiAgICAgIHZhciBjYWNoZSA9IHJlZi5jYWNoZTtcbiAgICAgIHZhciBrZXlzID0gcmVmLmtleXM7XG4gICAgICB2YXIgdm5vZGVUb0NhY2hlID0gcmVmLnZub2RlVG9DYWNoZTtcbiAgICAgIHZhciBrZXlUb0NhY2hlID0gcmVmLmtleVRvQ2FjaGU7XG4gICAgICBpZiAodm5vZGVUb0NhY2hlKSB7XG4gICAgICAgIHZhciB0YWcgPSB2bm9kZVRvQ2FjaGUudGFnO1xuICAgICAgICB2YXIgY29tcG9uZW50SW5zdGFuY2UgPSB2bm9kZVRvQ2FjaGUuY29tcG9uZW50SW5zdGFuY2U7XG4gICAgICAgIHZhciBjb21wb25lbnRPcHRpb25zID0gdm5vZGVUb0NhY2hlLmNvbXBvbmVudE9wdGlvbnM7XG4gICAgICAgIGNhY2hlW2tleVRvQ2FjaGVdID0ge1xuICAgICAgICAgIG5hbWU6IGdldENvbXBvbmVudE5hbWUoY29tcG9uZW50T3B0aW9ucyksXG4gICAgICAgICAgdGFnOiB0YWcsXG4gICAgICAgICAgY29tcG9uZW50SW5zdGFuY2U6IGNvbXBvbmVudEluc3RhbmNlLFxuICAgICAgICB9O1xuICAgICAgICBrZXlzLnB1c2goa2V5VG9DYWNoZSk7XG4gICAgICAgIC8vIHBydW5lIG9sZGVzdCBlbnRyeVxuICAgICAgICBpZiAodGhpcy5tYXggJiYga2V5cy5sZW5ndGggPiBwYXJzZUludCh0aGlzLm1heCkpIHtcbiAgICAgICAgICBwcnVuZUNhY2hlRW50cnkoY2FjaGUsIGtleXNbMF0sIGtleXMsIHRoaXMuX3Zub2RlKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnZub2RlVG9DYWNoZSA9IG51bGw7XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIGNyZWF0ZWQ6IGZ1bmN0aW9uIGNyZWF0ZWQgKCkge1xuICAgIHRoaXMuY2FjaGUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIHRoaXMua2V5cyA9IFtdO1xuICB9LFxuXG4gIGRlc3Ryb3llZDogZnVuY3Rpb24gZGVzdHJveWVkICgpIHtcbiAgICBmb3IgKHZhciBrZXkgaW4gdGhpcy5jYWNoZSkge1xuICAgICAgcHJ1bmVDYWNoZUVudHJ5KHRoaXMuY2FjaGUsIGtleSwgdGhpcy5rZXlzKTtcbiAgICB9XG4gIH0sXG5cbiAgbW91bnRlZDogZnVuY3Rpb24gbW91bnRlZCAoKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICB0aGlzLmNhY2hlVk5vZGUoKTtcbiAgICB0aGlzLiR3YXRjaCgnaW5jbHVkZScsIGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgIHBydW5lQ2FjaGUodGhpcyQxLCBmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gbWF0Y2hlcyh2YWwsIG5hbWUpOyB9KTtcbiAgICB9KTtcbiAgICB0aGlzLiR3YXRjaCgnZXhjbHVkZScsIGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgIHBydW5lQ2FjaGUodGhpcyQxLCBmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gIW1hdGNoZXModmFsLCBuYW1lKTsgfSk7XG4gICAgfSk7XG4gIH0sXG5cbiAgdXBkYXRlZDogZnVuY3Rpb24gdXBkYXRlZCAoKSB7XG4gICAgdGhpcy5jYWNoZVZOb2RlKCk7XG4gIH0sXG5cbiAgcmVuZGVyOiBmdW5jdGlvbiByZW5kZXIgKCkge1xuICAgIHZhciBzbG90ID0gdGhpcy4kc2xvdHMuZGVmYXVsdDtcbiAgICB2YXIgdm5vZGUgPSBnZXRGaXJzdENvbXBvbmVudENoaWxkKHNsb3QpO1xuICAgIHZhciBjb21wb25lbnRPcHRpb25zID0gdm5vZGUgJiYgdm5vZGUuY29tcG9uZW50T3B0aW9ucztcbiAgICBpZiAoY29tcG9uZW50T3B0aW9ucykge1xuICAgICAgLy8gY2hlY2sgcGF0dGVyblxuICAgICAgdmFyIG5hbWUgPSBnZXRDb21wb25lbnROYW1lKGNvbXBvbmVudE9wdGlvbnMpO1xuICAgICAgdmFyIHJlZiA9IHRoaXM7XG4gICAgICB2YXIgaW5jbHVkZSA9IHJlZi5pbmNsdWRlO1xuICAgICAgdmFyIGV4Y2x1ZGUgPSByZWYuZXhjbHVkZTtcbiAgICAgIGlmIChcbiAgICAgICAgLy8gbm90IGluY2x1ZGVkXG4gICAgICAgIChpbmNsdWRlICYmICghbmFtZSB8fCAhbWF0Y2hlcyhpbmNsdWRlLCBuYW1lKSkpIHx8XG4gICAgICAgIC8vIGV4Y2x1ZGVkXG4gICAgICAgIChleGNsdWRlICYmIG5hbWUgJiYgbWF0Y2hlcyhleGNsdWRlLCBuYW1lKSlcbiAgICAgICkge1xuICAgICAgICByZXR1cm4gdm5vZGVcbiAgICAgIH1cblxuICAgICAgdmFyIHJlZiQxID0gdGhpcztcbiAgICAgIHZhciBjYWNoZSA9IHJlZiQxLmNhY2hlO1xuICAgICAgdmFyIGtleXMgPSByZWYkMS5rZXlzO1xuICAgICAgdmFyIGtleSA9IHZub2RlLmtleSA9PSBudWxsXG4gICAgICAgIC8vIHNhbWUgY29uc3RydWN0b3IgbWF5IGdldCByZWdpc3RlcmVkIGFzIGRpZmZlcmVudCBsb2NhbCBjb21wb25lbnRzXG4gICAgICAgIC8vIHNvIGNpZCBhbG9uZSBpcyBub3QgZW5vdWdoICgjMzI2OSlcbiAgICAgICAgPyBjb21wb25lbnRPcHRpb25zLkN0b3IuY2lkICsgKGNvbXBvbmVudE9wdGlvbnMudGFnID8gKFwiOjpcIiArIChjb21wb25lbnRPcHRpb25zLnRhZykpIDogJycpXG4gICAgICAgIDogdm5vZGUua2V5O1xuICAgICAgaWYgKGNhY2hlW2tleV0pIHtcbiAgICAgICAgdm5vZGUuY29tcG9uZW50SW5zdGFuY2UgPSBjYWNoZVtrZXldLmNvbXBvbmVudEluc3RhbmNlO1xuICAgICAgICAvLyBtYWtlIGN1cnJlbnQga2V5IGZyZXNoZXN0XG4gICAgICAgIHJlbW92ZShrZXlzLCBrZXkpO1xuICAgICAgICBrZXlzLnB1c2goa2V5KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGRlbGF5IHNldHRpbmcgdGhlIGNhY2hlIHVudGlsIHVwZGF0ZVxuICAgICAgICB0aGlzLnZub2RlVG9DYWNoZSA9IHZub2RlO1xuICAgICAgICB0aGlzLmtleVRvQ2FjaGUgPSBrZXk7XG4gICAgICB9XG5cbiAgICAgIHZub2RlLmRhdGEua2VlcEFsaXZlID0gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIHZub2RlIHx8IChzbG90ICYmIHNsb3RbMF0pXG4gIH1cbn07XG5cbnZhciBidWlsdEluQ29tcG9uZW50cyA9IHtcbiAgS2VlcEFsaXZlOiBLZWVwQWxpdmVcbn07XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBpbml0R2xvYmFsQVBJIChWdWUpIHtcbiAgLy8gY29uZmlnXG4gIHZhciBjb25maWdEZWYgPSB7fTtcbiAgY29uZmlnRGVmLmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvbmZpZzsgfTtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBjb25maWdEZWYuc2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgd2FybihcbiAgICAgICAgJ0RvIG5vdCByZXBsYWNlIHRoZSBWdWUuY29uZmlnIG9iamVjdCwgc2V0IGluZGl2aWR1YWwgZmllbGRzIGluc3RlYWQuJ1xuICAgICAgKTtcbiAgICB9O1xuICB9XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShWdWUsICdjb25maWcnLCBjb25maWdEZWYpO1xuXG4gIC8vIGV4cG9zZWQgdXRpbCBtZXRob2RzLlxuICAvLyBOT1RFOiB0aGVzZSBhcmUgbm90IGNvbnNpZGVyZWQgcGFydCBvZiB0aGUgcHVibGljIEFQSSAtIGF2b2lkIHJlbHlpbmcgb25cbiAgLy8gdGhlbSB1bmxlc3MgeW91IGFyZSBhd2FyZSBvZiB0aGUgcmlzay5cbiAgVnVlLnV0aWwgPSB7XG4gICAgd2Fybjogd2FybixcbiAgICBleHRlbmQ6IGV4dGVuZCxcbiAgICBtZXJnZU9wdGlvbnM6IG1lcmdlT3B0aW9ucyxcbiAgICBkZWZpbmVSZWFjdGl2ZTogZGVmaW5lUmVhY3RpdmUkJDFcbiAgfTtcblxuICBWdWUuc2V0ID0gc2V0O1xuICBWdWUuZGVsZXRlID0gZGVsO1xuICBWdWUubmV4dFRpY2sgPSBuZXh0VGljaztcblxuICAvLyAyLjYgZXhwbGljaXQgb2JzZXJ2YWJsZSBBUElcbiAgVnVlLm9ic2VydmFibGUgPSBmdW5jdGlvbiAob2JqKSB7XG4gICAgb2JzZXJ2ZShvYmopO1xuICAgIHJldHVybiBvYmpcbiAgfTtcblxuICBWdWUub3B0aW9ucyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIEFTU0VUX1RZUEVTLmZvckVhY2goZnVuY3Rpb24gKHR5cGUpIHtcbiAgICBWdWUub3B0aW9uc1t0eXBlICsgJ3MnXSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIH0pO1xuXG4gIC8vIHRoaXMgaXMgdXNlZCB0byBpZGVudGlmeSB0aGUgXCJiYXNlXCIgY29uc3RydWN0b3IgdG8gZXh0ZW5kIGFsbCBwbGFpbi1vYmplY3RcbiAgLy8gY29tcG9uZW50cyB3aXRoIGluIFdlZXgncyBtdWx0aS1pbnN0YW5jZSBzY2VuYXJpb3MuXG4gIFZ1ZS5vcHRpb25zLl9iYXNlID0gVnVlO1xuXG4gIGV4dGVuZChWdWUub3B0aW9ucy5jb21wb25lbnRzLCBidWlsdEluQ29tcG9uZW50cyk7XG5cbiAgaW5pdFVzZShWdWUpO1xuICBpbml0TWl4aW4kMShWdWUpO1xuICBpbml0RXh0ZW5kKFZ1ZSk7XG4gIGluaXRBc3NldFJlZ2lzdGVycyhWdWUpO1xufVxuXG5pbml0R2xvYmFsQVBJKFZ1ZSk7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShWdWUucHJvdG90eXBlLCAnJGlzU2VydmVyJywge1xuICBnZXQ6IGlzU2VydmVyUmVuZGVyaW5nXG59KTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFZ1ZS5wcm90b3R5cGUsICckc3NyQ29udGV4dCcsIHtcbiAgZ2V0OiBmdW5jdGlvbiBnZXQgKCkge1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgcmV0dXJuIHRoaXMuJHZub2RlICYmIHRoaXMuJHZub2RlLnNzckNvbnRleHRcbiAgfVxufSk7XG5cbi8vIGV4cG9zZSBGdW5jdGlvbmFsUmVuZGVyQ29udGV4dCBmb3Igc3NyIHJ1bnRpbWUgaGVscGVyIGluc3RhbGxhdGlvblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFZ1ZSwgJ0Z1bmN0aW9uYWxSZW5kZXJDb250ZXh0Jywge1xuICB2YWx1ZTogRnVuY3Rpb25hbFJlbmRlckNvbnRleHRcbn0pO1xuXG5WdWUudmVyc2lvbiA9ICcyLjYuMTQnO1xuXG4vKiAgKi9cblxuLy8gdGhlc2UgYXJlIHJlc2VydmVkIGZvciB3ZWIgYmVjYXVzZSB0aGV5IGFyZSBkaXJlY3RseSBjb21waWxlZCBhd2F5XG4vLyBkdXJpbmcgdGVtcGxhdGUgY29tcGlsYXRpb25cbnZhciBpc1Jlc2VydmVkQXR0ciA9IG1ha2VNYXAoJ3N0eWxlLGNsYXNzJyk7XG5cbi8vIGF0dHJpYnV0ZXMgdGhhdCBzaG91bGQgYmUgdXNpbmcgcHJvcHMgZm9yIGJpbmRpbmdcbnZhciBhY2NlcHRWYWx1ZSA9IG1ha2VNYXAoJ2lucHV0LHRleHRhcmVhLG9wdGlvbixzZWxlY3QscHJvZ3Jlc3MnKTtcbnZhciBtdXN0VXNlUHJvcCA9IGZ1bmN0aW9uICh0YWcsIHR5cGUsIGF0dHIpIHtcbiAgcmV0dXJuIChcbiAgICAoYXR0ciA9PT0gJ3ZhbHVlJyAmJiBhY2NlcHRWYWx1ZSh0YWcpKSAmJiB0eXBlICE9PSAnYnV0dG9uJyB8fFxuICAgIChhdHRyID09PSAnc2VsZWN0ZWQnICYmIHRhZyA9PT0gJ29wdGlvbicpIHx8XG4gICAgKGF0dHIgPT09ICdjaGVja2VkJyAmJiB0YWcgPT09ICdpbnB1dCcpIHx8XG4gICAgKGF0dHIgPT09ICdtdXRlZCcgJiYgdGFnID09PSAndmlkZW8nKVxuICApXG59O1xuXG52YXIgaXNFbnVtZXJhdGVkQXR0ciA9IG1ha2VNYXAoJ2NvbnRlbnRlZGl0YWJsZSxkcmFnZ2FibGUsc3BlbGxjaGVjaycpO1xuXG52YXIgaXNWYWxpZENvbnRlbnRFZGl0YWJsZVZhbHVlID0gbWFrZU1hcCgnZXZlbnRzLGNhcmV0LHR5cGluZyxwbGFpbnRleHQtb25seScpO1xuXG52YXIgY29udmVydEVudW1lcmF0ZWRWYWx1ZSA9IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gIHJldHVybiBpc0ZhbHN5QXR0clZhbHVlKHZhbHVlKSB8fCB2YWx1ZSA9PT0gJ2ZhbHNlJ1xuICAgID8gJ2ZhbHNlJ1xuICAgIC8vIGFsbG93IGFyYml0cmFyeSBzdHJpbmcgdmFsdWUgZm9yIGNvbnRlbnRlZGl0YWJsZVxuICAgIDoga2V5ID09PSAnY29udGVudGVkaXRhYmxlJyAmJiBpc1ZhbGlkQ29udGVudEVkaXRhYmxlVmFsdWUodmFsdWUpXG4gICAgICA/IHZhbHVlXG4gICAgICA6ICd0cnVlJ1xufTtcblxudmFyIGlzQm9vbGVhbkF0dHIgPSBtYWtlTWFwKFxuICAnYWxsb3dmdWxsc2NyZWVuLGFzeW5jLGF1dG9mb2N1cyxhdXRvcGxheSxjaGVja2VkLGNvbXBhY3QsY29udHJvbHMsZGVjbGFyZSwnICtcbiAgJ2RlZmF1bHQsZGVmYXVsdGNoZWNrZWQsZGVmYXVsdG11dGVkLGRlZmF1bHRzZWxlY3RlZCxkZWZlcixkaXNhYmxlZCwnICtcbiAgJ2VuYWJsZWQsZm9ybW5vdmFsaWRhdGUsaGlkZGVuLGluZGV0ZXJtaW5hdGUsaW5lcnQsaXNtYXAsaXRlbXNjb3BlLGxvb3AsbXVsdGlwbGUsJyArXG4gICdtdXRlZCxub2hyZWYsbm9yZXNpemUsbm9zaGFkZSxub3ZhbGlkYXRlLG5vd3JhcCxvcGVuLHBhdXNlb25leGl0LHJlYWRvbmx5LCcgK1xuICAncmVxdWlyZWQscmV2ZXJzZWQsc2NvcGVkLHNlYW1sZXNzLHNlbGVjdGVkLHNvcnRhYmxlLCcgK1xuICAndHJ1ZXNwZWVkLHR5cGVtdXN0bWF0Y2gsdmlzaWJsZSdcbik7XG5cbnZhciB4bGlua05TID0gJ2h0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsnO1xuXG52YXIgaXNYbGluayA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gIHJldHVybiBuYW1lLmNoYXJBdCg1KSA9PT0gJzonICYmIG5hbWUuc2xpY2UoMCwgNSkgPT09ICd4bGluaydcbn07XG5cbnZhciBnZXRYbGlua1Byb3AgPSBmdW5jdGlvbiAobmFtZSkge1xuICByZXR1cm4gaXNYbGluayhuYW1lKSA/IG5hbWUuc2xpY2UoNiwgbmFtZS5sZW5ndGgpIDogJydcbn07XG5cbnZhciBpc0ZhbHN5QXR0clZhbHVlID0gZnVuY3Rpb24gKHZhbCkge1xuICByZXR1cm4gdmFsID09IG51bGwgfHwgdmFsID09PSBmYWxzZVxufTtcblxuLyogICovXG5cbmZ1bmN0aW9uIGdlbkNsYXNzRm9yVm5vZGUgKHZub2RlKSB7XG4gIHZhciBkYXRhID0gdm5vZGUuZGF0YTtcbiAgdmFyIHBhcmVudE5vZGUgPSB2bm9kZTtcbiAgdmFyIGNoaWxkTm9kZSA9IHZub2RlO1xuICB3aGlsZSAoaXNEZWYoY2hpbGROb2RlLmNvbXBvbmVudEluc3RhbmNlKSkge1xuICAgIGNoaWxkTm9kZSA9IGNoaWxkTm9kZS5jb21wb25lbnRJbnN0YW5jZS5fdm5vZGU7XG4gICAgaWYgKGNoaWxkTm9kZSAmJiBjaGlsZE5vZGUuZGF0YSkge1xuICAgICAgZGF0YSA9IG1lcmdlQ2xhc3NEYXRhKGNoaWxkTm9kZS5kYXRhLCBkYXRhKTtcbiAgICB9XG4gIH1cbiAgd2hpbGUgKGlzRGVmKHBhcmVudE5vZGUgPSBwYXJlbnROb2RlLnBhcmVudCkpIHtcbiAgICBpZiAocGFyZW50Tm9kZSAmJiBwYXJlbnROb2RlLmRhdGEpIHtcbiAgICAgIGRhdGEgPSBtZXJnZUNsYXNzRGF0YShkYXRhLCBwYXJlbnROb2RlLmRhdGEpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVuZGVyQ2xhc3MoZGF0YS5zdGF0aWNDbGFzcywgZGF0YS5jbGFzcylcbn1cblxuZnVuY3Rpb24gbWVyZ2VDbGFzc0RhdGEgKGNoaWxkLCBwYXJlbnQpIHtcbiAgcmV0dXJuIHtcbiAgICBzdGF0aWNDbGFzczogY29uY2F0KGNoaWxkLnN0YXRpY0NsYXNzLCBwYXJlbnQuc3RhdGljQ2xhc3MpLFxuICAgIGNsYXNzOiBpc0RlZihjaGlsZC5jbGFzcylcbiAgICAgID8gW2NoaWxkLmNsYXNzLCBwYXJlbnQuY2xhc3NdXG4gICAgICA6IHBhcmVudC5jbGFzc1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlbmRlckNsYXNzIChcbiAgc3RhdGljQ2xhc3MsXG4gIGR5bmFtaWNDbGFzc1xuKSB7XG4gIGlmIChpc0RlZihzdGF0aWNDbGFzcykgfHwgaXNEZWYoZHluYW1pY0NsYXNzKSkge1xuICAgIHJldHVybiBjb25jYXQoc3RhdGljQ2xhc3MsIHN0cmluZ2lmeUNsYXNzKGR5bmFtaWNDbGFzcykpXG4gIH1cbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgcmV0dXJuICcnXG59XG5cbmZ1bmN0aW9uIGNvbmNhdCAoYSwgYikge1xuICByZXR1cm4gYSA/IGIgPyAoYSArICcgJyArIGIpIDogYSA6IChiIHx8ICcnKVxufVxuXG5mdW5jdGlvbiBzdHJpbmdpZnlDbGFzcyAodmFsdWUpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgcmV0dXJuIHN0cmluZ2lmeUFycmF5KHZhbHVlKVxuICB9XG4gIGlmIChpc09iamVjdCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gc3RyaW5naWZ5T2JqZWN0KHZhbHVlKVxuICB9XG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHZhbHVlXG4gIH1cbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgcmV0dXJuICcnXG59XG5cbmZ1bmN0aW9uIHN0cmluZ2lmeUFycmF5ICh2YWx1ZSkge1xuICB2YXIgcmVzID0gJyc7XG4gIHZhciBzdHJpbmdpZmllZDtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSB2YWx1ZS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBpZiAoaXNEZWYoc3RyaW5naWZpZWQgPSBzdHJpbmdpZnlDbGFzcyh2YWx1ZVtpXSkpICYmIHN0cmluZ2lmaWVkICE9PSAnJykge1xuICAgICAgaWYgKHJlcykgeyByZXMgKz0gJyAnOyB9XG4gICAgICByZXMgKz0gc3RyaW5naWZpZWQ7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuZnVuY3Rpb24gc3RyaW5naWZ5T2JqZWN0ICh2YWx1ZSkge1xuICB2YXIgcmVzID0gJyc7XG4gIGZvciAodmFyIGtleSBpbiB2YWx1ZSkge1xuICAgIGlmICh2YWx1ZVtrZXldKSB7XG4gICAgICBpZiAocmVzKSB7IHJlcyArPSAnICc7IH1cbiAgICAgIHJlcyArPSBrZXk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuLyogICovXG5cbnZhciBuYW1lc3BhY2VNYXAgPSB7XG4gIHN2ZzogJ2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJyxcbiAgbWF0aDogJ2h0dHA6Ly93d3cudzMub3JnLzE5OTgvTWF0aC9NYXRoTUwnXG59O1xuXG52YXIgaXNIVE1MVGFnID0gbWFrZU1hcChcbiAgJ2h0bWwsYm9keSxiYXNlLGhlYWQsbGluayxtZXRhLHN0eWxlLHRpdGxlLCcgK1xuICAnYWRkcmVzcyxhcnRpY2xlLGFzaWRlLGZvb3RlcixoZWFkZXIsaDEsaDIsaDMsaDQsaDUsaDYsaGdyb3VwLG5hdixzZWN0aW9uLCcgK1xuICAnZGl2LGRkLGRsLGR0LGZpZ2NhcHRpb24sZmlndXJlLHBpY3R1cmUsaHIsaW1nLGxpLG1haW4sb2wscCxwcmUsdWwsJyArXG4gICdhLGIsYWJicixiZGksYmRvLGJyLGNpdGUsY29kZSxkYXRhLGRmbixlbSxpLGtiZCxtYXJrLHEscnAscnQscnRjLHJ1YnksJyArXG4gICdzLHNhbXAsc21hbGwsc3BhbixzdHJvbmcsc3ViLHN1cCx0aW1lLHUsdmFyLHdicixhcmVhLGF1ZGlvLG1hcCx0cmFjayx2aWRlbywnICtcbiAgJ2VtYmVkLG9iamVjdCxwYXJhbSxzb3VyY2UsY2FudmFzLHNjcmlwdCxub3NjcmlwdCxkZWwsaW5zLCcgK1xuICAnY2FwdGlvbixjb2wsY29sZ3JvdXAsdGFibGUsdGhlYWQsdGJvZHksdGQsdGgsdHIsJyArXG4gICdidXR0b24sZGF0YWxpc3QsZmllbGRzZXQsZm9ybSxpbnB1dCxsYWJlbCxsZWdlbmQsbWV0ZXIsb3B0Z3JvdXAsb3B0aW9uLCcgK1xuICAnb3V0cHV0LHByb2dyZXNzLHNlbGVjdCx0ZXh0YXJlYSwnICtcbiAgJ2RldGFpbHMsZGlhbG9nLG1lbnUsbWVudWl0ZW0sc3VtbWFyeSwnICtcbiAgJ2NvbnRlbnQsZWxlbWVudCxzaGFkb3csdGVtcGxhdGUsYmxvY2txdW90ZSxpZnJhbWUsdGZvb3QnXG4pO1xuXG4vLyB0aGlzIG1hcCBpcyBpbnRlbnRpb25hbGx5IHNlbGVjdGl2ZSwgb25seSBjb3ZlcmluZyBTVkcgZWxlbWVudHMgdGhhdCBtYXlcbi8vIGNvbnRhaW4gY2hpbGQgZWxlbWVudHMuXG52YXIgaXNTVkcgPSBtYWtlTWFwKFxuICAnc3ZnLGFuaW1hdGUsY2lyY2xlLGNsaXBwYXRoLGN1cnNvcixkZWZzLGRlc2MsZWxsaXBzZSxmaWx0ZXIsZm9udC1mYWNlLCcgK1xuICAnZm9yZWlnbm9iamVjdCxnLGdseXBoLGltYWdlLGxpbmUsbWFya2VyLG1hc2ssbWlzc2luZy1nbHlwaCxwYXRoLHBhdHRlcm4sJyArXG4gICdwb2x5Z29uLHBvbHlsaW5lLHJlY3Qsc3dpdGNoLHN5bWJvbCx0ZXh0LHRleHRwYXRoLHRzcGFuLHVzZSx2aWV3JyxcbiAgdHJ1ZVxuKTtcblxudmFyIGlzUmVzZXJ2ZWRUYWcgPSBmdW5jdGlvbiAodGFnKSB7XG4gIHJldHVybiBpc0hUTUxUYWcodGFnKSB8fCBpc1NWRyh0YWcpXG59O1xuXG5mdW5jdGlvbiBnZXRUYWdOYW1lc3BhY2UgKHRhZykge1xuICBpZiAoaXNTVkcodGFnKSkge1xuICAgIHJldHVybiAnc3ZnJ1xuICB9XG4gIC8vIGJhc2ljIHN1cHBvcnQgZm9yIE1hdGhNTFxuICAvLyBub3RlIGl0IGRvZXNuJ3Qgc3VwcG9ydCBvdGhlciBNYXRoTUwgZWxlbWVudHMgYmVpbmcgY29tcG9uZW50IHJvb3RzXG4gIGlmICh0YWcgPT09ICdtYXRoJykge1xuICAgIHJldHVybiAnbWF0aCdcbiAgfVxufVxuXG52YXIgdW5rbm93bkVsZW1lbnRDYWNoZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5mdW5jdGlvbiBpc1Vua25vd25FbGVtZW50ICh0YWcpIHtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmICghaW5Ccm93c2VyKSB7XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuICBpZiAoaXNSZXNlcnZlZFRhZyh0YWcpKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbiAgdGFnID0gdGFnLnRvTG93ZXJDYXNlKCk7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAodW5rbm93bkVsZW1lbnRDYWNoZVt0YWddICE9IG51bGwpIHtcbiAgICByZXR1cm4gdW5rbm93bkVsZW1lbnRDYWNoZVt0YWddXG4gIH1cbiAgdmFyIGVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0YWcpO1xuICBpZiAodGFnLmluZGV4T2YoJy0nKSA+IC0xKSB7XG4gICAgLy8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMjgyMTAzNjQvMTA3MDI0NFxuICAgIHJldHVybiAodW5rbm93bkVsZW1lbnRDYWNoZVt0YWddID0gKFxuICAgICAgZWwuY29uc3RydWN0b3IgPT09IHdpbmRvdy5IVE1MVW5rbm93bkVsZW1lbnQgfHxcbiAgICAgIGVsLmNvbnN0cnVjdG9yID09PSB3aW5kb3cuSFRNTEVsZW1lbnRcbiAgICApKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiAodW5rbm93bkVsZW1lbnRDYWNoZVt0YWddID0gL0hUTUxVbmtub3duRWxlbWVudC8udGVzdChlbC50b1N0cmluZygpKSlcbiAgfVxufVxuXG52YXIgaXNUZXh0SW5wdXRUeXBlID0gbWFrZU1hcCgndGV4dCxudW1iZXIscGFzc3dvcmQsc2VhcmNoLGVtYWlsLHRlbCx1cmwnKTtcblxuLyogICovXG5cbi8qKlxuICogUXVlcnkgYW4gZWxlbWVudCBzZWxlY3RvciBpZiBpdCdzIG5vdCBhbiBlbGVtZW50IGFscmVhZHkuXG4gKi9cbmZ1bmN0aW9uIHF1ZXJ5IChlbCkge1xuICBpZiAodHlwZW9mIGVsID09PSAnc3RyaW5nJykge1xuICAgIHZhciBzZWxlY3RlZCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoZWwpO1xuICAgIGlmICghc2VsZWN0ZWQpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybihcbiAgICAgICAgJ0Nhbm5vdCBmaW5kIGVsZW1lbnQ6ICcgKyBlbFxuICAgICAgKTtcbiAgICAgIHJldHVybiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKVxuICAgIH1cbiAgICByZXR1cm4gc2VsZWN0ZWRcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZWxcbiAgfVxufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gY3JlYXRlRWxlbWVudCQxICh0YWdOYW1lLCB2bm9kZSkge1xuICB2YXIgZWxtID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0YWdOYW1lKTtcbiAgaWYgKHRhZ05hbWUgIT09ICdzZWxlY3QnKSB7XG4gICAgcmV0dXJuIGVsbVxuICB9XG4gIC8vIGZhbHNlIG9yIG51bGwgd2lsbCByZW1vdmUgdGhlIGF0dHJpYnV0ZSBidXQgdW5kZWZpbmVkIHdpbGwgbm90XG4gIGlmICh2bm9kZS5kYXRhICYmIHZub2RlLmRhdGEuYXR0cnMgJiYgdm5vZGUuZGF0YS5hdHRycy5tdWx0aXBsZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgZWxtLnNldEF0dHJpYnV0ZSgnbXVsdGlwbGUnLCAnbXVsdGlwbGUnKTtcbiAgfVxuICByZXR1cm4gZWxtXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnROUyAobmFtZXNwYWNlLCB0YWdOYW1lKSB7XG4gIHJldHVybiBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMobmFtZXNwYWNlTWFwW25hbWVzcGFjZV0sIHRhZ05hbWUpXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVRleHROb2RlICh0ZXh0KSB7XG4gIHJldHVybiBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSh0ZXh0KVxufVxuXG5mdW5jdGlvbiBjcmVhdGVDb21tZW50ICh0ZXh0KSB7XG4gIHJldHVybiBkb2N1bWVudC5jcmVhdGVDb21tZW50KHRleHQpXG59XG5cbmZ1bmN0aW9uIGluc2VydEJlZm9yZSAocGFyZW50Tm9kZSwgbmV3Tm9kZSwgcmVmZXJlbmNlTm9kZSkge1xuICBwYXJlbnROb2RlLmluc2VydEJlZm9yZShuZXdOb2RlLCByZWZlcmVuY2VOb2RlKTtcbn1cblxuZnVuY3Rpb24gcmVtb3ZlQ2hpbGQgKG5vZGUsIGNoaWxkKSB7XG4gIG5vZGUucmVtb3ZlQ2hpbGQoY2hpbGQpO1xufVxuXG5mdW5jdGlvbiBhcHBlbmRDaGlsZCAobm9kZSwgY2hpbGQpIHtcbiAgbm9kZS5hcHBlbmRDaGlsZChjaGlsZCk7XG59XG5cbmZ1bmN0aW9uIHBhcmVudE5vZGUgKG5vZGUpIHtcbiAgcmV0dXJuIG5vZGUucGFyZW50Tm9kZVxufVxuXG5mdW5jdGlvbiBuZXh0U2libGluZyAobm9kZSkge1xuICByZXR1cm4gbm9kZS5uZXh0U2libGluZ1xufVxuXG5mdW5jdGlvbiB0YWdOYW1lIChub2RlKSB7XG4gIHJldHVybiBub2RlLnRhZ05hbWVcbn1cblxuZnVuY3Rpb24gc2V0VGV4dENvbnRlbnQgKG5vZGUsIHRleHQpIHtcbiAgbm9kZS50ZXh0Q29udGVudCA9IHRleHQ7XG59XG5cbmZ1bmN0aW9uIHNldFN0eWxlU2NvcGUgKG5vZGUsIHNjb3BlSWQpIHtcbiAgbm9kZS5zZXRBdHRyaWJ1dGUoc2NvcGVJZCwgJycpO1xufVxuXG52YXIgbm9kZU9wcyA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcbiAgY3JlYXRlRWxlbWVudDogY3JlYXRlRWxlbWVudCQxLFxuICBjcmVhdGVFbGVtZW50TlM6IGNyZWF0ZUVsZW1lbnROUyxcbiAgY3JlYXRlVGV4dE5vZGU6IGNyZWF0ZVRleHROb2RlLFxuICBjcmVhdGVDb21tZW50OiBjcmVhdGVDb21tZW50LFxuICBpbnNlcnRCZWZvcmU6IGluc2VydEJlZm9yZSxcbiAgcmVtb3ZlQ2hpbGQ6IHJlbW92ZUNoaWxkLFxuICBhcHBlbmRDaGlsZDogYXBwZW5kQ2hpbGQsXG4gIHBhcmVudE5vZGU6IHBhcmVudE5vZGUsXG4gIG5leHRTaWJsaW5nOiBuZXh0U2libGluZyxcbiAgdGFnTmFtZTogdGFnTmFtZSxcbiAgc2V0VGV4dENvbnRlbnQ6IHNldFRleHRDb250ZW50LFxuICBzZXRTdHlsZVNjb3BlOiBzZXRTdHlsZVNjb3BlXG59KTtcblxuLyogICovXG5cbnZhciByZWYgPSB7XG4gIGNyZWF0ZTogZnVuY3Rpb24gY3JlYXRlIChfLCB2bm9kZSkge1xuICAgIHJlZ2lzdGVyUmVmKHZub2RlKTtcbiAgfSxcbiAgdXBkYXRlOiBmdW5jdGlvbiB1cGRhdGUgKG9sZFZub2RlLCB2bm9kZSkge1xuICAgIGlmIChvbGRWbm9kZS5kYXRhLnJlZiAhPT0gdm5vZGUuZGF0YS5yZWYpIHtcbiAgICAgIHJlZ2lzdGVyUmVmKG9sZFZub2RlLCB0cnVlKTtcbiAgICAgIHJlZ2lzdGVyUmVmKHZub2RlKTtcbiAgICB9XG4gIH0sXG4gIGRlc3Ryb3k6IGZ1bmN0aW9uIGRlc3Ryb3kgKHZub2RlKSB7XG4gICAgcmVnaXN0ZXJSZWYodm5vZGUsIHRydWUpO1xuICB9XG59O1xuXG5mdW5jdGlvbiByZWdpc3RlclJlZiAodm5vZGUsIGlzUmVtb3ZhbCkge1xuICB2YXIga2V5ID0gdm5vZGUuZGF0YS5yZWY7XG4gIGlmICghaXNEZWYoa2V5KSkgeyByZXR1cm4gfVxuXG4gIHZhciB2bSA9IHZub2RlLmNvbnRleHQ7XG4gIHZhciByZWYgPSB2bm9kZS5jb21wb25lbnRJbnN0YW5jZSB8fCB2bm9kZS5lbG07XG4gIHZhciByZWZzID0gdm0uJHJlZnM7XG4gIGlmIChpc1JlbW92YWwpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShyZWZzW2tleV0pKSB7XG4gICAgICByZW1vdmUocmVmc1trZXldLCByZWYpO1xuICAgIH0gZWxzZSBpZiAocmVmc1trZXldID09PSByZWYpIHtcbiAgICAgIHJlZnNba2V5XSA9IHVuZGVmaW5lZDtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKHZub2RlLmRhdGEucmVmSW5Gb3IpIHtcbiAgICAgIGlmICghQXJyYXkuaXNBcnJheShyZWZzW2tleV0pKSB7XG4gICAgICAgIHJlZnNba2V5XSA9IFtyZWZdO1xuICAgICAgfSBlbHNlIGlmIChyZWZzW2tleV0uaW5kZXhPZihyZWYpIDwgMCkge1xuICAgICAgICAvLyAkZmxvdy1kaXNhYmxlLWxpbmVcbiAgICAgICAgcmVmc1trZXldLnB1c2gocmVmKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcmVmc1trZXldID0gcmVmO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIFZpcnR1YWwgRE9NIHBhdGNoaW5nIGFsZ29yaXRobSBiYXNlZCBvbiBTbmFiYmRvbSBieVxuICogU2ltb24gRnJpaXMgVmluZHVtIChAcGFsZGVwaW5kKVxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlXG4gKiBodHRwczovL2dpdGh1Yi5jb20vcGFsZGVwaW5kL3NuYWJiZG9tL2Jsb2IvbWFzdGVyL0xJQ0VOU0VcbiAqXG4gKiBtb2RpZmllZCBieSBFdmFuIFlvdSAoQHl5eDk5MDgwMylcbiAqXG4gKiBOb3QgdHlwZS1jaGVja2luZyB0aGlzIGJlY2F1c2UgdGhpcyBmaWxlIGlzIHBlcmYtY3JpdGljYWwgYW5kIHRoZSBjb3N0XG4gKiBvZiBtYWtpbmcgZmxvdyB1bmRlcnN0YW5kIGl0IGlzIG5vdCB3b3J0aCBpdC5cbiAqL1xuXG52YXIgZW1wdHlOb2RlID0gbmV3IFZOb2RlKCcnLCB7fSwgW10pO1xuXG52YXIgaG9va3MgPSBbJ2NyZWF0ZScsICdhY3RpdmF0ZScsICd1cGRhdGUnLCAncmVtb3ZlJywgJ2Rlc3Ryb3knXTtcblxuZnVuY3Rpb24gc2FtZVZub2RlIChhLCBiKSB7XG4gIHJldHVybiAoXG4gICAgYS5rZXkgPT09IGIua2V5ICYmXG4gICAgYS5hc3luY0ZhY3RvcnkgPT09IGIuYXN5bmNGYWN0b3J5ICYmIChcbiAgICAgIChcbiAgICAgICAgYS50YWcgPT09IGIudGFnICYmXG4gICAgICAgIGEuaXNDb21tZW50ID09PSBiLmlzQ29tbWVudCAmJlxuICAgICAgICBpc0RlZihhLmRhdGEpID09PSBpc0RlZihiLmRhdGEpICYmXG4gICAgICAgIHNhbWVJbnB1dFR5cGUoYSwgYilcbiAgICAgICkgfHwgKFxuICAgICAgICBpc1RydWUoYS5pc0FzeW5jUGxhY2Vob2xkZXIpICYmXG4gICAgICAgIGlzVW5kZWYoYi5hc3luY0ZhY3RvcnkuZXJyb3IpXG4gICAgICApXG4gICAgKVxuICApXG59XG5cbmZ1bmN0aW9uIHNhbWVJbnB1dFR5cGUgKGEsIGIpIHtcbiAgaWYgKGEudGFnICE9PSAnaW5wdXQnKSB7IHJldHVybiB0cnVlIH1cbiAgdmFyIGk7XG4gIHZhciB0eXBlQSA9IGlzRGVmKGkgPSBhLmRhdGEpICYmIGlzRGVmKGkgPSBpLmF0dHJzKSAmJiBpLnR5cGU7XG4gIHZhciB0eXBlQiA9IGlzRGVmKGkgPSBiLmRhdGEpICYmIGlzRGVmKGkgPSBpLmF0dHJzKSAmJiBpLnR5cGU7XG4gIHJldHVybiB0eXBlQSA9PT0gdHlwZUIgfHwgaXNUZXh0SW5wdXRUeXBlKHR5cGVBKSAmJiBpc1RleHRJbnB1dFR5cGUodHlwZUIpXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUtleVRvT2xkSWR4IChjaGlsZHJlbiwgYmVnaW5JZHgsIGVuZElkeCkge1xuICB2YXIgaSwga2V5O1xuICB2YXIgbWFwID0ge307XG4gIGZvciAoaSA9IGJlZ2luSWR4OyBpIDw9IGVuZElkeDsgKytpKSB7XG4gICAga2V5ID0gY2hpbGRyZW5baV0ua2V5O1xuICAgIGlmIChpc0RlZihrZXkpKSB7IG1hcFtrZXldID0gaTsgfVxuICB9XG4gIHJldHVybiBtYXBcbn1cblxuZnVuY3Rpb24gY3JlYXRlUGF0Y2hGdW5jdGlvbiAoYmFja2VuZCkge1xuICB2YXIgaSwgajtcbiAgdmFyIGNicyA9IHt9O1xuXG4gIHZhciBtb2R1bGVzID0gYmFja2VuZC5tb2R1bGVzO1xuICB2YXIgbm9kZU9wcyA9IGJhY2tlbmQubm9kZU9wcztcblxuICBmb3IgKGkgPSAwOyBpIDwgaG9va3MubGVuZ3RoOyArK2kpIHtcbiAgICBjYnNbaG9va3NbaV1dID0gW107XG4gICAgZm9yIChqID0gMDsgaiA8IG1vZHVsZXMubGVuZ3RoOyArK2opIHtcbiAgICAgIGlmIChpc0RlZihtb2R1bGVzW2pdW2hvb2tzW2ldXSkpIHtcbiAgICAgICAgY2JzW2hvb2tzW2ldXS5wdXNoKG1vZHVsZXNbal1baG9va3NbaV1dKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBlbXB0eU5vZGVBdCAoZWxtKSB7XG4gICAgcmV0dXJuIG5ldyBWTm9kZShub2RlT3BzLnRhZ05hbWUoZWxtKS50b0xvd2VyQ2FzZSgpLCB7fSwgW10sIHVuZGVmaW5lZCwgZWxtKVxuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlUm1DYiAoY2hpbGRFbG0sIGxpc3RlbmVycykge1xuICAgIGZ1bmN0aW9uIHJlbW92ZSQkMSAoKSB7XG4gICAgICBpZiAoLS1yZW1vdmUkJDEubGlzdGVuZXJzID09PSAwKSB7XG4gICAgICAgIHJlbW92ZU5vZGUoY2hpbGRFbG0pO1xuICAgICAgfVxuICAgIH1cbiAgICByZW1vdmUkJDEubGlzdGVuZXJzID0gbGlzdGVuZXJzO1xuICAgIHJldHVybiByZW1vdmUkJDFcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlbW92ZU5vZGUgKGVsKSB7XG4gICAgdmFyIHBhcmVudCA9IG5vZGVPcHMucGFyZW50Tm9kZShlbCk7XG4gICAgLy8gZWxlbWVudCBtYXkgaGF2ZSBhbHJlYWR5IGJlZW4gcmVtb3ZlZCBkdWUgdG8gdi1odG1sIC8gdi10ZXh0XG4gICAgaWYgKGlzRGVmKHBhcmVudCkpIHtcbiAgICAgIG5vZGVPcHMucmVtb3ZlQ2hpbGQocGFyZW50LCBlbCk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaXNVbmtub3duRWxlbWVudCQkMSAodm5vZGUsIGluVlByZSkge1xuICAgIHJldHVybiAoXG4gICAgICAhaW5WUHJlICYmXG4gICAgICAhdm5vZGUubnMgJiZcbiAgICAgICEoXG4gICAgICAgIGNvbmZpZy5pZ25vcmVkRWxlbWVudHMubGVuZ3RoICYmXG4gICAgICAgIGNvbmZpZy5pZ25vcmVkRWxlbWVudHMuc29tZShmdW5jdGlvbiAoaWdub3JlKSB7XG4gICAgICAgICAgcmV0dXJuIGlzUmVnRXhwKGlnbm9yZSlcbiAgICAgICAgICAgID8gaWdub3JlLnRlc3Qodm5vZGUudGFnKVxuICAgICAgICAgICAgOiBpZ25vcmUgPT09IHZub2RlLnRhZ1xuICAgICAgICB9KVxuICAgICAgKSAmJlxuICAgICAgY29uZmlnLmlzVW5rbm93bkVsZW1lbnQodm5vZGUudGFnKVxuICAgIClcbiAgfVxuXG4gIHZhciBjcmVhdGluZ0VsbUluVlByZSA9IDA7XG5cbiAgZnVuY3Rpb24gY3JlYXRlRWxtIChcbiAgICB2bm9kZSxcbiAgICBpbnNlcnRlZFZub2RlUXVldWUsXG4gICAgcGFyZW50RWxtLFxuICAgIHJlZkVsbSxcbiAgICBuZXN0ZWQsXG4gICAgb3duZXJBcnJheSxcbiAgICBpbmRleFxuICApIHtcbiAgICBpZiAoaXNEZWYodm5vZGUuZWxtKSAmJiBpc0RlZihvd25lckFycmF5KSkge1xuICAgICAgLy8gVGhpcyB2bm9kZSB3YXMgdXNlZCBpbiBhIHByZXZpb3VzIHJlbmRlciFcbiAgICAgIC8vIG5vdyBpdCdzIHVzZWQgYXMgYSBuZXcgbm9kZSwgb3ZlcndyaXRpbmcgaXRzIGVsbSB3b3VsZCBjYXVzZVxuICAgICAgLy8gcG90ZW50aWFsIHBhdGNoIGVycm9ycyBkb3duIHRoZSByb2FkIHdoZW4gaXQncyB1c2VkIGFzIGFuIGluc2VydGlvblxuICAgICAgLy8gcmVmZXJlbmNlIG5vZGUuIEluc3RlYWQsIHdlIGNsb25lIHRoZSBub2RlIG9uLWRlbWFuZCBiZWZvcmUgY3JlYXRpbmdcbiAgICAgIC8vIGFzc29jaWF0ZWQgRE9NIGVsZW1lbnQgZm9yIGl0LlxuICAgICAgdm5vZGUgPSBvd25lckFycmF5W2luZGV4XSA9IGNsb25lVk5vZGUodm5vZGUpO1xuICAgIH1cblxuICAgIHZub2RlLmlzUm9vdEluc2VydCA9ICFuZXN0ZWQ7IC8vIGZvciB0cmFuc2l0aW9uIGVudGVyIGNoZWNrXG4gICAgaWYgKGNyZWF0ZUNvbXBvbmVudCh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBwYXJlbnRFbG0sIHJlZkVsbSkpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIHZhciBkYXRhID0gdm5vZGUuZGF0YTtcbiAgICB2YXIgY2hpbGRyZW4gPSB2bm9kZS5jaGlsZHJlbjtcbiAgICB2YXIgdGFnID0gdm5vZGUudGFnO1xuICAgIGlmIChpc0RlZih0YWcpKSB7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICBpZiAoZGF0YSAmJiBkYXRhLnByZSkge1xuICAgICAgICAgIGNyZWF0aW5nRWxtSW5WUHJlKys7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzVW5rbm93bkVsZW1lbnQkJDEodm5vZGUsIGNyZWF0aW5nRWxtSW5WUHJlKSkge1xuICAgICAgICAgIHdhcm4oXG4gICAgICAgICAgICAnVW5rbm93biBjdXN0b20gZWxlbWVudDogPCcgKyB0YWcgKyAnPiAtIGRpZCB5b3UgJyArXG4gICAgICAgICAgICAncmVnaXN0ZXIgdGhlIGNvbXBvbmVudCBjb3JyZWN0bHk/IEZvciByZWN1cnNpdmUgY29tcG9uZW50cywgJyArXG4gICAgICAgICAgICAnbWFrZSBzdXJlIHRvIHByb3ZpZGUgdGhlIFwibmFtZVwiIG9wdGlvbi4nLFxuICAgICAgICAgICAgdm5vZGUuY29udGV4dFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdm5vZGUuZWxtID0gdm5vZGUubnNcbiAgICAgICAgPyBub2RlT3BzLmNyZWF0ZUVsZW1lbnROUyh2bm9kZS5ucywgdGFnKVxuICAgICAgICA6IG5vZGVPcHMuY3JlYXRlRWxlbWVudCh0YWcsIHZub2RlKTtcbiAgICAgIHNldFNjb3BlKHZub2RlKTtcblxuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICB7XG4gICAgICAgIGNyZWF0ZUNoaWxkcmVuKHZub2RlLCBjaGlsZHJlbiwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgICAgaWYgKGlzRGVmKGRhdGEpKSB7XG4gICAgICAgICAgaW52b2tlQ3JlYXRlSG9va3Modm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaW5zZXJ0KHBhcmVudEVsbSwgdm5vZGUuZWxtLCByZWZFbG0pO1xuICAgICAgfVxuXG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBkYXRhICYmIGRhdGEucHJlKSB7XG4gICAgICAgIGNyZWF0aW5nRWxtSW5WUHJlLS07XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChpc1RydWUodm5vZGUuaXNDb21tZW50KSkge1xuICAgICAgdm5vZGUuZWxtID0gbm9kZU9wcy5jcmVhdGVDb21tZW50KHZub2RlLnRleHQpO1xuICAgICAgaW5zZXJ0KHBhcmVudEVsbSwgdm5vZGUuZWxtLCByZWZFbG0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB2bm9kZS5lbG0gPSBub2RlT3BzLmNyZWF0ZVRleHROb2RlKHZub2RlLnRleHQpO1xuICAgICAgaW5zZXJ0KHBhcmVudEVsbSwgdm5vZGUuZWxtLCByZWZFbG0pO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUNvbXBvbmVudCAodm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgcGFyZW50RWxtLCByZWZFbG0pIHtcbiAgICB2YXIgaSA9IHZub2RlLmRhdGE7XG4gICAgaWYgKGlzRGVmKGkpKSB7XG4gICAgICB2YXIgaXNSZWFjdGl2YXRlZCA9IGlzRGVmKHZub2RlLmNvbXBvbmVudEluc3RhbmNlKSAmJiBpLmtlZXBBbGl2ZTtcbiAgICAgIGlmIChpc0RlZihpID0gaS5ob29rKSAmJiBpc0RlZihpID0gaS5pbml0KSkge1xuICAgICAgICBpKHZub2RlLCBmYWxzZSAvKiBoeWRyYXRpbmcgKi8pO1xuICAgICAgfVxuICAgICAgLy8gYWZ0ZXIgY2FsbGluZyB0aGUgaW5pdCBob29rLCBpZiB0aGUgdm5vZGUgaXMgYSBjaGlsZCBjb21wb25lbnRcbiAgICAgIC8vIGl0IHNob3VsZCd2ZSBjcmVhdGVkIGEgY2hpbGQgaW5zdGFuY2UgYW5kIG1vdW50ZWQgaXQuIHRoZSBjaGlsZFxuICAgICAgLy8gY29tcG9uZW50IGFsc28gaGFzIHNldCB0aGUgcGxhY2Vob2xkZXIgdm5vZGUncyBlbG0uXG4gICAgICAvLyBpbiB0aGF0IGNhc2Ugd2UgY2FuIGp1c3QgcmV0dXJuIHRoZSBlbGVtZW50IGFuZCBiZSBkb25lLlxuICAgICAgaWYgKGlzRGVmKHZub2RlLmNvbXBvbmVudEluc3RhbmNlKSkge1xuICAgICAgICBpbml0Q29tcG9uZW50KHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgICAgICBpbnNlcnQocGFyZW50RWxtLCB2bm9kZS5lbG0sIHJlZkVsbSk7XG4gICAgICAgIGlmIChpc1RydWUoaXNSZWFjdGl2YXRlZCkpIHtcbiAgICAgICAgICByZWFjdGl2YXRlQ29tcG9uZW50KHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIHBhcmVudEVsbSwgcmVmRWxtKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGluaXRDb21wb25lbnQgKHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpIHtcbiAgICBpZiAoaXNEZWYodm5vZGUuZGF0YS5wZW5kaW5nSW5zZXJ0KSkge1xuICAgICAgaW5zZXJ0ZWRWbm9kZVF1ZXVlLnB1c2guYXBwbHkoaW5zZXJ0ZWRWbm9kZVF1ZXVlLCB2bm9kZS5kYXRhLnBlbmRpbmdJbnNlcnQpO1xuICAgICAgdm5vZGUuZGF0YS5wZW5kaW5nSW5zZXJ0ID0gbnVsbDtcbiAgICB9XG4gICAgdm5vZGUuZWxtID0gdm5vZGUuY29tcG9uZW50SW5zdGFuY2UuJGVsO1xuICAgIGlmIChpc1BhdGNoYWJsZSh2bm9kZSkpIHtcbiAgICAgIGludm9rZUNyZWF0ZUhvb2tzKHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgICAgc2V0U2NvcGUodm5vZGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBlbXB0eSBjb21wb25lbnQgcm9vdC5cbiAgICAgIC8vIHNraXAgYWxsIGVsZW1lbnQtcmVsYXRlZCBtb2R1bGVzIGV4Y2VwdCBmb3IgcmVmICgjMzQ1NSlcbiAgICAgIHJlZ2lzdGVyUmVmKHZub2RlKTtcbiAgICAgIC8vIG1ha2Ugc3VyZSB0byBpbnZva2UgdGhlIGluc2VydCBob29rXG4gICAgICBpbnNlcnRlZFZub2RlUXVldWUucHVzaCh2bm9kZSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcmVhY3RpdmF0ZUNvbXBvbmVudCAodm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgcGFyZW50RWxtLCByZWZFbG0pIHtcbiAgICB2YXIgaTtcbiAgICAvLyBoYWNrIGZvciAjNDMzOTogYSByZWFjdGl2YXRlZCBjb21wb25lbnQgd2l0aCBpbm5lciB0cmFuc2l0aW9uXG4gICAgLy8gZG9lcyBub3QgdHJpZ2dlciBiZWNhdXNlIHRoZSBpbm5lciBub2RlJ3MgY3JlYXRlZCBob29rcyBhcmUgbm90IGNhbGxlZFxuICAgIC8vIGFnYWluLiBJdCdzIG5vdCBpZGVhbCB0byBpbnZvbHZlIG1vZHVsZS1zcGVjaWZpYyBsb2dpYyBpbiBoZXJlIGJ1dFxuICAgIC8vIHRoZXJlIGRvZXNuJ3Qgc2VlbSB0byBiZSBhIGJldHRlciB3YXkgdG8gZG8gaXQuXG4gICAgdmFyIGlubmVyTm9kZSA9IHZub2RlO1xuICAgIHdoaWxlIChpbm5lck5vZGUuY29tcG9uZW50SW5zdGFuY2UpIHtcbiAgICAgIGlubmVyTm9kZSA9IGlubmVyTm9kZS5jb21wb25lbnRJbnN0YW5jZS5fdm5vZGU7XG4gICAgICBpZiAoaXNEZWYoaSA9IGlubmVyTm9kZS5kYXRhKSAmJiBpc0RlZihpID0gaS50cmFuc2l0aW9uKSkge1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgY2JzLmFjdGl2YXRlLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgY2JzLmFjdGl2YXRlW2ldKGVtcHR5Tm9kZSwgaW5uZXJOb2RlKTtcbiAgICAgICAgfVxuICAgICAgICBpbnNlcnRlZFZub2RlUXVldWUucHVzaChpbm5lck5vZGUpO1xuICAgICAgICBicmVha1xuICAgICAgfVxuICAgIH1cbiAgICAvLyB1bmxpa2UgYSBuZXdseSBjcmVhdGVkIGNvbXBvbmVudCxcbiAgICAvLyBhIHJlYWN0aXZhdGVkIGtlZXAtYWxpdmUgY29tcG9uZW50IGRvZXNuJ3QgaW5zZXJ0IGl0c2VsZlxuICAgIGluc2VydChwYXJlbnRFbG0sIHZub2RlLmVsbSwgcmVmRWxtKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGluc2VydCAocGFyZW50LCBlbG0sIHJlZiQkMSkge1xuICAgIGlmIChpc0RlZihwYXJlbnQpKSB7XG4gICAgICBpZiAoaXNEZWYocmVmJCQxKSkge1xuICAgICAgICBpZiAobm9kZU9wcy5wYXJlbnROb2RlKHJlZiQkMSkgPT09IHBhcmVudCkge1xuICAgICAgICAgIG5vZGVPcHMuaW5zZXJ0QmVmb3JlKHBhcmVudCwgZWxtLCByZWYkJDEpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBub2RlT3BzLmFwcGVuZENoaWxkKHBhcmVudCwgZWxtKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVDaGlsZHJlbiAodm5vZGUsIGNoaWxkcmVuLCBpbnNlcnRlZFZub2RlUXVldWUpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShjaGlsZHJlbikpIHtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIGNoZWNrRHVwbGljYXRlS2V5cyhjaGlsZHJlbik7XG4gICAgICB9XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGNyZWF0ZUVsbShjaGlsZHJlbltpXSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCB2bm9kZS5lbG0sIG51bGwsIHRydWUsIGNoaWxkcmVuLCBpKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGlzUHJpbWl0aXZlKHZub2RlLnRleHQpKSB7XG4gICAgICBub2RlT3BzLmFwcGVuZENoaWxkKHZub2RlLmVsbSwgbm9kZU9wcy5jcmVhdGVUZXh0Tm9kZShTdHJpbmcodm5vZGUudGV4dCkpKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBpc1BhdGNoYWJsZSAodm5vZGUpIHtcbiAgICB3aGlsZSAodm5vZGUuY29tcG9uZW50SW5zdGFuY2UpIHtcbiAgICAgIHZub2RlID0gdm5vZGUuY29tcG9uZW50SW5zdGFuY2UuX3Zub2RlO1xuICAgIH1cbiAgICByZXR1cm4gaXNEZWYodm5vZGUudGFnKVxuICB9XG5cbiAgZnVuY3Rpb24gaW52b2tlQ3JlYXRlSG9va3MgKHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpIHtcbiAgICBmb3IgKHZhciBpJDEgPSAwOyBpJDEgPCBjYnMuY3JlYXRlLmxlbmd0aDsgKytpJDEpIHtcbiAgICAgIGNicy5jcmVhdGVbaSQxXShlbXB0eU5vZGUsIHZub2RlKTtcbiAgICB9XG4gICAgaSA9IHZub2RlLmRhdGEuaG9vazsgLy8gUmV1c2UgdmFyaWFibGVcbiAgICBpZiAoaXNEZWYoaSkpIHtcbiAgICAgIGlmIChpc0RlZihpLmNyZWF0ZSkpIHsgaS5jcmVhdGUoZW1wdHlOb2RlLCB2bm9kZSk7IH1cbiAgICAgIGlmIChpc0RlZihpLmluc2VydCkpIHsgaW5zZXJ0ZWRWbm9kZVF1ZXVlLnB1c2godm5vZGUpOyB9XG4gICAgfVxuICB9XG5cbiAgLy8gc2V0IHNjb3BlIGlkIGF0dHJpYnV0ZSBmb3Igc2NvcGVkIENTUy5cbiAgLy8gdGhpcyBpcyBpbXBsZW1lbnRlZCBhcyBhIHNwZWNpYWwgY2FzZSB0byBhdm9pZCB0aGUgb3ZlcmhlYWRcbiAgLy8gb2YgZ29pbmcgdGhyb3VnaCB0aGUgbm9ybWFsIGF0dHJpYnV0ZSBwYXRjaGluZyBwcm9jZXNzLlxuICBmdW5jdGlvbiBzZXRTY29wZSAodm5vZGUpIHtcbiAgICB2YXIgaTtcbiAgICBpZiAoaXNEZWYoaSA9IHZub2RlLmZuU2NvcGVJZCkpIHtcbiAgICAgIG5vZGVPcHMuc2V0U3R5bGVTY29wZSh2bm9kZS5lbG0sIGkpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgYW5jZXN0b3IgPSB2bm9kZTtcbiAgICAgIHdoaWxlIChhbmNlc3Rvcikge1xuICAgICAgICBpZiAoaXNEZWYoaSA9IGFuY2VzdG9yLmNvbnRleHQpICYmIGlzRGVmKGkgPSBpLiRvcHRpb25zLl9zY29wZUlkKSkge1xuICAgICAgICAgIG5vZGVPcHMuc2V0U3R5bGVTY29wZSh2bm9kZS5lbG0sIGkpO1xuICAgICAgICB9XG4gICAgICAgIGFuY2VzdG9yID0gYW5jZXN0b3IucGFyZW50O1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBmb3Igc2xvdCBjb250ZW50IHRoZXkgc2hvdWxkIGFsc28gZ2V0IHRoZSBzY29wZUlkIGZyb20gdGhlIGhvc3QgaW5zdGFuY2UuXG4gICAgaWYgKGlzRGVmKGkgPSBhY3RpdmVJbnN0YW5jZSkgJiZcbiAgICAgIGkgIT09IHZub2RlLmNvbnRleHQgJiZcbiAgICAgIGkgIT09IHZub2RlLmZuQ29udGV4dCAmJlxuICAgICAgaXNEZWYoaSA9IGkuJG9wdGlvbnMuX3Njb3BlSWQpXG4gICAgKSB7XG4gICAgICBub2RlT3BzLnNldFN0eWxlU2NvcGUodm5vZGUuZWxtLCBpKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBhZGRWbm9kZXMgKHBhcmVudEVsbSwgcmVmRWxtLCB2bm9kZXMsIHN0YXJ0SWR4LCBlbmRJZHgsIGluc2VydGVkVm5vZGVRdWV1ZSkge1xuICAgIGZvciAoOyBzdGFydElkeCA8PSBlbmRJZHg7ICsrc3RhcnRJZHgpIHtcbiAgICAgIGNyZWF0ZUVsbSh2bm9kZXNbc3RhcnRJZHhdLCBpbnNlcnRlZFZub2RlUXVldWUsIHBhcmVudEVsbSwgcmVmRWxtLCBmYWxzZSwgdm5vZGVzLCBzdGFydElkeCk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaW52b2tlRGVzdHJveUhvb2sgKHZub2RlKSB7XG4gICAgdmFyIGksIGo7XG4gICAgdmFyIGRhdGEgPSB2bm9kZS5kYXRhO1xuICAgIGlmIChpc0RlZihkYXRhKSkge1xuICAgICAgaWYgKGlzRGVmKGkgPSBkYXRhLmhvb2spICYmIGlzRGVmKGkgPSBpLmRlc3Ryb3kpKSB7IGkodm5vZGUpOyB9XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgY2JzLmRlc3Ryb3kubGVuZ3RoOyArK2kpIHsgY2JzLmRlc3Ryb3lbaV0odm5vZGUpOyB9XG4gICAgfVxuICAgIGlmIChpc0RlZihpID0gdm5vZGUuY2hpbGRyZW4pKSB7XG4gICAgICBmb3IgKGogPSAwOyBqIDwgdm5vZGUuY2hpbGRyZW4ubGVuZ3RoOyArK2opIHtcbiAgICAgICAgaW52b2tlRGVzdHJveUhvb2sodm5vZGUuY2hpbGRyZW5bal0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHJlbW92ZVZub2RlcyAodm5vZGVzLCBzdGFydElkeCwgZW5kSWR4KSB7XG4gICAgZm9yICg7IHN0YXJ0SWR4IDw9IGVuZElkeDsgKytzdGFydElkeCkge1xuICAgICAgdmFyIGNoID0gdm5vZGVzW3N0YXJ0SWR4XTtcbiAgICAgIGlmIChpc0RlZihjaCkpIHtcbiAgICAgICAgaWYgKGlzRGVmKGNoLnRhZykpIHtcbiAgICAgICAgICByZW1vdmVBbmRJbnZva2VSZW1vdmVIb29rKGNoKTtcbiAgICAgICAgICBpbnZva2VEZXN0cm95SG9vayhjaCk7XG4gICAgICAgIH0gZWxzZSB7IC8vIFRleHQgbm9kZVxuICAgICAgICAgIHJlbW92ZU5vZGUoY2guZWxtKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHJlbW92ZUFuZEludm9rZVJlbW92ZUhvb2sgKHZub2RlLCBybSkge1xuICAgIGlmIChpc0RlZihybSkgfHwgaXNEZWYodm5vZGUuZGF0YSkpIHtcbiAgICAgIHZhciBpO1xuICAgICAgdmFyIGxpc3RlbmVycyA9IGNicy5yZW1vdmUubGVuZ3RoICsgMTtcbiAgICAgIGlmIChpc0RlZihybSkpIHtcbiAgICAgICAgLy8gd2UgaGF2ZSBhIHJlY3Vyc2l2ZWx5IHBhc3NlZCBkb3duIHJtIGNhbGxiYWNrXG4gICAgICAgIC8vIGluY3JlYXNlIHRoZSBsaXN0ZW5lcnMgY291bnRcbiAgICAgICAgcm0ubGlzdGVuZXJzICs9IGxpc3RlbmVycztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGRpcmVjdGx5IHJlbW92aW5nXG4gICAgICAgIHJtID0gY3JlYXRlUm1DYih2bm9kZS5lbG0sIGxpc3RlbmVycyk7XG4gICAgICB9XG4gICAgICAvLyByZWN1cnNpdmVseSBpbnZva2UgaG9va3Mgb24gY2hpbGQgY29tcG9uZW50IHJvb3Qgbm9kZVxuICAgICAgaWYgKGlzRGVmKGkgPSB2bm9kZS5jb21wb25lbnRJbnN0YW5jZSkgJiYgaXNEZWYoaSA9IGkuX3Zub2RlKSAmJiBpc0RlZihpLmRhdGEpKSB7XG4gICAgICAgIHJlbW92ZUFuZEludm9rZVJlbW92ZUhvb2soaSwgcm0pO1xuICAgICAgfVxuICAgICAgZm9yIChpID0gMDsgaSA8IGNicy5yZW1vdmUubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgY2JzLnJlbW92ZVtpXSh2bm9kZSwgcm0pO1xuICAgICAgfVxuICAgICAgaWYgKGlzRGVmKGkgPSB2bm9kZS5kYXRhLmhvb2spICYmIGlzRGVmKGkgPSBpLnJlbW92ZSkpIHtcbiAgICAgICAgaSh2bm9kZSwgcm0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcm0oKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcmVtb3ZlTm9kZSh2bm9kZS5lbG0pO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHVwZGF0ZUNoaWxkcmVuIChwYXJlbnRFbG0sIG9sZENoLCBuZXdDaCwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCByZW1vdmVPbmx5KSB7XG4gICAgdmFyIG9sZFN0YXJ0SWR4ID0gMDtcbiAgICB2YXIgbmV3U3RhcnRJZHggPSAwO1xuICAgIHZhciBvbGRFbmRJZHggPSBvbGRDaC5sZW5ndGggLSAxO1xuICAgIHZhciBvbGRTdGFydFZub2RlID0gb2xkQ2hbMF07XG4gICAgdmFyIG9sZEVuZFZub2RlID0gb2xkQ2hbb2xkRW5kSWR4XTtcbiAgICB2YXIgbmV3RW5kSWR4ID0gbmV3Q2gubGVuZ3RoIC0gMTtcbiAgICB2YXIgbmV3U3RhcnRWbm9kZSA9IG5ld0NoWzBdO1xuICAgIHZhciBuZXdFbmRWbm9kZSA9IG5ld0NoW25ld0VuZElkeF07XG4gICAgdmFyIG9sZEtleVRvSWR4LCBpZHhJbk9sZCwgdm5vZGVUb01vdmUsIHJlZkVsbTtcblxuICAgIC8vIHJlbW92ZU9ubHkgaXMgYSBzcGVjaWFsIGZsYWcgdXNlZCBvbmx5IGJ5IDx0cmFuc2l0aW9uLWdyb3VwPlxuICAgIC8vIHRvIGVuc3VyZSByZW1vdmVkIGVsZW1lbnRzIHN0YXkgaW4gY29ycmVjdCByZWxhdGl2ZSBwb3NpdGlvbnNcbiAgICAvLyBkdXJpbmcgbGVhdmluZyB0cmFuc2l0aW9uc1xuICAgIHZhciBjYW5Nb3ZlID0gIXJlbW92ZU9ubHk7XG5cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgY2hlY2tEdXBsaWNhdGVLZXlzKG5ld0NoKTtcbiAgICB9XG5cbiAgICB3aGlsZSAob2xkU3RhcnRJZHggPD0gb2xkRW5kSWR4ICYmIG5ld1N0YXJ0SWR4IDw9IG5ld0VuZElkeCkge1xuICAgICAgaWYgKGlzVW5kZWYob2xkU3RhcnRWbm9kZSkpIHtcbiAgICAgICAgb2xkU3RhcnRWbm9kZSA9IG9sZENoWysrb2xkU3RhcnRJZHhdOyAvLyBWbm9kZSBoYXMgYmVlbiBtb3ZlZCBsZWZ0XG4gICAgICB9IGVsc2UgaWYgKGlzVW5kZWYob2xkRW5kVm5vZGUpKSB7XG4gICAgICAgIG9sZEVuZFZub2RlID0gb2xkQ2hbLS1vbGRFbmRJZHhdO1xuICAgICAgfSBlbHNlIGlmIChzYW1lVm5vZGUob2xkU3RhcnRWbm9kZSwgbmV3U3RhcnRWbm9kZSkpIHtcbiAgICAgICAgcGF0Y2hWbm9kZShvbGRTdGFydFZub2RlLCBuZXdTdGFydFZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIG5ld0NoLCBuZXdTdGFydElkeCk7XG4gICAgICAgIG9sZFN0YXJ0Vm5vZGUgPSBvbGRDaFsrK29sZFN0YXJ0SWR4XTtcbiAgICAgICAgbmV3U3RhcnRWbm9kZSA9IG5ld0NoWysrbmV3U3RhcnRJZHhdO1xuICAgICAgfSBlbHNlIGlmIChzYW1lVm5vZGUob2xkRW5kVm5vZGUsIG5ld0VuZFZub2RlKSkge1xuICAgICAgICBwYXRjaFZub2RlKG9sZEVuZFZub2RlLCBuZXdFbmRWbm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBuZXdDaCwgbmV3RW5kSWR4KTtcbiAgICAgICAgb2xkRW5kVm5vZGUgPSBvbGRDaFstLW9sZEVuZElkeF07XG4gICAgICAgIG5ld0VuZFZub2RlID0gbmV3Q2hbLS1uZXdFbmRJZHhdO1xuICAgICAgfSBlbHNlIGlmIChzYW1lVm5vZGUob2xkU3RhcnRWbm9kZSwgbmV3RW5kVm5vZGUpKSB7IC8vIFZub2RlIG1vdmVkIHJpZ2h0XG4gICAgICAgIHBhdGNoVm5vZGUob2xkU3RhcnRWbm9kZSwgbmV3RW5kVm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgbmV3Q2gsIG5ld0VuZElkeCk7XG4gICAgICAgIGNhbk1vdmUgJiYgbm9kZU9wcy5pbnNlcnRCZWZvcmUocGFyZW50RWxtLCBvbGRTdGFydFZub2RlLmVsbSwgbm9kZU9wcy5uZXh0U2libGluZyhvbGRFbmRWbm9kZS5lbG0pKTtcbiAgICAgICAgb2xkU3RhcnRWbm9kZSA9IG9sZENoWysrb2xkU3RhcnRJZHhdO1xuICAgICAgICBuZXdFbmRWbm9kZSA9IG5ld0NoWy0tbmV3RW5kSWR4XTtcbiAgICAgIH0gZWxzZSBpZiAoc2FtZVZub2RlKG9sZEVuZFZub2RlLCBuZXdTdGFydFZub2RlKSkgeyAvLyBWbm9kZSBtb3ZlZCBsZWZ0XG4gICAgICAgIHBhdGNoVm5vZGUob2xkRW5kVm5vZGUsIG5ld1N0YXJ0Vm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgbmV3Q2gsIG5ld1N0YXJ0SWR4KTtcbiAgICAgICAgY2FuTW92ZSAmJiBub2RlT3BzLmluc2VydEJlZm9yZShwYXJlbnRFbG0sIG9sZEVuZFZub2RlLmVsbSwgb2xkU3RhcnRWbm9kZS5lbG0pO1xuICAgICAgICBvbGRFbmRWbm9kZSA9IG9sZENoWy0tb2xkRW5kSWR4XTtcbiAgICAgICAgbmV3U3RhcnRWbm9kZSA9IG5ld0NoWysrbmV3U3RhcnRJZHhdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGlzVW5kZWYob2xkS2V5VG9JZHgpKSB7IG9sZEtleVRvSWR4ID0gY3JlYXRlS2V5VG9PbGRJZHgob2xkQ2gsIG9sZFN0YXJ0SWR4LCBvbGRFbmRJZHgpOyB9XG4gICAgICAgIGlkeEluT2xkID0gaXNEZWYobmV3U3RhcnRWbm9kZS5rZXkpXG4gICAgICAgICAgPyBvbGRLZXlUb0lkeFtuZXdTdGFydFZub2RlLmtleV1cbiAgICAgICAgICA6IGZpbmRJZHhJbk9sZChuZXdTdGFydFZub2RlLCBvbGRDaCwgb2xkU3RhcnRJZHgsIG9sZEVuZElkeCk7XG4gICAgICAgIGlmIChpc1VuZGVmKGlkeEluT2xkKSkgeyAvLyBOZXcgZWxlbWVudFxuICAgICAgICAgIGNyZWF0ZUVsbShuZXdTdGFydFZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIHBhcmVudEVsbSwgb2xkU3RhcnRWbm9kZS5lbG0sIGZhbHNlLCBuZXdDaCwgbmV3U3RhcnRJZHgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZub2RlVG9Nb3ZlID0gb2xkQ2hbaWR4SW5PbGRdO1xuICAgICAgICAgIGlmIChzYW1lVm5vZGUodm5vZGVUb01vdmUsIG5ld1N0YXJ0Vm5vZGUpKSB7XG4gICAgICAgICAgICBwYXRjaFZub2RlKHZub2RlVG9Nb3ZlLCBuZXdTdGFydFZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIG5ld0NoLCBuZXdTdGFydElkeCk7XG4gICAgICAgICAgICBvbGRDaFtpZHhJbk9sZF0gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBjYW5Nb3ZlICYmIG5vZGVPcHMuaW5zZXJ0QmVmb3JlKHBhcmVudEVsbSwgdm5vZGVUb01vdmUuZWxtLCBvbGRTdGFydFZub2RlLmVsbSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIHNhbWUga2V5IGJ1dCBkaWZmZXJlbnQgZWxlbWVudC4gdHJlYXQgYXMgbmV3IGVsZW1lbnRcbiAgICAgICAgICAgIGNyZWF0ZUVsbShuZXdTdGFydFZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIHBhcmVudEVsbSwgb2xkU3RhcnRWbm9kZS5lbG0sIGZhbHNlLCBuZXdDaCwgbmV3U3RhcnRJZHgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBuZXdTdGFydFZub2RlID0gbmV3Q2hbKytuZXdTdGFydElkeF07XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChvbGRTdGFydElkeCA+IG9sZEVuZElkeCkge1xuICAgICAgcmVmRWxtID0gaXNVbmRlZihuZXdDaFtuZXdFbmRJZHggKyAxXSkgPyBudWxsIDogbmV3Q2hbbmV3RW5kSWR4ICsgMV0uZWxtO1xuICAgICAgYWRkVm5vZGVzKHBhcmVudEVsbSwgcmVmRWxtLCBuZXdDaCwgbmV3U3RhcnRJZHgsIG5ld0VuZElkeCwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICB9IGVsc2UgaWYgKG5ld1N0YXJ0SWR4ID4gbmV3RW5kSWR4KSB7XG4gICAgICByZW1vdmVWbm9kZXMob2xkQ2gsIG9sZFN0YXJ0SWR4LCBvbGRFbmRJZHgpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNoZWNrRHVwbGljYXRlS2V5cyAoY2hpbGRyZW4pIHtcbiAgICB2YXIgc2VlbktleXMgPSB7fTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgdm5vZGUgPSBjaGlsZHJlbltpXTtcbiAgICAgIHZhciBrZXkgPSB2bm9kZS5rZXk7XG4gICAgICBpZiAoaXNEZWYoa2V5KSkge1xuICAgICAgICBpZiAoc2VlbktleXNba2V5XSkge1xuICAgICAgICAgIHdhcm4oXG4gICAgICAgICAgICAoXCJEdXBsaWNhdGUga2V5cyBkZXRlY3RlZDogJ1wiICsga2V5ICsgXCInLiBUaGlzIG1heSBjYXVzZSBhbiB1cGRhdGUgZXJyb3IuXCIpLFxuICAgICAgICAgICAgdm5vZGUuY29udGV4dFxuICAgICAgICAgICk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc2VlbktleXNba2V5XSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBmaW5kSWR4SW5PbGQgKG5vZGUsIG9sZENoLCBzdGFydCwgZW5kKSB7XG4gICAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpKyspIHtcbiAgICAgIHZhciBjID0gb2xkQ2hbaV07XG4gICAgICBpZiAoaXNEZWYoYykgJiYgc2FtZVZub2RlKG5vZGUsIGMpKSB7IHJldHVybiBpIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBwYXRjaFZub2RlIChcbiAgICBvbGRWbm9kZSxcbiAgICB2bm9kZSxcbiAgICBpbnNlcnRlZFZub2RlUXVldWUsXG4gICAgb3duZXJBcnJheSxcbiAgICBpbmRleCxcbiAgICByZW1vdmVPbmx5XG4gICkge1xuICAgIGlmIChvbGRWbm9kZSA9PT0gdm5vZGUpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGlmIChpc0RlZih2bm9kZS5lbG0pICYmIGlzRGVmKG93bmVyQXJyYXkpKSB7XG4gICAgICAvLyBjbG9uZSByZXVzZWQgdm5vZGVcbiAgICAgIHZub2RlID0gb3duZXJBcnJheVtpbmRleF0gPSBjbG9uZVZOb2RlKHZub2RlKTtcbiAgICB9XG5cbiAgICB2YXIgZWxtID0gdm5vZGUuZWxtID0gb2xkVm5vZGUuZWxtO1xuXG4gICAgaWYgKGlzVHJ1ZShvbGRWbm9kZS5pc0FzeW5jUGxhY2Vob2xkZXIpKSB7XG4gICAgICBpZiAoaXNEZWYodm5vZGUuYXN5bmNGYWN0b3J5LnJlc29sdmVkKSkge1xuICAgICAgICBoeWRyYXRlKG9sZFZub2RlLmVsbSwgdm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2bm9kZS5pc0FzeW5jUGxhY2Vob2xkZXIgPSB0cnVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgLy8gcmV1c2UgZWxlbWVudCBmb3Igc3RhdGljIHRyZWVzLlxuICAgIC8vIG5vdGUgd2Ugb25seSBkbyB0aGlzIGlmIHRoZSB2bm9kZSBpcyBjbG9uZWQgLVxuICAgIC8vIGlmIHRoZSBuZXcgbm9kZSBpcyBub3QgY2xvbmVkIGl0IG1lYW5zIHRoZSByZW5kZXIgZnVuY3Rpb25zIGhhdmUgYmVlblxuICAgIC8vIHJlc2V0IGJ5IHRoZSBob3QtcmVsb2FkLWFwaSBhbmQgd2UgbmVlZCB0byBkbyBhIHByb3BlciByZS1yZW5kZXIuXG4gICAgaWYgKGlzVHJ1ZSh2bm9kZS5pc1N0YXRpYykgJiZcbiAgICAgIGlzVHJ1ZShvbGRWbm9kZS5pc1N0YXRpYykgJiZcbiAgICAgIHZub2RlLmtleSA9PT0gb2xkVm5vZGUua2V5ICYmXG4gICAgICAoaXNUcnVlKHZub2RlLmlzQ2xvbmVkKSB8fCBpc1RydWUodm5vZGUuaXNPbmNlKSlcbiAgICApIHtcbiAgICAgIHZub2RlLmNvbXBvbmVudEluc3RhbmNlID0gb2xkVm5vZGUuY29tcG9uZW50SW5zdGFuY2U7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICB2YXIgaTtcbiAgICB2YXIgZGF0YSA9IHZub2RlLmRhdGE7XG4gICAgaWYgKGlzRGVmKGRhdGEpICYmIGlzRGVmKGkgPSBkYXRhLmhvb2spICYmIGlzRGVmKGkgPSBpLnByZXBhdGNoKSkge1xuICAgICAgaShvbGRWbm9kZSwgdm5vZGUpO1xuICAgIH1cblxuICAgIHZhciBvbGRDaCA9IG9sZFZub2RlLmNoaWxkcmVuO1xuICAgIHZhciBjaCA9IHZub2RlLmNoaWxkcmVuO1xuICAgIGlmIChpc0RlZihkYXRhKSAmJiBpc1BhdGNoYWJsZSh2bm9kZSkpIHtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBjYnMudXBkYXRlLmxlbmd0aDsgKytpKSB7IGNicy51cGRhdGVbaV0ob2xkVm5vZGUsIHZub2RlKTsgfVxuICAgICAgaWYgKGlzRGVmKGkgPSBkYXRhLmhvb2spICYmIGlzRGVmKGkgPSBpLnVwZGF0ZSkpIHsgaShvbGRWbm9kZSwgdm5vZGUpOyB9XG4gICAgfVxuICAgIGlmIChpc1VuZGVmKHZub2RlLnRleHQpKSB7XG4gICAgICBpZiAoaXNEZWYob2xkQ2gpICYmIGlzRGVmKGNoKSkge1xuICAgICAgICBpZiAob2xkQ2ggIT09IGNoKSB7IHVwZGF0ZUNoaWxkcmVuKGVsbSwgb2xkQ2gsIGNoLCBpbnNlcnRlZFZub2RlUXVldWUsIHJlbW92ZU9ubHkpOyB9XG4gICAgICB9IGVsc2UgaWYgKGlzRGVmKGNoKSkge1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgIGNoZWNrRHVwbGljYXRlS2V5cyhjaCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzRGVmKG9sZFZub2RlLnRleHQpKSB7IG5vZGVPcHMuc2V0VGV4dENvbnRlbnQoZWxtLCAnJyk7IH1cbiAgICAgICAgYWRkVm5vZGVzKGVsbSwgbnVsbCwgY2gsIDAsIGNoLmxlbmd0aCAtIDEsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICB9IGVsc2UgaWYgKGlzRGVmKG9sZENoKSkge1xuICAgICAgICByZW1vdmVWbm9kZXMob2xkQ2gsIDAsIG9sZENoLmxlbmd0aCAtIDEpO1xuICAgICAgfSBlbHNlIGlmIChpc0RlZihvbGRWbm9kZS50ZXh0KSkge1xuICAgICAgICBub2RlT3BzLnNldFRleHRDb250ZW50KGVsbSwgJycpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAob2xkVm5vZGUudGV4dCAhPT0gdm5vZGUudGV4dCkge1xuICAgICAgbm9kZU9wcy5zZXRUZXh0Q29udGVudChlbG0sIHZub2RlLnRleHQpO1xuICAgIH1cbiAgICBpZiAoaXNEZWYoZGF0YSkpIHtcbiAgICAgIGlmIChpc0RlZihpID0gZGF0YS5ob29rKSAmJiBpc0RlZihpID0gaS5wb3N0cGF0Y2gpKSB7IGkob2xkVm5vZGUsIHZub2RlKTsgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGludm9rZUluc2VydEhvb2sgKHZub2RlLCBxdWV1ZSwgaW5pdGlhbCkge1xuICAgIC8vIGRlbGF5IGluc2VydCBob29rcyBmb3IgY29tcG9uZW50IHJvb3Qgbm9kZXMsIGludm9rZSB0aGVtIGFmdGVyIHRoZVxuICAgIC8vIGVsZW1lbnQgaXMgcmVhbGx5IGluc2VydGVkXG4gICAgaWYgKGlzVHJ1ZShpbml0aWFsKSAmJiBpc0RlZih2bm9kZS5wYXJlbnQpKSB7XG4gICAgICB2bm9kZS5wYXJlbnQuZGF0YS5wZW5kaW5nSW5zZXJ0ID0gcXVldWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcXVldWUubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgcXVldWVbaV0uZGF0YS5ob29rLmluc2VydChxdWV1ZVtpXSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdmFyIGh5ZHJhdGlvbkJhaWxlZCA9IGZhbHNlO1xuICAvLyBsaXN0IG9mIG1vZHVsZXMgdGhhdCBjYW4gc2tpcCBjcmVhdGUgaG9vayBkdXJpbmcgaHlkcmF0aW9uIGJlY2F1c2UgdGhleVxuICAvLyBhcmUgYWxyZWFkeSByZW5kZXJlZCBvbiB0aGUgY2xpZW50IG9yIGhhcyBubyBuZWVkIGZvciBpbml0aWFsaXphdGlvblxuICAvLyBOb3RlOiBzdHlsZSBpcyBleGNsdWRlZCBiZWNhdXNlIGl0IHJlbGllcyBvbiBpbml0aWFsIGNsb25lIGZvciBmdXR1cmVcbiAgLy8gZGVlcCB1cGRhdGVzICgjNzA2MykuXG4gIHZhciBpc1JlbmRlcmVkTW9kdWxlID0gbWFrZU1hcCgnYXR0cnMsY2xhc3Msc3RhdGljQ2xhc3Msc3RhdGljU3R5bGUsa2V5Jyk7XG5cbiAgLy8gTm90ZTogdGhpcyBpcyBhIGJyb3dzZXItb25seSBmdW5jdGlvbiBzbyB3ZSBjYW4gYXNzdW1lIGVsbXMgYXJlIERPTSBub2Rlcy5cbiAgZnVuY3Rpb24gaHlkcmF0ZSAoZWxtLCB2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBpblZQcmUpIHtcbiAgICB2YXIgaTtcbiAgICB2YXIgdGFnID0gdm5vZGUudGFnO1xuICAgIHZhciBkYXRhID0gdm5vZGUuZGF0YTtcbiAgICB2YXIgY2hpbGRyZW4gPSB2bm9kZS5jaGlsZHJlbjtcbiAgICBpblZQcmUgPSBpblZQcmUgfHwgKGRhdGEgJiYgZGF0YS5wcmUpO1xuICAgIHZub2RlLmVsbSA9IGVsbTtcblxuICAgIGlmIChpc1RydWUodm5vZGUuaXNDb21tZW50KSAmJiBpc0RlZih2bm9kZS5hc3luY0ZhY3RvcnkpKSB7XG4gICAgICB2bm9kZS5pc0FzeW5jUGxhY2Vob2xkZXIgPSB0cnVlO1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gICAgLy8gYXNzZXJ0IG5vZGUgbWF0Y2hcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgaWYgKCFhc3NlcnROb2RlTWF0Y2goZWxtLCB2bm9kZSwgaW5WUHJlKSkge1xuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGlzRGVmKGRhdGEpKSB7XG4gICAgICBpZiAoaXNEZWYoaSA9IGRhdGEuaG9vaykgJiYgaXNEZWYoaSA9IGkuaW5pdCkpIHsgaSh2bm9kZSwgdHJ1ZSAvKiBoeWRyYXRpbmcgKi8pOyB9XG4gICAgICBpZiAoaXNEZWYoaSA9IHZub2RlLmNvbXBvbmVudEluc3RhbmNlKSkge1xuICAgICAgICAvLyBjaGlsZCBjb21wb25lbnQuIGl0IHNob3VsZCBoYXZlIGh5ZHJhdGVkIGl0cyBvd24gdHJlZS5cbiAgICAgICAgaW5pdENvbXBvbmVudCh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGlzRGVmKHRhZykpIHtcbiAgICAgIGlmIChpc0RlZihjaGlsZHJlbikpIHtcbiAgICAgICAgLy8gZW1wdHkgZWxlbWVudCwgYWxsb3cgY2xpZW50IHRvIHBpY2sgdXAgYW5kIHBvcHVsYXRlIGNoaWxkcmVuXG4gICAgICAgIGlmICghZWxtLmhhc0NoaWxkTm9kZXMoKSkge1xuICAgICAgICAgIGNyZWF0ZUNoaWxkcmVuKHZub2RlLCBjaGlsZHJlbiwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyB2LWh0bWwgYW5kIGRvbVByb3BzOiBpbm5lckhUTUxcbiAgICAgICAgICBpZiAoaXNEZWYoaSA9IGRhdGEpICYmIGlzRGVmKGkgPSBpLmRvbVByb3BzKSAmJiBpc0RlZihpID0gaS5pbm5lckhUTUwpKSB7XG4gICAgICAgICAgICBpZiAoaSAhPT0gZWxtLmlubmVySFRNTCkge1xuICAgICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiZcbiAgICAgICAgICAgICAgICB0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgICAgICAgICAgICAhaHlkcmF0aW9uQmFpbGVkXG4gICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIGh5ZHJhdGlvbkJhaWxlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdQYXJlbnQ6ICcsIGVsbSk7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdzZXJ2ZXIgaW5uZXJIVE1MOiAnLCBpKTtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ2NsaWVudCBpbm5lckhUTUw6ICcsIGVsbS5pbm5lckhUTUwpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBpdGVyYXRlIGFuZCBjb21wYXJlIGNoaWxkcmVuIGxpc3RzXG4gICAgICAgICAgICB2YXIgY2hpbGRyZW5NYXRjaCA9IHRydWU7XG4gICAgICAgICAgICB2YXIgY2hpbGROb2RlID0gZWxtLmZpcnN0Q2hpbGQ7XG4gICAgICAgICAgICBmb3IgKHZhciBpJDEgPSAwOyBpJDEgPCBjaGlsZHJlbi5sZW5ndGg7IGkkMSsrKSB7XG4gICAgICAgICAgICAgIGlmICghY2hpbGROb2RlIHx8ICFoeWRyYXRlKGNoaWxkTm9kZSwgY2hpbGRyZW5baSQxXSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBpblZQcmUpKSB7XG4gICAgICAgICAgICAgICAgY2hpbGRyZW5NYXRjaCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY2hpbGROb2RlID0gY2hpbGROb2RlLm5leHRTaWJsaW5nO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gaWYgY2hpbGROb2RlIGlzIG5vdCBudWxsLCBpdCBtZWFucyB0aGUgYWN0dWFsIGNoaWxkTm9kZXMgbGlzdCBpc1xuICAgICAgICAgICAgLy8gbG9uZ2VyIHRoYW4gdGhlIHZpcnR1YWwgY2hpbGRyZW4gbGlzdC5cbiAgICAgICAgICAgIGlmICghY2hpbGRyZW5NYXRjaCB8fCBjaGlsZE5vZGUpIHtcbiAgICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmXG4gICAgICAgICAgICAgICAgdHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnICYmXG4gICAgICAgICAgICAgICAgIWh5ZHJhdGlvbkJhaWxlZFxuICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICBoeWRyYXRpb25CYWlsZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignUGFyZW50OiAnLCBlbG0pO1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignTWlzbWF0Y2hpbmcgY2hpbGROb2RlcyB2cy4gVk5vZGVzOiAnLCBlbG0uY2hpbGROb2RlcywgY2hpbGRyZW4pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGlzRGVmKGRhdGEpKSB7XG4gICAgICAgIHZhciBmdWxsSW52b2tlID0gZmFsc2U7XG4gICAgICAgIGZvciAodmFyIGtleSBpbiBkYXRhKSB7XG4gICAgICAgICAgaWYgKCFpc1JlbmRlcmVkTW9kdWxlKGtleSkpIHtcbiAgICAgICAgICAgIGZ1bGxJbnZva2UgPSB0cnVlO1xuICAgICAgICAgICAgaW52b2tlQ3JlYXRlSG9va3Modm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICAgICAgICBicmVha1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIWZ1bGxJbnZva2UgJiYgZGF0YVsnY2xhc3MnXSkge1xuICAgICAgICAgIC8vIGVuc3VyZSBjb2xsZWN0aW5nIGRlcHMgZm9yIGRlZXAgY2xhc3MgYmluZGluZ3MgZm9yIGZ1dHVyZSB1cGRhdGVzXG4gICAgICAgICAgdHJhdmVyc2UoZGF0YVsnY2xhc3MnXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGVsbS5kYXRhICE9PSB2bm9kZS50ZXh0KSB7XG4gICAgICBlbG0uZGF0YSA9IHZub2RlLnRleHQ7XG4gICAgfVxuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICBmdW5jdGlvbiBhc3NlcnROb2RlTWF0Y2ggKG5vZGUsIHZub2RlLCBpblZQcmUpIHtcbiAgICBpZiAoaXNEZWYodm5vZGUudGFnKSkge1xuICAgICAgcmV0dXJuIHZub2RlLnRhZy5pbmRleE9mKCd2dWUtY29tcG9uZW50JykgPT09IDAgfHwgKFxuICAgICAgICAhaXNVbmtub3duRWxlbWVudCQkMSh2bm9kZSwgaW5WUHJlKSAmJlxuICAgICAgICB2bm9kZS50YWcudG9Mb3dlckNhc2UoKSA9PT0gKG5vZGUudGFnTmFtZSAmJiBub2RlLnRhZ05hbWUudG9Mb3dlckNhc2UoKSlcbiAgICAgIClcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG5vZGUubm9kZVR5cGUgPT09ICh2bm9kZS5pc0NvbW1lbnQgPyA4IDogMylcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24gcGF0Y2ggKG9sZFZub2RlLCB2bm9kZSwgaHlkcmF0aW5nLCByZW1vdmVPbmx5KSB7XG4gICAgaWYgKGlzVW5kZWYodm5vZGUpKSB7XG4gICAgICBpZiAoaXNEZWYob2xkVm5vZGUpKSB7IGludm9rZURlc3Ryb3lIb29rKG9sZFZub2RlKTsgfVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgdmFyIGlzSW5pdGlhbFBhdGNoID0gZmFsc2U7XG4gICAgdmFyIGluc2VydGVkVm5vZGVRdWV1ZSA9IFtdO1xuXG4gICAgaWYgKGlzVW5kZWYob2xkVm5vZGUpKSB7XG4gICAgICAvLyBlbXB0eSBtb3VudCAobGlrZWx5IGFzIGNvbXBvbmVudCksIGNyZWF0ZSBuZXcgcm9vdCBlbGVtZW50XG4gICAgICBpc0luaXRpYWxQYXRjaCA9IHRydWU7XG4gICAgICBjcmVhdGVFbG0odm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBpc1JlYWxFbGVtZW50ID0gaXNEZWYob2xkVm5vZGUubm9kZVR5cGUpO1xuICAgICAgaWYgKCFpc1JlYWxFbGVtZW50ICYmIHNhbWVWbm9kZShvbGRWbm9kZSwgdm5vZGUpKSB7XG4gICAgICAgIC8vIHBhdGNoIGV4aXN0aW5nIHJvb3Qgbm9kZVxuICAgICAgICBwYXRjaFZub2RlKG9sZFZub2RlLCB2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBudWxsLCBudWxsLCByZW1vdmVPbmx5KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChpc1JlYWxFbGVtZW50KSB7XG4gICAgICAgICAgLy8gbW91bnRpbmcgdG8gYSByZWFsIGVsZW1lbnRcbiAgICAgICAgICAvLyBjaGVjayBpZiB0aGlzIGlzIHNlcnZlci1yZW5kZXJlZCBjb250ZW50IGFuZCBpZiB3ZSBjYW4gcGVyZm9ybVxuICAgICAgICAgIC8vIGEgc3VjY2Vzc2Z1bCBoeWRyYXRpb24uXG4gICAgICAgICAgaWYgKG9sZFZub2RlLm5vZGVUeXBlID09PSAxICYmIG9sZFZub2RlLmhhc0F0dHJpYnV0ZShTU1JfQVRUUikpIHtcbiAgICAgICAgICAgIG9sZFZub2RlLnJlbW92ZUF0dHJpYnV0ZShTU1JfQVRUUik7XG4gICAgICAgICAgICBoeWRyYXRpbmcgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaXNUcnVlKGh5ZHJhdGluZykpIHtcbiAgICAgICAgICAgIGlmIChoeWRyYXRlKG9sZFZub2RlLCB2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKSkge1xuICAgICAgICAgICAgICBpbnZva2VJbnNlcnRIb29rKHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIHRydWUpO1xuICAgICAgICAgICAgICByZXR1cm4gb2xkVm5vZGVcbiAgICAgICAgICAgIH0gZWxzZSBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgICAgICB3YXJuKFxuICAgICAgICAgICAgICAgICdUaGUgY2xpZW50LXNpZGUgcmVuZGVyZWQgdmlydHVhbCBET00gdHJlZSBpcyBub3QgbWF0Y2hpbmcgJyArXG4gICAgICAgICAgICAgICAgJ3NlcnZlci1yZW5kZXJlZCBjb250ZW50LiBUaGlzIGlzIGxpa2VseSBjYXVzZWQgYnkgaW5jb3JyZWN0ICcgK1xuICAgICAgICAgICAgICAgICdIVE1MIG1hcmt1cCwgZm9yIGV4YW1wbGUgbmVzdGluZyBibG9jay1sZXZlbCBlbGVtZW50cyBpbnNpZGUgJyArXG4gICAgICAgICAgICAgICAgJzxwPiwgb3IgbWlzc2luZyA8dGJvZHk+LiBCYWlsaW5nIGh5ZHJhdGlvbiBhbmQgcGVyZm9ybWluZyAnICtcbiAgICAgICAgICAgICAgICAnZnVsbCBjbGllbnQtc2lkZSByZW5kZXIuJ1xuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBlaXRoZXIgbm90IHNlcnZlci1yZW5kZXJlZCwgb3IgaHlkcmF0aW9uIGZhaWxlZC5cbiAgICAgICAgICAvLyBjcmVhdGUgYW4gZW1wdHkgbm9kZSBhbmQgcmVwbGFjZSBpdFxuICAgICAgICAgIG9sZFZub2RlID0gZW1wdHlOb2RlQXQob2xkVm5vZGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gcmVwbGFjaW5nIGV4aXN0aW5nIGVsZW1lbnRcbiAgICAgICAgdmFyIG9sZEVsbSA9IG9sZFZub2RlLmVsbTtcbiAgICAgICAgdmFyIHBhcmVudEVsbSA9IG5vZGVPcHMucGFyZW50Tm9kZShvbGRFbG0pO1xuXG4gICAgICAgIC8vIGNyZWF0ZSBuZXcgbm9kZVxuICAgICAgICBjcmVhdGVFbG0oXG4gICAgICAgICAgdm5vZGUsXG4gICAgICAgICAgaW5zZXJ0ZWRWbm9kZVF1ZXVlLFxuICAgICAgICAgIC8vIGV4dHJlbWVseSByYXJlIGVkZ2UgY2FzZTogZG8gbm90IGluc2VydCBpZiBvbGQgZWxlbWVudCBpcyBpbiBhXG4gICAgICAgICAgLy8gbGVhdmluZyB0cmFuc2l0aW9uLiBPbmx5IGhhcHBlbnMgd2hlbiBjb21iaW5pbmcgdHJhbnNpdGlvbiArXG4gICAgICAgICAgLy8ga2VlcC1hbGl2ZSArIEhPQ3MuICgjNDU5MClcbiAgICAgICAgICBvbGRFbG0uX2xlYXZlQ2IgPyBudWxsIDogcGFyZW50RWxtLFxuICAgICAgICAgIG5vZGVPcHMubmV4dFNpYmxpbmcob2xkRWxtKVxuICAgICAgICApO1xuXG4gICAgICAgIC8vIHVwZGF0ZSBwYXJlbnQgcGxhY2Vob2xkZXIgbm9kZSBlbGVtZW50LCByZWN1cnNpdmVseVxuICAgICAgICBpZiAoaXNEZWYodm5vZGUucGFyZW50KSkge1xuICAgICAgICAgIHZhciBhbmNlc3RvciA9IHZub2RlLnBhcmVudDtcbiAgICAgICAgICB2YXIgcGF0Y2hhYmxlID0gaXNQYXRjaGFibGUodm5vZGUpO1xuICAgICAgICAgIHdoaWxlIChhbmNlc3Rvcikge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjYnMuZGVzdHJveS5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICBjYnMuZGVzdHJveVtpXShhbmNlc3Rvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhbmNlc3Rvci5lbG0gPSB2bm9kZS5lbG07XG4gICAgICAgICAgICBpZiAocGF0Y2hhYmxlKSB7XG4gICAgICAgICAgICAgIGZvciAodmFyIGkkMSA9IDA7IGkkMSA8IGNicy5jcmVhdGUubGVuZ3RoOyArK2kkMSkge1xuICAgICAgICAgICAgICAgIGNicy5jcmVhdGVbaSQxXShlbXB0eU5vZGUsIGFuY2VzdG9yKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAvLyAjNjUxM1xuICAgICAgICAgICAgICAvLyBpbnZva2UgaW5zZXJ0IGhvb2tzIHRoYXQgbWF5IGhhdmUgYmVlbiBtZXJnZWQgYnkgY3JlYXRlIGhvb2tzLlxuICAgICAgICAgICAgICAvLyBlLmcuIGZvciBkaXJlY3RpdmVzIHRoYXQgdXNlcyB0aGUgXCJpbnNlcnRlZFwiIGhvb2suXG4gICAgICAgICAgICAgIHZhciBpbnNlcnQgPSBhbmNlc3Rvci5kYXRhLmhvb2suaW5zZXJ0O1xuICAgICAgICAgICAgICBpZiAoaW5zZXJ0Lm1lcmdlZCkge1xuICAgICAgICAgICAgICAgIC8vIHN0YXJ0IGF0IGluZGV4IDEgdG8gYXZvaWQgcmUtaW52b2tpbmcgY29tcG9uZW50IG1vdW50ZWQgaG9va1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkkMiA9IDE7IGkkMiA8IGluc2VydC5mbnMubGVuZ3RoOyBpJDIrKykge1xuICAgICAgICAgICAgICAgICAgaW5zZXJ0LmZuc1tpJDJdKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZWdpc3RlclJlZihhbmNlc3Rvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhbmNlc3RvciA9IGFuY2VzdG9yLnBhcmVudDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBkZXN0cm95IG9sZCBub2RlXG4gICAgICAgIGlmIChpc0RlZihwYXJlbnRFbG0pKSB7XG4gICAgICAgICAgcmVtb3ZlVm5vZGVzKFtvbGRWbm9kZV0sIDAsIDApO1xuICAgICAgICB9IGVsc2UgaWYgKGlzRGVmKG9sZFZub2RlLnRhZykpIHtcbiAgICAgICAgICBpbnZva2VEZXN0cm95SG9vayhvbGRWbm9kZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpbnZva2VJbnNlcnRIb29rKHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIGlzSW5pdGlhbFBhdGNoKTtcbiAgICByZXR1cm4gdm5vZGUuZWxtXG4gIH1cbn1cblxuLyogICovXG5cbnZhciBkaXJlY3RpdmVzID0ge1xuICBjcmVhdGU6IHVwZGF0ZURpcmVjdGl2ZXMsXG4gIHVwZGF0ZTogdXBkYXRlRGlyZWN0aXZlcyxcbiAgZGVzdHJveTogZnVuY3Rpb24gdW5iaW5kRGlyZWN0aXZlcyAodm5vZGUpIHtcbiAgICB1cGRhdGVEaXJlY3RpdmVzKHZub2RlLCBlbXB0eU5vZGUpO1xuICB9XG59O1xuXG5mdW5jdGlvbiB1cGRhdGVEaXJlY3RpdmVzIChvbGRWbm9kZSwgdm5vZGUpIHtcbiAgaWYgKG9sZFZub2RlLmRhdGEuZGlyZWN0aXZlcyB8fCB2bm9kZS5kYXRhLmRpcmVjdGl2ZXMpIHtcbiAgICBfdXBkYXRlKG9sZFZub2RlLCB2bm9kZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gX3VwZGF0ZSAob2xkVm5vZGUsIHZub2RlKSB7XG4gIHZhciBpc0NyZWF0ZSA9IG9sZFZub2RlID09PSBlbXB0eU5vZGU7XG4gIHZhciBpc0Rlc3Ryb3kgPSB2bm9kZSA9PT0gZW1wdHlOb2RlO1xuICB2YXIgb2xkRGlycyA9IG5vcm1hbGl6ZURpcmVjdGl2ZXMkMShvbGRWbm9kZS5kYXRhLmRpcmVjdGl2ZXMsIG9sZFZub2RlLmNvbnRleHQpO1xuICB2YXIgbmV3RGlycyA9IG5vcm1hbGl6ZURpcmVjdGl2ZXMkMSh2bm9kZS5kYXRhLmRpcmVjdGl2ZXMsIHZub2RlLmNvbnRleHQpO1xuXG4gIHZhciBkaXJzV2l0aEluc2VydCA9IFtdO1xuICB2YXIgZGlyc1dpdGhQb3N0cGF0Y2ggPSBbXTtcblxuICB2YXIga2V5LCBvbGREaXIsIGRpcjtcbiAgZm9yIChrZXkgaW4gbmV3RGlycykge1xuICAgIG9sZERpciA9IG9sZERpcnNba2V5XTtcbiAgICBkaXIgPSBuZXdEaXJzW2tleV07XG4gICAgaWYgKCFvbGREaXIpIHtcbiAgICAgIC8vIG5ldyBkaXJlY3RpdmUsIGJpbmRcbiAgICAgIGNhbGxIb29rJDEoZGlyLCAnYmluZCcsIHZub2RlLCBvbGRWbm9kZSk7XG4gICAgICBpZiAoZGlyLmRlZiAmJiBkaXIuZGVmLmluc2VydGVkKSB7XG4gICAgICAgIGRpcnNXaXRoSW5zZXJ0LnB1c2goZGlyKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gZXhpc3RpbmcgZGlyZWN0aXZlLCB1cGRhdGVcbiAgICAgIGRpci5vbGRWYWx1ZSA9IG9sZERpci52YWx1ZTtcbiAgICAgIGRpci5vbGRBcmcgPSBvbGREaXIuYXJnO1xuICAgICAgY2FsbEhvb2skMShkaXIsICd1cGRhdGUnLCB2bm9kZSwgb2xkVm5vZGUpO1xuICAgICAgaWYgKGRpci5kZWYgJiYgZGlyLmRlZi5jb21wb25lbnRVcGRhdGVkKSB7XG4gICAgICAgIGRpcnNXaXRoUG9zdHBhdGNoLnB1c2goZGlyKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAoZGlyc1dpdGhJbnNlcnQubGVuZ3RoKSB7XG4gICAgdmFyIGNhbGxJbnNlcnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRpcnNXaXRoSW5zZXJ0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNhbGxIb29rJDEoZGlyc1dpdGhJbnNlcnRbaV0sICdpbnNlcnRlZCcsIHZub2RlLCBvbGRWbm9kZSk7XG4gICAgICB9XG4gICAgfTtcbiAgICBpZiAoaXNDcmVhdGUpIHtcbiAgICAgIG1lcmdlVk5vZGVIb29rKHZub2RlLCAnaW5zZXJ0JywgY2FsbEluc2VydCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNhbGxJbnNlcnQoKTtcbiAgICB9XG4gIH1cblxuICBpZiAoZGlyc1dpdGhQb3N0cGF0Y2gubGVuZ3RoKSB7XG4gICAgbWVyZ2VWTm9kZUhvb2sodm5vZGUsICdwb3N0cGF0Y2gnLCBmdW5jdGlvbiAoKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRpcnNXaXRoUG9zdHBhdGNoLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNhbGxIb29rJDEoZGlyc1dpdGhQb3N0cGF0Y2hbaV0sICdjb21wb25lbnRVcGRhdGVkJywgdm5vZGUsIG9sZFZub2RlKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIGlmICghaXNDcmVhdGUpIHtcbiAgICBmb3IgKGtleSBpbiBvbGREaXJzKSB7XG4gICAgICBpZiAoIW5ld0RpcnNba2V5XSkge1xuICAgICAgICAvLyBubyBsb25nZXIgcHJlc2VudCwgdW5iaW5kXG4gICAgICAgIGNhbGxIb29rJDEob2xkRGlyc1trZXldLCAndW5iaW5kJywgb2xkVm5vZGUsIG9sZFZub2RlLCBpc0Rlc3Ryb3kpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG52YXIgZW1wdHlNb2RpZmllcnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG5mdW5jdGlvbiBub3JtYWxpemVEaXJlY3RpdmVzJDEgKFxuICBkaXJzLFxuICB2bVxuKSB7XG4gIHZhciByZXMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICBpZiAoIWRpcnMpIHtcbiAgICAvLyAkZmxvdy1kaXNhYmxlLWxpbmVcbiAgICByZXR1cm4gcmVzXG4gIH1cbiAgdmFyIGksIGRpcjtcbiAgZm9yIChpID0gMDsgaSA8IGRpcnMubGVuZ3RoOyBpKyspIHtcbiAgICBkaXIgPSBkaXJzW2ldO1xuICAgIGlmICghZGlyLm1vZGlmaWVycykge1xuICAgICAgLy8gJGZsb3ctZGlzYWJsZS1saW5lXG4gICAgICBkaXIubW9kaWZpZXJzID0gZW1wdHlNb2RpZmllcnM7XG4gICAgfVxuICAgIHJlc1tnZXRSYXdEaXJOYW1lKGRpcildID0gZGlyO1xuICAgIGRpci5kZWYgPSByZXNvbHZlQXNzZXQodm0uJG9wdGlvbnMsICdkaXJlY3RpdmVzJywgZGlyLm5hbWUsIHRydWUpO1xuICB9XG4gIC8vICRmbG93LWRpc2FibGUtbGluZVxuICByZXR1cm4gcmVzXG59XG5cbmZ1bmN0aW9uIGdldFJhd0Rpck5hbWUgKGRpcikge1xuICByZXR1cm4gZGlyLnJhd05hbWUgfHwgKChkaXIubmFtZSkgKyBcIi5cIiArIChPYmplY3Qua2V5cyhkaXIubW9kaWZpZXJzIHx8IHt9KS5qb2luKCcuJykpKVxufVxuXG5mdW5jdGlvbiBjYWxsSG9vayQxIChkaXIsIGhvb2ssIHZub2RlLCBvbGRWbm9kZSwgaXNEZXN0cm95KSB7XG4gIHZhciBmbiA9IGRpci5kZWYgJiYgZGlyLmRlZltob29rXTtcbiAgaWYgKGZuKSB7XG4gICAgdHJ5IHtcbiAgICAgIGZuKHZub2RlLmVsbSwgZGlyLCB2bm9kZSwgb2xkVm5vZGUsIGlzRGVzdHJveSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgaGFuZGxlRXJyb3IoZSwgdm5vZGUuY29udGV4dCwgKFwiZGlyZWN0aXZlIFwiICsgKGRpci5uYW1lKSArIFwiIFwiICsgaG9vayArIFwiIGhvb2tcIikpO1xuICAgIH1cbiAgfVxufVxuXG52YXIgYmFzZU1vZHVsZXMgPSBbXG4gIHJlZixcbiAgZGlyZWN0aXZlc1xuXTtcblxuLyogICovXG5cbmZ1bmN0aW9uIHVwZGF0ZUF0dHJzIChvbGRWbm9kZSwgdm5vZGUpIHtcbiAgdmFyIG9wdHMgPSB2bm9kZS5jb21wb25lbnRPcHRpb25zO1xuICBpZiAoaXNEZWYob3B0cykgJiYgb3B0cy5DdG9yLm9wdGlvbnMuaW5oZXJpdEF0dHJzID09PSBmYWxzZSkge1xuICAgIHJldHVyblxuICB9XG4gIGlmIChpc1VuZGVmKG9sZFZub2RlLmRhdGEuYXR0cnMpICYmIGlzVW5kZWYodm5vZGUuZGF0YS5hdHRycykpIHtcbiAgICByZXR1cm5cbiAgfVxuICB2YXIga2V5LCBjdXIsIG9sZDtcbiAgdmFyIGVsbSA9IHZub2RlLmVsbTtcbiAgdmFyIG9sZEF0dHJzID0gb2xkVm5vZGUuZGF0YS5hdHRycyB8fCB7fTtcbiAgdmFyIGF0dHJzID0gdm5vZGUuZGF0YS5hdHRycyB8fCB7fTtcbiAgLy8gY2xvbmUgb2JzZXJ2ZWQgb2JqZWN0cywgYXMgdGhlIHVzZXIgcHJvYmFibHkgd2FudHMgdG8gbXV0YXRlIGl0XG4gIGlmIChpc0RlZihhdHRycy5fX29iX18pKSB7XG4gICAgYXR0cnMgPSB2bm9kZS5kYXRhLmF0dHJzID0gZXh0ZW5kKHt9LCBhdHRycyk7XG4gIH1cblxuICBmb3IgKGtleSBpbiBhdHRycykge1xuICAgIGN1ciA9IGF0dHJzW2tleV07XG4gICAgb2xkID0gb2xkQXR0cnNba2V5XTtcbiAgICBpZiAob2xkICE9PSBjdXIpIHtcbiAgICAgIHNldEF0dHIoZWxtLCBrZXksIGN1ciwgdm5vZGUuZGF0YS5wcmUpO1xuICAgIH1cbiAgfVxuICAvLyAjNDM5MTogaW4gSUU5LCBzZXR0aW5nIHR5cGUgY2FuIHJlc2V0IHZhbHVlIGZvciBpbnB1dFt0eXBlPXJhZGlvXVxuICAvLyAjNjY2NjogSUUvRWRnZSBmb3JjZXMgcHJvZ3Jlc3MgdmFsdWUgZG93biB0byAxIGJlZm9yZSBzZXR0aW5nIGEgbWF4XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoKGlzSUUgfHwgaXNFZGdlKSAmJiBhdHRycy52YWx1ZSAhPT0gb2xkQXR0cnMudmFsdWUpIHtcbiAgICBzZXRBdHRyKGVsbSwgJ3ZhbHVlJywgYXR0cnMudmFsdWUpO1xuICB9XG4gIGZvciAoa2V5IGluIG9sZEF0dHJzKSB7XG4gICAgaWYgKGlzVW5kZWYoYXR0cnNba2V5XSkpIHtcbiAgICAgIGlmIChpc1hsaW5rKGtleSkpIHtcbiAgICAgICAgZWxtLnJlbW92ZUF0dHJpYnV0ZU5TKHhsaW5rTlMsIGdldFhsaW5rUHJvcChrZXkpKTtcbiAgICAgIH0gZWxzZSBpZiAoIWlzRW51bWVyYXRlZEF0dHIoa2V5KSkge1xuICAgICAgICBlbG0ucmVtb3ZlQXR0cmlidXRlKGtleSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHNldEF0dHIgKGVsLCBrZXksIHZhbHVlLCBpc0luUHJlKSB7XG4gIGlmIChpc0luUHJlIHx8IGVsLnRhZ05hbWUuaW5kZXhPZignLScpID4gLTEpIHtcbiAgICBiYXNlU2V0QXR0cihlbCwga2V5LCB2YWx1ZSk7XG4gIH0gZWxzZSBpZiAoaXNCb29sZWFuQXR0cihrZXkpKSB7XG4gICAgLy8gc2V0IGF0dHJpYnV0ZSBmb3IgYmxhbmsgdmFsdWVcbiAgICAvLyBlLmcuIDxvcHRpb24gZGlzYWJsZWQ+U2VsZWN0IG9uZTwvb3B0aW9uPlxuICAgIGlmIChpc0ZhbHN5QXR0clZhbHVlKHZhbHVlKSkge1xuICAgICAgZWwucmVtb3ZlQXR0cmlidXRlKGtleSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHRlY2huaWNhbGx5IGFsbG93ZnVsbHNjcmVlbiBpcyBhIGJvb2xlYW4gYXR0cmlidXRlIGZvciA8aWZyYW1lPixcbiAgICAgIC8vIGJ1dCBGbGFzaCBleHBlY3RzIGEgdmFsdWUgb2YgXCJ0cnVlXCIgd2hlbiB1c2VkIG9uIDxlbWJlZD4gdGFnXG4gICAgICB2YWx1ZSA9IGtleSA9PT0gJ2FsbG93ZnVsbHNjcmVlbicgJiYgZWwudGFnTmFtZSA9PT0gJ0VNQkVEJ1xuICAgICAgICA/ICd0cnVlJ1xuICAgICAgICA6IGtleTtcbiAgICAgIGVsLnNldEF0dHJpYnV0ZShrZXksIHZhbHVlKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoaXNFbnVtZXJhdGVkQXR0cihrZXkpKSB7XG4gICAgZWwuc2V0QXR0cmlidXRlKGtleSwgY29udmVydEVudW1lcmF0ZWRWYWx1ZShrZXksIHZhbHVlKSk7XG4gIH0gZWxzZSBpZiAoaXNYbGluayhrZXkpKSB7XG4gICAgaWYgKGlzRmFsc3lBdHRyVmFsdWUodmFsdWUpKSB7XG4gICAgICBlbC5yZW1vdmVBdHRyaWJ1dGVOUyh4bGlua05TLCBnZXRYbGlua1Byb3Aoa2V5KSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsLnNldEF0dHJpYnV0ZU5TKHhsaW5rTlMsIGtleSwgdmFsdWUpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBiYXNlU2V0QXR0cihlbCwga2V5LCB2YWx1ZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gYmFzZVNldEF0dHIgKGVsLCBrZXksIHZhbHVlKSB7XG4gIGlmIChpc0ZhbHN5QXR0clZhbHVlKHZhbHVlKSkge1xuICAgIGVsLnJlbW92ZUF0dHJpYnV0ZShrZXkpO1xuICB9IGVsc2Uge1xuICAgIC8vICM3MTM4OiBJRTEwICYgMTEgZmlyZXMgaW5wdXQgZXZlbnQgd2hlbiBzZXR0aW5nIHBsYWNlaG9sZGVyIG9uXG4gICAgLy8gPHRleHRhcmVhPi4uLiBibG9jayB0aGUgZmlyc3QgaW5wdXQgZXZlbnQgYW5kIHJlbW92ZSB0aGUgYmxvY2tlclxuICAgIC8vIGltbWVkaWF0ZWx5LlxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmIChcbiAgICAgIGlzSUUgJiYgIWlzSUU5ICYmXG4gICAgICBlbC50YWdOYW1lID09PSAnVEVYVEFSRUEnICYmXG4gICAgICBrZXkgPT09ICdwbGFjZWhvbGRlcicgJiYgdmFsdWUgIT09ICcnICYmICFlbC5fX2llcGhcbiAgICApIHtcbiAgICAgIHZhciBibG9ja2VyID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgZS5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcbiAgICAgICAgZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcignaW5wdXQnLCBibG9ja2VyKTtcbiAgICAgIH07XG4gICAgICBlbC5hZGRFdmVudExpc3RlbmVyKCdpbnB1dCcsIGJsb2NrZXIpO1xuICAgICAgLy8gJGZsb3ctZGlzYWJsZS1saW5lXG4gICAgICBlbC5fX2llcGggPSB0cnVlOyAvKiBJRSBwbGFjZWhvbGRlciBwYXRjaGVkICovXG4gICAgfVxuICAgIGVsLnNldEF0dHJpYnV0ZShrZXksIHZhbHVlKTtcbiAgfVxufVxuXG52YXIgYXR0cnMgPSB7XG4gIGNyZWF0ZTogdXBkYXRlQXR0cnMsXG4gIHVwZGF0ZTogdXBkYXRlQXR0cnNcbn07XG5cbi8qICAqL1xuXG5mdW5jdGlvbiB1cGRhdGVDbGFzcyAob2xkVm5vZGUsIHZub2RlKSB7XG4gIHZhciBlbCA9IHZub2RlLmVsbTtcbiAgdmFyIGRhdGEgPSB2bm9kZS5kYXRhO1xuICB2YXIgb2xkRGF0YSA9IG9sZFZub2RlLmRhdGE7XG4gIGlmIChcbiAgICBpc1VuZGVmKGRhdGEuc3RhdGljQ2xhc3MpICYmXG4gICAgaXNVbmRlZihkYXRhLmNsYXNzKSAmJiAoXG4gICAgICBpc1VuZGVmKG9sZERhdGEpIHx8IChcbiAgICAgICAgaXNVbmRlZihvbGREYXRhLnN0YXRpY0NsYXNzKSAmJlxuICAgICAgICBpc1VuZGVmKG9sZERhdGEuY2xhc3MpXG4gICAgICApXG4gICAgKVxuICApIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIHZhciBjbHMgPSBnZW5DbGFzc0ZvclZub2RlKHZub2RlKTtcblxuICAvLyBoYW5kbGUgdHJhbnNpdGlvbiBjbGFzc2VzXG4gIHZhciB0cmFuc2l0aW9uQ2xhc3MgPSBlbC5fdHJhbnNpdGlvbkNsYXNzZXM7XG4gIGlmIChpc0RlZih0cmFuc2l0aW9uQ2xhc3MpKSB7XG4gICAgY2xzID0gY29uY2F0KGNscywgc3RyaW5naWZ5Q2xhc3ModHJhbnNpdGlvbkNsYXNzKSk7XG4gIH1cblxuICAvLyBzZXQgdGhlIGNsYXNzXG4gIGlmIChjbHMgIT09IGVsLl9wcmV2Q2xhc3MpIHtcbiAgICBlbC5zZXRBdHRyaWJ1dGUoJ2NsYXNzJywgY2xzKTtcbiAgICBlbC5fcHJldkNsYXNzID0gY2xzO1xuICB9XG59XG5cbnZhciBrbGFzcyA9IHtcbiAgY3JlYXRlOiB1cGRhdGVDbGFzcyxcbiAgdXBkYXRlOiB1cGRhdGVDbGFzc1xufTtcblxuLyogICovXG5cbi8qICAqL1xuXG4vKiAgKi9cblxuLyogICovXG5cbi8vIGluIHNvbWUgY2FzZXMsIHRoZSBldmVudCB1c2VkIGhhcyB0byBiZSBkZXRlcm1pbmVkIGF0IHJ1bnRpbWVcbi8vIHNvIHdlIHVzZWQgc29tZSByZXNlcnZlZCB0b2tlbnMgZHVyaW5nIGNvbXBpbGUuXG52YXIgUkFOR0VfVE9LRU4gPSAnX19yJztcbnZhciBDSEVDS0JPWF9SQURJT19UT0tFTiA9ICdfX2MnO1xuXG4vKiAgKi9cblxuLy8gbm9ybWFsaXplIHYtbW9kZWwgZXZlbnQgdG9rZW5zIHRoYXQgY2FuIG9ubHkgYmUgZGV0ZXJtaW5lZCBhdCBydW50aW1lLlxuLy8gaXQncyBpbXBvcnRhbnQgdG8gcGxhY2UgdGhlIGV2ZW50IGFzIHRoZSBmaXJzdCBpbiB0aGUgYXJyYXkgYmVjYXVzZVxuLy8gdGhlIHdob2xlIHBvaW50IGlzIGVuc3VyaW5nIHRoZSB2LW1vZGVsIGNhbGxiYWNrIGdldHMgY2FsbGVkIGJlZm9yZVxuLy8gdXNlci1hdHRhY2hlZCBoYW5kbGVycy5cbmZ1bmN0aW9uIG5vcm1hbGl6ZUV2ZW50cyAob24pIHtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChpc0RlZihvbltSQU5HRV9UT0tFTl0pKSB7XG4gICAgLy8gSUUgaW5wdXRbdHlwZT1yYW5nZV0gb25seSBzdXBwb3J0cyBgY2hhbmdlYCBldmVudFxuICAgIHZhciBldmVudCA9IGlzSUUgPyAnY2hhbmdlJyA6ICdpbnB1dCc7XG4gICAgb25bZXZlbnRdID0gW10uY29uY2F0KG9uW1JBTkdFX1RPS0VOXSwgb25bZXZlbnRdIHx8IFtdKTtcbiAgICBkZWxldGUgb25bUkFOR0VfVE9LRU5dO1xuICB9XG4gIC8vIFRoaXMgd2FzIG9yaWdpbmFsbHkgaW50ZW5kZWQgdG8gZml4ICM0NTIxIGJ1dCBubyBsb25nZXIgbmVjZXNzYXJ5XG4gIC8vIGFmdGVyIDIuNS4gS2VlcGluZyBpdCBmb3IgYmFja3dhcmRzIGNvbXBhdCB3aXRoIGdlbmVyYXRlZCBjb2RlIGZyb20gPCAyLjRcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChpc0RlZihvbltDSEVDS0JPWF9SQURJT19UT0tFTl0pKSB7XG4gICAgb24uY2hhbmdlID0gW10uY29uY2F0KG9uW0NIRUNLQk9YX1JBRElPX1RPS0VOXSwgb24uY2hhbmdlIHx8IFtdKTtcbiAgICBkZWxldGUgb25bQ0hFQ0tCT1hfUkFESU9fVE9LRU5dO1xuICB9XG59XG5cbnZhciB0YXJnZXQkMTtcblxuZnVuY3Rpb24gY3JlYXRlT25jZUhhbmRsZXIkMSAoZXZlbnQsIGhhbmRsZXIsIGNhcHR1cmUpIHtcbiAgdmFyIF90YXJnZXQgPSB0YXJnZXQkMTsgLy8gc2F2ZSBjdXJyZW50IHRhcmdldCBlbGVtZW50IGluIGNsb3N1cmVcbiAgcmV0dXJuIGZ1bmN0aW9uIG9uY2VIYW5kbGVyICgpIHtcbiAgICB2YXIgcmVzID0gaGFuZGxlci5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgIGlmIChyZXMgIT09IG51bGwpIHtcbiAgICAgIHJlbW92ZSQyKGV2ZW50LCBvbmNlSGFuZGxlciwgY2FwdHVyZSwgX3RhcmdldCk7XG4gICAgfVxuICB9XG59XG5cbi8vICM5NDQ2OiBGaXJlZm94IDw9IDUzIChpbiBwYXJ0aWN1bGFyLCBFU1IgNTIpIGhhcyBpbmNvcnJlY3QgRXZlbnQudGltZVN0YW1wXG4vLyBpbXBsZW1lbnRhdGlvbiBhbmQgZG9lcyBub3QgZmlyZSBtaWNyb3Rhc2tzIGluIGJldHdlZW4gZXZlbnQgcHJvcGFnYXRpb24sIHNvXG4vLyBzYWZlIHRvIGV4Y2x1ZGUuXG52YXIgdXNlTWljcm90YXNrRml4ID0gaXNVc2luZ01pY3JvVGFzayAmJiAhKGlzRkYgJiYgTnVtYmVyKGlzRkZbMV0pIDw9IDUzKTtcblxuZnVuY3Rpb24gYWRkJDEgKFxuICBuYW1lLFxuICBoYW5kbGVyLFxuICBjYXB0dXJlLFxuICBwYXNzaXZlXG4pIHtcbiAgLy8gYXN5bmMgZWRnZSBjYXNlICM2NTY2OiBpbm5lciBjbGljayBldmVudCB0cmlnZ2VycyBwYXRjaCwgZXZlbnQgaGFuZGxlclxuICAvLyBhdHRhY2hlZCB0byBvdXRlciBlbGVtZW50IGR1cmluZyBwYXRjaCwgYW5kIHRyaWdnZXJlZCBhZ2Fpbi4gVGhpc1xuICAvLyBoYXBwZW5zIGJlY2F1c2UgYnJvd3NlcnMgZmlyZSBtaWNyb3Rhc2sgdGlja3MgYmV0d2VlbiBldmVudCBwcm9wYWdhdGlvbi5cbiAgLy8gdGhlIHNvbHV0aW9uIGlzIHNpbXBsZTogd2Ugc2F2ZSB0aGUgdGltZXN0YW1wIHdoZW4gYSBoYW5kbGVyIGlzIGF0dGFjaGVkLFxuICAvLyBhbmQgdGhlIGhhbmRsZXIgd291bGQgb25seSBmaXJlIGlmIHRoZSBldmVudCBwYXNzZWQgdG8gaXQgd2FzIGZpcmVkXG4gIC8vIEFGVEVSIGl0IHdhcyBhdHRhY2hlZC5cbiAgaWYgKHVzZU1pY3JvdGFza0ZpeCkge1xuICAgIHZhciBhdHRhY2hlZFRpbWVzdGFtcCA9IGN1cnJlbnRGbHVzaFRpbWVzdGFtcDtcbiAgICB2YXIgb3JpZ2luYWwgPSBoYW5kbGVyO1xuICAgIGhhbmRsZXIgPSBvcmlnaW5hbC5fd3JhcHBlciA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICBpZiAoXG4gICAgICAgIC8vIG5vIGJ1YmJsaW5nLCBzaG91bGQgYWx3YXlzIGZpcmUuXG4gICAgICAgIC8vIHRoaXMgaXMganVzdCBhIHNhZmV0eSBuZXQgaW4gY2FzZSBldmVudC50aW1lU3RhbXAgaXMgdW5yZWxpYWJsZSBpblxuICAgICAgICAvLyBjZXJ0YWluIHdlaXJkIGVudmlyb25tZW50cy4uLlxuICAgICAgICBlLnRhcmdldCA9PT0gZS5jdXJyZW50VGFyZ2V0IHx8XG4gICAgICAgIC8vIGV2ZW50IGlzIGZpcmVkIGFmdGVyIGhhbmRsZXIgYXR0YWNobWVudFxuICAgICAgICBlLnRpbWVTdGFtcCA+PSBhdHRhY2hlZFRpbWVzdGFtcCB8fFxuICAgICAgICAvLyBiYWlsIGZvciBlbnZpcm9ubWVudHMgdGhhdCBoYXZlIGJ1Z2d5IGV2ZW50LnRpbWVTdGFtcCBpbXBsZW1lbnRhdGlvbnNcbiAgICAgICAgLy8gIzk0NjIgaU9TIDkgYnVnOiBldmVudC50aW1lU3RhbXAgaXMgMCBhZnRlciBoaXN0b3J5LnB1c2hTdGF0ZVxuICAgICAgICAvLyAjOTY4MSBRdFdlYkVuZ2luZSBldmVudC50aW1lU3RhbXAgaXMgbmVnYXRpdmUgdmFsdWVcbiAgICAgICAgZS50aW1lU3RhbXAgPD0gMCB8fFxuICAgICAgICAvLyAjOTQ0OCBiYWlsIGlmIGV2ZW50IGlzIGZpcmVkIGluIGFub3RoZXIgZG9jdW1lbnQgaW4gYSBtdWx0aS1wYWdlXG4gICAgICAgIC8vIGVsZWN0cm9uL253LmpzIGFwcCwgc2luY2UgZXZlbnQudGltZVN0YW1wIHdpbGwgYmUgdXNpbmcgYSBkaWZmZXJlbnRcbiAgICAgICAgLy8gc3RhcnRpbmcgcmVmZXJlbmNlXG4gICAgICAgIGUudGFyZ2V0Lm93bmVyRG9jdW1lbnQgIT09IGRvY3VtZW50XG4gICAgICApIHtcbiAgICAgICAgcmV0dXJuIG9yaWdpbmFsLmFwcGx5KHRoaXMsIGFyZ3VtZW50cylcbiAgICAgIH1cbiAgICB9O1xuICB9XG4gIHRhcmdldCQxLmFkZEV2ZW50TGlzdGVuZXIoXG4gICAgbmFtZSxcbiAgICBoYW5kbGVyLFxuICAgIHN1cHBvcnRzUGFzc2l2ZVxuICAgICAgPyB7IGNhcHR1cmU6IGNhcHR1cmUsIHBhc3NpdmU6IHBhc3NpdmUgfVxuICAgICAgOiBjYXB0dXJlXG4gICk7XG59XG5cbmZ1bmN0aW9uIHJlbW92ZSQyIChcbiAgbmFtZSxcbiAgaGFuZGxlcixcbiAgY2FwdHVyZSxcbiAgX3RhcmdldFxuKSB7XG4gIChfdGFyZ2V0IHx8IHRhcmdldCQxKS5yZW1vdmVFdmVudExpc3RlbmVyKFxuICAgIG5hbWUsXG4gICAgaGFuZGxlci5fd3JhcHBlciB8fCBoYW5kbGVyLFxuICAgIGNhcHR1cmVcbiAgKTtcbn1cblxuZnVuY3Rpb24gdXBkYXRlRE9NTGlzdGVuZXJzIChvbGRWbm9kZSwgdm5vZGUpIHtcbiAgaWYgKGlzVW5kZWYob2xkVm5vZGUuZGF0YS5vbikgJiYgaXNVbmRlZih2bm9kZS5kYXRhLm9uKSkge1xuICAgIHJldHVyblxuICB9XG4gIHZhciBvbiA9IHZub2RlLmRhdGEub24gfHwge307XG4gIHZhciBvbGRPbiA9IG9sZFZub2RlLmRhdGEub24gfHwge307XG4gIHRhcmdldCQxID0gdm5vZGUuZWxtO1xuICBub3JtYWxpemVFdmVudHMob24pO1xuICB1cGRhdGVMaXN0ZW5lcnMob24sIG9sZE9uLCBhZGQkMSwgcmVtb3ZlJDIsIGNyZWF0ZU9uY2VIYW5kbGVyJDEsIHZub2RlLmNvbnRleHQpO1xuICB0YXJnZXQkMSA9IHVuZGVmaW5lZDtcbn1cblxudmFyIGV2ZW50cyA9IHtcbiAgY3JlYXRlOiB1cGRhdGVET01MaXN0ZW5lcnMsXG4gIHVwZGF0ZTogdXBkYXRlRE9NTGlzdGVuZXJzXG59O1xuXG4vKiAgKi9cblxudmFyIHN2Z0NvbnRhaW5lcjtcblxuZnVuY3Rpb24gdXBkYXRlRE9NUHJvcHMgKG9sZFZub2RlLCB2bm9kZSkge1xuICBpZiAoaXNVbmRlZihvbGRWbm9kZS5kYXRhLmRvbVByb3BzKSAmJiBpc1VuZGVmKHZub2RlLmRhdGEuZG9tUHJvcHMpKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgdmFyIGtleSwgY3VyO1xuICB2YXIgZWxtID0gdm5vZGUuZWxtO1xuICB2YXIgb2xkUHJvcHMgPSBvbGRWbm9kZS5kYXRhLmRvbVByb3BzIHx8IHt9O1xuICB2YXIgcHJvcHMgPSB2bm9kZS5kYXRhLmRvbVByb3BzIHx8IHt9O1xuICAvLyBjbG9uZSBvYnNlcnZlZCBvYmplY3RzLCBhcyB0aGUgdXNlciBwcm9iYWJseSB3YW50cyB0byBtdXRhdGUgaXRcbiAgaWYgKGlzRGVmKHByb3BzLl9fb2JfXykpIHtcbiAgICBwcm9wcyA9IHZub2RlLmRhdGEuZG9tUHJvcHMgPSBleHRlbmQoe30sIHByb3BzKTtcbiAgfVxuXG4gIGZvciAoa2V5IGluIG9sZFByb3BzKSB7XG4gICAgaWYgKCEoa2V5IGluIHByb3BzKSkge1xuICAgICAgZWxtW2tleV0gPSAnJztcbiAgICB9XG4gIH1cblxuICBmb3IgKGtleSBpbiBwcm9wcykge1xuICAgIGN1ciA9IHByb3BzW2tleV07XG4gICAgLy8gaWdub3JlIGNoaWxkcmVuIGlmIHRoZSBub2RlIGhhcyB0ZXh0Q29udGVudCBvciBpbm5lckhUTUwsXG4gICAgLy8gYXMgdGhlc2Ugd2lsbCB0aHJvdyBhd2F5IGV4aXN0aW5nIERPTSBub2RlcyBhbmQgY2F1c2UgcmVtb3ZhbCBlcnJvcnNcbiAgICAvLyBvbiBzdWJzZXF1ZW50IHBhdGNoZXMgKCMzMzYwKVxuICAgIGlmIChrZXkgPT09ICd0ZXh0Q29udGVudCcgfHwga2V5ID09PSAnaW5uZXJIVE1MJykge1xuICAgICAgaWYgKHZub2RlLmNoaWxkcmVuKSB7IHZub2RlLmNoaWxkcmVuLmxlbmd0aCA9IDA7IH1cbiAgICAgIGlmIChjdXIgPT09IG9sZFByb3BzW2tleV0pIHsgY29udGludWUgfVxuICAgICAgLy8gIzY2MDEgd29yayBhcm91bmQgQ2hyb21lIHZlcnNpb24gPD0gNTUgYnVnIHdoZXJlIHNpbmdsZSB0ZXh0Tm9kZVxuICAgICAgLy8gcmVwbGFjZWQgYnkgaW5uZXJIVE1ML3RleHRDb250ZW50IHJldGFpbnMgaXRzIHBhcmVudE5vZGUgcHJvcGVydHlcbiAgICAgIGlmIChlbG0uY2hpbGROb2Rlcy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgZWxtLnJlbW92ZUNoaWxkKGVsbS5jaGlsZE5vZGVzWzBdKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoa2V5ID09PSAndmFsdWUnICYmIGVsbS50YWdOYW1lICE9PSAnUFJPR1JFU1MnKSB7XG4gICAgICAvLyBzdG9yZSB2YWx1ZSBhcyBfdmFsdWUgYXMgd2VsbCBzaW5jZVxuICAgICAgLy8gbm9uLXN0cmluZyB2YWx1ZXMgd2lsbCBiZSBzdHJpbmdpZmllZFxuICAgICAgZWxtLl92YWx1ZSA9IGN1cjtcbiAgICAgIC8vIGF2b2lkIHJlc2V0dGluZyBjdXJzb3IgcG9zaXRpb24gd2hlbiB2YWx1ZSBpcyB0aGUgc2FtZVxuICAgICAgdmFyIHN0ckN1ciA9IGlzVW5kZWYoY3VyKSA/ICcnIDogU3RyaW5nKGN1cik7XG4gICAgICBpZiAoc2hvdWxkVXBkYXRlVmFsdWUoZWxtLCBzdHJDdXIpKSB7XG4gICAgICAgIGVsbS52YWx1ZSA9IHN0ckN1cjtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGtleSA9PT0gJ2lubmVySFRNTCcgJiYgaXNTVkcoZWxtLnRhZ05hbWUpICYmIGlzVW5kZWYoZWxtLmlubmVySFRNTCkpIHtcbiAgICAgIC8vIElFIGRvZXNuJ3Qgc3VwcG9ydCBpbm5lckhUTUwgZm9yIFNWRyBlbGVtZW50c1xuICAgICAgc3ZnQ29udGFpbmVyID0gc3ZnQ29udGFpbmVyIHx8IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgc3ZnQ29udGFpbmVyLmlubmVySFRNTCA9IFwiPHN2Zz5cIiArIGN1ciArIFwiPC9zdmc+XCI7XG4gICAgICB2YXIgc3ZnID0gc3ZnQ29udGFpbmVyLmZpcnN0Q2hpbGQ7XG4gICAgICB3aGlsZSAoZWxtLmZpcnN0Q2hpbGQpIHtcbiAgICAgICAgZWxtLnJlbW92ZUNoaWxkKGVsbS5maXJzdENoaWxkKTtcbiAgICAgIH1cbiAgICAgIHdoaWxlIChzdmcuZmlyc3RDaGlsZCkge1xuICAgICAgICBlbG0uYXBwZW5kQ2hpbGQoc3ZnLmZpcnN0Q2hpbGQpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoXG4gICAgICAvLyBza2lwIHRoZSB1cGRhdGUgaWYgb2xkIGFuZCBuZXcgVkRPTSBzdGF0ZSBpcyB0aGUgc2FtZS5cbiAgICAgIC8vIGB2YWx1ZWAgaXMgaGFuZGxlZCBzZXBhcmF0ZWx5IGJlY2F1c2UgdGhlIERPTSB2YWx1ZSBtYXkgYmUgdGVtcG9yYXJpbHlcbiAgICAgIC8vIG91dCBvZiBzeW5jIHdpdGggVkRPTSBzdGF0ZSBkdWUgdG8gZm9jdXMsIGNvbXBvc2l0aW9uIGFuZCBtb2RpZmllcnMuXG4gICAgICAvLyBUaGlzICAjNDUyMSBieSBza2lwcGluZyB0aGUgdW5uZWNlc3NhcnkgYGNoZWNrZWRgIHVwZGF0ZS5cbiAgICAgIGN1ciAhPT0gb2xkUHJvcHNba2V5XVxuICAgICkge1xuICAgICAgLy8gc29tZSBwcm9wZXJ0eSB1cGRhdGVzIGNhbiB0aHJvd1xuICAgICAgLy8gZS5nLiBgdmFsdWVgIG9uIDxwcm9ncmVzcz4gdy8gbm9uLWZpbml0ZSB2YWx1ZVxuICAgICAgdHJ5IHtcbiAgICAgICAgZWxtW2tleV0gPSBjdXI7XG4gICAgICB9IGNhdGNoIChlKSB7fVxuICAgIH1cbiAgfVxufVxuXG4vLyBjaGVjayBwbGF0Zm9ybXMvd2ViL3V0aWwvYXR0cnMuanMgYWNjZXB0VmFsdWVcblxuXG5mdW5jdGlvbiBzaG91bGRVcGRhdGVWYWx1ZSAoZWxtLCBjaGVja1ZhbCkge1xuICByZXR1cm4gKCFlbG0uY29tcG9zaW5nICYmIChcbiAgICBlbG0udGFnTmFtZSA9PT0gJ09QVElPTicgfHxcbiAgICBpc05vdEluRm9jdXNBbmREaXJ0eShlbG0sIGNoZWNrVmFsKSB8fFxuICAgIGlzRGlydHlXaXRoTW9kaWZpZXJzKGVsbSwgY2hlY2tWYWwpXG4gICkpXG59XG5cbmZ1bmN0aW9uIGlzTm90SW5Gb2N1c0FuZERpcnR5IChlbG0sIGNoZWNrVmFsKSB7XG4gIC8vIHJldHVybiB0cnVlIHdoZW4gdGV4dGJveCAoLm51bWJlciBhbmQgLnRyaW0pIGxvc2VzIGZvY3VzIGFuZCBpdHMgdmFsdWUgaXNcbiAgLy8gbm90IGVxdWFsIHRvIHRoZSB1cGRhdGVkIHZhbHVlXG4gIHZhciBub3RJbkZvY3VzID0gdHJ1ZTtcbiAgLy8gIzYxNTdcbiAgLy8gd29yayBhcm91bmQgSUUgYnVnIHdoZW4gYWNjZXNzaW5nIGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgaW4gYW4gaWZyYW1lXG4gIHRyeSB7IG5vdEluRm9jdXMgPSBkb2N1bWVudC5hY3RpdmVFbGVtZW50ICE9PSBlbG07IH0gY2F0Y2ggKGUpIHt9XG4gIHJldHVybiBub3RJbkZvY3VzICYmIGVsbS52YWx1ZSAhPT0gY2hlY2tWYWxcbn1cblxuZnVuY3Rpb24gaXNEaXJ0eVdpdGhNb2RpZmllcnMgKGVsbSwgbmV3VmFsKSB7XG4gIHZhciB2YWx1ZSA9IGVsbS52YWx1ZTtcbiAgdmFyIG1vZGlmaWVycyA9IGVsbS5fdk1vZGlmaWVyczsgLy8gaW5qZWN0ZWQgYnkgdi1tb2RlbCBydW50aW1lXG4gIGlmIChpc0RlZihtb2RpZmllcnMpKSB7XG4gICAgaWYgKG1vZGlmaWVycy5udW1iZXIpIHtcbiAgICAgIHJldHVybiB0b051bWJlcih2YWx1ZSkgIT09IHRvTnVtYmVyKG5ld1ZhbClcbiAgICB9XG4gICAgaWYgKG1vZGlmaWVycy50cmltKSB7XG4gICAgICByZXR1cm4gdmFsdWUudHJpbSgpICE9PSBuZXdWYWwudHJpbSgpXG4gICAgfVxuICB9XG4gIHJldHVybiB2YWx1ZSAhPT0gbmV3VmFsXG59XG5cbnZhciBkb21Qcm9wcyA9IHtcbiAgY3JlYXRlOiB1cGRhdGVET01Qcm9wcyxcbiAgdXBkYXRlOiB1cGRhdGVET01Qcm9wc1xufTtcblxuLyogICovXG5cbnZhciBwYXJzZVN0eWxlVGV4dCA9IGNhY2hlZChmdW5jdGlvbiAoY3NzVGV4dCkge1xuICB2YXIgcmVzID0ge307XG4gIHZhciBsaXN0RGVsaW1pdGVyID0gLzsoPyFbXihdKlxcKSkvZztcbiAgdmFyIHByb3BlcnR5RGVsaW1pdGVyID0gLzooLispLztcbiAgY3NzVGV4dC5zcGxpdChsaXN0RGVsaW1pdGVyKS5mb3JFYWNoKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgaWYgKGl0ZW0pIHtcbiAgICAgIHZhciB0bXAgPSBpdGVtLnNwbGl0KHByb3BlcnR5RGVsaW1pdGVyKTtcbiAgICAgIHRtcC5sZW5ndGggPiAxICYmIChyZXNbdG1wWzBdLnRyaW0oKV0gPSB0bXBbMV0udHJpbSgpKTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gcmVzXG59KTtcblxuLy8gbWVyZ2Ugc3RhdGljIGFuZCBkeW5hbWljIHN0eWxlIGRhdGEgb24gdGhlIHNhbWUgdm5vZGVcbmZ1bmN0aW9uIG5vcm1hbGl6ZVN0eWxlRGF0YSAoZGF0YSkge1xuICB2YXIgc3R5bGUgPSBub3JtYWxpemVTdHlsZUJpbmRpbmcoZGF0YS5zdHlsZSk7XG4gIC8vIHN0YXRpYyBzdHlsZSBpcyBwcmUtcHJvY2Vzc2VkIGludG8gYW4gb2JqZWN0IGR1cmluZyBjb21waWxhdGlvblxuICAvLyBhbmQgaXMgYWx3YXlzIGEgZnJlc2ggb2JqZWN0LCBzbyBpdCdzIHNhZmUgdG8gbWVyZ2UgaW50byBpdFxuICByZXR1cm4gZGF0YS5zdGF0aWNTdHlsZVxuICAgID8gZXh0ZW5kKGRhdGEuc3RhdGljU3R5bGUsIHN0eWxlKVxuICAgIDogc3R5bGVcbn1cblxuLy8gbm9ybWFsaXplIHBvc3NpYmxlIGFycmF5IC8gc3RyaW5nIHZhbHVlcyBpbnRvIE9iamVjdFxuZnVuY3Rpb24gbm9ybWFsaXplU3R5bGVCaW5kaW5nIChiaW5kaW5nU3R5bGUpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoYmluZGluZ1N0eWxlKSkge1xuICAgIHJldHVybiB0b09iamVjdChiaW5kaW5nU3R5bGUpXG4gIH1cbiAgaWYgKHR5cGVvZiBiaW5kaW5nU3R5bGUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHBhcnNlU3R5bGVUZXh0KGJpbmRpbmdTdHlsZSlcbiAgfVxuICByZXR1cm4gYmluZGluZ1N0eWxlXG59XG5cbi8qKlxuICogcGFyZW50IGNvbXBvbmVudCBzdHlsZSBzaG91bGQgYmUgYWZ0ZXIgY2hpbGQnc1xuICogc28gdGhhdCBwYXJlbnQgY29tcG9uZW50J3Mgc3R5bGUgY291bGQgb3ZlcnJpZGUgaXRcbiAqL1xuZnVuY3Rpb24gZ2V0U3R5bGUgKHZub2RlLCBjaGVja0NoaWxkKSB7XG4gIHZhciByZXMgPSB7fTtcbiAgdmFyIHN0eWxlRGF0YTtcblxuICBpZiAoY2hlY2tDaGlsZCkge1xuICAgIHZhciBjaGlsZE5vZGUgPSB2bm9kZTtcbiAgICB3aGlsZSAoY2hpbGROb2RlLmNvbXBvbmVudEluc3RhbmNlKSB7XG4gICAgICBjaGlsZE5vZGUgPSBjaGlsZE5vZGUuY29tcG9uZW50SW5zdGFuY2UuX3Zub2RlO1xuICAgICAgaWYgKFxuICAgICAgICBjaGlsZE5vZGUgJiYgY2hpbGROb2RlLmRhdGEgJiZcbiAgICAgICAgKHN0eWxlRGF0YSA9IG5vcm1hbGl6ZVN0eWxlRGF0YShjaGlsZE5vZGUuZGF0YSkpXG4gICAgICApIHtcbiAgICAgICAgZXh0ZW5kKHJlcywgc3R5bGVEYXRhKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAoKHN0eWxlRGF0YSA9IG5vcm1hbGl6ZVN0eWxlRGF0YSh2bm9kZS5kYXRhKSkpIHtcbiAgICBleHRlbmQocmVzLCBzdHlsZURhdGEpO1xuICB9XG5cbiAgdmFyIHBhcmVudE5vZGUgPSB2bm9kZTtcbiAgd2hpbGUgKChwYXJlbnROb2RlID0gcGFyZW50Tm9kZS5wYXJlbnQpKSB7XG4gICAgaWYgKHBhcmVudE5vZGUuZGF0YSAmJiAoc3R5bGVEYXRhID0gbm9ybWFsaXplU3R5bGVEYXRhKHBhcmVudE5vZGUuZGF0YSkpKSB7XG4gICAgICBleHRlbmQocmVzLCBzdHlsZURhdGEpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbi8qICAqL1xuXG52YXIgY3NzVmFyUkUgPSAvXi0tLztcbnZhciBpbXBvcnRhbnRSRSA9IC9cXHMqIWltcG9ydGFudCQvO1xudmFyIHNldFByb3AgPSBmdW5jdGlvbiAoZWwsIG5hbWUsIHZhbCkge1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKGNzc1ZhclJFLnRlc3QobmFtZSkpIHtcbiAgICBlbC5zdHlsZS5zZXRQcm9wZXJ0eShuYW1lLCB2YWwpO1xuICB9IGVsc2UgaWYgKGltcG9ydGFudFJFLnRlc3QodmFsKSkge1xuICAgIGVsLnN0eWxlLnNldFByb3BlcnR5KGh5cGhlbmF0ZShuYW1lKSwgdmFsLnJlcGxhY2UoaW1wb3J0YW50UkUsICcnKSwgJ2ltcG9ydGFudCcpO1xuICB9IGVsc2Uge1xuICAgIHZhciBub3JtYWxpemVkTmFtZSA9IG5vcm1hbGl6ZShuYW1lKTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWwpKSB7XG4gICAgICAvLyBTdXBwb3J0IHZhbHVlcyBhcnJheSBjcmVhdGVkIGJ5IGF1dG9wcmVmaXhlciwgZS5nLlxuICAgICAgLy8ge2Rpc3BsYXk6IFtcIi13ZWJraXQtYm94XCIsIFwiLW1zLWZsZXhib3hcIiwgXCJmbGV4XCJdfVxuICAgICAgLy8gU2V0IHRoZW0gb25lIGJ5IG9uZSwgYW5kIHRoZSBicm93c2VyIHdpbGwgb25seSBzZXQgdGhvc2UgaXQgY2FuIHJlY29nbml6ZVxuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHZhbC5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBlbC5zdHlsZVtub3JtYWxpemVkTmFtZV0gPSB2YWxbaV07XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsLnN0eWxlW25vcm1hbGl6ZWROYW1lXSA9IHZhbDtcbiAgICB9XG4gIH1cbn07XG5cbnZhciB2ZW5kb3JOYW1lcyA9IFsnV2Via2l0JywgJ01veicsICdtcyddO1xuXG52YXIgZW1wdHlTdHlsZTtcbnZhciBub3JtYWxpemUgPSBjYWNoZWQoZnVuY3Rpb24gKHByb3ApIHtcbiAgZW1wdHlTdHlsZSA9IGVtcHR5U3R5bGUgfHwgZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jykuc3R5bGU7XG4gIHByb3AgPSBjYW1lbGl6ZShwcm9wKTtcbiAgaWYgKHByb3AgIT09ICdmaWx0ZXInICYmIChwcm9wIGluIGVtcHR5U3R5bGUpKSB7XG4gICAgcmV0dXJuIHByb3BcbiAgfVxuICB2YXIgY2FwTmFtZSA9IHByb3AuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBwcm9wLnNsaWNlKDEpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHZlbmRvck5hbWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIG5hbWUgPSB2ZW5kb3JOYW1lc1tpXSArIGNhcE5hbWU7XG4gICAgaWYgKG5hbWUgaW4gZW1wdHlTdHlsZSkge1xuICAgICAgcmV0dXJuIG5hbWVcbiAgICB9XG4gIH1cbn0pO1xuXG5mdW5jdGlvbiB1cGRhdGVTdHlsZSAob2xkVm5vZGUsIHZub2RlKSB7XG4gIHZhciBkYXRhID0gdm5vZGUuZGF0YTtcbiAgdmFyIG9sZERhdGEgPSBvbGRWbm9kZS5kYXRhO1xuXG4gIGlmIChpc1VuZGVmKGRhdGEuc3RhdGljU3R5bGUpICYmIGlzVW5kZWYoZGF0YS5zdHlsZSkgJiZcbiAgICBpc1VuZGVmKG9sZERhdGEuc3RhdGljU3R5bGUpICYmIGlzVW5kZWYob2xkRGF0YS5zdHlsZSlcbiAgKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICB2YXIgY3VyLCBuYW1lO1xuICB2YXIgZWwgPSB2bm9kZS5lbG07XG4gIHZhciBvbGRTdGF0aWNTdHlsZSA9IG9sZERhdGEuc3RhdGljU3R5bGU7XG4gIHZhciBvbGRTdHlsZUJpbmRpbmcgPSBvbGREYXRhLm5vcm1hbGl6ZWRTdHlsZSB8fCBvbGREYXRhLnN0eWxlIHx8IHt9O1xuXG4gIC8vIGlmIHN0YXRpYyBzdHlsZSBleGlzdHMsIHN0eWxlYmluZGluZyBhbHJlYWR5IG1lcmdlZCBpbnRvIGl0IHdoZW4gZG9pbmcgbm9ybWFsaXplU3R5bGVEYXRhXG4gIHZhciBvbGRTdHlsZSA9IG9sZFN0YXRpY1N0eWxlIHx8IG9sZFN0eWxlQmluZGluZztcblxuICB2YXIgc3R5bGUgPSBub3JtYWxpemVTdHlsZUJpbmRpbmcodm5vZGUuZGF0YS5zdHlsZSkgfHwge307XG5cbiAgLy8gc3RvcmUgbm9ybWFsaXplZCBzdHlsZSB1bmRlciBhIGRpZmZlcmVudCBrZXkgZm9yIG5leHQgZGlmZlxuICAvLyBtYWtlIHN1cmUgdG8gY2xvbmUgaXQgaWYgaXQncyByZWFjdGl2ZSwgc2luY2UgdGhlIHVzZXIgbGlrZWx5IHdhbnRzXG4gIC8vIHRvIG11dGF0ZSBpdC5cbiAgdm5vZGUuZGF0YS5ub3JtYWxpemVkU3R5bGUgPSBpc0RlZihzdHlsZS5fX29iX18pXG4gICAgPyBleHRlbmQoe30sIHN0eWxlKVxuICAgIDogc3R5bGU7XG5cbiAgdmFyIG5ld1N0eWxlID0gZ2V0U3R5bGUodm5vZGUsIHRydWUpO1xuXG4gIGZvciAobmFtZSBpbiBvbGRTdHlsZSkge1xuICAgIGlmIChpc1VuZGVmKG5ld1N0eWxlW25hbWVdKSkge1xuICAgICAgc2V0UHJvcChlbCwgbmFtZSwgJycpO1xuICAgIH1cbiAgfVxuICBmb3IgKG5hbWUgaW4gbmV3U3R5bGUpIHtcbiAgICBjdXIgPSBuZXdTdHlsZVtuYW1lXTtcbiAgICBpZiAoY3VyICE9PSBvbGRTdHlsZVtuYW1lXSkge1xuICAgICAgLy8gaWU5IHNldHRpbmcgdG8gbnVsbCBoYXMgbm8gZWZmZWN0LCBtdXN0IHVzZSBlbXB0eSBzdHJpbmdcbiAgICAgIHNldFByb3AoZWwsIG5hbWUsIGN1ciA9PSBudWxsID8gJycgOiBjdXIpO1xuICAgIH1cbiAgfVxufVxuXG52YXIgc3R5bGUgPSB7XG4gIGNyZWF0ZTogdXBkYXRlU3R5bGUsXG4gIHVwZGF0ZTogdXBkYXRlU3R5bGVcbn07XG5cbi8qICAqL1xuXG52YXIgd2hpdGVzcGFjZVJFID0gL1xccysvO1xuXG4vKipcbiAqIEFkZCBjbGFzcyB3aXRoIGNvbXBhdGliaWxpdHkgZm9yIFNWRyBzaW5jZSBjbGFzc0xpc3QgaXMgbm90IHN1cHBvcnRlZCBvblxuICogU1ZHIGVsZW1lbnRzIGluIElFXG4gKi9cbmZ1bmN0aW9uIGFkZENsYXNzIChlbCwgY2xzKSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoIWNscyB8fCAhKGNscyA9IGNscy50cmltKCkpKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICBpZiAoZWwuY2xhc3NMaXN0KSB7XG4gICAgaWYgKGNscy5pbmRleE9mKCcgJykgPiAtMSkge1xuICAgICAgY2xzLnNwbGl0KHdoaXRlc3BhY2VSRSkuZm9yRWFjaChmdW5jdGlvbiAoYykgeyByZXR1cm4gZWwuY2xhc3NMaXN0LmFkZChjKTsgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsLmNsYXNzTGlzdC5hZGQoY2xzKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdmFyIGN1ciA9IFwiIFwiICsgKGVsLmdldEF0dHJpYnV0ZSgnY2xhc3MnKSB8fCAnJykgKyBcIiBcIjtcbiAgICBpZiAoY3VyLmluZGV4T2YoJyAnICsgY2xzICsgJyAnKSA8IDApIHtcbiAgICAgIGVsLnNldEF0dHJpYnV0ZSgnY2xhc3MnLCAoY3VyICsgY2xzKS50cmltKCkpO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIFJlbW92ZSBjbGFzcyB3aXRoIGNvbXBhdGliaWxpdHkgZm9yIFNWRyBzaW5jZSBjbGFzc0xpc3QgaXMgbm90IHN1cHBvcnRlZCBvblxuICogU1ZHIGVsZW1lbnRzIGluIElFXG4gKi9cbmZ1bmN0aW9uIHJlbW92ZUNsYXNzIChlbCwgY2xzKSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoIWNscyB8fCAhKGNscyA9IGNscy50cmltKCkpKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICBpZiAoZWwuY2xhc3NMaXN0KSB7XG4gICAgaWYgKGNscy5pbmRleE9mKCcgJykgPiAtMSkge1xuICAgICAgY2xzLnNwbGl0KHdoaXRlc3BhY2VSRSkuZm9yRWFjaChmdW5jdGlvbiAoYykgeyByZXR1cm4gZWwuY2xhc3NMaXN0LnJlbW92ZShjKTsgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsLmNsYXNzTGlzdC5yZW1vdmUoY2xzKTtcbiAgICB9XG4gICAgaWYgKCFlbC5jbGFzc0xpc3QubGVuZ3RoKSB7XG4gICAgICBlbC5yZW1vdmVBdHRyaWJ1dGUoJ2NsYXNzJyk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhciBjdXIgPSBcIiBcIiArIChlbC5nZXRBdHRyaWJ1dGUoJ2NsYXNzJykgfHwgJycpICsgXCIgXCI7XG4gICAgdmFyIHRhciA9ICcgJyArIGNscyArICcgJztcbiAgICB3aGlsZSAoY3VyLmluZGV4T2YodGFyKSA+PSAwKSB7XG4gICAgICBjdXIgPSBjdXIucmVwbGFjZSh0YXIsICcgJyk7XG4gICAgfVxuICAgIGN1ciA9IGN1ci50cmltKCk7XG4gICAgaWYgKGN1cikge1xuICAgICAgZWwuc2V0QXR0cmlidXRlKCdjbGFzcycsIGN1cik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsLnJlbW92ZUF0dHJpYnV0ZSgnY2xhc3MnKTtcbiAgICB9XG4gIH1cbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIHJlc29sdmVUcmFuc2l0aW9uIChkZWYkJDEpIHtcbiAgaWYgKCFkZWYkJDEpIHtcbiAgICByZXR1cm5cbiAgfVxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICBpZiAodHlwZW9mIGRlZiQkMSA9PT0gJ29iamVjdCcpIHtcbiAgICB2YXIgcmVzID0ge307XG4gICAgaWYgKGRlZiQkMS5jc3MgIT09IGZhbHNlKSB7XG4gICAgICBleHRlbmQocmVzLCBhdXRvQ3NzVHJhbnNpdGlvbihkZWYkJDEubmFtZSB8fCAndicpKTtcbiAgICB9XG4gICAgZXh0ZW5kKHJlcywgZGVmJCQxKTtcbiAgICByZXR1cm4gcmVzXG4gIH0gZWxzZSBpZiAodHlwZW9mIGRlZiQkMSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gYXV0b0Nzc1RyYW5zaXRpb24oZGVmJCQxKVxuICB9XG59XG5cbnZhciBhdXRvQ3NzVHJhbnNpdGlvbiA9IGNhY2hlZChmdW5jdGlvbiAobmFtZSkge1xuICByZXR1cm4ge1xuICAgIGVudGVyQ2xhc3M6IChuYW1lICsgXCItZW50ZXJcIiksXG4gICAgZW50ZXJUb0NsYXNzOiAobmFtZSArIFwiLWVudGVyLXRvXCIpLFxuICAgIGVudGVyQWN0aXZlQ2xhc3M6IChuYW1lICsgXCItZW50ZXItYWN0aXZlXCIpLFxuICAgIGxlYXZlQ2xhc3M6IChuYW1lICsgXCItbGVhdmVcIiksXG4gICAgbGVhdmVUb0NsYXNzOiAobmFtZSArIFwiLWxlYXZlLXRvXCIpLFxuICAgIGxlYXZlQWN0aXZlQ2xhc3M6IChuYW1lICsgXCItbGVhdmUtYWN0aXZlXCIpXG4gIH1cbn0pO1xuXG52YXIgaGFzVHJhbnNpdGlvbiA9IGluQnJvd3NlciAmJiAhaXNJRTk7XG52YXIgVFJBTlNJVElPTiA9ICd0cmFuc2l0aW9uJztcbnZhciBBTklNQVRJT04gPSAnYW5pbWF0aW9uJztcblxuLy8gVHJhbnNpdGlvbiBwcm9wZXJ0eS9ldmVudCBzbmlmZmluZ1xudmFyIHRyYW5zaXRpb25Qcm9wID0gJ3RyYW5zaXRpb24nO1xudmFyIHRyYW5zaXRpb25FbmRFdmVudCA9ICd0cmFuc2l0aW9uZW5kJztcbnZhciBhbmltYXRpb25Qcm9wID0gJ2FuaW1hdGlvbic7XG52YXIgYW5pbWF0aW9uRW5kRXZlbnQgPSAnYW5pbWF0aW9uZW5kJztcbmlmIChoYXNUcmFuc2l0aW9uKSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAod2luZG93Lm9udHJhbnNpdGlvbmVuZCA9PT0gdW5kZWZpbmVkICYmXG4gICAgd2luZG93Lm9ud2Via2l0dHJhbnNpdGlvbmVuZCAhPT0gdW5kZWZpbmVkXG4gICkge1xuICAgIHRyYW5zaXRpb25Qcm9wID0gJ1dlYmtpdFRyYW5zaXRpb24nO1xuICAgIHRyYW5zaXRpb25FbmRFdmVudCA9ICd3ZWJraXRUcmFuc2l0aW9uRW5kJztcbiAgfVxuICBpZiAod2luZG93Lm9uYW5pbWF0aW9uZW5kID09PSB1bmRlZmluZWQgJiZcbiAgICB3aW5kb3cub253ZWJraXRhbmltYXRpb25lbmQgIT09IHVuZGVmaW5lZFxuICApIHtcbiAgICBhbmltYXRpb25Qcm9wID0gJ1dlYmtpdEFuaW1hdGlvbic7XG4gICAgYW5pbWF0aW9uRW5kRXZlbnQgPSAnd2Via2l0QW5pbWF0aW9uRW5kJztcbiAgfVxufVxuXG4vLyBiaW5kaW5nIHRvIHdpbmRvdyBpcyBuZWNlc3NhcnkgdG8gbWFrZSBob3QgcmVsb2FkIHdvcmsgaW4gSUUgaW4gc3RyaWN0IG1vZGVcbnZhciByYWYgPSBpbkJyb3dzZXJcbiAgPyB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lXG4gICAgPyB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lLmJpbmQod2luZG93KVxuICAgIDogc2V0VGltZW91dFxuICA6IC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovIGZ1bmN0aW9uIChmbikgeyByZXR1cm4gZm4oKTsgfTtcblxuZnVuY3Rpb24gbmV4dEZyYW1lIChmbikge1xuICByYWYoZnVuY3Rpb24gKCkge1xuICAgIHJhZihmbik7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBhZGRUcmFuc2l0aW9uQ2xhc3MgKGVsLCBjbHMpIHtcbiAgdmFyIHRyYW5zaXRpb25DbGFzc2VzID0gZWwuX3RyYW5zaXRpb25DbGFzc2VzIHx8IChlbC5fdHJhbnNpdGlvbkNsYXNzZXMgPSBbXSk7XG4gIGlmICh0cmFuc2l0aW9uQ2xhc3Nlcy5pbmRleE9mKGNscykgPCAwKSB7XG4gICAgdHJhbnNpdGlvbkNsYXNzZXMucHVzaChjbHMpO1xuICAgIGFkZENsYXNzKGVsLCBjbHMpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlbW92ZVRyYW5zaXRpb25DbGFzcyAoZWwsIGNscykge1xuICBpZiAoZWwuX3RyYW5zaXRpb25DbGFzc2VzKSB7XG4gICAgcmVtb3ZlKGVsLl90cmFuc2l0aW9uQ2xhc3NlcywgY2xzKTtcbiAgfVxuICByZW1vdmVDbGFzcyhlbCwgY2xzKTtcbn1cblxuZnVuY3Rpb24gd2hlblRyYW5zaXRpb25FbmRzIChcbiAgZWwsXG4gIGV4cGVjdGVkVHlwZSxcbiAgY2Jcbikge1xuICB2YXIgcmVmID0gZ2V0VHJhbnNpdGlvbkluZm8oZWwsIGV4cGVjdGVkVHlwZSk7XG4gIHZhciB0eXBlID0gcmVmLnR5cGU7XG4gIHZhciB0aW1lb3V0ID0gcmVmLnRpbWVvdXQ7XG4gIHZhciBwcm9wQ291bnQgPSByZWYucHJvcENvdW50O1xuICBpZiAoIXR5cGUpIHsgcmV0dXJuIGNiKCkgfVxuICB2YXIgZXZlbnQgPSB0eXBlID09PSBUUkFOU0lUSU9OID8gdHJhbnNpdGlvbkVuZEV2ZW50IDogYW5pbWF0aW9uRW5kRXZlbnQ7XG4gIHZhciBlbmRlZCA9IDA7XG4gIHZhciBlbmQgPSBmdW5jdGlvbiAoKSB7XG4gICAgZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudCwgb25FbmQpO1xuICAgIGNiKCk7XG4gIH07XG4gIHZhciBvbkVuZCA9IGZ1bmN0aW9uIChlKSB7XG4gICAgaWYgKGUudGFyZ2V0ID09PSBlbCkge1xuICAgICAgaWYgKCsrZW5kZWQgPj0gcHJvcENvdW50KSB7XG4gICAgICAgIGVuZCgpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgaWYgKGVuZGVkIDwgcHJvcENvdW50KSB7XG4gICAgICBlbmQoKTtcbiAgICB9XG4gIH0sIHRpbWVvdXQgKyAxKTtcbiAgZWwuYWRkRXZlbnRMaXN0ZW5lcihldmVudCwgb25FbmQpO1xufVxuXG52YXIgdHJhbnNmb3JtUkUgPSAvXFxiKHRyYW5zZm9ybXxhbGwpKCx8JCkvO1xuXG5mdW5jdGlvbiBnZXRUcmFuc2l0aW9uSW5mbyAoZWwsIGV4cGVjdGVkVHlwZSkge1xuICB2YXIgc3R5bGVzID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZWwpO1xuICAvLyBKU0RPTSBtYXkgcmV0dXJuIHVuZGVmaW5lZCBmb3IgdHJhbnNpdGlvbiBwcm9wZXJ0aWVzXG4gIHZhciB0cmFuc2l0aW9uRGVsYXlzID0gKHN0eWxlc1t0cmFuc2l0aW9uUHJvcCArICdEZWxheSddIHx8ICcnKS5zcGxpdCgnLCAnKTtcbiAgdmFyIHRyYW5zaXRpb25EdXJhdGlvbnMgPSAoc3R5bGVzW3RyYW5zaXRpb25Qcm9wICsgJ0R1cmF0aW9uJ10gfHwgJycpLnNwbGl0KCcsICcpO1xuICB2YXIgdHJhbnNpdGlvblRpbWVvdXQgPSBnZXRUaW1lb3V0KHRyYW5zaXRpb25EZWxheXMsIHRyYW5zaXRpb25EdXJhdGlvbnMpO1xuICB2YXIgYW5pbWF0aW9uRGVsYXlzID0gKHN0eWxlc1thbmltYXRpb25Qcm9wICsgJ0RlbGF5J10gfHwgJycpLnNwbGl0KCcsICcpO1xuICB2YXIgYW5pbWF0aW9uRHVyYXRpb25zID0gKHN0eWxlc1thbmltYXRpb25Qcm9wICsgJ0R1cmF0aW9uJ10gfHwgJycpLnNwbGl0KCcsICcpO1xuICB2YXIgYW5pbWF0aW9uVGltZW91dCA9IGdldFRpbWVvdXQoYW5pbWF0aW9uRGVsYXlzLCBhbmltYXRpb25EdXJhdGlvbnMpO1xuXG4gIHZhciB0eXBlO1xuICB2YXIgdGltZW91dCA9IDA7XG4gIHZhciBwcm9wQ291bnQgPSAwO1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKGV4cGVjdGVkVHlwZSA9PT0gVFJBTlNJVElPTikge1xuICAgIGlmICh0cmFuc2l0aW9uVGltZW91dCA+IDApIHtcbiAgICAgIHR5cGUgPSBUUkFOU0lUSU9OO1xuICAgICAgdGltZW91dCA9IHRyYW5zaXRpb25UaW1lb3V0O1xuICAgICAgcHJvcENvdW50ID0gdHJhbnNpdGlvbkR1cmF0aW9ucy5sZW5ndGg7XG4gICAgfVxuICB9IGVsc2UgaWYgKGV4cGVjdGVkVHlwZSA9PT0gQU5JTUFUSU9OKSB7XG4gICAgaWYgKGFuaW1hdGlvblRpbWVvdXQgPiAwKSB7XG4gICAgICB0eXBlID0gQU5JTUFUSU9OO1xuICAgICAgdGltZW91dCA9IGFuaW1hdGlvblRpbWVvdXQ7XG4gICAgICBwcm9wQ291bnQgPSBhbmltYXRpb25EdXJhdGlvbnMubGVuZ3RoO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB0aW1lb3V0ID0gTWF0aC5tYXgodHJhbnNpdGlvblRpbWVvdXQsIGFuaW1hdGlvblRpbWVvdXQpO1xuICAgIHR5cGUgPSB0aW1lb3V0ID4gMFxuICAgICAgPyB0cmFuc2l0aW9uVGltZW91dCA+IGFuaW1hdGlvblRpbWVvdXRcbiAgICAgICAgPyBUUkFOU0lUSU9OXG4gICAgICAgIDogQU5JTUFUSU9OXG4gICAgICA6IG51bGw7XG4gICAgcHJvcENvdW50ID0gdHlwZVxuICAgICAgPyB0eXBlID09PSBUUkFOU0lUSU9OXG4gICAgICAgID8gdHJhbnNpdGlvbkR1cmF0aW9ucy5sZW5ndGhcbiAgICAgICAgOiBhbmltYXRpb25EdXJhdGlvbnMubGVuZ3RoXG4gICAgICA6IDA7XG4gIH1cbiAgdmFyIGhhc1RyYW5zZm9ybSA9XG4gICAgdHlwZSA9PT0gVFJBTlNJVElPTiAmJlxuICAgIHRyYW5zZm9ybVJFLnRlc3Qoc3R5bGVzW3RyYW5zaXRpb25Qcm9wICsgJ1Byb3BlcnR5J10pO1xuICByZXR1cm4ge1xuICAgIHR5cGU6IHR5cGUsXG4gICAgdGltZW91dDogdGltZW91dCxcbiAgICBwcm9wQ291bnQ6IHByb3BDb3VudCxcbiAgICBoYXNUcmFuc2Zvcm06IGhhc1RyYW5zZm9ybVxuICB9XG59XG5cbmZ1bmN0aW9uIGdldFRpbWVvdXQgKGRlbGF5cywgZHVyYXRpb25zKSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gIHdoaWxlIChkZWxheXMubGVuZ3RoIDwgZHVyYXRpb25zLmxlbmd0aCkge1xuICAgIGRlbGF5cyA9IGRlbGF5cy5jb25jYXQoZGVsYXlzKTtcbiAgfVxuXG4gIHJldHVybiBNYXRoLm1heC5hcHBseShudWxsLCBkdXJhdGlvbnMubWFwKGZ1bmN0aW9uIChkLCBpKSB7XG4gICAgcmV0dXJuIHRvTXMoZCkgKyB0b01zKGRlbGF5c1tpXSlcbiAgfSkpXG59XG5cbi8vIE9sZCB2ZXJzaW9ucyBvZiBDaHJvbWl1bSAoYmVsb3cgNjEuMC4zMTYzLjEwMCkgZm9ybWF0cyBmbG9hdGluZyBwb2ludGVyIG51bWJlcnNcbi8vIGluIGEgbG9jYWxlLWRlcGVuZGVudCB3YXksIHVzaW5nIGEgY29tbWEgaW5zdGVhZCBvZiBhIGRvdC5cbi8vIElmIGNvbW1hIGlzIG5vdCByZXBsYWNlZCB3aXRoIGEgZG90LCB0aGUgaW5wdXQgd2lsbCBiZSByb3VuZGVkIGRvd24gKGkuZS4gYWN0aW5nXG4vLyBhcyBhIGZsb29yIGZ1bmN0aW9uKSBjYXVzaW5nIHVuZXhwZWN0ZWQgYmVoYXZpb3JzXG5mdW5jdGlvbiB0b01zIChzKSB7XG4gIHJldHVybiBOdW1iZXIocy5zbGljZSgwLCAtMSkucmVwbGFjZSgnLCcsICcuJykpICogMTAwMFxufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gZW50ZXIgKHZub2RlLCB0b2dnbGVEaXNwbGF5KSB7XG4gIHZhciBlbCA9IHZub2RlLmVsbTtcblxuICAvLyBjYWxsIGxlYXZlIGNhbGxiYWNrIG5vd1xuICBpZiAoaXNEZWYoZWwuX2xlYXZlQ2IpKSB7XG4gICAgZWwuX2xlYXZlQ2IuY2FuY2VsbGVkID0gdHJ1ZTtcbiAgICBlbC5fbGVhdmVDYigpO1xuICB9XG5cbiAgdmFyIGRhdGEgPSByZXNvbHZlVHJhbnNpdGlvbih2bm9kZS5kYXRhLnRyYW5zaXRpb24pO1xuICBpZiAoaXNVbmRlZihkYXRhKSkge1xuICAgIHJldHVyblxuICB9XG5cbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChpc0RlZihlbC5fZW50ZXJDYikgfHwgZWwubm9kZVR5cGUgIT09IDEpIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIHZhciBjc3MgPSBkYXRhLmNzcztcbiAgdmFyIHR5cGUgPSBkYXRhLnR5cGU7XG4gIHZhciBlbnRlckNsYXNzID0gZGF0YS5lbnRlckNsYXNzO1xuICB2YXIgZW50ZXJUb0NsYXNzID0gZGF0YS5lbnRlclRvQ2xhc3M7XG4gIHZhciBlbnRlckFjdGl2ZUNsYXNzID0gZGF0YS5lbnRlckFjdGl2ZUNsYXNzO1xuICB2YXIgYXBwZWFyQ2xhc3MgPSBkYXRhLmFwcGVhckNsYXNzO1xuICB2YXIgYXBwZWFyVG9DbGFzcyA9IGRhdGEuYXBwZWFyVG9DbGFzcztcbiAgdmFyIGFwcGVhckFjdGl2ZUNsYXNzID0gZGF0YS5hcHBlYXJBY3RpdmVDbGFzcztcbiAgdmFyIGJlZm9yZUVudGVyID0gZGF0YS5iZWZvcmVFbnRlcjtcbiAgdmFyIGVudGVyID0gZGF0YS5lbnRlcjtcbiAgdmFyIGFmdGVyRW50ZXIgPSBkYXRhLmFmdGVyRW50ZXI7XG4gIHZhciBlbnRlckNhbmNlbGxlZCA9IGRhdGEuZW50ZXJDYW5jZWxsZWQ7XG4gIHZhciBiZWZvcmVBcHBlYXIgPSBkYXRhLmJlZm9yZUFwcGVhcjtcbiAgdmFyIGFwcGVhciA9IGRhdGEuYXBwZWFyO1xuICB2YXIgYWZ0ZXJBcHBlYXIgPSBkYXRhLmFmdGVyQXBwZWFyO1xuICB2YXIgYXBwZWFyQ2FuY2VsbGVkID0gZGF0YS5hcHBlYXJDYW5jZWxsZWQ7XG4gIHZhciBkdXJhdGlvbiA9IGRhdGEuZHVyYXRpb247XG5cbiAgLy8gYWN0aXZlSW5zdGFuY2Ugd2lsbCBhbHdheXMgYmUgdGhlIDx0cmFuc2l0aW9uPiBjb21wb25lbnQgbWFuYWdpbmcgdGhpc1xuICAvLyB0cmFuc2l0aW9uLiBPbmUgZWRnZSBjYXNlIHRvIGNoZWNrIGlzIHdoZW4gdGhlIDx0cmFuc2l0aW9uPiBpcyBwbGFjZWRcbiAgLy8gYXMgdGhlIHJvb3Qgbm9kZSBvZiBhIGNoaWxkIGNvbXBvbmVudC4gSW4gdGhhdCBjYXNlIHdlIG5lZWQgdG8gY2hlY2tcbiAgLy8gPHRyYW5zaXRpb24+J3MgcGFyZW50IGZvciBhcHBlYXIgY2hlY2suXG4gIHZhciBjb250ZXh0ID0gYWN0aXZlSW5zdGFuY2U7XG4gIHZhciB0cmFuc2l0aW9uTm9kZSA9IGFjdGl2ZUluc3RhbmNlLiR2bm9kZTtcbiAgd2hpbGUgKHRyYW5zaXRpb25Ob2RlICYmIHRyYW5zaXRpb25Ob2RlLnBhcmVudCkge1xuICAgIGNvbnRleHQgPSB0cmFuc2l0aW9uTm9kZS5jb250ZXh0O1xuICAgIHRyYW5zaXRpb25Ob2RlID0gdHJhbnNpdGlvbk5vZGUucGFyZW50O1xuICB9XG5cbiAgdmFyIGlzQXBwZWFyID0gIWNvbnRleHQuX2lzTW91bnRlZCB8fCAhdm5vZGUuaXNSb290SW5zZXJ0O1xuXG4gIGlmIChpc0FwcGVhciAmJiAhYXBwZWFyICYmIGFwcGVhciAhPT0gJycpIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIHZhciBzdGFydENsYXNzID0gaXNBcHBlYXIgJiYgYXBwZWFyQ2xhc3NcbiAgICA/IGFwcGVhckNsYXNzXG4gICAgOiBlbnRlckNsYXNzO1xuICB2YXIgYWN0aXZlQ2xhc3MgPSBpc0FwcGVhciAmJiBhcHBlYXJBY3RpdmVDbGFzc1xuICAgID8gYXBwZWFyQWN0aXZlQ2xhc3NcbiAgICA6IGVudGVyQWN0aXZlQ2xhc3M7XG4gIHZhciB0b0NsYXNzID0gaXNBcHBlYXIgJiYgYXBwZWFyVG9DbGFzc1xuICAgID8gYXBwZWFyVG9DbGFzc1xuICAgIDogZW50ZXJUb0NsYXNzO1xuXG4gIHZhciBiZWZvcmVFbnRlckhvb2sgPSBpc0FwcGVhclxuICAgID8gKGJlZm9yZUFwcGVhciB8fCBiZWZvcmVFbnRlcilcbiAgICA6IGJlZm9yZUVudGVyO1xuICB2YXIgZW50ZXJIb29rID0gaXNBcHBlYXJcbiAgICA/ICh0eXBlb2YgYXBwZWFyID09PSAnZnVuY3Rpb24nID8gYXBwZWFyIDogZW50ZXIpXG4gICAgOiBlbnRlcjtcbiAgdmFyIGFmdGVyRW50ZXJIb29rID0gaXNBcHBlYXJcbiAgICA/IChhZnRlckFwcGVhciB8fCBhZnRlckVudGVyKVxuICAgIDogYWZ0ZXJFbnRlcjtcbiAgdmFyIGVudGVyQ2FuY2VsbGVkSG9vayA9IGlzQXBwZWFyXG4gICAgPyAoYXBwZWFyQ2FuY2VsbGVkIHx8IGVudGVyQ2FuY2VsbGVkKVxuICAgIDogZW50ZXJDYW5jZWxsZWQ7XG5cbiAgdmFyIGV4cGxpY2l0RW50ZXJEdXJhdGlvbiA9IHRvTnVtYmVyKFxuICAgIGlzT2JqZWN0KGR1cmF0aW9uKVxuICAgICAgPyBkdXJhdGlvbi5lbnRlclxuICAgICAgOiBkdXJhdGlvblxuICApO1xuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGV4cGxpY2l0RW50ZXJEdXJhdGlvbiAhPSBudWxsKSB7XG4gICAgY2hlY2tEdXJhdGlvbihleHBsaWNpdEVudGVyRHVyYXRpb24sICdlbnRlcicsIHZub2RlKTtcbiAgfVxuXG4gIHZhciBleHBlY3RzQ1NTID0gY3NzICE9PSBmYWxzZSAmJiAhaXNJRTk7XG4gIHZhciB1c2VyV2FudHNDb250cm9sID0gZ2V0SG9va0FyZ3VtZW50c0xlbmd0aChlbnRlckhvb2spO1xuXG4gIHZhciBjYiA9IGVsLl9lbnRlckNiID0gb25jZShmdW5jdGlvbiAoKSB7XG4gICAgaWYgKGV4cGVjdHNDU1MpIHtcbiAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgdG9DbGFzcyk7XG4gICAgICByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIGFjdGl2ZUNsYXNzKTtcbiAgICB9XG4gICAgaWYgKGNiLmNhbmNlbGxlZCkge1xuICAgICAgaWYgKGV4cGVjdHNDU1MpIHtcbiAgICAgICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBzdGFydENsYXNzKTtcbiAgICAgIH1cbiAgICAgIGVudGVyQ2FuY2VsbGVkSG9vayAmJiBlbnRlckNhbmNlbGxlZEhvb2soZWwpO1xuICAgIH0gZWxzZSB7XG4gICAgICBhZnRlckVudGVySG9vayAmJiBhZnRlckVudGVySG9vayhlbCk7XG4gICAgfVxuICAgIGVsLl9lbnRlckNiID0gbnVsbDtcbiAgfSk7XG5cbiAgaWYgKCF2bm9kZS5kYXRhLnNob3cpIHtcbiAgICAvLyByZW1vdmUgcGVuZGluZyBsZWF2ZSBlbGVtZW50IG9uIGVudGVyIGJ5IGluamVjdGluZyBhbiBpbnNlcnQgaG9va1xuICAgIG1lcmdlVk5vZGVIb29rKHZub2RlLCAnaW5zZXJ0JywgZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHBhcmVudCA9IGVsLnBhcmVudE5vZGU7XG4gICAgICB2YXIgcGVuZGluZ05vZGUgPSBwYXJlbnQgJiYgcGFyZW50Ll9wZW5kaW5nICYmIHBhcmVudC5fcGVuZGluZ1t2bm9kZS5rZXldO1xuICAgICAgaWYgKHBlbmRpbmdOb2RlICYmXG4gICAgICAgIHBlbmRpbmdOb2RlLnRhZyA9PT0gdm5vZGUudGFnICYmXG4gICAgICAgIHBlbmRpbmdOb2RlLmVsbS5fbGVhdmVDYlxuICAgICAgKSB7XG4gICAgICAgIHBlbmRpbmdOb2RlLmVsbS5fbGVhdmVDYigpO1xuICAgICAgfVxuICAgICAgZW50ZXJIb29rICYmIGVudGVySG9vayhlbCwgY2IpO1xuICAgIH0pO1xuICB9XG5cbiAgLy8gc3RhcnQgZW50ZXIgdHJhbnNpdGlvblxuICBiZWZvcmVFbnRlckhvb2sgJiYgYmVmb3JlRW50ZXJIb29rKGVsKTtcbiAgaWYgKGV4cGVjdHNDU1MpIHtcbiAgICBhZGRUcmFuc2l0aW9uQ2xhc3MoZWwsIHN0YXJ0Q2xhc3MpO1xuICAgIGFkZFRyYW5zaXRpb25DbGFzcyhlbCwgYWN0aXZlQ2xhc3MpO1xuICAgIG5leHRGcmFtZShmdW5jdGlvbiAoKSB7XG4gICAgICByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIHN0YXJ0Q2xhc3MpO1xuICAgICAgaWYgKCFjYi5jYW5jZWxsZWQpIHtcbiAgICAgICAgYWRkVHJhbnNpdGlvbkNsYXNzKGVsLCB0b0NsYXNzKTtcbiAgICAgICAgaWYgKCF1c2VyV2FudHNDb250cm9sKSB7XG4gICAgICAgICAgaWYgKGlzVmFsaWREdXJhdGlvbihleHBsaWNpdEVudGVyRHVyYXRpb24pKSB7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KGNiLCBleHBsaWNpdEVudGVyRHVyYXRpb24pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB3aGVuVHJhbnNpdGlvbkVuZHMoZWwsIHR5cGUsIGNiKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIGlmICh2bm9kZS5kYXRhLnNob3cpIHtcbiAgICB0b2dnbGVEaXNwbGF5ICYmIHRvZ2dsZURpc3BsYXkoKTtcbiAgICBlbnRlckhvb2sgJiYgZW50ZXJIb29rKGVsLCBjYik7XG4gIH1cblxuICBpZiAoIWV4cGVjdHNDU1MgJiYgIXVzZXJXYW50c0NvbnRyb2wpIHtcbiAgICBjYigpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGxlYXZlICh2bm9kZSwgcm0pIHtcbiAgdmFyIGVsID0gdm5vZGUuZWxtO1xuXG4gIC8vIGNhbGwgZW50ZXIgY2FsbGJhY2sgbm93XG4gIGlmIChpc0RlZihlbC5fZW50ZXJDYikpIHtcbiAgICBlbC5fZW50ZXJDYi5jYW5jZWxsZWQgPSB0cnVlO1xuICAgIGVsLl9lbnRlckNiKCk7XG4gIH1cblxuICB2YXIgZGF0YSA9IHJlc29sdmVUcmFuc2l0aW9uKHZub2RlLmRhdGEudHJhbnNpdGlvbik7XG4gIGlmIChpc1VuZGVmKGRhdGEpIHx8IGVsLm5vZGVUeXBlICE9PSAxKSB7XG4gICAgcmV0dXJuIHJtKClcbiAgfVxuXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoaXNEZWYoZWwuX2xlYXZlQ2IpKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICB2YXIgY3NzID0gZGF0YS5jc3M7XG4gIHZhciB0eXBlID0gZGF0YS50eXBlO1xuICB2YXIgbGVhdmVDbGFzcyA9IGRhdGEubGVhdmVDbGFzcztcbiAgdmFyIGxlYXZlVG9DbGFzcyA9IGRhdGEubGVhdmVUb0NsYXNzO1xuICB2YXIgbGVhdmVBY3RpdmVDbGFzcyA9IGRhdGEubGVhdmVBY3RpdmVDbGFzcztcbiAgdmFyIGJlZm9yZUxlYXZlID0gZGF0YS5iZWZvcmVMZWF2ZTtcbiAgdmFyIGxlYXZlID0gZGF0YS5sZWF2ZTtcbiAgdmFyIGFmdGVyTGVhdmUgPSBkYXRhLmFmdGVyTGVhdmU7XG4gIHZhciBsZWF2ZUNhbmNlbGxlZCA9IGRhdGEubGVhdmVDYW5jZWxsZWQ7XG4gIHZhciBkZWxheUxlYXZlID0gZGF0YS5kZWxheUxlYXZlO1xuICB2YXIgZHVyYXRpb24gPSBkYXRhLmR1cmF0aW9uO1xuXG4gIHZhciBleHBlY3RzQ1NTID0gY3NzICE9PSBmYWxzZSAmJiAhaXNJRTk7XG4gIHZhciB1c2VyV2FudHNDb250cm9sID0gZ2V0SG9va0FyZ3VtZW50c0xlbmd0aChsZWF2ZSk7XG5cbiAgdmFyIGV4cGxpY2l0TGVhdmVEdXJhdGlvbiA9IHRvTnVtYmVyKFxuICAgIGlzT2JqZWN0KGR1cmF0aW9uKVxuICAgICAgPyBkdXJhdGlvbi5sZWF2ZVxuICAgICAgOiBkdXJhdGlvblxuICApO1xuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGlzRGVmKGV4cGxpY2l0TGVhdmVEdXJhdGlvbikpIHtcbiAgICBjaGVja0R1cmF0aW9uKGV4cGxpY2l0TGVhdmVEdXJhdGlvbiwgJ2xlYXZlJywgdm5vZGUpO1xuICB9XG5cbiAgdmFyIGNiID0gZWwuX2xlYXZlQ2IgPSBvbmNlKGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoZWwucGFyZW50Tm9kZSAmJiBlbC5wYXJlbnROb2RlLl9wZW5kaW5nKSB7XG4gICAgICBlbC5wYXJlbnROb2RlLl9wZW5kaW5nW3Zub2RlLmtleV0gPSBudWxsO1xuICAgIH1cbiAgICBpZiAoZXhwZWN0c0NTUykge1xuICAgICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBsZWF2ZVRvQ2xhc3MpO1xuICAgICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBsZWF2ZUFjdGl2ZUNsYXNzKTtcbiAgICB9XG4gICAgaWYgKGNiLmNhbmNlbGxlZCkge1xuICAgICAgaWYgKGV4cGVjdHNDU1MpIHtcbiAgICAgICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBsZWF2ZUNsYXNzKTtcbiAgICAgIH1cbiAgICAgIGxlYXZlQ2FuY2VsbGVkICYmIGxlYXZlQ2FuY2VsbGVkKGVsKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcm0oKTtcbiAgICAgIGFmdGVyTGVhdmUgJiYgYWZ0ZXJMZWF2ZShlbCk7XG4gICAgfVxuICAgIGVsLl9sZWF2ZUNiID0gbnVsbDtcbiAgfSk7XG5cbiAgaWYgKGRlbGF5TGVhdmUpIHtcbiAgICBkZWxheUxlYXZlKHBlcmZvcm1MZWF2ZSk7XG4gIH0gZWxzZSB7XG4gICAgcGVyZm9ybUxlYXZlKCk7XG4gIH1cblxuICBmdW5jdGlvbiBwZXJmb3JtTGVhdmUgKCkge1xuICAgIC8vIHRoZSBkZWxheWVkIGxlYXZlIG1heSBoYXZlIGFscmVhZHkgYmVlbiBjYW5jZWxsZWRcbiAgICBpZiAoY2IuY2FuY2VsbGVkKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgLy8gcmVjb3JkIGxlYXZpbmcgZWxlbWVudFxuICAgIGlmICghdm5vZGUuZGF0YS5zaG93ICYmIGVsLnBhcmVudE5vZGUpIHtcbiAgICAgIChlbC5wYXJlbnROb2RlLl9wZW5kaW5nIHx8IChlbC5wYXJlbnROb2RlLl9wZW5kaW5nID0ge30pKVsodm5vZGUua2V5KV0gPSB2bm9kZTtcbiAgICB9XG4gICAgYmVmb3JlTGVhdmUgJiYgYmVmb3JlTGVhdmUoZWwpO1xuICAgIGlmIChleHBlY3RzQ1NTKSB7XG4gICAgICBhZGRUcmFuc2l0aW9uQ2xhc3MoZWwsIGxlYXZlQ2xhc3MpO1xuICAgICAgYWRkVHJhbnNpdGlvbkNsYXNzKGVsLCBsZWF2ZUFjdGl2ZUNsYXNzKTtcbiAgICAgIG5leHRGcmFtZShmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgbGVhdmVDbGFzcyk7XG4gICAgICAgIGlmICghY2IuY2FuY2VsbGVkKSB7XG4gICAgICAgICAgYWRkVHJhbnNpdGlvbkNsYXNzKGVsLCBsZWF2ZVRvQ2xhc3MpO1xuICAgICAgICAgIGlmICghdXNlcldhbnRzQ29udHJvbCkge1xuICAgICAgICAgICAgaWYgKGlzVmFsaWREdXJhdGlvbihleHBsaWNpdExlYXZlRHVyYXRpb24pKSB7XG4gICAgICAgICAgICAgIHNldFRpbWVvdXQoY2IsIGV4cGxpY2l0TGVhdmVEdXJhdGlvbik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB3aGVuVHJhbnNpdGlvbkVuZHMoZWwsIHR5cGUsIGNiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgICBsZWF2ZSAmJiBsZWF2ZShlbCwgY2IpO1xuICAgIGlmICghZXhwZWN0c0NTUyAmJiAhdXNlcldhbnRzQ29udHJvbCkge1xuICAgICAgY2IoKTtcbiAgICB9XG4gIH1cbn1cblxuLy8gb25seSB1c2VkIGluIGRldiBtb2RlXG5mdW5jdGlvbiBjaGVja0R1cmF0aW9uICh2YWwsIG5hbWUsIHZub2RlKSB7XG4gIGlmICh0eXBlb2YgdmFsICE9PSAnbnVtYmVyJykge1xuICAgIHdhcm4oXG4gICAgICBcIjx0cmFuc2l0aW9uPiBleHBsaWNpdCBcIiArIG5hbWUgKyBcIiBkdXJhdGlvbiBpcyBub3QgYSB2YWxpZCBudW1iZXIgLSBcIiArXG4gICAgICBcImdvdCBcIiArIChKU09OLnN0cmluZ2lmeSh2YWwpKSArIFwiLlwiLFxuICAgICAgdm5vZGUuY29udGV4dFxuICAgICk7XG4gIH0gZWxzZSBpZiAoaXNOYU4odmFsKSkge1xuICAgIHdhcm4oXG4gICAgICBcIjx0cmFuc2l0aW9uPiBleHBsaWNpdCBcIiArIG5hbWUgKyBcIiBkdXJhdGlvbiBpcyBOYU4gLSBcIiArXG4gICAgICAndGhlIGR1cmF0aW9uIGV4cHJlc3Npb24gbWlnaHQgYmUgaW5jb3JyZWN0LicsXG4gICAgICB2bm9kZS5jb250ZXh0XG4gICAgKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpc1ZhbGlkRHVyYXRpb24gKHZhbCkge1xuICByZXR1cm4gdHlwZW9mIHZhbCA9PT0gJ251bWJlcicgJiYgIWlzTmFOKHZhbClcbn1cblxuLyoqXG4gKiBOb3JtYWxpemUgYSB0cmFuc2l0aW9uIGhvb2sncyBhcmd1bWVudCBsZW5ndGguIFRoZSBob29rIG1heSBiZTpcbiAqIC0gYSBtZXJnZWQgaG9vayAoaW52b2tlcikgd2l0aCB0aGUgb3JpZ2luYWwgaW4gLmZuc1xuICogLSBhIHdyYXBwZWQgY29tcG9uZW50IG1ldGhvZCAoY2hlY2sgLl9sZW5ndGgpXG4gKiAtIGEgcGxhaW4gZnVuY3Rpb24gKC5sZW5ndGgpXG4gKi9cbmZ1bmN0aW9uIGdldEhvb2tBcmd1bWVudHNMZW5ndGggKGZuKSB7XG4gIGlmIChpc1VuZGVmKGZuKSkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG4gIHZhciBpbnZva2VyRm5zID0gZm4uZm5zO1xuICBpZiAoaXNEZWYoaW52b2tlckZucykpIHtcbiAgICAvLyBpbnZva2VyXG4gICAgcmV0dXJuIGdldEhvb2tBcmd1bWVudHNMZW5ndGgoXG4gICAgICBBcnJheS5pc0FycmF5KGludm9rZXJGbnMpXG4gICAgICAgID8gaW52b2tlckZuc1swXVxuICAgICAgICA6IGludm9rZXJGbnNcbiAgICApXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIChmbi5fbGVuZ3RoIHx8IGZuLmxlbmd0aCkgPiAxXG4gIH1cbn1cblxuZnVuY3Rpb24gX2VudGVyIChfLCB2bm9kZSkge1xuICBpZiAodm5vZGUuZGF0YS5zaG93ICE9PSB0cnVlKSB7XG4gICAgZW50ZXIodm5vZGUpO1xuICB9XG59XG5cbnZhciB0cmFuc2l0aW9uID0gaW5Ccm93c2VyID8ge1xuICBjcmVhdGU6IF9lbnRlcixcbiAgYWN0aXZhdGU6IF9lbnRlcixcbiAgcmVtb3ZlOiBmdW5jdGlvbiByZW1vdmUkJDEgKHZub2RlLCBybSkge1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgaWYgKHZub2RlLmRhdGEuc2hvdyAhPT0gdHJ1ZSkge1xuICAgICAgbGVhdmUodm5vZGUsIHJtKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcm0oKTtcbiAgICB9XG4gIH1cbn0gOiB7fTtcblxudmFyIHBsYXRmb3JtTW9kdWxlcyA9IFtcbiAgYXR0cnMsXG4gIGtsYXNzLFxuICBldmVudHMsXG4gIGRvbVByb3BzLFxuICBzdHlsZSxcbiAgdHJhbnNpdGlvblxuXTtcblxuLyogICovXG5cbi8vIHRoZSBkaXJlY3RpdmUgbW9kdWxlIHNob3VsZCBiZSBhcHBsaWVkIGxhc3QsIGFmdGVyIGFsbFxuLy8gYnVpbHQtaW4gbW9kdWxlcyBoYXZlIGJlZW4gYXBwbGllZC5cbnZhciBtb2R1bGVzID0gcGxhdGZvcm1Nb2R1bGVzLmNvbmNhdChiYXNlTW9kdWxlcyk7XG5cbnZhciBwYXRjaCA9IGNyZWF0ZVBhdGNoRnVuY3Rpb24oeyBub2RlT3BzOiBub2RlT3BzLCBtb2R1bGVzOiBtb2R1bGVzIH0pO1xuXG4vKipcbiAqIE5vdCB0eXBlIGNoZWNraW5nIHRoaXMgZmlsZSBiZWNhdXNlIGZsb3cgZG9lc24ndCBsaWtlIGF0dGFjaGluZ1xuICogcHJvcGVydGllcyB0byBFbGVtZW50cy5cbiAqL1xuXG4vKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbmlmIChpc0lFOSkge1xuICAvLyBodHRwOi8vd3d3Lm1hdHRzNDExLmNvbS9wb3N0L2ludGVybmV0LWV4cGxvcmVyLTktb25pbnB1dC9cbiAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignc2VsZWN0aW9uY2hhbmdlJywgZnVuY3Rpb24gKCkge1xuICAgIHZhciBlbCA9IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQ7XG4gICAgaWYgKGVsICYmIGVsLnZtb2RlbCkge1xuICAgICAgdHJpZ2dlcihlbCwgJ2lucHV0Jyk7XG4gICAgfVxuICB9KTtcbn1cblxudmFyIGRpcmVjdGl2ZSA9IHtcbiAgaW5zZXJ0ZWQ6IGZ1bmN0aW9uIGluc2VydGVkIChlbCwgYmluZGluZywgdm5vZGUsIG9sZFZub2RlKSB7XG4gICAgaWYgKHZub2RlLnRhZyA9PT0gJ3NlbGVjdCcpIHtcbiAgICAgIC8vICM2OTAzXG4gICAgICBpZiAob2xkVm5vZGUuZWxtICYmICFvbGRWbm9kZS5lbG0uX3ZPcHRpb25zKSB7XG4gICAgICAgIG1lcmdlVk5vZGVIb29rKHZub2RlLCAncG9zdHBhdGNoJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGRpcmVjdGl2ZS5jb21wb25lbnRVcGRhdGVkKGVsLCBiaW5kaW5nLCB2bm9kZSk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2V0U2VsZWN0ZWQoZWwsIGJpbmRpbmcsIHZub2RlLmNvbnRleHQpO1xuICAgICAgfVxuICAgICAgZWwuX3ZPcHRpb25zID0gW10ubWFwLmNhbGwoZWwub3B0aW9ucywgZ2V0VmFsdWUpO1xuICAgIH0gZWxzZSBpZiAodm5vZGUudGFnID09PSAndGV4dGFyZWEnIHx8IGlzVGV4dElucHV0VHlwZShlbC50eXBlKSkge1xuICAgICAgZWwuX3ZNb2RpZmllcnMgPSBiaW5kaW5nLm1vZGlmaWVycztcbiAgICAgIGlmICghYmluZGluZy5tb2RpZmllcnMubGF6eSkge1xuICAgICAgICBlbC5hZGRFdmVudExpc3RlbmVyKCdjb21wb3NpdGlvbnN0YXJ0Jywgb25Db21wb3NpdGlvblN0YXJ0KTtcbiAgICAgICAgZWwuYWRkRXZlbnRMaXN0ZW5lcignY29tcG9zaXRpb25lbmQnLCBvbkNvbXBvc2l0aW9uRW5kKTtcbiAgICAgICAgLy8gU2FmYXJpIDwgMTAuMiAmIFVJV2ViVmlldyBkb2Vzbid0IGZpcmUgY29tcG9zaXRpb25lbmQgd2hlblxuICAgICAgICAvLyBzd2l0Y2hpbmcgZm9jdXMgYmVmb3JlIGNvbmZpcm1pbmcgY29tcG9zaXRpb24gY2hvaWNlXG4gICAgICAgIC8vIHRoaXMgYWxzbyBmaXhlcyB0aGUgaXNzdWUgd2hlcmUgc29tZSBicm93c2VycyBlLmcuIGlPUyBDaHJvbWVcbiAgICAgICAgLy8gZmlyZXMgXCJjaGFuZ2VcIiBpbnN0ZWFkIG9mIFwiaW5wdXRcIiBvbiBhdXRvY29tcGxldGUuXG4gICAgICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIG9uQ29tcG9zaXRpb25FbmQpO1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgaWYgKGlzSUU5KSB7XG4gICAgICAgICAgZWwudm1vZGVsID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICBjb21wb25lbnRVcGRhdGVkOiBmdW5jdGlvbiBjb21wb25lbnRVcGRhdGVkIChlbCwgYmluZGluZywgdm5vZGUpIHtcbiAgICBpZiAodm5vZGUudGFnID09PSAnc2VsZWN0Jykge1xuICAgICAgc2V0U2VsZWN0ZWQoZWwsIGJpbmRpbmcsIHZub2RlLmNvbnRleHQpO1xuICAgICAgLy8gaW4gY2FzZSB0aGUgb3B0aW9ucyByZW5kZXJlZCBieSB2LWZvciBoYXZlIGNoYW5nZWQsXG4gICAgICAvLyBpdCdzIHBvc3NpYmxlIHRoYXQgdGhlIHZhbHVlIGlzIG91dC1vZi1zeW5jIHdpdGggdGhlIHJlbmRlcmVkIG9wdGlvbnMuXG4gICAgICAvLyBkZXRlY3Qgc3VjaCBjYXNlcyBhbmQgZmlsdGVyIG91dCB2YWx1ZXMgdGhhdCBubyBsb25nZXIgaGFzIGEgbWF0Y2hpbmdcbiAgICAgIC8vIG9wdGlvbiBpbiB0aGUgRE9NLlxuICAgICAgdmFyIHByZXZPcHRpb25zID0gZWwuX3ZPcHRpb25zO1xuICAgICAgdmFyIGN1ck9wdGlvbnMgPSBlbC5fdk9wdGlvbnMgPSBbXS5tYXAuY2FsbChlbC5vcHRpb25zLCBnZXRWYWx1ZSk7XG4gICAgICBpZiAoY3VyT3B0aW9ucy5zb21lKGZ1bmN0aW9uIChvLCBpKSB7IHJldHVybiAhbG9vc2VFcXVhbChvLCBwcmV2T3B0aW9uc1tpXSk7IH0pKSB7XG4gICAgICAgIC8vIHRyaWdnZXIgY2hhbmdlIGV2ZW50IGlmXG4gICAgICAgIC8vIG5vIG1hdGNoaW5nIG9wdGlvbiBmb3VuZCBmb3IgYXQgbGVhc3Qgb25lIHZhbHVlXG4gICAgICAgIHZhciBuZWVkUmVzZXQgPSBlbC5tdWx0aXBsZVxuICAgICAgICAgID8gYmluZGluZy52YWx1ZS5zb21lKGZ1bmN0aW9uICh2KSB7IHJldHVybiBoYXNOb01hdGNoaW5nT3B0aW9uKHYsIGN1ck9wdGlvbnMpOyB9KVxuICAgICAgICAgIDogYmluZGluZy52YWx1ZSAhPT0gYmluZGluZy5vbGRWYWx1ZSAmJiBoYXNOb01hdGNoaW5nT3B0aW9uKGJpbmRpbmcudmFsdWUsIGN1ck9wdGlvbnMpO1xuICAgICAgICBpZiAobmVlZFJlc2V0KSB7XG4gICAgICAgICAgdHJpZ2dlcihlbCwgJ2NoYW5nZScpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG5mdW5jdGlvbiBzZXRTZWxlY3RlZCAoZWwsIGJpbmRpbmcsIHZtKSB7XG4gIGFjdHVhbGx5U2V0U2VsZWN0ZWQoZWwsIGJpbmRpbmcsIHZtKTtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChpc0lFIHx8IGlzRWRnZSkge1xuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgYWN0dWFsbHlTZXRTZWxlY3RlZChlbCwgYmluZGluZywgdm0pO1xuICAgIH0sIDApO1xuICB9XG59XG5cbmZ1bmN0aW9uIGFjdHVhbGx5U2V0U2VsZWN0ZWQgKGVsLCBiaW5kaW5nLCB2bSkge1xuICB2YXIgdmFsdWUgPSBiaW5kaW5nLnZhbHVlO1xuICB2YXIgaXNNdWx0aXBsZSA9IGVsLm11bHRpcGxlO1xuICBpZiAoaXNNdWx0aXBsZSAmJiAhQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oXG4gICAgICBcIjxzZWxlY3QgbXVsdGlwbGUgdi1tb2RlbD1cXFwiXCIgKyAoYmluZGluZy5leHByZXNzaW9uKSArIFwiXFxcIj4gXCIgK1xuICAgICAgXCJleHBlY3RzIGFuIEFycmF5IHZhbHVlIGZvciBpdHMgYmluZGluZywgYnV0IGdvdCBcIiArIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpLnNsaWNlKDgsIC0xKSksXG4gICAgICB2bVxuICAgICk7XG4gICAgcmV0dXJuXG4gIH1cbiAgdmFyIHNlbGVjdGVkLCBvcHRpb247XG4gIGZvciAodmFyIGkgPSAwLCBsID0gZWwub3B0aW9ucy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBvcHRpb24gPSBlbC5vcHRpb25zW2ldO1xuICAgIGlmIChpc011bHRpcGxlKSB7XG4gICAgICBzZWxlY3RlZCA9IGxvb3NlSW5kZXhPZih2YWx1ZSwgZ2V0VmFsdWUob3B0aW9uKSkgPiAtMTtcbiAgICAgIGlmIChvcHRpb24uc2VsZWN0ZWQgIT09IHNlbGVjdGVkKSB7XG4gICAgICAgIG9wdGlvbi5zZWxlY3RlZCA9IHNlbGVjdGVkO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAobG9vc2VFcXVhbChnZXRWYWx1ZShvcHRpb24pLCB2YWx1ZSkpIHtcbiAgICAgICAgaWYgKGVsLnNlbGVjdGVkSW5kZXggIT09IGkpIHtcbiAgICAgICAgICBlbC5zZWxlY3RlZEluZGV4ID0gaTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm5cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaWYgKCFpc011bHRpcGxlKSB7XG4gICAgZWwuc2VsZWN0ZWRJbmRleCA9IC0xO1xuICB9XG59XG5cbmZ1bmN0aW9uIGhhc05vTWF0Y2hpbmdPcHRpb24gKHZhbHVlLCBvcHRpb25zKSB7XG4gIHJldHVybiBvcHRpb25zLmV2ZXJ5KGZ1bmN0aW9uIChvKSB7IHJldHVybiAhbG9vc2VFcXVhbChvLCB2YWx1ZSk7IH0pXG59XG5cbmZ1bmN0aW9uIGdldFZhbHVlIChvcHRpb24pIHtcbiAgcmV0dXJuICdfdmFsdWUnIGluIG9wdGlvblxuICAgID8gb3B0aW9uLl92YWx1ZVxuICAgIDogb3B0aW9uLnZhbHVlXG59XG5cbmZ1bmN0aW9uIG9uQ29tcG9zaXRpb25TdGFydCAoZSkge1xuICBlLnRhcmdldC5jb21wb3NpbmcgPSB0cnVlO1xufVxuXG5mdW5jdGlvbiBvbkNvbXBvc2l0aW9uRW5kIChlKSB7XG4gIC8vIHByZXZlbnQgdHJpZ2dlcmluZyBhbiBpbnB1dCBldmVudCBmb3Igbm8gcmVhc29uXG4gIGlmICghZS50YXJnZXQuY29tcG9zaW5nKSB7IHJldHVybiB9XG4gIGUudGFyZ2V0LmNvbXBvc2luZyA9IGZhbHNlO1xuICB0cmlnZ2VyKGUudGFyZ2V0LCAnaW5wdXQnKTtcbn1cblxuZnVuY3Rpb24gdHJpZ2dlciAoZWwsIHR5cGUpIHtcbiAgdmFyIGUgPSBkb2N1bWVudC5jcmVhdGVFdmVudCgnSFRNTEV2ZW50cycpO1xuICBlLmluaXRFdmVudCh0eXBlLCB0cnVlLCB0cnVlKTtcbiAgZWwuZGlzcGF0Y2hFdmVudChlKTtcbn1cblxuLyogICovXG5cbi8vIHJlY3Vyc2l2ZWx5IHNlYXJjaCBmb3IgcG9zc2libGUgdHJhbnNpdGlvbiBkZWZpbmVkIGluc2lkZSB0aGUgY29tcG9uZW50IHJvb3RcbmZ1bmN0aW9uIGxvY2F0ZU5vZGUgKHZub2RlKSB7XG4gIHJldHVybiB2bm9kZS5jb21wb25lbnRJbnN0YW5jZSAmJiAoIXZub2RlLmRhdGEgfHwgIXZub2RlLmRhdGEudHJhbnNpdGlvbilcbiAgICA/IGxvY2F0ZU5vZGUodm5vZGUuY29tcG9uZW50SW5zdGFuY2UuX3Zub2RlKVxuICAgIDogdm5vZGVcbn1cblxudmFyIHNob3cgPSB7XG4gIGJpbmQ6IGZ1bmN0aW9uIGJpbmQgKGVsLCByZWYsIHZub2RlKSB7XG4gICAgdmFyIHZhbHVlID0gcmVmLnZhbHVlO1xuXG4gICAgdm5vZGUgPSBsb2NhdGVOb2RlKHZub2RlKTtcbiAgICB2YXIgdHJhbnNpdGlvbiQkMSA9IHZub2RlLmRhdGEgJiYgdm5vZGUuZGF0YS50cmFuc2l0aW9uO1xuICAgIHZhciBvcmlnaW5hbERpc3BsYXkgPSBlbC5fX3ZPcmlnaW5hbERpc3BsYXkgPVxuICAgICAgZWwuc3R5bGUuZGlzcGxheSA9PT0gJ25vbmUnID8gJycgOiBlbC5zdHlsZS5kaXNwbGF5O1xuICAgIGlmICh2YWx1ZSAmJiB0cmFuc2l0aW9uJCQxKSB7XG4gICAgICB2bm9kZS5kYXRhLnNob3cgPSB0cnVlO1xuICAgICAgZW50ZXIodm5vZGUsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZWwuc3R5bGUuZGlzcGxheSA9IG9yaWdpbmFsRGlzcGxheTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbC5zdHlsZS5kaXNwbGF5ID0gdmFsdWUgPyBvcmlnaW5hbERpc3BsYXkgOiAnbm9uZSc7XG4gICAgfVxuICB9LFxuXG4gIHVwZGF0ZTogZnVuY3Rpb24gdXBkYXRlIChlbCwgcmVmLCB2bm9kZSkge1xuICAgIHZhciB2YWx1ZSA9IHJlZi52YWx1ZTtcbiAgICB2YXIgb2xkVmFsdWUgPSByZWYub2xkVmFsdWU7XG5cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoIXZhbHVlID09PSAhb2xkVmFsdWUpIHsgcmV0dXJuIH1cbiAgICB2bm9kZSA9IGxvY2F0ZU5vZGUodm5vZGUpO1xuICAgIHZhciB0cmFuc2l0aW9uJCQxID0gdm5vZGUuZGF0YSAmJiB2bm9kZS5kYXRhLnRyYW5zaXRpb247XG4gICAgaWYgKHRyYW5zaXRpb24kJDEpIHtcbiAgICAgIHZub2RlLmRhdGEuc2hvdyA9IHRydWU7XG4gICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgZW50ZXIodm5vZGUsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBlbC5zdHlsZS5kaXNwbGF5ID0gZWwuX192T3JpZ2luYWxEaXNwbGF5O1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxlYXZlKHZub2RlLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgZWwuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsLnN0eWxlLmRpc3BsYXkgPSB2YWx1ZSA/IGVsLl9fdk9yaWdpbmFsRGlzcGxheSA6ICdub25lJztcbiAgICB9XG4gIH0sXG5cbiAgdW5iaW5kOiBmdW5jdGlvbiB1bmJpbmQgKFxuICAgIGVsLFxuICAgIGJpbmRpbmcsXG4gICAgdm5vZGUsXG4gICAgb2xkVm5vZGUsXG4gICAgaXNEZXN0cm95XG4gICkge1xuICAgIGlmICghaXNEZXN0cm95KSB7XG4gICAgICBlbC5zdHlsZS5kaXNwbGF5ID0gZWwuX192T3JpZ2luYWxEaXNwbGF5O1xuICAgIH1cbiAgfVxufTtcblxudmFyIHBsYXRmb3JtRGlyZWN0aXZlcyA9IHtcbiAgbW9kZWw6IGRpcmVjdGl2ZSxcbiAgc2hvdzogc2hvd1xufTtcblxuLyogICovXG5cbnZhciB0cmFuc2l0aW9uUHJvcHMgPSB7XG4gIG5hbWU6IFN0cmluZyxcbiAgYXBwZWFyOiBCb29sZWFuLFxuICBjc3M6IEJvb2xlYW4sXG4gIG1vZGU6IFN0cmluZyxcbiAgdHlwZTogU3RyaW5nLFxuICBlbnRlckNsYXNzOiBTdHJpbmcsXG4gIGxlYXZlQ2xhc3M6IFN0cmluZyxcbiAgZW50ZXJUb0NsYXNzOiBTdHJpbmcsXG4gIGxlYXZlVG9DbGFzczogU3RyaW5nLFxuICBlbnRlckFjdGl2ZUNsYXNzOiBTdHJpbmcsXG4gIGxlYXZlQWN0aXZlQ2xhc3M6IFN0cmluZyxcbiAgYXBwZWFyQ2xhc3M6IFN0cmluZyxcbiAgYXBwZWFyQWN0aXZlQ2xhc3M6IFN0cmluZyxcbiAgYXBwZWFyVG9DbGFzczogU3RyaW5nLFxuICBkdXJhdGlvbjogW051bWJlciwgU3RyaW5nLCBPYmplY3RdXG59O1xuXG4vLyBpbiBjYXNlIHRoZSBjaGlsZCBpcyBhbHNvIGFuIGFic3RyYWN0IGNvbXBvbmVudCwgZS5nLiA8a2VlcC1hbGl2ZT5cbi8vIHdlIHdhbnQgdG8gcmVjdXJzaXZlbHkgcmV0cmlldmUgdGhlIHJlYWwgY29tcG9uZW50IHRvIGJlIHJlbmRlcmVkXG5mdW5jdGlvbiBnZXRSZWFsQ2hpbGQgKHZub2RlKSB7XG4gIHZhciBjb21wT3B0aW9ucyA9IHZub2RlICYmIHZub2RlLmNvbXBvbmVudE9wdGlvbnM7XG4gIGlmIChjb21wT3B0aW9ucyAmJiBjb21wT3B0aW9ucy5DdG9yLm9wdGlvbnMuYWJzdHJhY3QpIHtcbiAgICByZXR1cm4gZ2V0UmVhbENoaWxkKGdldEZpcnN0Q29tcG9uZW50Q2hpbGQoY29tcE9wdGlvbnMuY2hpbGRyZW4pKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiB2bm9kZVxuICB9XG59XG5cbmZ1bmN0aW9uIGV4dHJhY3RUcmFuc2l0aW9uRGF0YSAoY29tcCkge1xuICB2YXIgZGF0YSA9IHt9O1xuICB2YXIgb3B0aW9ucyA9IGNvbXAuJG9wdGlvbnM7XG4gIC8vIHByb3BzXG4gIGZvciAodmFyIGtleSBpbiBvcHRpb25zLnByb3BzRGF0YSkge1xuICAgIGRhdGFba2V5XSA9IGNvbXBba2V5XTtcbiAgfVxuICAvLyBldmVudHMuXG4gIC8vIGV4dHJhY3QgbGlzdGVuZXJzIGFuZCBwYXNzIHRoZW0gZGlyZWN0bHkgdG8gdGhlIHRyYW5zaXRpb24gbWV0aG9kc1xuICB2YXIgbGlzdGVuZXJzID0gb3B0aW9ucy5fcGFyZW50TGlzdGVuZXJzO1xuICBmb3IgKHZhciBrZXkkMSBpbiBsaXN0ZW5lcnMpIHtcbiAgICBkYXRhW2NhbWVsaXplKGtleSQxKV0gPSBsaXN0ZW5lcnNba2V5JDFdO1xuICB9XG4gIHJldHVybiBkYXRhXG59XG5cbmZ1bmN0aW9uIHBsYWNlaG9sZGVyIChoLCByYXdDaGlsZCkge1xuICBpZiAoL1xcZC1rZWVwLWFsaXZlJC8udGVzdChyYXdDaGlsZC50YWcpKSB7XG4gICAgcmV0dXJuIGgoJ2tlZXAtYWxpdmUnLCB7XG4gICAgICBwcm9wczogcmF3Q2hpbGQuY29tcG9uZW50T3B0aW9ucy5wcm9wc0RhdGFcbiAgICB9KVxuICB9XG59XG5cbmZ1bmN0aW9uIGhhc1BhcmVudFRyYW5zaXRpb24gKHZub2RlKSB7XG4gIHdoaWxlICgodm5vZGUgPSB2bm9kZS5wYXJlbnQpKSB7XG4gICAgaWYgKHZub2RlLmRhdGEudHJhbnNpdGlvbikge1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gaXNTYW1lQ2hpbGQgKGNoaWxkLCBvbGRDaGlsZCkge1xuICByZXR1cm4gb2xkQ2hpbGQua2V5ID09PSBjaGlsZC5rZXkgJiYgb2xkQ2hpbGQudGFnID09PSBjaGlsZC50YWdcbn1cblxudmFyIGlzTm90VGV4dE5vZGUgPSBmdW5jdGlvbiAoYykgeyByZXR1cm4gYy50YWcgfHwgaXNBc3luY1BsYWNlaG9sZGVyKGMpOyB9O1xuXG52YXIgaXNWU2hvd0RpcmVjdGl2ZSA9IGZ1bmN0aW9uIChkKSB7IHJldHVybiBkLm5hbWUgPT09ICdzaG93JzsgfTtcblxudmFyIFRyYW5zaXRpb24gPSB7XG4gIG5hbWU6ICd0cmFuc2l0aW9uJyxcbiAgcHJvcHM6IHRyYW5zaXRpb25Qcm9wcyxcbiAgYWJzdHJhY3Q6IHRydWUsXG5cbiAgcmVuZGVyOiBmdW5jdGlvbiByZW5kZXIgKGgpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIHZhciBjaGlsZHJlbiA9IHRoaXMuJHNsb3RzLmRlZmF1bHQ7XG4gICAgaWYgKCFjaGlsZHJlbikge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgLy8gZmlsdGVyIG91dCB0ZXh0IG5vZGVzIChwb3NzaWJsZSB3aGl0ZXNwYWNlcylcbiAgICBjaGlsZHJlbiA9IGNoaWxkcmVuLmZpbHRlcihpc05vdFRleHROb2RlKTtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoIWNoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgLy8gd2FybiBtdWx0aXBsZSBlbGVtZW50c1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGNoaWxkcmVuLmxlbmd0aCA+IDEpIHtcbiAgICAgIHdhcm4oXG4gICAgICAgICc8dHJhbnNpdGlvbj4gY2FuIG9ubHkgYmUgdXNlZCBvbiBhIHNpbmdsZSBlbGVtZW50LiBVc2UgJyArXG4gICAgICAgICc8dHJhbnNpdGlvbi1ncm91cD4gZm9yIGxpc3RzLicsXG4gICAgICAgIHRoaXMuJHBhcmVudFxuICAgICAgKTtcbiAgICB9XG5cbiAgICB2YXIgbW9kZSA9IHRoaXMubW9kZTtcblxuICAgIC8vIHdhcm4gaW52YWxpZCBtb2RlXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiZcbiAgICAgIG1vZGUgJiYgbW9kZSAhPT0gJ2luLW91dCcgJiYgbW9kZSAhPT0gJ291dC1pbidcbiAgICApIHtcbiAgICAgIHdhcm4oXG4gICAgICAgICdpbnZhbGlkIDx0cmFuc2l0aW9uPiBtb2RlOiAnICsgbW9kZSxcbiAgICAgICAgdGhpcy4kcGFyZW50XG4gICAgICApO1xuICAgIH1cblxuICAgIHZhciByYXdDaGlsZCA9IGNoaWxkcmVuWzBdO1xuXG4gICAgLy8gaWYgdGhpcyBpcyBhIGNvbXBvbmVudCByb290IG5vZGUgYW5kIHRoZSBjb21wb25lbnQnc1xuICAgIC8vIHBhcmVudCBjb250YWluZXIgbm9kZSBhbHNvIGhhcyB0cmFuc2l0aW9uLCBza2lwLlxuICAgIGlmIChoYXNQYXJlbnRUcmFuc2l0aW9uKHRoaXMuJHZub2RlKSkge1xuICAgICAgcmV0dXJuIHJhd0NoaWxkXG4gICAgfVxuXG4gICAgLy8gYXBwbHkgdHJhbnNpdGlvbiBkYXRhIHRvIGNoaWxkXG4gICAgLy8gdXNlIGdldFJlYWxDaGlsZCgpIHRvIGlnbm9yZSBhYnN0cmFjdCBjb21wb25lbnRzIGUuZy4ga2VlcC1hbGl2ZVxuICAgIHZhciBjaGlsZCA9IGdldFJlYWxDaGlsZChyYXdDaGlsZCk7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKCFjaGlsZCkge1xuICAgICAgcmV0dXJuIHJhd0NoaWxkXG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX2xlYXZpbmcpIHtcbiAgICAgIHJldHVybiBwbGFjZWhvbGRlcihoLCByYXdDaGlsZClcbiAgICB9XG5cbiAgICAvLyBlbnN1cmUgYSBrZXkgdGhhdCBpcyB1bmlxdWUgdG8gdGhlIHZub2RlIHR5cGUgYW5kIHRvIHRoaXMgdHJhbnNpdGlvblxuICAgIC8vIGNvbXBvbmVudCBpbnN0YW5jZS4gVGhpcyBrZXkgd2lsbCBiZSB1c2VkIHRvIHJlbW92ZSBwZW5kaW5nIGxlYXZpbmcgbm9kZXNcbiAgICAvLyBkdXJpbmcgZW50ZXJpbmcuXG4gICAgdmFyIGlkID0gXCJfX3RyYW5zaXRpb24tXCIgKyAodGhpcy5fdWlkKSArIFwiLVwiO1xuICAgIGNoaWxkLmtleSA9IGNoaWxkLmtleSA9PSBudWxsXG4gICAgICA/IGNoaWxkLmlzQ29tbWVudFxuICAgICAgICA/IGlkICsgJ2NvbW1lbnQnXG4gICAgICAgIDogaWQgKyBjaGlsZC50YWdcbiAgICAgIDogaXNQcmltaXRpdmUoY2hpbGQua2V5KVxuICAgICAgICA/IChTdHJpbmcoY2hpbGQua2V5KS5pbmRleE9mKGlkKSA9PT0gMCA/IGNoaWxkLmtleSA6IGlkICsgY2hpbGQua2V5KVxuICAgICAgICA6IGNoaWxkLmtleTtcblxuICAgIHZhciBkYXRhID0gKGNoaWxkLmRhdGEgfHwgKGNoaWxkLmRhdGEgPSB7fSkpLnRyYW5zaXRpb24gPSBleHRyYWN0VHJhbnNpdGlvbkRhdGEodGhpcyk7XG4gICAgdmFyIG9sZFJhd0NoaWxkID0gdGhpcy5fdm5vZGU7XG4gICAgdmFyIG9sZENoaWxkID0gZ2V0UmVhbENoaWxkKG9sZFJhd0NoaWxkKTtcblxuICAgIC8vIG1hcmsgdi1zaG93XG4gICAgLy8gc28gdGhhdCB0aGUgdHJhbnNpdGlvbiBtb2R1bGUgY2FuIGhhbmQgb3ZlciB0aGUgY29udHJvbCB0byB0aGUgZGlyZWN0aXZlXG4gICAgaWYgKGNoaWxkLmRhdGEuZGlyZWN0aXZlcyAmJiBjaGlsZC5kYXRhLmRpcmVjdGl2ZXMuc29tZShpc1ZTaG93RGlyZWN0aXZlKSkge1xuICAgICAgY2hpbGQuZGF0YS5zaG93ID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAoXG4gICAgICBvbGRDaGlsZCAmJlxuICAgICAgb2xkQ2hpbGQuZGF0YSAmJlxuICAgICAgIWlzU2FtZUNoaWxkKGNoaWxkLCBvbGRDaGlsZCkgJiZcbiAgICAgICFpc0FzeW5jUGxhY2Vob2xkZXIob2xkQ2hpbGQpICYmXG4gICAgICAvLyAjNjY4NyBjb21wb25lbnQgcm9vdCBpcyBhIGNvbW1lbnQgbm9kZVxuICAgICAgIShvbGRDaGlsZC5jb21wb25lbnRJbnN0YW5jZSAmJiBvbGRDaGlsZC5jb21wb25lbnRJbnN0YW5jZS5fdm5vZGUuaXNDb21tZW50KVxuICAgICkge1xuICAgICAgLy8gcmVwbGFjZSBvbGQgY2hpbGQgdHJhbnNpdGlvbiBkYXRhIHdpdGggZnJlc2ggb25lXG4gICAgICAvLyBpbXBvcnRhbnQgZm9yIGR5bmFtaWMgdHJhbnNpdGlvbnMhXG4gICAgICB2YXIgb2xkRGF0YSA9IG9sZENoaWxkLmRhdGEudHJhbnNpdGlvbiA9IGV4dGVuZCh7fSwgZGF0YSk7XG4gICAgICAvLyBoYW5kbGUgdHJhbnNpdGlvbiBtb2RlXG4gICAgICBpZiAobW9kZSA9PT0gJ291dC1pbicpIHtcbiAgICAgICAgLy8gcmV0dXJuIHBsYWNlaG9sZGVyIG5vZGUgYW5kIHF1ZXVlIHVwZGF0ZSB3aGVuIGxlYXZlIGZpbmlzaGVzXG4gICAgICAgIHRoaXMuX2xlYXZpbmcgPSB0cnVlO1xuICAgICAgICBtZXJnZVZOb2RlSG9vayhvbGREYXRhLCAnYWZ0ZXJMZWF2ZScsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB0aGlzJDEuX2xlYXZpbmcgPSBmYWxzZTtcbiAgICAgICAgICB0aGlzJDEuJGZvcmNlVXBkYXRlKCk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcGxhY2Vob2xkZXIoaCwgcmF3Q2hpbGQpXG4gICAgICB9IGVsc2UgaWYgKG1vZGUgPT09ICdpbi1vdXQnKSB7XG4gICAgICAgIGlmIChpc0FzeW5jUGxhY2Vob2xkZXIoY2hpbGQpKSB7XG4gICAgICAgICAgcmV0dXJuIG9sZFJhd0NoaWxkXG4gICAgICAgIH1cbiAgICAgICAgdmFyIGRlbGF5ZWRMZWF2ZTtcbiAgICAgICAgdmFyIHBlcmZvcm1MZWF2ZSA9IGZ1bmN0aW9uICgpIHsgZGVsYXllZExlYXZlKCk7IH07XG4gICAgICAgIG1lcmdlVk5vZGVIb29rKGRhdGEsICdhZnRlckVudGVyJywgcGVyZm9ybUxlYXZlKTtcbiAgICAgICAgbWVyZ2VWTm9kZUhvb2soZGF0YSwgJ2VudGVyQ2FuY2VsbGVkJywgcGVyZm9ybUxlYXZlKTtcbiAgICAgICAgbWVyZ2VWTm9kZUhvb2sob2xkRGF0YSwgJ2RlbGF5TGVhdmUnLCBmdW5jdGlvbiAobGVhdmUpIHsgZGVsYXllZExlYXZlID0gbGVhdmU7IH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByYXdDaGlsZFxuICB9XG59O1xuXG4vKiAgKi9cblxudmFyIHByb3BzID0gZXh0ZW5kKHtcbiAgdGFnOiBTdHJpbmcsXG4gIG1vdmVDbGFzczogU3RyaW5nXG59LCB0cmFuc2l0aW9uUHJvcHMpO1xuXG5kZWxldGUgcHJvcHMubW9kZTtcblxudmFyIFRyYW5zaXRpb25Hcm91cCA9IHtcbiAgcHJvcHM6IHByb3BzLFxuXG4gIGJlZm9yZU1vdW50OiBmdW5jdGlvbiBiZWZvcmVNb3VudCAoKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICB2YXIgdXBkYXRlID0gdGhpcy5fdXBkYXRlO1xuICAgIHRoaXMuX3VwZGF0ZSA9IGZ1bmN0aW9uICh2bm9kZSwgaHlkcmF0aW5nKSB7XG4gICAgICB2YXIgcmVzdG9yZUFjdGl2ZUluc3RhbmNlID0gc2V0QWN0aXZlSW5zdGFuY2UodGhpcyQxKTtcbiAgICAgIC8vIGZvcmNlIHJlbW92aW5nIHBhc3NcbiAgICAgIHRoaXMkMS5fX3BhdGNoX18oXG4gICAgICAgIHRoaXMkMS5fdm5vZGUsXG4gICAgICAgIHRoaXMkMS5rZXB0LFxuICAgICAgICBmYWxzZSwgLy8gaHlkcmF0aW5nXG4gICAgICAgIHRydWUgLy8gcmVtb3ZlT25seSAoIWltcG9ydGFudCwgYXZvaWRzIHVubmVjZXNzYXJ5IG1vdmVzKVxuICAgICAgKTtcbiAgICAgIHRoaXMkMS5fdm5vZGUgPSB0aGlzJDEua2VwdDtcbiAgICAgIHJlc3RvcmVBY3RpdmVJbnN0YW5jZSgpO1xuICAgICAgdXBkYXRlLmNhbGwodGhpcyQxLCB2bm9kZSwgaHlkcmF0aW5nKTtcbiAgICB9O1xuICB9LFxuXG4gIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyIChoKSB7XG4gICAgdmFyIHRhZyA9IHRoaXMudGFnIHx8IHRoaXMuJHZub2RlLmRhdGEudGFnIHx8ICdzcGFuJztcbiAgICB2YXIgbWFwID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB2YXIgcHJldkNoaWxkcmVuID0gdGhpcy5wcmV2Q2hpbGRyZW4gPSB0aGlzLmNoaWxkcmVuO1xuICAgIHZhciByYXdDaGlsZHJlbiA9IHRoaXMuJHNsb3RzLmRlZmF1bHQgfHwgW107XG4gICAgdmFyIGNoaWxkcmVuID0gdGhpcy5jaGlsZHJlbiA9IFtdO1xuICAgIHZhciB0cmFuc2l0aW9uRGF0YSA9IGV4dHJhY3RUcmFuc2l0aW9uRGF0YSh0aGlzKTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmF3Q2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBjID0gcmF3Q2hpbGRyZW5baV07XG4gICAgICBpZiAoYy50YWcpIHtcbiAgICAgICAgaWYgKGMua2V5ICE9IG51bGwgJiYgU3RyaW5nKGMua2V5KS5pbmRleE9mKCdfX3ZsaXN0JykgIT09IDApIHtcbiAgICAgICAgICBjaGlsZHJlbi5wdXNoKGMpO1xuICAgICAgICAgIG1hcFtjLmtleV0gPSBjXG4gICAgICAgICAgOyhjLmRhdGEgfHwgKGMuZGF0YSA9IHt9KSkudHJhbnNpdGlvbiA9IHRyYW5zaXRpb25EYXRhO1xuICAgICAgICB9IGVsc2UgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICB2YXIgb3B0cyA9IGMuY29tcG9uZW50T3B0aW9ucztcbiAgICAgICAgICB2YXIgbmFtZSA9IG9wdHMgPyAob3B0cy5DdG9yLm9wdGlvbnMubmFtZSB8fCBvcHRzLnRhZyB8fCAnJykgOiBjLnRhZztcbiAgICAgICAgICB3YXJuKChcIjx0cmFuc2l0aW9uLWdyb3VwPiBjaGlsZHJlbiBtdXN0IGJlIGtleWVkOiA8XCIgKyBuYW1lICsgXCI+XCIpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChwcmV2Q2hpbGRyZW4pIHtcbiAgICAgIHZhciBrZXB0ID0gW107XG4gICAgICB2YXIgcmVtb3ZlZCA9IFtdO1xuICAgICAgZm9yICh2YXIgaSQxID0gMDsgaSQxIDwgcHJldkNoaWxkcmVuLmxlbmd0aDsgaSQxKyspIHtcbiAgICAgICAgdmFyIGMkMSA9IHByZXZDaGlsZHJlbltpJDFdO1xuICAgICAgICBjJDEuZGF0YS50cmFuc2l0aW9uID0gdHJhbnNpdGlvbkRhdGE7XG4gICAgICAgIGMkMS5kYXRhLnBvcyA9IGMkMS5lbG0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIGlmIChtYXBbYyQxLmtleV0pIHtcbiAgICAgICAgICBrZXB0LnB1c2goYyQxKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZW1vdmVkLnB1c2goYyQxKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5rZXB0ID0gaCh0YWcsIG51bGwsIGtlcHQpO1xuICAgICAgdGhpcy5yZW1vdmVkID0gcmVtb3ZlZDtcbiAgICB9XG5cbiAgICByZXR1cm4gaCh0YWcsIG51bGwsIGNoaWxkcmVuKVxuICB9LFxuXG4gIHVwZGF0ZWQ6IGZ1bmN0aW9uIHVwZGF0ZWQgKCkge1xuICAgIHZhciBjaGlsZHJlbiA9IHRoaXMucHJldkNoaWxkcmVuO1xuICAgIHZhciBtb3ZlQ2xhc3MgPSB0aGlzLm1vdmVDbGFzcyB8fCAoKHRoaXMubmFtZSB8fCAndicpICsgJy1tb3ZlJyk7XG4gICAgaWYgKCFjaGlsZHJlbi5sZW5ndGggfHwgIXRoaXMuaGFzTW92ZShjaGlsZHJlblswXS5lbG0sIG1vdmVDbGFzcykpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIC8vIHdlIGRpdmlkZSB0aGUgd29yayBpbnRvIHRocmVlIGxvb3BzIHRvIGF2b2lkIG1peGluZyBET00gcmVhZHMgYW5kIHdyaXRlc1xuICAgIC8vIGluIGVhY2ggaXRlcmF0aW9uIC0gd2hpY2ggaGVscHMgcHJldmVudCBsYXlvdXQgdGhyYXNoaW5nLlxuICAgIGNoaWxkcmVuLmZvckVhY2goY2FsbFBlbmRpbmdDYnMpO1xuICAgIGNoaWxkcmVuLmZvckVhY2gocmVjb3JkUG9zaXRpb24pO1xuICAgIGNoaWxkcmVuLmZvckVhY2goYXBwbHlUcmFuc2xhdGlvbik7XG5cbiAgICAvLyBmb3JjZSByZWZsb3cgdG8gcHV0IGV2ZXJ5dGhpbmcgaW4gcG9zaXRpb25cbiAgICAvLyBhc3NpZ24gdG8gdGhpcyB0byBhdm9pZCBiZWluZyByZW1vdmVkIGluIHRyZWUtc2hha2luZ1xuICAgIC8vICRmbG93LWRpc2FibGUtbGluZVxuICAgIHRoaXMuX3JlZmxvdyA9IGRvY3VtZW50LmJvZHkub2Zmc2V0SGVpZ2h0O1xuXG4gICAgY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbiAoYykge1xuICAgICAgaWYgKGMuZGF0YS5tb3ZlZCkge1xuICAgICAgICB2YXIgZWwgPSBjLmVsbTtcbiAgICAgICAgdmFyIHMgPSBlbC5zdHlsZTtcbiAgICAgICAgYWRkVHJhbnNpdGlvbkNsYXNzKGVsLCBtb3ZlQ2xhc3MpO1xuICAgICAgICBzLnRyYW5zZm9ybSA9IHMuV2Via2l0VHJhbnNmb3JtID0gcy50cmFuc2l0aW9uRHVyYXRpb24gPSAnJztcbiAgICAgICAgZWwuYWRkRXZlbnRMaXN0ZW5lcih0cmFuc2l0aW9uRW5kRXZlbnQsIGVsLl9tb3ZlQ2IgPSBmdW5jdGlvbiBjYiAoZSkge1xuICAgICAgICAgIGlmIChlICYmIGUudGFyZ2V0ICE9PSBlbCkge1xuICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghZSB8fCAvdHJhbnNmb3JtJC8udGVzdChlLnByb3BlcnR5TmFtZSkpIHtcbiAgICAgICAgICAgIGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIodHJhbnNpdGlvbkVuZEV2ZW50LCBjYik7XG4gICAgICAgICAgICBlbC5fbW92ZUNiID0gbnVsbDtcbiAgICAgICAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgbW92ZUNsYXNzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuICB9LFxuXG4gIG1ldGhvZHM6IHtcbiAgICBoYXNNb3ZlOiBmdW5jdGlvbiBoYXNNb3ZlIChlbCwgbW92ZUNsYXNzKSB7XG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgIGlmICghaGFzVHJhbnNpdGlvbikge1xuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgaWYgKHRoaXMuX2hhc01vdmUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2hhc01vdmVcbiAgICAgIH1cbiAgICAgIC8vIERldGVjdCB3aGV0aGVyIGFuIGVsZW1lbnQgd2l0aCB0aGUgbW92ZSBjbGFzcyBhcHBsaWVkIGhhc1xuICAgICAgLy8gQ1NTIHRyYW5zaXRpb25zLiBTaW5jZSB0aGUgZWxlbWVudCBtYXkgYmUgaW5zaWRlIGFuIGVudGVyaW5nXG4gICAgICAvLyB0cmFuc2l0aW9uIGF0IHRoaXMgdmVyeSBtb21lbnQsIHdlIG1ha2UgYSBjbG9uZSBvZiBpdCBhbmQgcmVtb3ZlXG4gICAgICAvLyBhbGwgb3RoZXIgdHJhbnNpdGlvbiBjbGFzc2VzIGFwcGxpZWQgdG8gZW5zdXJlIG9ubHkgdGhlIG1vdmUgY2xhc3NcbiAgICAgIC8vIGlzIGFwcGxpZWQuXG4gICAgICB2YXIgY2xvbmUgPSBlbC5jbG9uZU5vZGUoKTtcbiAgICAgIGlmIChlbC5fdHJhbnNpdGlvbkNsYXNzZXMpIHtcbiAgICAgICAgZWwuX3RyYW5zaXRpb25DbGFzc2VzLmZvckVhY2goZnVuY3Rpb24gKGNscykgeyByZW1vdmVDbGFzcyhjbG9uZSwgY2xzKTsgfSk7XG4gICAgICB9XG4gICAgICBhZGRDbGFzcyhjbG9uZSwgbW92ZUNsYXNzKTtcbiAgICAgIGNsb25lLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICB0aGlzLiRlbC5hcHBlbmRDaGlsZChjbG9uZSk7XG4gICAgICB2YXIgaW5mbyA9IGdldFRyYW5zaXRpb25JbmZvKGNsb25lKTtcbiAgICAgIHRoaXMuJGVsLnJlbW92ZUNoaWxkKGNsb25lKTtcbiAgICAgIHJldHVybiAodGhpcy5faGFzTW92ZSA9IGluZm8uaGFzVHJhbnNmb3JtKVxuICAgIH1cbiAgfVxufTtcblxuZnVuY3Rpb24gY2FsbFBlbmRpbmdDYnMgKGMpIHtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChjLmVsbS5fbW92ZUNiKSB7XG4gICAgYy5lbG0uX21vdmVDYigpO1xuICB9XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoYy5lbG0uX2VudGVyQ2IpIHtcbiAgICBjLmVsbS5fZW50ZXJDYigpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlY29yZFBvc2l0aW9uIChjKSB7XG4gIGMuZGF0YS5uZXdQb3MgPSBjLmVsbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbn1cblxuZnVuY3Rpb24gYXBwbHlUcmFuc2xhdGlvbiAoYykge1xuICB2YXIgb2xkUG9zID0gYy5kYXRhLnBvcztcbiAgdmFyIG5ld1BvcyA9IGMuZGF0YS5uZXdQb3M7XG4gIHZhciBkeCA9IG9sZFBvcy5sZWZ0IC0gbmV3UG9zLmxlZnQ7XG4gIHZhciBkeSA9IG9sZFBvcy50b3AgLSBuZXdQb3MudG9wO1xuICBpZiAoZHggfHwgZHkpIHtcbiAgICBjLmRhdGEubW92ZWQgPSB0cnVlO1xuICAgIHZhciBzID0gYy5lbG0uc3R5bGU7XG4gICAgcy50cmFuc2Zvcm0gPSBzLldlYmtpdFRyYW5zZm9ybSA9IFwidHJhbnNsYXRlKFwiICsgZHggKyBcInB4LFwiICsgZHkgKyBcInB4KVwiO1xuICAgIHMudHJhbnNpdGlvbkR1cmF0aW9uID0gJzBzJztcbiAgfVxufVxuXG52YXIgcGxhdGZvcm1Db21wb25lbnRzID0ge1xuICBUcmFuc2l0aW9uOiBUcmFuc2l0aW9uLFxuICBUcmFuc2l0aW9uR3JvdXA6IFRyYW5zaXRpb25Hcm91cFxufTtcblxuLyogICovXG5cbi8vIGluc3RhbGwgcGxhdGZvcm0gc3BlY2lmaWMgdXRpbHNcblZ1ZS5jb25maWcubXVzdFVzZVByb3AgPSBtdXN0VXNlUHJvcDtcblZ1ZS5jb25maWcuaXNSZXNlcnZlZFRhZyA9IGlzUmVzZXJ2ZWRUYWc7XG5WdWUuY29uZmlnLmlzUmVzZXJ2ZWRBdHRyID0gaXNSZXNlcnZlZEF0dHI7XG5WdWUuY29uZmlnLmdldFRhZ05hbWVzcGFjZSA9IGdldFRhZ05hbWVzcGFjZTtcblZ1ZS5jb25maWcuaXNVbmtub3duRWxlbWVudCA9IGlzVW5rbm93bkVsZW1lbnQ7XG5cbi8vIGluc3RhbGwgcGxhdGZvcm0gcnVudGltZSBkaXJlY3RpdmVzICYgY29tcG9uZW50c1xuZXh0ZW5kKFZ1ZS5vcHRpb25zLmRpcmVjdGl2ZXMsIHBsYXRmb3JtRGlyZWN0aXZlcyk7XG5leHRlbmQoVnVlLm9wdGlvbnMuY29tcG9uZW50cywgcGxhdGZvcm1Db21wb25lbnRzKTtcblxuLy8gaW5zdGFsbCBwbGF0Zm9ybSBwYXRjaCBmdW5jdGlvblxuVnVlLnByb3RvdHlwZS5fX3BhdGNoX18gPSBpbkJyb3dzZXIgPyBwYXRjaCA6IG5vb3A7XG5cbi8vIHB1YmxpYyBtb3VudCBtZXRob2RcblZ1ZS5wcm90b3R5cGUuJG1vdW50ID0gZnVuY3Rpb24gKFxuICBlbCxcbiAgaHlkcmF0aW5nXG4pIHtcbiAgZWwgPSBlbCAmJiBpbkJyb3dzZXIgPyBxdWVyeShlbCkgOiB1bmRlZmluZWQ7XG4gIHJldHVybiBtb3VudENvbXBvbmVudCh0aGlzLCBlbCwgaHlkcmF0aW5nKVxufTtcblxuLy8gZGV2dG9vbHMgZ2xvYmFsIGhvb2tcbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5pZiAoaW5Ccm93c2VyKSB7XG4gIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgIGlmIChjb25maWcuZGV2dG9vbHMpIHtcbiAgICAgIGlmIChkZXZ0b29scykge1xuICAgICAgICBkZXZ0b29scy5lbWl0KCdpbml0JywgVnVlKTtcbiAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiZcbiAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICd0ZXN0J1xuICAgICAgKSB7XG4gICAgICAgIGNvbnNvbGVbY29uc29sZS5pbmZvID8gJ2luZm8nIDogJ2xvZyddKFxuICAgICAgICAgICdEb3dubG9hZCB0aGUgVnVlIERldnRvb2xzIGV4dGVuc2lvbiBmb3IgYSBiZXR0ZXIgZGV2ZWxvcG1lbnQgZXhwZXJpZW5jZTpcXG4nICtcbiAgICAgICAgICAnaHR0cHM6Ly9naXRodWIuY29tL3Z1ZWpzL3Z1ZS1kZXZ0b29scydcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiZcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAndGVzdCcgJiZcbiAgICAgIGNvbmZpZy5wcm9kdWN0aW9uVGlwICE9PSBmYWxzZSAmJlxuICAgICAgdHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnXG4gICAgKSB7XG4gICAgICBjb25zb2xlW2NvbnNvbGUuaW5mbyA/ICdpbmZvJyA6ICdsb2cnXShcbiAgICAgICAgXCJZb3UgYXJlIHJ1bm5pbmcgVnVlIGluIGRldmVsb3BtZW50IG1vZGUuXFxuXCIgK1xuICAgICAgICBcIk1ha2Ugc3VyZSB0byB0dXJuIG9uIHByb2R1Y3Rpb24gbW9kZSB3aGVuIGRlcGxveWluZyBmb3IgcHJvZHVjdGlvbi5cXG5cIiArXG4gICAgICAgIFwiU2VlIG1vcmUgdGlwcyBhdCBodHRwczovL3Z1ZWpzLm9yZy9ndWlkZS9kZXBsb3ltZW50Lmh0bWxcIlxuICAgICAgKTtcbiAgICB9XG4gIH0sIDApO1xufVxuXG4vKiAgKi9cblxuZXhwb3J0IGRlZmF1bHQgVnVlO1xuIiwiKGZ1bmN0aW9uIHdlYnBhY2tVbml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uKHJvb3QsIGZhY3RvcnkpIHtcblx0aWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnKVxuXHRcdG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeShyZXF1aXJlKFwic29ydGFibGVqc1wiKSk7XG5cdGVsc2UgaWYodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKVxuXHRcdGRlZmluZShbXCJzb3J0YWJsZWpzXCJdLCBmYWN0b3J5KTtcblx0ZWxzZSBpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcpXG5cdFx0ZXhwb3J0c1tcInZ1ZWRyYWdnYWJsZVwiXSA9IGZhY3RvcnkocmVxdWlyZShcInNvcnRhYmxlanNcIikpO1xuXHRlbHNlXG5cdFx0cm9vdFtcInZ1ZWRyYWdnYWJsZVwiXSA9IGZhY3Rvcnkocm9vdFtcIlNvcnRhYmxlXCJdKTtcbn0pKCh0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcgPyBzZWxmIDogdGhpcyksIGZ1bmN0aW9uKF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfYTM1Ml9fKSB7XG5yZXR1cm4gIiwiIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxuIFx0dmFyIGluc3RhbGxlZE1vZHVsZXMgPSB7fTtcblxuIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbiBcdGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcblxuIFx0XHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcbiBcdFx0aWYoaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0pIHtcbiBcdFx0XHRyZXR1cm4gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0uZXhwb3J0cztcbiBcdFx0fVxuIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuIFx0XHR2YXIgbW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0gPSB7XG4gXHRcdFx0aTogbW9kdWxlSWQsXG4gXHRcdFx0bDogZmFsc2UsXG4gXHRcdFx0ZXhwb3J0czoge31cbiBcdFx0fTtcblxuIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cbiBcdFx0bW9kdWxlc1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG5cbiBcdFx0Ly8gRmxhZyB0aGUgbW9kdWxlIGFzIGxvYWRlZFxuIFx0XHRtb2R1bGUubCA9IHRydWU7XG5cbiBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbiBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuIFx0fVxuXG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlcyBvYmplY3QgKF9fd2VicGFja19tb2R1bGVzX18pXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm0gPSBtb2R1bGVzO1xuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZSBjYWNoZVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5jID0gaW5zdGFsbGVkTW9kdWxlcztcblxuIFx0Ly8gZGVmaW5lIGdldHRlciBmdW5jdGlvbiBmb3IgaGFybW9ueSBleHBvcnRzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQgPSBmdW5jdGlvbihleHBvcnRzLCBuYW1lLCBnZXR0ZXIpIHtcbiBcdFx0aWYoIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBuYW1lKSkge1xuIFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBuYW1lLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZ2V0dGVyIH0pO1xuIFx0XHR9XG4gXHR9O1xuXG4gXHQvLyBkZWZpbmUgX19lc01vZHVsZSBvbiBleHBvcnRzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnIgPSBmdW5jdGlvbihleHBvcnRzKSB7XG4gXHRcdGlmKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIFN5bWJvbC50b1N0cmluZ1RhZykge1xuIFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBTeW1ib2wudG9TdHJpbmdUYWcsIHsgdmFsdWU6ICdNb2R1bGUnIH0pO1xuIFx0XHR9XG4gXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG4gXHR9O1xuXG4gXHQvLyBjcmVhdGUgYSBmYWtlIG5hbWVzcGFjZSBvYmplY3RcbiBcdC8vIG1vZGUgJiAxOiB2YWx1ZSBpcyBhIG1vZHVsZSBpZCwgcmVxdWlyZSBpdFxuIFx0Ly8gbW9kZSAmIDI6IG1lcmdlIGFsbCBwcm9wZXJ0aWVzIG9mIHZhbHVlIGludG8gdGhlIG5zXG4gXHQvLyBtb2RlICYgNDogcmV0dXJuIHZhbHVlIHdoZW4gYWxyZWFkeSBucyBvYmplY3RcbiBcdC8vIG1vZGUgJiA4fDE6IGJlaGF2ZSBsaWtlIHJlcXVpcmVcbiBcdF9fd2VicGFja19yZXF1aXJlX18udCA9IGZ1bmN0aW9uKHZhbHVlLCBtb2RlKSB7XG4gXHRcdGlmKG1vZGUgJiAxKSB2YWx1ZSA9IF9fd2VicGFja19yZXF1aXJlX18odmFsdWUpO1xuIFx0XHRpZihtb2RlICYgOCkgcmV0dXJuIHZhbHVlO1xuIFx0XHRpZigobW9kZSAmIDQpICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgdmFsdWUgJiYgdmFsdWUuX19lc01vZHVsZSkgcmV0dXJuIHZhbHVlO1xuIFx0XHR2YXIgbnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLnIobnMpO1xuIFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkobnMsICdkZWZhdWx0JywgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdmFsdWUgfSk7XG4gXHRcdGlmKG1vZGUgJiAyICYmIHR5cGVvZiB2YWx1ZSAhPSAnc3RyaW5nJykgZm9yKHZhciBrZXkgaW4gdmFsdWUpIF9fd2VicGFja19yZXF1aXJlX18uZChucywga2V5LCBmdW5jdGlvbihrZXkpIHsgcmV0dXJuIHZhbHVlW2tleV07IH0uYmluZChudWxsLCBrZXkpKTtcbiBcdFx0cmV0dXJuIG5zO1xuIFx0fTtcblxuIFx0Ly8gZ2V0RGVmYXVsdEV4cG9ydCBmdW5jdGlvbiBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIG5vbi1oYXJtb255IG1vZHVsZXNcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubiA9IGZ1bmN0aW9uKG1vZHVsZSkge1xuIFx0XHR2YXIgZ2V0dGVyID0gbW9kdWxlICYmIG1vZHVsZS5fX2VzTW9kdWxlID9cbiBcdFx0XHRmdW5jdGlvbiBnZXREZWZhdWx0KCkgeyByZXR1cm4gbW9kdWxlWydkZWZhdWx0J107IH0gOlxuIFx0XHRcdGZ1bmN0aW9uIGdldE1vZHVsZUV4cG9ydHMoKSB7IHJldHVybiBtb2R1bGU7IH07XG4gXHRcdF9fd2VicGFja19yZXF1aXJlX18uZChnZXR0ZXIsICdhJywgZ2V0dGVyKTtcbiBcdFx0cmV0dXJuIGdldHRlcjtcbiBcdH07XG5cbiBcdC8vIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbFxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5vID0gZnVuY3Rpb24ob2JqZWN0LCBwcm9wZXJ0eSkgeyByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpOyB9O1xuXG4gXHQvLyBfX3dlYnBhY2tfcHVibGljX3BhdGhfX1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXCJcIjtcblxuXG4gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbiBcdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKF9fd2VicGFja19yZXF1aXJlX18ucyA9IFwiZmIxNVwiKTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBMSUJSQVJZID0gcmVxdWlyZSgnLi9fbGlicmFyeScpO1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciByZWRlZmluZSA9IHJlcXVpcmUoJy4vX3JlZGVmaW5lJyk7XG52YXIgaGlkZSA9IHJlcXVpcmUoJy4vX2hpZGUnKTtcbnZhciBJdGVyYXRvcnMgPSByZXF1aXJlKCcuL19pdGVyYXRvcnMnKTtcbnZhciAkaXRlckNyZWF0ZSA9IHJlcXVpcmUoJy4vX2l0ZXItY3JlYXRlJyk7XG52YXIgc2V0VG9TdHJpbmdUYWcgPSByZXF1aXJlKCcuL19zZXQtdG8tc3RyaW5nLXRhZycpO1xudmFyIGdldFByb3RvdHlwZU9mID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdwbycpO1xudmFyIElURVJBVE9SID0gcmVxdWlyZSgnLi9fd2tzJykoJ2l0ZXJhdG9yJyk7XG52YXIgQlVHR1kgPSAhKFtdLmtleXMgJiYgJ25leHQnIGluIFtdLmtleXMoKSk7IC8vIFNhZmFyaSBoYXMgYnVnZ3kgaXRlcmF0b3JzIHcvbyBgbmV4dGBcbnZhciBGRl9JVEVSQVRPUiA9ICdAQGl0ZXJhdG9yJztcbnZhciBLRVlTID0gJ2tleXMnO1xudmFyIFZBTFVFUyA9ICd2YWx1ZXMnO1xuXG52YXIgcmV0dXJuVGhpcyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH07XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKEJhc2UsIE5BTUUsIENvbnN0cnVjdG9yLCBuZXh0LCBERUZBVUxULCBJU19TRVQsIEZPUkNFRCkge1xuICAkaXRlckNyZWF0ZShDb25zdHJ1Y3RvciwgTkFNRSwgbmV4dCk7XG4gIHZhciBnZXRNZXRob2QgPSBmdW5jdGlvbiAoa2luZCkge1xuICAgIGlmICghQlVHR1kgJiYga2luZCBpbiBwcm90bykgcmV0dXJuIHByb3RvW2tpbmRdO1xuICAgIHN3aXRjaCAoa2luZCkge1xuICAgICAgY2FzZSBLRVlTOiByZXR1cm4gZnVuY3Rpb24ga2V5cygpIHsgcmV0dXJuIG5ldyBDb25zdHJ1Y3Rvcih0aGlzLCBraW5kKTsgfTtcbiAgICAgIGNhc2UgVkFMVUVTOiByZXR1cm4gZnVuY3Rpb24gdmFsdWVzKCkgeyByZXR1cm4gbmV3IENvbnN0cnVjdG9yKHRoaXMsIGtpbmQpOyB9O1xuICAgIH0gcmV0dXJuIGZ1bmN0aW9uIGVudHJpZXMoKSB7IHJldHVybiBuZXcgQ29uc3RydWN0b3IodGhpcywga2luZCk7IH07XG4gIH07XG4gIHZhciBUQUcgPSBOQU1FICsgJyBJdGVyYXRvcic7XG4gIHZhciBERUZfVkFMVUVTID0gREVGQVVMVCA9PSBWQUxVRVM7XG4gIHZhciBWQUxVRVNfQlVHID0gZmFsc2U7XG4gIHZhciBwcm90byA9IEJhc2UucHJvdG90eXBlO1xuICB2YXIgJG5hdGl2ZSA9IHByb3RvW0lURVJBVE9SXSB8fCBwcm90b1tGRl9JVEVSQVRPUl0gfHwgREVGQVVMVCAmJiBwcm90b1tERUZBVUxUXTtcbiAgdmFyICRkZWZhdWx0ID0gJG5hdGl2ZSB8fCBnZXRNZXRob2QoREVGQVVMVCk7XG4gIHZhciAkZW50cmllcyA9IERFRkFVTFQgPyAhREVGX1ZBTFVFUyA/ICRkZWZhdWx0IDogZ2V0TWV0aG9kKCdlbnRyaWVzJykgOiB1bmRlZmluZWQ7XG4gIHZhciAkYW55TmF0aXZlID0gTkFNRSA9PSAnQXJyYXknID8gcHJvdG8uZW50cmllcyB8fCAkbmF0aXZlIDogJG5hdGl2ZTtcbiAgdmFyIG1ldGhvZHMsIGtleSwgSXRlcmF0b3JQcm90b3R5cGU7XG4gIC8vIEZpeCBuYXRpdmVcbiAgaWYgKCRhbnlOYXRpdmUpIHtcbiAgICBJdGVyYXRvclByb3RvdHlwZSA9IGdldFByb3RvdHlwZU9mKCRhbnlOYXRpdmUuY2FsbChuZXcgQmFzZSgpKSk7XG4gICAgaWYgKEl0ZXJhdG9yUHJvdG90eXBlICE9PSBPYmplY3QucHJvdG90eXBlICYmIEl0ZXJhdG9yUHJvdG90eXBlLm5leHQpIHtcbiAgICAgIC8vIFNldCBAQHRvU3RyaW5nVGFnIHRvIG5hdGl2ZSBpdGVyYXRvcnNcbiAgICAgIHNldFRvU3RyaW5nVGFnKEl0ZXJhdG9yUHJvdG90eXBlLCBUQUcsIHRydWUpO1xuICAgICAgLy8gZml4IGZvciBzb21lIG9sZCBlbmdpbmVzXG4gICAgICBpZiAoIUxJQlJBUlkgJiYgdHlwZW9mIEl0ZXJhdG9yUHJvdG90eXBlW0lURVJBVE9SXSAhPSAnZnVuY3Rpb24nKSBoaWRlKEl0ZXJhdG9yUHJvdG90eXBlLCBJVEVSQVRPUiwgcmV0dXJuVGhpcyk7XG4gICAgfVxuICB9XG4gIC8vIGZpeCBBcnJheSN7dmFsdWVzLCBAQGl0ZXJhdG9yfS5uYW1lIGluIFY4IC8gRkZcbiAgaWYgKERFRl9WQUxVRVMgJiYgJG5hdGl2ZSAmJiAkbmF0aXZlLm5hbWUgIT09IFZBTFVFUykge1xuICAgIFZBTFVFU19CVUcgPSB0cnVlO1xuICAgICRkZWZhdWx0ID0gZnVuY3Rpb24gdmFsdWVzKCkgeyByZXR1cm4gJG5hdGl2ZS5jYWxsKHRoaXMpOyB9O1xuICB9XG4gIC8vIERlZmluZSBpdGVyYXRvclxuICBpZiAoKCFMSUJSQVJZIHx8IEZPUkNFRCkgJiYgKEJVR0dZIHx8IFZBTFVFU19CVUcgfHwgIXByb3RvW0lURVJBVE9SXSkpIHtcbiAgICBoaWRlKHByb3RvLCBJVEVSQVRPUiwgJGRlZmF1bHQpO1xuICB9XG4gIC8vIFBsdWcgZm9yIGxpYnJhcnlcbiAgSXRlcmF0b3JzW05BTUVdID0gJGRlZmF1bHQ7XG4gIEl0ZXJhdG9yc1tUQUddID0gcmV0dXJuVGhpcztcbiAgaWYgKERFRkFVTFQpIHtcbiAgICBtZXRob2RzID0ge1xuICAgICAgdmFsdWVzOiBERUZfVkFMVUVTID8gJGRlZmF1bHQgOiBnZXRNZXRob2QoVkFMVUVTKSxcbiAgICAgIGtleXM6IElTX1NFVCA/ICRkZWZhdWx0IDogZ2V0TWV0aG9kKEtFWVMpLFxuICAgICAgZW50cmllczogJGVudHJpZXNcbiAgICB9O1xuICAgIGlmIChGT1JDRUQpIGZvciAoa2V5IGluIG1ldGhvZHMpIHtcbiAgICAgIGlmICghKGtleSBpbiBwcm90bykpIHJlZGVmaW5lKHByb3RvLCBrZXksIG1ldGhvZHNba2V5XSk7XG4gICAgfSBlbHNlICRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogKEJVR0dZIHx8IFZBTFVFU19CVUcpLCBOQU1FLCBtZXRob2RzKTtcbiAgfVxuICByZXR1cm4gbWV0aG9kcztcbn07XG4iLCJ2YXIgdG9JbnRlZ2VyID0gcmVxdWlyZSgnLi9fdG8taW50ZWdlcicpO1xudmFyIGRlZmluZWQgPSByZXF1aXJlKCcuL19kZWZpbmVkJyk7XG4vLyB0cnVlICAtPiBTdHJpbmcjYXRcbi8vIGZhbHNlIC0+IFN0cmluZyNjb2RlUG9pbnRBdFxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoVE9fU1RSSU5HKSB7XG4gIHJldHVybiBmdW5jdGlvbiAodGhhdCwgcG9zKSB7XG4gICAgdmFyIHMgPSBTdHJpbmcoZGVmaW5lZCh0aGF0KSk7XG4gICAgdmFyIGkgPSB0b0ludGVnZXIocG9zKTtcbiAgICB2YXIgbCA9IHMubGVuZ3RoO1xuICAgIHZhciBhLCBiO1xuICAgIGlmIChpIDwgMCB8fCBpID49IGwpIHJldHVybiBUT19TVFJJTkcgPyAnJyA6IHVuZGVmaW5lZDtcbiAgICBhID0gcy5jaGFyQ29kZUF0KGkpO1xuICAgIHJldHVybiBhIDwgMHhkODAwIHx8IGEgPiAweGRiZmYgfHwgaSArIDEgPT09IGwgfHwgKGIgPSBzLmNoYXJDb2RlQXQoaSArIDEpKSA8IDB4ZGMwMCB8fCBiID4gMHhkZmZmXG4gICAgICA/IFRPX1NUUklORyA/IHMuY2hhckF0KGkpIDogYVxuICAgICAgOiBUT19TVFJJTkcgPyBzLnNsaWNlKGksIGkgKyAyKSA6IChhIC0gMHhkODAwIDw8IDEwKSArIChiIC0gMHhkYzAwKSArIDB4MTAwMDA7XG4gIH07XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGF0ID0gcmVxdWlyZSgnLi9fc3RyaW5nLWF0JykodHJ1ZSk7XG5cbiAvLyBgQWR2YW5jZVN0cmluZ0luZGV4YCBhYnN0cmFjdCBvcGVyYXRpb25cbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWFkdmFuY2VzdHJpbmdpbmRleFxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoUywgaW5kZXgsIHVuaWNvZGUpIHtcbiAgcmV0dXJuIGluZGV4ICsgKHVuaWNvZGUgPyBhdChTLCBpbmRleCkubGVuZ3RoIDogMSk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuLy8gMjEuMi41LjMgZ2V0IFJlZ0V4cC5wcm90b3R5cGUuZmxhZ3NcbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciB0aGF0ID0gYW5PYmplY3QodGhpcyk7XG4gIHZhciByZXN1bHQgPSAnJztcbiAgaWYgKHRoYXQuZ2xvYmFsKSByZXN1bHQgKz0gJ2cnO1xuICBpZiAodGhhdC5pZ25vcmVDYXNlKSByZXN1bHQgKz0gJ2knO1xuICBpZiAodGhhdC5tdWx0aWxpbmUpIHJlc3VsdCArPSAnbSc7XG4gIGlmICh0aGF0LnVuaWNvZGUpIHJlc3VsdCArPSAndSc7XG4gIGlmICh0aGF0LnN0aWNreSkgcmVzdWx0ICs9ICd5JztcbiAgcmV0dXJuIHJlc3VsdDtcbn07XG4iLCIvLyAxOS4xLjIuMTQgLyAxNS4yLjMuMTQgT2JqZWN0LmtleXMoTylcbnZhciAka2V5cyA9IHJlcXVpcmUoJy4vX29iamVjdC1rZXlzLWludGVybmFsJyk7XG52YXIgZW51bUJ1Z0tleXMgPSByZXF1aXJlKCcuL19lbnVtLWJ1Zy1rZXlzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gT2JqZWN0LmtleXMgfHwgZnVuY3Rpb24ga2V5cyhPKSB7XG4gIHJldHVybiAka2V5cyhPLCBlbnVtQnVnS2V5cyk7XG59O1xuIiwidmFyIGRQID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJyk7XG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcbnZhciBnZXRLZXlzID0gcmVxdWlyZSgnLi9fb2JqZWN0LWtleXMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpID8gT2JqZWN0LmRlZmluZVByb3BlcnRpZXMgOiBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKE8sIFByb3BlcnRpZXMpIHtcbiAgYW5PYmplY3QoTyk7XG4gIHZhciBrZXlzID0gZ2V0S2V5cyhQcm9wZXJ0aWVzKTtcbiAgdmFyIGxlbmd0aCA9IGtleXMubGVuZ3RoO1xuICB2YXIgaSA9IDA7XG4gIHZhciBQO1xuICB3aGlsZSAobGVuZ3RoID4gaSkgZFAuZihPLCBQID0ga2V5c1tpKytdLCBQcm9wZXJ0aWVzW1BdKTtcbiAgcmV0dXJuIE87XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xucmVxdWlyZSgnLi9lczYucmVnZXhwLmV4ZWMnKTtcbnZhciByZWRlZmluZSA9IHJlcXVpcmUoJy4vX3JlZGVmaW5lJyk7XG52YXIgaGlkZSA9IHJlcXVpcmUoJy4vX2hpZGUnKTtcbnZhciBmYWlscyA9IHJlcXVpcmUoJy4vX2ZhaWxzJyk7XG52YXIgZGVmaW5lZCA9IHJlcXVpcmUoJy4vX2RlZmluZWQnKTtcbnZhciB3a3MgPSByZXF1aXJlKCcuL193a3MnKTtcbnZhciByZWdleHBFeGVjID0gcmVxdWlyZSgnLi9fcmVnZXhwLWV4ZWMnKTtcblxudmFyIFNQRUNJRVMgPSB3a3MoJ3NwZWNpZXMnKTtcblxudmFyIFJFUExBQ0VfU1VQUE9SVFNfTkFNRURfR1JPVVBTID0gIWZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgLy8gI3JlcGxhY2UgbmVlZHMgYnVpbHQtaW4gc3VwcG9ydCBmb3IgbmFtZWQgZ3JvdXBzLlxuICAvLyAjbWF0Y2ggd29ya3MgZmluZSBiZWNhdXNlIGl0IGp1c3QgcmV0dXJuIHRoZSBleGVjIHJlc3VsdHMsIGV2ZW4gaWYgaXQgaGFzXG4gIC8vIGEgXCJncm9wc1wiIHByb3BlcnR5LlxuICB2YXIgcmUgPSAvLi87XG4gIHJlLmV4ZWMgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgIHJlc3VsdC5ncm91cHMgPSB7IGE6ICc3JyB9O1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG4gIHJldHVybiAnJy5yZXBsYWNlKHJlLCAnJDxhPicpICE9PSAnNyc7XG59KTtcblxudmFyIFNQTElUX1dPUktTX1dJVEhfT1ZFUldSSVRURU5fRVhFQyA9IChmdW5jdGlvbiAoKSB7XG4gIC8vIENocm9tZSA1MSBoYXMgYSBidWdneSBcInNwbGl0XCIgaW1wbGVtZW50YXRpb24gd2hlbiBSZWdFeHAjZXhlYyAhPT0gbmF0aXZlRXhlY1xuICB2YXIgcmUgPSAvKD86KS87XG4gIHZhciBvcmlnaW5hbEV4ZWMgPSByZS5leGVjO1xuICByZS5leGVjID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gb3JpZ2luYWxFeGVjLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH07XG4gIHZhciByZXN1bHQgPSAnYWInLnNwbGl0KHJlKTtcbiAgcmV0dXJuIHJlc3VsdC5sZW5ndGggPT09IDIgJiYgcmVzdWx0WzBdID09PSAnYScgJiYgcmVzdWx0WzFdID09PSAnYic7XG59KSgpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChLRVksIGxlbmd0aCwgZXhlYykge1xuICB2YXIgU1lNQk9MID0gd2tzKEtFWSk7XG5cbiAgdmFyIERFTEVHQVRFU19UT19TWU1CT0wgPSAhZmFpbHMoZnVuY3Rpb24gKCkge1xuICAgIC8vIFN0cmluZyBtZXRob2RzIGNhbGwgc3ltYm9sLW5hbWVkIFJlZ0VwIG1ldGhvZHNcbiAgICB2YXIgTyA9IHt9O1xuICAgIE9bU1lNQk9MXSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDc7IH07XG4gICAgcmV0dXJuICcnW0tFWV0oTykgIT0gNztcbiAgfSk7XG5cbiAgdmFyIERFTEVHQVRFU19UT19FWEVDID0gREVMRUdBVEVTX1RPX1NZTUJPTCA/ICFmYWlscyhmdW5jdGlvbiAoKSB7XG4gICAgLy8gU3ltYm9sLW5hbWVkIFJlZ0V4cCBtZXRob2RzIGNhbGwgLmV4ZWNcbiAgICB2YXIgZXhlY0NhbGxlZCA9IGZhbHNlO1xuICAgIHZhciByZSA9IC9hLztcbiAgICByZS5leGVjID0gZnVuY3Rpb24gKCkgeyBleGVjQ2FsbGVkID0gdHJ1ZTsgcmV0dXJuIG51bGw7IH07XG4gICAgaWYgKEtFWSA9PT0gJ3NwbGl0Jykge1xuICAgICAgLy8gUmVnRXhwW0BAc3BsaXRdIGRvZXNuJ3QgY2FsbCB0aGUgcmVnZXgncyBleGVjIG1ldGhvZCwgYnV0IGZpcnN0IGNyZWF0ZXNcbiAgICAgIC8vIGEgbmV3IG9uZS4gV2UgbmVlZCB0byByZXR1cm4gdGhlIHBhdGNoZWQgcmVnZXggd2hlbiBjcmVhdGluZyB0aGUgbmV3IG9uZS5cbiAgICAgIHJlLmNvbnN0cnVjdG9yID0ge307XG4gICAgICByZS5jb25zdHJ1Y3RvcltTUEVDSUVTXSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHJlOyB9O1xuICAgIH1cbiAgICByZVtTWU1CT0xdKCcnKTtcbiAgICByZXR1cm4gIWV4ZWNDYWxsZWQ7XG4gIH0pIDogdW5kZWZpbmVkO1xuXG4gIGlmIChcbiAgICAhREVMRUdBVEVTX1RPX1NZTUJPTCB8fFxuICAgICFERUxFR0FURVNfVE9fRVhFQyB8fFxuICAgIChLRVkgPT09ICdyZXBsYWNlJyAmJiAhUkVQTEFDRV9TVVBQT1JUU19OQU1FRF9HUk9VUFMpIHx8XG4gICAgKEtFWSA9PT0gJ3NwbGl0JyAmJiAhU1BMSVRfV09SS1NfV0lUSF9PVkVSV1JJVFRFTl9FWEVDKVxuICApIHtcbiAgICB2YXIgbmF0aXZlUmVnRXhwTWV0aG9kID0gLy4vW1NZTUJPTF07XG4gICAgdmFyIGZucyA9IGV4ZWMoXG4gICAgICBkZWZpbmVkLFxuICAgICAgU1lNQk9MLFxuICAgICAgJydbS0VZXSxcbiAgICAgIGZ1bmN0aW9uIG1heWJlQ2FsbE5hdGl2ZShuYXRpdmVNZXRob2QsIHJlZ2V4cCwgc3RyLCBhcmcyLCBmb3JjZVN0cmluZ01ldGhvZCkge1xuICAgICAgICBpZiAocmVnZXhwLmV4ZWMgPT09IHJlZ2V4cEV4ZWMpIHtcbiAgICAgICAgICBpZiAoREVMRUdBVEVTX1RPX1NZTUJPTCAmJiAhZm9yY2VTdHJpbmdNZXRob2QpIHtcbiAgICAgICAgICAgIC8vIFRoZSBuYXRpdmUgU3RyaW5nIG1ldGhvZCBhbHJlYWR5IGRlbGVnYXRlcyB0byBAQG1ldGhvZCAodGhpc1xuICAgICAgICAgICAgLy8gcG9seWZpbGxlZCBmdW5jdGlvbiksIGxlYXNpbmcgdG8gaW5maW5pdGUgcmVjdXJzaW9uLlxuICAgICAgICAgICAgLy8gV2UgYXZvaWQgaXQgYnkgZGlyZWN0bHkgY2FsbGluZyB0aGUgbmF0aXZlIEBAbWV0aG9kIG1ldGhvZC5cbiAgICAgICAgICAgIHJldHVybiB7IGRvbmU6IHRydWUsIHZhbHVlOiBuYXRpdmVSZWdFeHBNZXRob2QuY2FsbChyZWdleHAsIHN0ciwgYXJnMikgfTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHsgZG9uZTogdHJ1ZSwgdmFsdWU6IG5hdGl2ZU1ldGhvZC5jYWxsKHN0ciwgcmVnZXhwLCBhcmcyKSB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IGRvbmU6IGZhbHNlIH07XG4gICAgICB9XG4gICAgKTtcbiAgICB2YXIgc3RyZm4gPSBmbnNbMF07XG4gICAgdmFyIHJ4Zm4gPSBmbnNbMV07XG5cbiAgICByZWRlZmluZShTdHJpbmcucHJvdG90eXBlLCBLRVksIHN0cmZuKTtcbiAgICBoaWRlKFJlZ0V4cC5wcm90b3R5cGUsIFNZTUJPTCwgbGVuZ3RoID09IDJcbiAgICAgIC8vIDIxLjIuNS44IFJlZ0V4cC5wcm90b3R5cGVbQEByZXBsYWNlXShzdHJpbmcsIHJlcGxhY2VWYWx1ZSlcbiAgICAgIC8vIDIxLjIuNS4xMSBSZWdFeHAucHJvdG90eXBlW0BAc3BsaXRdKHN0cmluZywgbGltaXQpXG4gICAgICA/IGZ1bmN0aW9uIChzdHJpbmcsIGFyZykgeyByZXR1cm4gcnhmbi5jYWxsKHN0cmluZywgdGhpcywgYXJnKTsgfVxuICAgICAgLy8gMjEuMi41LjYgUmVnRXhwLnByb3RvdHlwZVtAQG1hdGNoXShzdHJpbmcpXG4gICAgICAvLyAyMS4yLjUuOSBSZWdFeHAucHJvdG90eXBlW0BAc2VhcmNoXShzdHJpbmcpXG4gICAgICA6IGZ1bmN0aW9uIChzdHJpbmcpIHsgcmV0dXJuIHJ4Zm4uY2FsbChzdHJpbmcsIHRoaXMpOyB9XG4gICAgKTtcbiAgfVxufTtcbiIsInZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xudmFyIGRvY3VtZW50ID0gcmVxdWlyZSgnLi9fZ2xvYmFsJykuZG9jdW1lbnQ7XG4vLyB0eXBlb2YgZG9jdW1lbnQuY3JlYXRlRWxlbWVudCBpcyAnb2JqZWN0JyBpbiBvbGQgSUVcbnZhciBpcyA9IGlzT2JqZWN0KGRvY3VtZW50KSAmJiBpc09iamVjdChkb2N1bWVudC5jcmVhdGVFbGVtZW50KTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiBpcyA/IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoaXQpIDoge307XG59O1xuIiwiLy8gZ2V0dGluZyB0YWcgZnJvbSAxOS4xLjMuNiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nKClcbnZhciBjb2YgPSByZXF1aXJlKCcuL19jb2YnKTtcbnZhciBUQUcgPSByZXF1aXJlKCcuL193a3MnKSgndG9TdHJpbmdUYWcnKTtcbi8vIEVTMyB3cm9uZyBoZXJlXG52YXIgQVJHID0gY29mKGZ1bmN0aW9uICgpIHsgcmV0dXJuIGFyZ3VtZW50czsgfSgpKSA9PSAnQXJndW1lbnRzJztcblxuLy8gZmFsbGJhY2sgZm9yIElFMTEgU2NyaXB0IEFjY2VzcyBEZW5pZWQgZXJyb3JcbnZhciB0cnlHZXQgPSBmdW5jdGlvbiAoaXQsIGtleSkge1xuICB0cnkge1xuICAgIHJldHVybiBpdFtrZXldO1xuICB9IGNhdGNoIChlKSB7IC8qIGVtcHR5ICovIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIHZhciBPLCBULCBCO1xuICByZXR1cm4gaXQgPT09IHVuZGVmaW5lZCA/ICdVbmRlZmluZWQnIDogaXQgPT09IG51bGwgPyAnTnVsbCdcbiAgICAvLyBAQHRvU3RyaW5nVGFnIGNhc2VcbiAgICA6IHR5cGVvZiAoVCA9IHRyeUdldChPID0gT2JqZWN0KGl0KSwgVEFHKSkgPT0gJ3N0cmluZycgPyBUXG4gICAgLy8gYnVpbHRpblRhZyBjYXNlXG4gICAgOiBBUkcgPyBjb2YoTylcbiAgICAvLyBFUzMgYXJndW1lbnRzIGZhbGxiYWNrXG4gICAgOiAoQiA9IGNvZihPKSkgPT0gJ09iamVjdCcgJiYgdHlwZW9mIE8uY2FsbGVlID09ICdmdW5jdGlvbicgPyAnQXJndW1lbnRzJyA6IEI7XG59O1xuIiwiZXhwb3J0cy5mID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scztcbiIsInZhciBnbG9iYWwgPSByZXF1aXJlKCcuL19nbG9iYWwnKTtcbnZhciBoaWRlID0gcmVxdWlyZSgnLi9faGlkZScpO1xudmFyIGhhcyA9IHJlcXVpcmUoJy4vX2hhcycpO1xudmFyIFNSQyA9IHJlcXVpcmUoJy4vX3VpZCcpKCdzcmMnKTtcbnZhciAkdG9TdHJpbmcgPSByZXF1aXJlKCcuL19mdW5jdGlvbi10by1zdHJpbmcnKTtcbnZhciBUT19TVFJJTkcgPSAndG9TdHJpbmcnO1xudmFyIFRQTCA9ICgnJyArICR0b1N0cmluZykuc3BsaXQoVE9fU1RSSU5HKTtcblxucmVxdWlyZSgnLi9fY29yZScpLmluc3BlY3RTb3VyY2UgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuICR0b1N0cmluZy5jYWxsKGl0KTtcbn07XG5cbihtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChPLCBrZXksIHZhbCwgc2FmZSkge1xuICB2YXIgaXNGdW5jdGlvbiA9IHR5cGVvZiB2YWwgPT0gJ2Z1bmN0aW9uJztcbiAgaWYgKGlzRnVuY3Rpb24pIGhhcyh2YWwsICduYW1lJykgfHwgaGlkZSh2YWwsICduYW1lJywga2V5KTtcbiAgaWYgKE9ba2V5XSA9PT0gdmFsKSByZXR1cm47XG4gIGlmIChpc0Z1bmN0aW9uKSBoYXModmFsLCBTUkMpIHx8IGhpZGUodmFsLCBTUkMsIE9ba2V5XSA/ICcnICsgT1trZXldIDogVFBMLmpvaW4oU3RyaW5nKGtleSkpKTtcbiAgaWYgKE8gPT09IGdsb2JhbCkge1xuICAgIE9ba2V5XSA9IHZhbDtcbiAgfSBlbHNlIGlmICghc2FmZSkge1xuICAgIGRlbGV0ZSBPW2tleV07XG4gICAgaGlkZShPLCBrZXksIHZhbCk7XG4gIH0gZWxzZSBpZiAoT1trZXldKSB7XG4gICAgT1trZXldID0gdmFsO1xuICB9IGVsc2Uge1xuICAgIGhpZGUoTywga2V5LCB2YWwpO1xuICB9XG4vLyBhZGQgZmFrZSBGdW5jdGlvbiN0b1N0cmluZyBmb3IgY29ycmVjdCB3b3JrIHdyYXBwZWQgbWV0aG9kcyAvIGNvbnN0cnVjdG9ycyB3aXRoIG1ldGhvZHMgbGlrZSBMb0Rhc2ggaXNOYXRpdmVcbn0pKEZ1bmN0aW9uLnByb3RvdHlwZSwgVE9fU1RSSU5HLCBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgcmV0dXJuIHR5cGVvZiB0aGlzID09ICdmdW5jdGlvbicgJiYgdGhpc1tTUkNdIHx8ICR0b1N0cmluZy5jYWxsKHRoaXMpO1xufSk7XG4iLCIvLyAxOS4xLjIuMiAvIDE1LjIuMy41IE9iamVjdC5jcmVhdGUoTyBbLCBQcm9wZXJ0aWVzXSlcbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xudmFyIGRQcyA9IHJlcXVpcmUoJy4vX29iamVjdC1kcHMnKTtcbnZhciBlbnVtQnVnS2V5cyA9IHJlcXVpcmUoJy4vX2VudW0tYnVnLWtleXMnKTtcbnZhciBJRV9QUk9UTyA9IHJlcXVpcmUoJy4vX3NoYXJlZC1rZXknKSgnSUVfUFJPVE8nKTtcbnZhciBFbXB0eSA9IGZ1bmN0aW9uICgpIHsgLyogZW1wdHkgKi8gfTtcbnZhciBQUk9UT1RZUEUgPSAncHJvdG90eXBlJztcblxuLy8gQ3JlYXRlIG9iamVjdCB3aXRoIGZha2UgYG51bGxgIHByb3RvdHlwZTogdXNlIGlmcmFtZSBPYmplY3Qgd2l0aCBjbGVhcmVkIHByb3RvdHlwZVxudmFyIGNyZWF0ZURpY3QgPSBmdW5jdGlvbiAoKSB7XG4gIC8vIFRocmFzaCwgd2FzdGUgYW5kIHNvZG9teTogSUUgR0MgYnVnXG4gIHZhciBpZnJhbWUgPSByZXF1aXJlKCcuL19kb20tY3JlYXRlJykoJ2lmcmFtZScpO1xuICB2YXIgaSA9IGVudW1CdWdLZXlzLmxlbmd0aDtcbiAgdmFyIGx0ID0gJzwnO1xuICB2YXIgZ3QgPSAnPic7XG4gIHZhciBpZnJhbWVEb2N1bWVudDtcbiAgaWZyYW1lLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gIHJlcXVpcmUoJy4vX2h0bWwnKS5hcHBlbmRDaGlsZChpZnJhbWUpO1xuICBpZnJhbWUuc3JjID0gJ2phdmFzY3JpcHQ6JzsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1zY3JpcHQtdXJsXG4gIC8vIGNyZWF0ZURpY3QgPSBpZnJhbWUuY29udGVudFdpbmRvdy5PYmplY3Q7XG4gIC8vIGh0bWwucmVtb3ZlQ2hpbGQoaWZyYW1lKTtcbiAgaWZyYW1lRG9jdW1lbnQgPSBpZnJhbWUuY29udGVudFdpbmRvdy5kb2N1bWVudDtcbiAgaWZyYW1lRG9jdW1lbnQub3BlbigpO1xuICBpZnJhbWVEb2N1bWVudC53cml0ZShsdCArICdzY3JpcHQnICsgZ3QgKyAnZG9jdW1lbnQuRj1PYmplY3QnICsgbHQgKyAnL3NjcmlwdCcgKyBndCk7XG4gIGlmcmFtZURvY3VtZW50LmNsb3NlKCk7XG4gIGNyZWF0ZURpY3QgPSBpZnJhbWVEb2N1bWVudC5GO1xuICB3aGlsZSAoaS0tKSBkZWxldGUgY3JlYXRlRGljdFtQUk9UT1RZUEVdW2VudW1CdWdLZXlzW2ldXTtcbiAgcmV0dXJuIGNyZWF0ZURpY3QoKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gT2JqZWN0LmNyZWF0ZSB8fCBmdW5jdGlvbiBjcmVhdGUoTywgUHJvcGVydGllcykge1xuICB2YXIgcmVzdWx0O1xuICBpZiAoTyAhPT0gbnVsbCkge1xuICAgIEVtcHR5W1BST1RPVFlQRV0gPSBhbk9iamVjdChPKTtcbiAgICByZXN1bHQgPSBuZXcgRW1wdHkoKTtcbiAgICBFbXB0eVtQUk9UT1RZUEVdID0gbnVsbDtcbiAgICAvLyBhZGQgXCJfX3Byb3RvX19cIiBmb3IgT2JqZWN0LmdldFByb3RvdHlwZU9mIHBvbHlmaWxsXG4gICAgcmVzdWx0W0lFX1BST1RPXSA9IE87XG4gIH0gZWxzZSByZXN1bHQgPSBjcmVhdGVEaWN0KCk7XG4gIHJldHVybiBQcm9wZXJ0aWVzID09PSB1bmRlZmluZWQgPyByZXN1bHQgOiBkUHMocmVzdWx0LCBQcm9wZXJ0aWVzKTtcbn07XG4iLCJ2YXIgc3RvcmUgPSByZXF1aXJlKCcuL19zaGFyZWQnKSgnd2tzJyk7XG52YXIgdWlkID0gcmVxdWlyZSgnLi9fdWlkJyk7XG52YXIgU3ltYm9sID0gcmVxdWlyZSgnLi9fZ2xvYmFsJykuU3ltYm9sO1xudmFyIFVTRV9TWU1CT0wgPSB0eXBlb2YgU3ltYm9sID09ICdmdW5jdGlvbic7XG5cbnZhciAkZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgcmV0dXJuIHN0b3JlW25hbWVdIHx8IChzdG9yZVtuYW1lXSA9XG4gICAgVVNFX1NZTUJPTCAmJiBTeW1ib2xbbmFtZV0gfHwgKFVTRV9TWU1CT0wgPyBTeW1ib2wgOiB1aWQpKCdTeW1ib2wuJyArIG5hbWUpKTtcbn07XG5cbiRleHBvcnRzLnN0b3JlID0gc3RvcmU7XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZhbHNlO1xuIiwidmFyIHRvU3RyaW5nID0ge30udG9TdHJpbmc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiB0b1N0cmluZy5jYWxsKGl0KS5zbGljZSg4LCAtMSk7XG59O1xuIiwiLy8gMjEuMS4zLjcgU3RyaW5nLnByb3RvdHlwZS5pbmNsdWRlcyhzZWFyY2hTdHJpbmcsIHBvc2l0aW9uID0gMClcbid1c2Ugc3RyaWN0JztcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgY29udGV4dCA9IHJlcXVpcmUoJy4vX3N0cmluZy1jb250ZXh0Jyk7XG52YXIgSU5DTFVERVMgPSAnaW5jbHVkZXMnO1xuXG4kZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuRiAqIHJlcXVpcmUoJy4vX2ZhaWxzLWlzLXJlZ2V4cCcpKElOQ0xVREVTKSwgJ1N0cmluZycsIHtcbiAgaW5jbHVkZXM6IGZ1bmN0aW9uIGluY2x1ZGVzKHNlYXJjaFN0cmluZyAvKiAsIHBvc2l0aW9uID0gMCAqLykge1xuICAgIHJldHVybiAhIX5jb250ZXh0KHRoaXMsIHNlYXJjaFN0cmluZywgSU5DTFVERVMpXG4gICAgICAuaW5kZXhPZihzZWFyY2hTdHJpbmcsIGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkKTtcbiAgfVxufSk7XG4iLCJ2YXIgZFAgPSByZXF1aXJlKCcuL19vYmplY3QtZHAnKTtcbnZhciBjcmVhdGVEZXNjID0gcmVxdWlyZSgnLi9fcHJvcGVydHktZGVzYycpO1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpID8gZnVuY3Rpb24gKG9iamVjdCwga2V5LCB2YWx1ZSkge1xuICByZXR1cm4gZFAuZihvYmplY3QsIGtleSwgY3JlYXRlRGVzYygxLCB2YWx1ZSkpO1xufSA6IGZ1bmN0aW9uIChvYmplY3QsIGtleSwgdmFsdWUpIHtcbiAgb2JqZWN0W2tleV0gPSB2YWx1ZTtcbiAgcmV0dXJuIG9iamVjdDtcbn07XG4iLCIvLyAxOS4xLjIuOSAvIDE1LjIuMy4yIE9iamVjdC5nZXRQcm90b3R5cGVPZihPKVxudmFyIGhhcyA9IHJlcXVpcmUoJy4vX2hhcycpO1xudmFyIHRvT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8tb2JqZWN0Jyk7XG52YXIgSUVfUFJPVE8gPSByZXF1aXJlKCcuL19zaGFyZWQta2V5JykoJ0lFX1BST1RPJyk7XG52YXIgT2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG5tb2R1bGUuZXhwb3J0cyA9IE9iamVjdC5nZXRQcm90b3R5cGVPZiB8fCBmdW5jdGlvbiAoTykge1xuICBPID0gdG9PYmplY3QoTyk7XG4gIGlmIChoYXMoTywgSUVfUFJPVE8pKSByZXR1cm4gT1tJRV9QUk9UT107XG4gIGlmICh0eXBlb2YgTy5jb25zdHJ1Y3RvciA9PSAnZnVuY3Rpb24nICYmIE8gaW5zdGFuY2VvZiBPLmNvbnN0cnVjdG9yKSB7XG4gICAgcmV0dXJuIE8uY29uc3RydWN0b3IucHJvdG90eXBlO1xuICB9IHJldHVybiBPIGluc3RhbmNlb2YgT2JqZWN0ID8gT2JqZWN0UHJvdG8gOiBudWxsO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBjcmVhdGUgPSByZXF1aXJlKCcuL19vYmplY3QtY3JlYXRlJyk7XG52YXIgZGVzY3JpcHRvciA9IHJlcXVpcmUoJy4vX3Byb3BlcnR5LWRlc2MnKTtcbnZhciBzZXRUb1N0cmluZ1RhZyA9IHJlcXVpcmUoJy4vX3NldC10by1zdHJpbmctdGFnJyk7XG52YXIgSXRlcmF0b3JQcm90b3R5cGUgPSB7fTtcblxuLy8gMjUuMS4yLjEuMSAlSXRlcmF0b3JQcm90b3R5cGUlW0BAaXRlcmF0b3JdKClcbnJlcXVpcmUoJy4vX2hpZGUnKShJdGVyYXRvclByb3RvdHlwZSwgcmVxdWlyZSgnLi9fd2tzJykoJ2l0ZXJhdG9yJyksIGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgTkFNRSwgbmV4dCkge1xuICBDb25zdHJ1Y3Rvci5wcm90b3R5cGUgPSBjcmVhdGUoSXRlcmF0b3JQcm90b3R5cGUsIHsgbmV4dDogZGVzY3JpcHRvcigxLCBuZXh0KSB9KTtcbiAgc2V0VG9TdHJpbmdUYWcoQ29uc3RydWN0b3IsIE5BTUUgKyAnIEl0ZXJhdG9yJyk7XG59O1xuIiwiLy8gMTkuMS4yLjE0IE9iamVjdC5rZXlzKE8pXG52YXIgdG9PYmplY3QgPSByZXF1aXJlKCcuL190by1vYmplY3QnKTtcbnZhciAka2V5cyA9IHJlcXVpcmUoJy4vX29iamVjdC1rZXlzJyk7XG5cbnJlcXVpcmUoJy4vX29iamVjdC1zYXAnKSgna2V5cycsIGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIGtleXMoaXQpIHtcbiAgICByZXR1cm4gJGtleXModG9PYmplY3QoaXQpKTtcbiAgfTtcbn0pO1xuIiwiLy8gNy4xLjQgVG9JbnRlZ2VyXG52YXIgY2VpbCA9IE1hdGguY2VpbDtcbnZhciBmbG9vciA9IE1hdGguZmxvb3I7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gaXNOYU4oaXQgPSAraXQpID8gMCA6IChpdCA+IDAgPyBmbG9vciA6IGNlaWwpKGl0KTtcbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChiaXRtYXAsIHZhbHVlKSB7XG4gIHJldHVybiB7XG4gICAgZW51bWVyYWJsZTogIShiaXRtYXAgJiAxKSxcbiAgICBjb25maWd1cmFibGU6ICEoYml0bWFwICYgMiksXG4gICAgd3JpdGFibGU6ICEoYml0bWFwICYgNCksXG4gICAgdmFsdWU6IHZhbHVlXG4gIH07XG59O1xuIiwiLy8gNy4xLjEzIFRvT2JqZWN0KGFyZ3VtZW50KVxudmFyIGRlZmluZWQgPSByZXF1aXJlKCcuL19kZWZpbmVkJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gT2JqZWN0KGRlZmluZWQoaXQpKTtcbn07XG4iLCJ2YXIgTUFUQ0ggPSByZXF1aXJlKCcuL193a3MnKSgnbWF0Y2gnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKEtFWSkge1xuICB2YXIgcmUgPSAvLi87XG4gIHRyeSB7XG4gICAgJy8uLydbS0VZXShyZSk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICB0cnkge1xuICAgICAgcmVbTUFUQ0hdID0gZmFsc2U7XG4gICAgICByZXR1cm4gIScvLi8nW0tFWV0ocmUpO1xuICAgIH0gY2F0Y2ggKGYpIHsgLyogZW1wdHkgKi8gfVxuICB9IHJldHVybiB0cnVlO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHJlZ2V4cEZsYWdzID0gcmVxdWlyZSgnLi9fZmxhZ3MnKTtcblxudmFyIG5hdGl2ZUV4ZWMgPSBSZWdFeHAucHJvdG90eXBlLmV4ZWM7XG4vLyBUaGlzIGFsd2F5cyByZWZlcnMgdG8gdGhlIG5hdGl2ZSBpbXBsZW1lbnRhdGlvbiwgYmVjYXVzZSB0aGVcbi8vIFN0cmluZyNyZXBsYWNlIHBvbHlmaWxsIHVzZXMgLi9maXgtcmVnZXhwLXdlbGwta25vd24tc3ltYm9sLWxvZ2ljLmpzLFxuLy8gd2hpY2ggbG9hZHMgdGhpcyBmaWxlIGJlZm9yZSBwYXRjaGluZyB0aGUgbWV0aG9kLlxudmFyIG5hdGl2ZVJlcGxhY2UgPSBTdHJpbmcucHJvdG90eXBlLnJlcGxhY2U7XG5cbnZhciBwYXRjaGVkRXhlYyA9IG5hdGl2ZUV4ZWM7XG5cbnZhciBMQVNUX0lOREVYID0gJ2xhc3RJbmRleCc7XG5cbnZhciBVUERBVEVTX0xBU1RfSU5ERVhfV1JPTkcgPSAoZnVuY3Rpb24gKCkge1xuICB2YXIgcmUxID0gL2EvLFxuICAgICAgcmUyID0gL2IqL2c7XG4gIG5hdGl2ZUV4ZWMuY2FsbChyZTEsICdhJyk7XG4gIG5hdGl2ZUV4ZWMuY2FsbChyZTIsICdhJyk7XG4gIHJldHVybiByZTFbTEFTVF9JTkRFWF0gIT09IDAgfHwgcmUyW0xBU1RfSU5ERVhdICE9PSAwO1xufSkoKTtcblxuLy8gbm9ucGFydGljaXBhdGluZyBjYXB0dXJpbmcgZ3JvdXAsIGNvcGllZCBmcm9tIGVzNS1zaGltJ3MgU3RyaW5nI3NwbGl0IHBhdGNoLlxudmFyIE5QQ0dfSU5DTFVERUQgPSAvKCk/Py8uZXhlYygnJylbMV0gIT09IHVuZGVmaW5lZDtcblxudmFyIFBBVENIID0gVVBEQVRFU19MQVNUX0lOREVYX1dST05HIHx8IE5QQ0dfSU5DTFVERUQ7XG5cbmlmIChQQVRDSCkge1xuICBwYXRjaGVkRXhlYyA9IGZ1bmN0aW9uIGV4ZWMoc3RyKSB7XG4gICAgdmFyIHJlID0gdGhpcztcbiAgICB2YXIgbGFzdEluZGV4LCByZUNvcHksIG1hdGNoLCBpO1xuXG4gICAgaWYgKE5QQ0dfSU5DTFVERUQpIHtcbiAgICAgIHJlQ29weSA9IG5ldyBSZWdFeHAoJ14nICsgcmUuc291cmNlICsgJyQoPyFcXFxccyknLCByZWdleHBGbGFncy5jYWxsKHJlKSk7XG4gICAgfVxuICAgIGlmIChVUERBVEVTX0xBU1RfSU5ERVhfV1JPTkcpIGxhc3RJbmRleCA9IHJlW0xBU1RfSU5ERVhdO1xuXG4gICAgbWF0Y2ggPSBuYXRpdmVFeGVjLmNhbGwocmUsIHN0cik7XG5cbiAgICBpZiAoVVBEQVRFU19MQVNUX0lOREVYX1dST05HICYmIG1hdGNoKSB7XG4gICAgICByZVtMQVNUX0lOREVYXSA9IHJlLmdsb2JhbCA/IG1hdGNoLmluZGV4ICsgbWF0Y2hbMF0ubGVuZ3RoIDogbGFzdEluZGV4O1xuICAgIH1cbiAgICBpZiAoTlBDR19JTkNMVURFRCAmJiBtYXRjaCAmJiBtYXRjaC5sZW5ndGggPiAxKSB7XG4gICAgICAvLyBGaXggYnJvd3NlcnMgd2hvc2UgYGV4ZWNgIG1ldGhvZHMgZG9uJ3QgY29uc2lzdGVudGx5IHJldHVybiBgdW5kZWZpbmVkYFxuICAgICAgLy8gZm9yIE5QQ0csIGxpa2UgSUU4LiBOT1RFOiBUaGlzIGRvZXNuJyB3b3JrIGZvciAvKC4/KT8vXG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tbG9vcC1mdW5jXG4gICAgICBuYXRpdmVSZXBsYWNlLmNhbGwobWF0Y2hbMF0sIHJlQ29weSwgZnVuY3Rpb24gKCkge1xuICAgICAgICBmb3IgKGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aCAtIDI7IGkrKykge1xuICAgICAgICAgIGlmIChhcmd1bWVudHNbaV0gPT09IHVuZGVmaW5lZCkgbWF0Y2hbaV0gPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiBtYXRjaDtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBwYXRjaGVkRXhlYztcbiIsImV4cG9ydHMuZiA9IHt9LnByb3BlcnR5SXNFbnVtZXJhYmxlO1xuIiwidmFyIGNvcmUgPSByZXF1aXJlKCcuL19jb3JlJyk7XG52YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi9fZ2xvYmFsJyk7XG52YXIgU0hBUkVEID0gJ19fY29yZS1qc19zaGFyZWRfXyc7XG52YXIgc3RvcmUgPSBnbG9iYWxbU0hBUkVEXSB8fCAoZ2xvYmFsW1NIQVJFRF0gPSB7fSk7XG5cbihtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gIHJldHVybiBzdG9yZVtrZXldIHx8IChzdG9yZVtrZXldID0gdmFsdWUgIT09IHVuZGVmaW5lZCA/IHZhbHVlIDoge30pO1xufSkoJ3ZlcnNpb25zJywgW10pLnB1c2goe1xuICB2ZXJzaW9uOiBjb3JlLnZlcnNpb24sXG4gIG1vZGU6IHJlcXVpcmUoJy4vX2xpYnJhcnknKSA/ICdwdXJlJyA6ICdnbG9iYWwnLFxuICBjb3B5cmlnaHQ6ICfCqSAyMDE5IERlbmlzIFB1c2hrYXJldiAoemxvaXJvY2sucnUpJ1xufSk7XG4iLCJ2YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi9fZ2xvYmFsJyk7XG52YXIgY29yZSA9IHJlcXVpcmUoJy4vX2NvcmUnKTtcbnZhciBoaWRlID0gcmVxdWlyZSgnLi9faGlkZScpO1xudmFyIHJlZGVmaW5lID0gcmVxdWlyZSgnLi9fcmVkZWZpbmUnKTtcbnZhciBjdHggPSByZXF1aXJlKCcuL19jdHgnKTtcbnZhciBQUk9UT1RZUEUgPSAncHJvdG90eXBlJztcblxudmFyICRleHBvcnQgPSBmdW5jdGlvbiAodHlwZSwgbmFtZSwgc291cmNlKSB7XG4gIHZhciBJU19GT1JDRUQgPSB0eXBlICYgJGV4cG9ydC5GO1xuICB2YXIgSVNfR0xPQkFMID0gdHlwZSAmICRleHBvcnQuRztcbiAgdmFyIElTX1NUQVRJQyA9IHR5cGUgJiAkZXhwb3J0LlM7XG4gIHZhciBJU19QUk9UTyA9IHR5cGUgJiAkZXhwb3J0LlA7XG4gIHZhciBJU19CSU5EID0gdHlwZSAmICRleHBvcnQuQjtcbiAgdmFyIHRhcmdldCA9IElTX0dMT0JBTCA/IGdsb2JhbCA6IElTX1NUQVRJQyA/IGdsb2JhbFtuYW1lXSB8fCAoZ2xvYmFsW25hbWVdID0ge30pIDogKGdsb2JhbFtuYW1lXSB8fCB7fSlbUFJPVE9UWVBFXTtcbiAgdmFyIGV4cG9ydHMgPSBJU19HTE9CQUwgPyBjb3JlIDogY29yZVtuYW1lXSB8fCAoY29yZVtuYW1lXSA9IHt9KTtcbiAgdmFyIGV4cFByb3RvID0gZXhwb3J0c1tQUk9UT1RZUEVdIHx8IChleHBvcnRzW1BST1RPVFlQRV0gPSB7fSk7XG4gIHZhciBrZXksIG93biwgb3V0LCBleHA7XG4gIGlmIChJU19HTE9CQUwpIHNvdXJjZSA9IG5hbWU7XG4gIGZvciAoa2V5IGluIHNvdXJjZSkge1xuICAgIC8vIGNvbnRhaW5zIGluIG5hdGl2ZVxuICAgIG93biA9ICFJU19GT1JDRUQgJiYgdGFyZ2V0ICYmIHRhcmdldFtrZXldICE9PSB1bmRlZmluZWQ7XG4gICAgLy8gZXhwb3J0IG5hdGl2ZSBvciBwYXNzZWRcbiAgICBvdXQgPSAob3duID8gdGFyZ2V0IDogc291cmNlKVtrZXldO1xuICAgIC8vIGJpbmQgdGltZXJzIHRvIGdsb2JhbCBmb3IgY2FsbCBmcm9tIGV4cG9ydCBjb250ZXh0XG4gICAgZXhwID0gSVNfQklORCAmJiBvd24gPyBjdHgob3V0LCBnbG9iYWwpIDogSVNfUFJPVE8gJiYgdHlwZW9mIG91dCA9PSAnZnVuY3Rpb24nID8gY3R4KEZ1bmN0aW9uLmNhbGwsIG91dCkgOiBvdXQ7XG4gICAgLy8gZXh0ZW5kIGdsb2JhbFxuICAgIGlmICh0YXJnZXQpIHJlZGVmaW5lKHRhcmdldCwga2V5LCBvdXQsIHR5cGUgJiAkZXhwb3J0LlUpO1xuICAgIC8vIGV4cG9ydFxuICAgIGlmIChleHBvcnRzW2tleV0gIT0gb3V0KSBoaWRlKGV4cG9ydHMsIGtleSwgZXhwKTtcbiAgICBpZiAoSVNfUFJPVE8gJiYgZXhwUHJvdG9ba2V5XSAhPSBvdXQpIGV4cFByb3RvW2tleV0gPSBvdXQ7XG4gIH1cbn07XG5nbG9iYWwuY29yZSA9IGNvcmU7XG4vLyB0eXBlIGJpdG1hcFxuJGV4cG9ydC5GID0gMTsgICAvLyBmb3JjZWRcbiRleHBvcnQuRyA9IDI7ICAgLy8gZ2xvYmFsXG4kZXhwb3J0LlMgPSA0OyAgIC8vIHN0YXRpY1xuJGV4cG9ydC5QID0gODsgICAvLyBwcm90b1xuJGV4cG9ydC5CID0gMTY7ICAvLyBiaW5kXG4kZXhwb3J0LlcgPSAzMjsgIC8vIHdyYXBcbiRleHBvcnQuVSA9IDY0OyAgLy8gc2FmZVxuJGV4cG9ydC5SID0gMTI4OyAvLyByZWFsIHByb3RvIG1ldGhvZCBmb3IgYGxpYnJhcnlgXG5tb2R1bGUuZXhwb3J0cyA9ICRleHBvcnQ7XG4iLCIvLyBtb3N0IE9iamVjdCBtZXRob2RzIGJ5IEVTNiBzaG91bGQgYWNjZXB0IHByaW1pdGl2ZXNcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgY29yZSA9IHJlcXVpcmUoJy4vX2NvcmUnKTtcbnZhciBmYWlscyA9IHJlcXVpcmUoJy4vX2ZhaWxzJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChLRVksIGV4ZWMpIHtcbiAgdmFyIGZuID0gKGNvcmUuT2JqZWN0IHx8IHt9KVtLRVldIHx8IE9iamVjdFtLRVldO1xuICB2YXIgZXhwID0ge307XG4gIGV4cFtLRVldID0gZXhlYyhmbik7XG4gICRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogZmFpbHMoZnVuY3Rpb24gKCkgeyBmbigxKTsgfSksICdPYmplY3QnLCBleHApO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGNsYXNzb2YgPSByZXF1aXJlKCcuL19jbGFzc29mJyk7XG52YXIgYnVpbHRpbkV4ZWMgPSBSZWdFeHAucHJvdG90eXBlLmV4ZWM7XG5cbiAvLyBgUmVnRXhwRXhlY2AgYWJzdHJhY3Qgb3BlcmF0aW9uXG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1yZWdleHBleGVjXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChSLCBTKSB7XG4gIHZhciBleGVjID0gUi5leGVjO1xuICBpZiAodHlwZW9mIGV4ZWMgPT09ICdmdW5jdGlvbicpIHtcbiAgICB2YXIgcmVzdWx0ID0gZXhlYy5jYWxsKFIsIFMpO1xuICAgIGlmICh0eXBlb2YgcmVzdWx0ICE9PSAnb2JqZWN0Jykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignUmVnRXhwIGV4ZWMgbWV0aG9kIHJldHVybmVkIHNvbWV0aGluZyBvdGhlciB0aGFuIGFuIE9iamVjdCBvciBudWxsJyk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgaWYgKGNsYXNzb2YoUikgIT09ICdSZWdFeHAnKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignUmVnRXhwI2V4ZWMgY2FsbGVkIG9uIGluY29tcGF0aWJsZSByZWNlaXZlcicpO1xuICB9XG4gIHJldHVybiBidWlsdGluRXhlYy5jYWxsKFIsIFMpO1xufTtcbiIsInZhciBzaGFyZWQgPSByZXF1aXJlKCcuL19zaGFyZWQnKSgna2V5cycpO1xudmFyIHVpZCA9IHJlcXVpcmUoJy4vX3VpZCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoa2V5KSB7XG4gIHJldHVybiBzaGFyZWRba2V5XSB8fCAoc2hhcmVkW2tleV0gPSB1aWQoa2V5KSk7XG59O1xuIiwiLy8gZmFsbGJhY2sgZm9yIG5vbi1hcnJheS1saWtlIEVTMyBhbmQgbm9uLWVudW1lcmFibGUgb2xkIFY4IHN0cmluZ3NcbnZhciBjb2YgPSByZXF1aXJlKCcuL19jb2YnKTtcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wcm90b3R5cGUtYnVpbHRpbnNcbm1vZHVsZS5leHBvcnRzID0gT2JqZWN0KCd6JykucHJvcGVydHlJc0VudW1lcmFibGUoMCkgPyBPYmplY3QgOiBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIGNvZihpdCkgPT0gJ1N0cmluZycgPyBpdC5zcGxpdCgnJykgOiBPYmplY3QoaXQpO1xufTtcbiIsIid1c2Ugc3RyaWN0Jztcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS90YzM5L0FycmF5LnByb3RvdHlwZS5pbmNsdWRlc1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciAkaW5jbHVkZXMgPSByZXF1aXJlKCcuL19hcnJheS1pbmNsdWRlcycpKHRydWUpO1xuXG4kZXhwb3J0KCRleHBvcnQuUCwgJ0FycmF5Jywge1xuICBpbmNsdWRlczogZnVuY3Rpb24gaW5jbHVkZXMoZWwgLyogLCBmcm9tSW5kZXggPSAwICovKSB7XG4gICAgcmV0dXJuICRpbmNsdWRlcyh0aGlzLCBlbCwgYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQpO1xuICB9XG59KTtcblxucmVxdWlyZSgnLi9fYWRkLXRvLXVuc2NvcGFibGVzJykoJ2luY2x1ZGVzJyk7XG4iLCIvLyB0byBpbmRleGVkIG9iamVjdCwgdG9PYmplY3Qgd2l0aCBmYWxsYmFjayBmb3Igbm9uLWFycmF5LWxpa2UgRVMzIHN0cmluZ3NcbnZhciBJT2JqZWN0ID0gcmVxdWlyZSgnLi9faW9iamVjdCcpO1xudmFyIGRlZmluZWQgPSByZXF1aXJlKCcuL19kZWZpbmVkJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gSU9iamVjdChkZWZpbmVkKGl0KSk7XG59O1xuIiwidmFyIGhhc093blByb3BlcnR5ID0ge30uaGFzT3duUHJvcGVydHk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCwga2V5KSB7XG4gIHJldHVybiBoYXNPd25Qcm9wZXJ0eS5jYWxsKGl0LCBrZXkpO1xufTtcbiIsIi8vIDcuMS4xIFRvUHJpbWl0aXZlKGlucHV0IFssIFByZWZlcnJlZFR5cGVdKVxudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG4vLyBpbnN0ZWFkIG9mIHRoZSBFUzYgc3BlYyB2ZXJzaW9uLCB3ZSBkaWRuJ3QgaW1wbGVtZW50IEBAdG9QcmltaXRpdmUgY2FzZVxuLy8gYW5kIHRoZSBzZWNvbmQgYXJndW1lbnQgLSBmbGFnIC0gcHJlZmVycmVkIHR5cGUgaXMgYSBzdHJpbmdcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0LCBTKSB7XG4gIGlmICghaXNPYmplY3QoaXQpKSByZXR1cm4gaXQ7XG4gIHZhciBmbiwgdmFsO1xuICBpZiAoUyAmJiB0eXBlb2YgKGZuID0gaXQudG9TdHJpbmcpID09ICdmdW5jdGlvbicgJiYgIWlzT2JqZWN0KHZhbCA9IGZuLmNhbGwoaXQpKSkgcmV0dXJuIHZhbDtcbiAgaWYgKHR5cGVvZiAoZm4gPSBpdC52YWx1ZU9mKSA9PSAnZnVuY3Rpb24nICYmICFpc09iamVjdCh2YWwgPSBmbi5jYWxsKGl0KSkpIHJldHVybiB2YWw7XG4gIGlmICghUyAmJiB0eXBlb2YgKGZuID0gaXQudG9TdHJpbmcpID09ICdmdW5jdGlvbicgJiYgIWlzT2JqZWN0KHZhbCA9IGZuLmNhbGwoaXQpKSkgcmV0dXJuIHZhbDtcbiAgdGhyb3cgVHlwZUVycm9yKFwiQ2FuJ3QgY29udmVydCBvYmplY3QgdG8gcHJpbWl0aXZlIHZhbHVlXCIpO1xufTtcbiIsIid1c2Ugc3RyaWN0Jztcbi8vIDE5LjEuMi4xIE9iamVjdC5hc3NpZ24odGFyZ2V0LCBzb3VyY2UsIC4uLilcbnZhciBnZXRLZXlzID0gcmVxdWlyZSgnLi9fb2JqZWN0LWtleXMnKTtcbnZhciBnT1BTID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdvcHMnKTtcbnZhciBwSUUgPSByZXF1aXJlKCcuL19vYmplY3QtcGllJyk7XG52YXIgdG9PYmplY3QgPSByZXF1aXJlKCcuL190by1vYmplY3QnKTtcbnZhciBJT2JqZWN0ID0gcmVxdWlyZSgnLi9faW9iamVjdCcpO1xudmFyICRhc3NpZ24gPSBPYmplY3QuYXNzaWduO1xuXG4vLyBzaG91bGQgd29yayB3aXRoIHN5bWJvbHMgYW5kIHNob3VsZCBoYXZlIGRldGVybWluaXN0aWMgcHJvcGVydHkgb3JkZXIgKFY4IGJ1Zylcbm1vZHVsZS5leHBvcnRzID0gISRhc3NpZ24gfHwgcmVxdWlyZSgnLi9fZmFpbHMnKShmdW5jdGlvbiAoKSB7XG4gIHZhciBBID0ge307XG4gIHZhciBCID0ge307XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bmRlZlxuICB2YXIgUyA9IFN5bWJvbCgpO1xuICB2YXIgSyA9ICdhYmNkZWZnaGlqa2xtbm9wcXJzdCc7XG4gIEFbU10gPSA3O1xuICBLLnNwbGl0KCcnKS5mb3JFYWNoKGZ1bmN0aW9uIChrKSB7IEJba10gPSBrOyB9KTtcbiAgcmV0dXJuICRhc3NpZ24oe30sIEEpW1NdICE9IDcgfHwgT2JqZWN0LmtleXMoJGFzc2lnbih7fSwgQikpLmpvaW4oJycpICE9IEs7XG59KSA/IGZ1bmN0aW9uIGFzc2lnbih0YXJnZXQsIHNvdXJjZSkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG4gIHZhciBUID0gdG9PYmplY3QodGFyZ2V0KTtcbiAgdmFyIGFMZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICB2YXIgaW5kZXggPSAxO1xuICB2YXIgZ2V0U3ltYm9scyA9IGdPUFMuZjtcbiAgdmFyIGlzRW51bSA9IHBJRS5mO1xuICB3aGlsZSAoYUxlbiA+IGluZGV4KSB7XG4gICAgdmFyIFMgPSBJT2JqZWN0KGFyZ3VtZW50c1tpbmRleCsrXSk7XG4gICAgdmFyIGtleXMgPSBnZXRTeW1ib2xzID8gZ2V0S2V5cyhTKS5jb25jYXQoZ2V0U3ltYm9scyhTKSkgOiBnZXRLZXlzKFMpO1xuICAgIHZhciBsZW5ndGggPSBrZXlzLmxlbmd0aDtcbiAgICB2YXIgaiA9IDA7XG4gICAgdmFyIGtleTtcbiAgICB3aGlsZSAobGVuZ3RoID4gaikgaWYgKGlzRW51bS5jYWxsKFMsIGtleSA9IGtleXNbaisrXSkpIFRba2V5XSA9IFNba2V5XTtcbiAgfSByZXR1cm4gVDtcbn0gOiAkYXNzaWduO1xuIiwiLy8gaHR0cHM6Ly9naXRodWIuY29tL3psb2lyb2NrL2NvcmUtanMvaXNzdWVzLzg2I2lzc3VlY29tbWVudC0xMTU3NTkwMjhcbnZhciBnbG9iYWwgPSBtb2R1bGUuZXhwb3J0cyA9IHR5cGVvZiB3aW5kb3cgIT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93Lk1hdGggPT0gTWF0aFxuICA/IHdpbmRvdyA6IHR5cGVvZiBzZWxmICE9ICd1bmRlZmluZWQnICYmIHNlbGYuTWF0aCA9PSBNYXRoID8gc2VsZlxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tbmV3LWZ1bmNcbiAgOiBGdW5jdGlvbigncmV0dXJuIHRoaXMnKSgpO1xuaWYgKHR5cGVvZiBfX2cgPT0gJ251bWJlcicpIF9fZyA9IGdsb2JhbDsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZlxuIiwidmFyIHRvSW50ZWdlciA9IHJlcXVpcmUoJy4vX3RvLWludGVnZXInKTtcbnZhciBtYXggPSBNYXRoLm1heDtcbnZhciBtaW4gPSBNYXRoLm1pbjtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGluZGV4LCBsZW5ndGgpIHtcbiAgaW5kZXggPSB0b0ludGVnZXIoaW5kZXgpO1xuICByZXR1cm4gaW5kZXggPCAwID8gbWF4KGluZGV4ICsgbGVuZ3RoLCAwKSA6IG1pbihpbmRleCwgbGVuZ3RoKTtcbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChleGVjKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuICEhZXhlYygpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn07XG4iLCJ2YXIgZGVmID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJykuZjtcbnZhciBoYXMgPSByZXF1aXJlKCcuL19oYXMnKTtcbnZhciBUQUcgPSByZXF1aXJlKCcuL193a3MnKSgndG9TdHJpbmdUYWcnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQsIHRhZywgc3RhdCkge1xuICBpZiAoaXQgJiYgIWhhcyhpdCA9IHN0YXQgPyBpdCA6IGl0LnByb3RvdHlwZSwgVEFHKSkgZGVmKGl0LCBUQUcsIHsgY29uZmlndXJhYmxlOiB0cnVlLCB2YWx1ZTogdGFnIH0pO1xufTtcbiIsInZhciBjb3JlID0gbW9kdWxlLmV4cG9ydHMgPSB7IHZlcnNpb246ICcyLjYuNScgfTtcbmlmICh0eXBlb2YgX19lID09ICdudW1iZXInKSBfX2UgPSBjb3JlOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVuZGVmXG4iLCJtb2R1bGUuZXhwb3J0cyA9IHt9O1xuIiwidmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG52YXIgSUU4X0RPTV9ERUZJTkUgPSByZXF1aXJlKCcuL19pZTgtZG9tLWRlZmluZScpO1xudmFyIHRvUHJpbWl0aXZlID0gcmVxdWlyZSgnLi9fdG8tcHJpbWl0aXZlJyk7XG52YXIgZFAgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG5cbmV4cG9ydHMuZiA9IHJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJykgPyBPYmplY3QuZGVmaW5lUHJvcGVydHkgOiBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0eShPLCBQLCBBdHRyaWJ1dGVzKSB7XG4gIGFuT2JqZWN0KE8pO1xuICBQID0gdG9QcmltaXRpdmUoUCwgdHJ1ZSk7XG4gIGFuT2JqZWN0KEF0dHJpYnV0ZXMpO1xuICBpZiAoSUU4X0RPTV9ERUZJTkUpIHRyeSB7XG4gICAgcmV0dXJuIGRQKE8sIFAsIEF0dHJpYnV0ZXMpO1xuICB9IGNhdGNoIChlKSB7IC8qIGVtcHR5ICovIH1cbiAgaWYgKCdnZXQnIGluIEF0dHJpYnV0ZXMgfHwgJ3NldCcgaW4gQXR0cmlidXRlcykgdGhyb3cgVHlwZUVycm9yKCdBY2Nlc3NvcnMgbm90IHN1cHBvcnRlZCEnKTtcbiAgaWYgKCd2YWx1ZScgaW4gQXR0cmlidXRlcykgT1tQXSA9IEF0dHJpYnV0ZXMudmFsdWU7XG4gIHJldHVybiBPO1xufTtcbiIsIi8vIG9wdGlvbmFsIC8gc2ltcGxlIGNvbnRleHQgYmluZGluZ1xudmFyIGFGdW5jdGlvbiA9IHJlcXVpcmUoJy4vX2EtZnVuY3Rpb24nKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGZuLCB0aGF0LCBsZW5ndGgpIHtcbiAgYUZ1bmN0aW9uKGZuKTtcbiAgaWYgKHRoYXQgPT09IHVuZGVmaW5lZCkgcmV0dXJuIGZuO1xuICBzd2l0Y2ggKGxlbmd0aCkge1xuICAgIGNhc2UgMTogcmV0dXJuIGZ1bmN0aW9uIChhKSB7XG4gICAgICByZXR1cm4gZm4uY2FsbCh0aGF0LCBhKTtcbiAgICB9O1xuICAgIGNhc2UgMjogcmV0dXJuIGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICByZXR1cm4gZm4uY2FsbCh0aGF0LCBhLCBiKTtcbiAgICB9O1xuICAgIGNhc2UgMzogcmV0dXJuIGZ1bmN0aW9uIChhLCBiLCBjKSB7XG4gICAgICByZXR1cm4gZm4uY2FsbCh0aGF0LCBhLCBiLCBjKTtcbiAgICB9O1xuICB9XG4gIHJldHVybiBmdW5jdGlvbiAoLyogLi4uYXJncyAqLykge1xuICAgIHJldHVybiBmbi5hcHBseSh0aGF0LCBhcmd1bWVudHMpO1xuICB9O1xufTtcbiIsIi8vIDIyLjEuMy4zMSBBcnJheS5wcm90b3R5cGVbQEB1bnNjb3BhYmxlc11cbnZhciBVTlNDT1BBQkxFUyA9IHJlcXVpcmUoJy4vX3drcycpKCd1bnNjb3BhYmxlcycpO1xudmFyIEFycmF5UHJvdG8gPSBBcnJheS5wcm90b3R5cGU7XG5pZiAoQXJyYXlQcm90b1tVTlNDT1BBQkxFU10gPT0gdW5kZWZpbmVkKSByZXF1aXJlKCcuL19oaWRlJykoQXJyYXlQcm90bywgVU5TQ09QQUJMRVMsIHt9KTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGtleSkge1xuICBBcnJheVByb3RvW1VOU0NPUEFCTEVTXVtrZXldID0gdHJ1ZTtcbn07XG4iLCIvLyA3LjEuMTUgVG9MZW5ndGhcbnZhciB0b0ludGVnZXIgPSByZXF1aXJlKCcuL190by1pbnRlZ2VyJyk7XG52YXIgbWluID0gTWF0aC5taW47XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gaXQgPiAwID8gbWluKHRvSW50ZWdlcihpdCksIDB4MWZmZmZmZmZmZmZmZmYpIDogMDsgLy8gcG93KDIsIDUzKSAtIDEgPT0gOTAwNzE5OTI1NDc0MDk5MVxufTtcbiIsIi8vIFRoYW5rJ3MgSUU4IGZvciBoaXMgZnVubnkgZGVmaW5lUHJvcGVydHlcbm1vZHVsZS5leHBvcnRzID0gIXJlcXVpcmUoJy4vX2ZhaWxzJykoZnVuY3Rpb24gKCkge1xuICByZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KHt9LCAnYScsIHsgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiA3OyB9IH0pLmEgIT0gNztcbn0pO1xuIiwibW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFX2EzNTJfXzsiLCIndXNlIHN0cmljdCc7XG5cbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xudmFyIHRvT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8tb2JqZWN0Jyk7XG52YXIgdG9MZW5ndGggPSByZXF1aXJlKCcuL190by1sZW5ndGgnKTtcbnZhciB0b0ludGVnZXIgPSByZXF1aXJlKCcuL190by1pbnRlZ2VyJyk7XG52YXIgYWR2YW5jZVN0cmluZ0luZGV4ID0gcmVxdWlyZSgnLi9fYWR2YW5jZS1zdHJpbmctaW5kZXgnKTtcbnZhciByZWdFeHBFeGVjID0gcmVxdWlyZSgnLi9fcmVnZXhwLWV4ZWMtYWJzdHJhY3QnKTtcbnZhciBtYXggPSBNYXRoLm1heDtcbnZhciBtaW4gPSBNYXRoLm1pbjtcbnZhciBmbG9vciA9IE1hdGguZmxvb3I7XG52YXIgU1VCU1RJVFVUSU9OX1NZTUJPTFMgPSAvXFwkKFskJmAnXXxcXGRcXGQ/fDxbXj5dKj4pL2c7XG52YXIgU1VCU1RJVFVUSU9OX1NZTUJPTFNfTk9fTkFNRUQgPSAvXFwkKFskJmAnXXxcXGRcXGQ/KS9nO1xuXG52YXIgbWF5YmVUb1N0cmluZyA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gaXQgPT09IHVuZGVmaW5lZCA/IGl0IDogU3RyaW5nKGl0KTtcbn07XG5cbi8vIEBAcmVwbGFjZSBsb2dpY1xucmVxdWlyZSgnLi9fZml4LXJlLXdrcycpKCdyZXBsYWNlJywgMiwgZnVuY3Rpb24gKGRlZmluZWQsIFJFUExBQ0UsICRyZXBsYWNlLCBtYXliZUNhbGxOYXRpdmUpIHtcbiAgcmV0dXJuIFtcbiAgICAvLyBgU3RyaW5nLnByb3RvdHlwZS5yZXBsYWNlYCBtZXRob2RcbiAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1zdHJpbmcucHJvdG90eXBlLnJlcGxhY2VcbiAgICBmdW5jdGlvbiByZXBsYWNlKHNlYXJjaFZhbHVlLCByZXBsYWNlVmFsdWUpIHtcbiAgICAgIHZhciBPID0gZGVmaW5lZCh0aGlzKTtcbiAgICAgIHZhciBmbiA9IHNlYXJjaFZhbHVlID09IHVuZGVmaW5lZCA/IHVuZGVmaW5lZCA6IHNlYXJjaFZhbHVlW1JFUExBQ0VdO1xuICAgICAgcmV0dXJuIGZuICE9PSB1bmRlZmluZWRcbiAgICAgICAgPyBmbi5jYWxsKHNlYXJjaFZhbHVlLCBPLCByZXBsYWNlVmFsdWUpXG4gICAgICAgIDogJHJlcGxhY2UuY2FsbChTdHJpbmcoTyksIHNlYXJjaFZhbHVlLCByZXBsYWNlVmFsdWUpO1xuICAgIH0sXG4gICAgLy8gYFJlZ0V4cC5wcm90b3R5cGVbQEByZXBsYWNlXWAgbWV0aG9kXG4gICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtcmVnZXhwLnByb3RvdHlwZS1AQHJlcGxhY2VcbiAgICBmdW5jdGlvbiAocmVnZXhwLCByZXBsYWNlVmFsdWUpIHtcbiAgICAgIHZhciByZXMgPSBtYXliZUNhbGxOYXRpdmUoJHJlcGxhY2UsIHJlZ2V4cCwgdGhpcywgcmVwbGFjZVZhbHVlKTtcbiAgICAgIGlmIChyZXMuZG9uZSkgcmV0dXJuIHJlcy52YWx1ZTtcblxuICAgICAgdmFyIHJ4ID0gYW5PYmplY3QocmVnZXhwKTtcbiAgICAgIHZhciBTID0gU3RyaW5nKHRoaXMpO1xuICAgICAgdmFyIGZ1bmN0aW9uYWxSZXBsYWNlID0gdHlwZW9mIHJlcGxhY2VWYWx1ZSA9PT0gJ2Z1bmN0aW9uJztcbiAgICAgIGlmICghZnVuY3Rpb25hbFJlcGxhY2UpIHJlcGxhY2VWYWx1ZSA9IFN0cmluZyhyZXBsYWNlVmFsdWUpO1xuICAgICAgdmFyIGdsb2JhbCA9IHJ4Lmdsb2JhbDtcbiAgICAgIGlmIChnbG9iYWwpIHtcbiAgICAgICAgdmFyIGZ1bGxVbmljb2RlID0gcngudW5pY29kZTtcbiAgICAgICAgcngubGFzdEluZGV4ID0gMDtcbiAgICAgIH1cbiAgICAgIHZhciByZXN1bHRzID0gW107XG4gICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gcmVnRXhwRXhlYyhyeCwgUyk7XG4gICAgICAgIGlmIChyZXN1bHQgPT09IG51bGwpIGJyZWFrO1xuICAgICAgICByZXN1bHRzLnB1c2gocmVzdWx0KTtcbiAgICAgICAgaWYgKCFnbG9iYWwpIGJyZWFrO1xuICAgICAgICB2YXIgbWF0Y2hTdHIgPSBTdHJpbmcocmVzdWx0WzBdKTtcbiAgICAgICAgaWYgKG1hdGNoU3RyID09PSAnJykgcngubGFzdEluZGV4ID0gYWR2YW5jZVN0cmluZ0luZGV4KFMsIHRvTGVuZ3RoKHJ4Lmxhc3RJbmRleCksIGZ1bGxVbmljb2RlKTtcbiAgICAgIH1cbiAgICAgIHZhciBhY2N1bXVsYXRlZFJlc3VsdCA9ICcnO1xuICAgICAgdmFyIG5leHRTb3VyY2VQb3NpdGlvbiA9IDA7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJlc3VsdHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgcmVzdWx0ID0gcmVzdWx0c1tpXTtcbiAgICAgICAgdmFyIG1hdGNoZWQgPSBTdHJpbmcocmVzdWx0WzBdKTtcbiAgICAgICAgdmFyIHBvc2l0aW9uID0gbWF4KG1pbih0b0ludGVnZXIocmVzdWx0LmluZGV4KSwgUy5sZW5ndGgpLCAwKTtcbiAgICAgICAgdmFyIGNhcHR1cmVzID0gW107XG4gICAgICAgIC8vIE5PVEU6IFRoaXMgaXMgZXF1aXZhbGVudCB0b1xuICAgICAgICAvLyAgIGNhcHR1cmVzID0gcmVzdWx0LnNsaWNlKDEpLm1hcChtYXliZVRvU3RyaW5nKVxuICAgICAgICAvLyBidXQgZm9yIHNvbWUgcmVhc29uIGBuYXRpdmVTbGljZS5jYWxsKHJlc3VsdCwgMSwgcmVzdWx0Lmxlbmd0aClgIChjYWxsZWQgaW5cbiAgICAgICAgLy8gdGhlIHNsaWNlIHBvbHlmaWxsIHdoZW4gc2xpY2luZyBuYXRpdmUgYXJyYXlzKSBcImRvZXNuJ3Qgd29ya1wiIGluIHNhZmFyaSA5IGFuZFxuICAgICAgICAvLyBjYXVzZXMgYSBjcmFzaCAoaHR0cHM6Ly9wYXN0ZWJpbi5jb20vTjIxUXplUUEpIHdoZW4gdHJ5aW5nIHRvIGRlYnVnIGl0LlxuICAgICAgICBmb3IgKHZhciBqID0gMTsgaiA8IHJlc3VsdC5sZW5ndGg7IGorKykgY2FwdHVyZXMucHVzaChtYXliZVRvU3RyaW5nKHJlc3VsdFtqXSkpO1xuICAgICAgICB2YXIgbmFtZWRDYXB0dXJlcyA9IHJlc3VsdC5ncm91cHM7XG4gICAgICAgIGlmIChmdW5jdGlvbmFsUmVwbGFjZSkge1xuICAgICAgICAgIHZhciByZXBsYWNlckFyZ3MgPSBbbWF0Y2hlZF0uY29uY2F0KGNhcHR1cmVzLCBwb3NpdGlvbiwgUyk7XG4gICAgICAgICAgaWYgKG5hbWVkQ2FwdHVyZXMgIT09IHVuZGVmaW5lZCkgcmVwbGFjZXJBcmdzLnB1c2gobmFtZWRDYXB0dXJlcyk7XG4gICAgICAgICAgdmFyIHJlcGxhY2VtZW50ID0gU3RyaW5nKHJlcGxhY2VWYWx1ZS5hcHBseSh1bmRlZmluZWQsIHJlcGxhY2VyQXJncykpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlcGxhY2VtZW50ID0gZ2V0U3Vic3RpdHV0aW9uKG1hdGNoZWQsIFMsIHBvc2l0aW9uLCBjYXB0dXJlcywgbmFtZWRDYXB0dXJlcywgcmVwbGFjZVZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocG9zaXRpb24gPj0gbmV4dFNvdXJjZVBvc2l0aW9uKSB7XG4gICAgICAgICAgYWNjdW11bGF0ZWRSZXN1bHQgKz0gUy5zbGljZShuZXh0U291cmNlUG9zaXRpb24sIHBvc2l0aW9uKSArIHJlcGxhY2VtZW50O1xuICAgICAgICAgIG5leHRTb3VyY2VQb3NpdGlvbiA9IHBvc2l0aW9uICsgbWF0Y2hlZC5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBhY2N1bXVsYXRlZFJlc3VsdCArIFMuc2xpY2UobmV4dFNvdXJjZVBvc2l0aW9uKTtcbiAgICB9XG4gIF07XG5cbiAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1nZXRzdWJzdGl0dXRpb25cbiAgZnVuY3Rpb24gZ2V0U3Vic3RpdHV0aW9uKG1hdGNoZWQsIHN0ciwgcG9zaXRpb24sIGNhcHR1cmVzLCBuYW1lZENhcHR1cmVzLCByZXBsYWNlbWVudCkge1xuICAgIHZhciB0YWlsUG9zID0gcG9zaXRpb24gKyBtYXRjaGVkLmxlbmd0aDtcbiAgICB2YXIgbSA9IGNhcHR1cmVzLmxlbmd0aDtcbiAgICB2YXIgc3ltYm9scyA9IFNVQlNUSVRVVElPTl9TWU1CT0xTX05PX05BTUVEO1xuICAgIGlmIChuYW1lZENhcHR1cmVzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIG5hbWVkQ2FwdHVyZXMgPSB0b09iamVjdChuYW1lZENhcHR1cmVzKTtcbiAgICAgIHN5bWJvbHMgPSBTVUJTVElUVVRJT05fU1lNQk9MUztcbiAgICB9XG4gICAgcmV0dXJuICRyZXBsYWNlLmNhbGwocmVwbGFjZW1lbnQsIHN5bWJvbHMsIGZ1bmN0aW9uIChtYXRjaCwgY2gpIHtcbiAgICAgIHZhciBjYXB0dXJlO1xuICAgICAgc3dpdGNoIChjaC5jaGFyQXQoMCkpIHtcbiAgICAgICAgY2FzZSAnJCc6IHJldHVybiAnJCc7XG4gICAgICAgIGNhc2UgJyYnOiByZXR1cm4gbWF0Y2hlZDtcbiAgICAgICAgY2FzZSAnYCc6IHJldHVybiBzdHIuc2xpY2UoMCwgcG9zaXRpb24pO1xuICAgICAgICBjYXNlIFwiJ1wiOiByZXR1cm4gc3RyLnNsaWNlKHRhaWxQb3MpO1xuICAgICAgICBjYXNlICc8JzpcbiAgICAgICAgICBjYXB0dXJlID0gbmFtZWRDYXB0dXJlc1tjaC5zbGljZSgxLCAtMSldO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OiAvLyBcXGRcXGQ/XG4gICAgICAgICAgdmFyIG4gPSArY2g7XG4gICAgICAgICAgaWYgKG4gPT09IDApIHJldHVybiBtYXRjaDtcbiAgICAgICAgICBpZiAobiA+IG0pIHtcbiAgICAgICAgICAgIHZhciBmID0gZmxvb3IobiAvIDEwKTtcbiAgICAgICAgICAgIGlmIChmID09PSAwKSByZXR1cm4gbWF0Y2g7XG4gICAgICAgICAgICBpZiAoZiA8PSBtKSByZXR1cm4gY2FwdHVyZXNbZiAtIDFdID09PSB1bmRlZmluZWQgPyBjaC5jaGFyQXQoMSkgOiBjYXB0dXJlc1tmIC0gMV0gKyBjaC5jaGFyQXQoMSk7XG4gICAgICAgICAgICByZXR1cm4gbWF0Y2g7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhcHR1cmUgPSBjYXB0dXJlc1tuIC0gMV07XG4gICAgICB9XG4gICAgICByZXR1cm4gY2FwdHVyZSA9PT0gdW5kZWZpbmVkID8gJycgOiBjYXB0dXJlO1xuICAgIH0pO1xuICB9XG59KTtcbiIsIi8vIDcuMi44IElzUmVnRXhwKGFyZ3VtZW50KVxudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG52YXIgY29mID0gcmVxdWlyZSgnLi9fY29mJyk7XG52YXIgTUFUQ0ggPSByZXF1aXJlKCcuL193a3MnKSgnbWF0Y2gnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIHZhciBpc1JlZ0V4cDtcbiAgcmV0dXJuIGlzT2JqZWN0KGl0KSAmJiAoKGlzUmVnRXhwID0gaXRbTUFUQ0hdKSAhPT0gdW5kZWZpbmVkID8gISFpc1JlZ0V4cCA6IGNvZihpdCkgPT0gJ1JlZ0V4cCcpO1xufTtcbiIsInZhciAkaXRlcmF0b3JzID0gcmVxdWlyZSgnLi9lczYuYXJyYXkuaXRlcmF0b3InKTtcbnZhciBnZXRLZXlzID0gcmVxdWlyZSgnLi9fb2JqZWN0LWtleXMnKTtcbnZhciByZWRlZmluZSA9IHJlcXVpcmUoJy4vX3JlZGVmaW5lJyk7XG52YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi9fZ2xvYmFsJyk7XG52YXIgaGlkZSA9IHJlcXVpcmUoJy4vX2hpZGUnKTtcbnZhciBJdGVyYXRvcnMgPSByZXF1aXJlKCcuL19pdGVyYXRvcnMnKTtcbnZhciB3a3MgPSByZXF1aXJlKCcuL193a3MnKTtcbnZhciBJVEVSQVRPUiA9IHdrcygnaXRlcmF0b3InKTtcbnZhciBUT19TVFJJTkdfVEFHID0gd2tzKCd0b1N0cmluZ1RhZycpO1xudmFyIEFycmF5VmFsdWVzID0gSXRlcmF0b3JzLkFycmF5O1xuXG52YXIgRE9NSXRlcmFibGVzID0ge1xuICBDU1NSdWxlTGlzdDogdHJ1ZSwgLy8gVE9ETzogTm90IHNwZWMgY29tcGxpYW50LCBzaG91bGQgYmUgZmFsc2UuXG4gIENTU1N0eWxlRGVjbGFyYXRpb246IGZhbHNlLFxuICBDU1NWYWx1ZUxpc3Q6IGZhbHNlLFxuICBDbGllbnRSZWN0TGlzdDogZmFsc2UsXG4gIERPTVJlY3RMaXN0OiBmYWxzZSxcbiAgRE9NU3RyaW5nTGlzdDogZmFsc2UsXG4gIERPTVRva2VuTGlzdDogdHJ1ZSxcbiAgRGF0YVRyYW5zZmVySXRlbUxpc3Q6IGZhbHNlLFxuICBGaWxlTGlzdDogZmFsc2UsXG4gIEhUTUxBbGxDb2xsZWN0aW9uOiBmYWxzZSxcbiAgSFRNTENvbGxlY3Rpb246IGZhbHNlLFxuICBIVE1MRm9ybUVsZW1lbnQ6IGZhbHNlLFxuICBIVE1MU2VsZWN0RWxlbWVudDogZmFsc2UsXG4gIE1lZGlhTGlzdDogdHJ1ZSwgLy8gVE9ETzogTm90IHNwZWMgY29tcGxpYW50LCBzaG91bGQgYmUgZmFsc2UuXG4gIE1pbWVUeXBlQXJyYXk6IGZhbHNlLFxuICBOYW1lZE5vZGVNYXA6IGZhbHNlLFxuICBOb2RlTGlzdDogdHJ1ZSxcbiAgUGFpbnRSZXF1ZXN0TGlzdDogZmFsc2UsXG4gIFBsdWdpbjogZmFsc2UsXG4gIFBsdWdpbkFycmF5OiBmYWxzZSxcbiAgU1ZHTGVuZ3RoTGlzdDogZmFsc2UsXG4gIFNWR051bWJlckxpc3Q6IGZhbHNlLFxuICBTVkdQYXRoU2VnTGlzdDogZmFsc2UsXG4gIFNWR1BvaW50TGlzdDogZmFsc2UsXG4gIFNWR1N0cmluZ0xpc3Q6IGZhbHNlLFxuICBTVkdUcmFuc2Zvcm1MaXN0OiBmYWxzZSxcbiAgU291cmNlQnVmZmVyTGlzdDogZmFsc2UsXG4gIFN0eWxlU2hlZXRMaXN0OiB0cnVlLCAvLyBUT0RPOiBOb3Qgc3BlYyBjb21wbGlhbnQsIHNob3VsZCBiZSBmYWxzZS5cbiAgVGV4dFRyYWNrQ3VlTGlzdDogZmFsc2UsXG4gIFRleHRUcmFja0xpc3Q6IGZhbHNlLFxuICBUb3VjaExpc3Q6IGZhbHNlXG59O1xuXG5mb3IgKHZhciBjb2xsZWN0aW9ucyA9IGdldEtleXMoRE9NSXRlcmFibGVzKSwgaSA9IDA7IGkgPCBjb2xsZWN0aW9ucy5sZW5ndGg7IGkrKykge1xuICB2YXIgTkFNRSA9IGNvbGxlY3Rpb25zW2ldO1xuICB2YXIgZXhwbGljaXQgPSBET01JdGVyYWJsZXNbTkFNRV07XG4gIHZhciBDb2xsZWN0aW9uID0gZ2xvYmFsW05BTUVdO1xuICB2YXIgcHJvdG8gPSBDb2xsZWN0aW9uICYmIENvbGxlY3Rpb24ucHJvdG90eXBlO1xuICB2YXIga2V5O1xuICBpZiAocHJvdG8pIHtcbiAgICBpZiAoIXByb3RvW0lURVJBVE9SXSkgaGlkZShwcm90bywgSVRFUkFUT1IsIEFycmF5VmFsdWVzKTtcbiAgICBpZiAoIXByb3RvW1RPX1NUUklOR19UQUddKSBoaWRlKHByb3RvLCBUT19TVFJJTkdfVEFHLCBOQU1FKTtcbiAgICBJdGVyYXRvcnNbTkFNRV0gPSBBcnJheVZhbHVlcztcbiAgICBpZiAoZXhwbGljaXQpIGZvciAoa2V5IGluICRpdGVyYXRvcnMpIGlmICghcHJvdG9ba2V5XSkgcmVkZWZpbmUocHJvdG8sIGtleSwgJGl0ZXJhdG9yc1trZXldLCB0cnVlKTtcbiAgfVxufVxuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIHJlZ2V4cEV4ZWMgPSByZXF1aXJlKCcuL19yZWdleHAtZXhlYycpO1xucmVxdWlyZSgnLi9fZXhwb3J0Jykoe1xuICB0YXJnZXQ6ICdSZWdFeHAnLFxuICBwcm90bzogdHJ1ZSxcbiAgZm9yY2VkOiByZWdleHBFeGVjICE9PSAvLi8uZXhlY1xufSwge1xuICBleGVjOiByZWdleHBFeGVjXG59KTtcbiIsIi8vIDcuMi4xIFJlcXVpcmVPYmplY3RDb2VyY2libGUoYXJndW1lbnQpXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICBpZiAoaXQgPT0gdW5kZWZpbmVkKSB0aHJvdyBUeXBlRXJyb3IoXCJDYW4ndCBjYWxsIG1ldGhvZCBvbiAgXCIgKyBpdCk7XG4gIHJldHVybiBpdDtcbn07XG4iLCIvLyBmYWxzZSAtPiBBcnJheSNpbmRleE9mXG4vLyB0cnVlICAtPiBBcnJheSNpbmNsdWRlc1xudmFyIHRvSU9iamVjdCA9IHJlcXVpcmUoJy4vX3RvLWlvYmplY3QnKTtcbnZhciB0b0xlbmd0aCA9IHJlcXVpcmUoJy4vX3RvLWxlbmd0aCcpO1xudmFyIHRvQWJzb2x1dGVJbmRleCA9IHJlcXVpcmUoJy4vX3RvLWFic29sdXRlLWluZGV4Jyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChJU19JTkNMVURFUykge1xuICByZXR1cm4gZnVuY3Rpb24gKCR0aGlzLCBlbCwgZnJvbUluZGV4KSB7XG4gICAgdmFyIE8gPSB0b0lPYmplY3QoJHRoaXMpO1xuICAgIHZhciBsZW5ndGggPSB0b0xlbmd0aChPLmxlbmd0aCk7XG4gICAgdmFyIGluZGV4ID0gdG9BYnNvbHV0ZUluZGV4KGZyb21JbmRleCwgbGVuZ3RoKTtcbiAgICB2YXIgdmFsdWU7XG4gICAgLy8gQXJyYXkjaW5jbHVkZXMgdXNlcyBTYW1lVmFsdWVaZXJvIGVxdWFsaXR5IGFsZ29yaXRobVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1zZWxmLWNvbXBhcmVcbiAgICBpZiAoSVNfSU5DTFVERVMgJiYgZWwgIT0gZWwpIHdoaWxlIChsZW5ndGggPiBpbmRleCkge1xuICAgICAgdmFsdWUgPSBPW2luZGV4KytdO1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXNlbGYtY29tcGFyZVxuICAgICAgaWYgKHZhbHVlICE9IHZhbHVlKSByZXR1cm4gdHJ1ZTtcbiAgICAvLyBBcnJheSNpbmRleE9mIGlnbm9yZXMgaG9sZXMsIEFycmF5I2luY2x1ZGVzIC0gbm90XG4gICAgfSBlbHNlIGZvciAoO2xlbmd0aCA+IGluZGV4OyBpbmRleCsrKSBpZiAoSVNfSU5DTFVERVMgfHwgaW5kZXggaW4gTykge1xuICAgICAgaWYgKE9baW5kZXhdID09PSBlbCkgcmV0dXJuIElTX0lOQ0xVREVTIHx8IGluZGV4IHx8IDA7XG4gICAgfSByZXR1cm4gIUlTX0lOQ0xVREVTICYmIC0xO1xuICB9O1xufTtcbiIsImZ1bmN0aW9uIGdldENvbnNvbGUoKSB7XHJcbiAgaWYgKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIpIHtcclxuICAgIHJldHVybiB3aW5kb3cuY29uc29sZTtcclxuICB9XHJcbiAgcmV0dXJuIGdsb2JhbC5jb25zb2xlO1xyXG59XHJcbmNvbnN0IGNvbnNvbGUgPSBnZXRDb25zb2xlKCk7XHJcblxyXG5mdW5jdGlvbiBjYWNoZWQoZm4pIHtcclxuICBjb25zdCBjYWNoZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XHJcbiAgcmV0dXJuIGZ1bmN0aW9uIGNhY2hlZEZuKHN0cikge1xyXG4gICAgY29uc3QgaGl0ID0gY2FjaGVbc3RyXTtcclxuICAgIHJldHVybiBoaXQgfHwgKGNhY2hlW3N0cl0gPSBmbihzdHIpKTtcclxuICB9O1xyXG59XHJcblxyXG5jb25zdCByZWdleCA9IC8tKFxcdykvZztcclxuY29uc3QgY2FtZWxpemUgPSBjYWNoZWQoc3RyID0+XHJcbiAgc3RyLnJlcGxhY2UocmVnZXgsIChfLCBjKSA9PiAoYyA/IGMudG9VcHBlckNhc2UoKSA6IFwiXCIpKVxyXG4pO1xyXG5cclxuZnVuY3Rpb24gcmVtb3ZlTm9kZShub2RlKSB7XHJcbiAgaWYgKG5vZGUucGFyZW50RWxlbWVudCAhPT0gbnVsbCkge1xyXG4gICAgbm9kZS5wYXJlbnRFbGVtZW50LnJlbW92ZUNoaWxkKG5vZGUpO1xyXG4gIH1cclxufVxyXG5cclxuZnVuY3Rpb24gaW5zZXJ0Tm9kZUF0KGZhdGhlck5vZGUsIG5vZGUsIHBvc2l0aW9uKSB7XHJcbiAgY29uc3QgcmVmTm9kZSA9XHJcbiAgICBwb3NpdGlvbiA9PT0gMFxyXG4gICAgICA/IGZhdGhlck5vZGUuY2hpbGRyZW5bMF1cclxuICAgICAgOiBmYXRoZXJOb2RlLmNoaWxkcmVuW3Bvc2l0aW9uIC0gMV0ubmV4dFNpYmxpbmc7XHJcbiAgZmF0aGVyTm9kZS5pbnNlcnRCZWZvcmUobm9kZSwgcmVmTm9kZSk7XHJcbn1cclxuXHJcbmV4cG9ydCB7IGluc2VydE5vZGVBdCwgY2FtZWxpemUsIGNvbnNvbGUsIHJlbW92ZU5vZGUgfTtcclxuIiwibW9kdWxlLmV4cG9ydHMgPSAhcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKSAmJiAhcmVxdWlyZSgnLi9fZmFpbHMnKShmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkocmVxdWlyZSgnLi9fZG9tLWNyZWF0ZScpKCdkaXYnKSwgJ2EnLCB7IGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gNzsgfSB9KS5hICE9IDc7XG59KTtcbiIsInZhciBnO1xuXG4vLyBUaGlzIHdvcmtzIGluIG5vbi1zdHJpY3QgbW9kZVxuZyA9IChmdW5jdGlvbigpIHtcblx0cmV0dXJuIHRoaXM7XG59KSgpO1xuXG50cnkge1xuXHQvLyBUaGlzIHdvcmtzIGlmIGV2YWwgaXMgYWxsb3dlZCAoc2VlIENTUClcblx0ZyA9IGcgfHwgbmV3IEZ1bmN0aW9uKFwicmV0dXJuIHRoaXNcIikoKTtcbn0gY2F0Y2ggKGUpIHtcblx0Ly8gVGhpcyB3b3JrcyBpZiB0aGUgd2luZG93IHJlZmVyZW5jZSBpcyBhdmFpbGFibGVcblx0aWYgKHR5cGVvZiB3aW5kb3cgPT09IFwib2JqZWN0XCIpIGcgPSB3aW5kb3c7XG59XG5cbi8vIGcgY2FuIHN0aWxsIGJlIHVuZGVmaW5lZCwgYnV0IG5vdGhpbmcgdG8gZG8gYWJvdXQgaXQuLi5cbi8vIFdlIHJldHVybiB1bmRlZmluZWQsIGluc3RlYWQgb2Ygbm90aGluZyBoZXJlLCBzbyBpdCdzXG4vLyBlYXNpZXIgdG8gaGFuZGxlIHRoaXMgY2FzZS4gaWYoIWdsb2JhbCkgeyAuLi59XG5cbm1vZHVsZS5leHBvcnRzID0gZztcbiIsInZhciBpZCA9IDA7XG52YXIgcHggPSBNYXRoLnJhbmRvbSgpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoa2V5KSB7XG4gIHJldHVybiAnU3ltYm9sKCcuY29uY2F0KGtleSA9PT0gdW5kZWZpbmVkID8gJycgOiBrZXksICcpXycsICgrK2lkICsgcHgpLnRvU3RyaW5nKDM2KSk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGFkZFRvVW5zY29wYWJsZXMgPSByZXF1aXJlKCcuL19hZGQtdG8tdW5zY29wYWJsZXMnKTtcbnZhciBzdGVwID0gcmVxdWlyZSgnLi9faXRlci1zdGVwJyk7XG52YXIgSXRlcmF0b3JzID0gcmVxdWlyZSgnLi9faXRlcmF0b3JzJyk7XG52YXIgdG9JT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8taW9iamVjdCcpO1xuXG4vLyAyMi4xLjMuNCBBcnJheS5wcm90b3R5cGUuZW50cmllcygpXG4vLyAyMi4xLjMuMTMgQXJyYXkucHJvdG90eXBlLmtleXMoKVxuLy8gMjIuMS4zLjI5IEFycmF5LnByb3RvdHlwZS52YWx1ZXMoKVxuLy8gMjIuMS4zLjMwIEFycmF5LnByb3RvdHlwZVtAQGl0ZXJhdG9yXSgpXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vX2l0ZXItZGVmaW5lJykoQXJyYXksICdBcnJheScsIGZ1bmN0aW9uIChpdGVyYXRlZCwga2luZCkge1xuICB0aGlzLl90ID0gdG9JT2JqZWN0KGl0ZXJhdGVkKTsgLy8gdGFyZ2V0XG4gIHRoaXMuX2kgPSAwOyAgICAgICAgICAgICAgICAgICAvLyBuZXh0IGluZGV4XG4gIHRoaXMuX2sgPSBraW5kOyAgICAgICAgICAgICAgICAvLyBraW5kXG4vLyAyMi4xLjUuMi4xICVBcnJheUl0ZXJhdG9yUHJvdG90eXBlJS5uZXh0KClcbn0sIGZ1bmN0aW9uICgpIHtcbiAgdmFyIE8gPSB0aGlzLl90O1xuICB2YXIga2luZCA9IHRoaXMuX2s7XG4gIHZhciBpbmRleCA9IHRoaXMuX2krKztcbiAgaWYgKCFPIHx8IGluZGV4ID49IE8ubGVuZ3RoKSB7XG4gICAgdGhpcy5fdCA9IHVuZGVmaW5lZDtcbiAgICByZXR1cm4gc3RlcCgxKTtcbiAgfVxuICBpZiAoa2luZCA9PSAna2V5cycpIHJldHVybiBzdGVwKDAsIGluZGV4KTtcbiAgaWYgKGtpbmQgPT0gJ3ZhbHVlcycpIHJldHVybiBzdGVwKDAsIE9baW5kZXhdKTtcbiAgcmV0dXJuIHN0ZXAoMCwgW2luZGV4LCBPW2luZGV4XV0pO1xufSwgJ3ZhbHVlcycpO1xuXG4vLyBhcmd1bWVudHNMaXN0W0BAaXRlcmF0b3JdIGlzICVBcnJheVByb3RvX3ZhbHVlcyUgKDkuNC40LjYsIDkuNC40LjcpXG5JdGVyYXRvcnMuQXJndW1lbnRzID0gSXRlcmF0b3JzLkFycmF5O1xuXG5hZGRUb1Vuc2NvcGFibGVzKCdrZXlzJyk7XG5hZGRUb1Vuc2NvcGFibGVzKCd2YWx1ZXMnKTtcbmFkZFRvVW5zY29wYWJsZXMoJ2VudHJpZXMnKTtcbiIsInZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgaWYgKCFpc09iamVjdChpdCkpIHRocm93IFR5cGVFcnJvcihpdCArICcgaXMgbm90IGFuIG9iamVjdCEnKTtcbiAgcmV0dXJuIGl0O1xufTtcbiIsInZhciBoYXMgPSByZXF1aXJlKCcuL19oYXMnKTtcbnZhciB0b0lPYmplY3QgPSByZXF1aXJlKCcuL190by1pb2JqZWN0Jyk7XG52YXIgYXJyYXlJbmRleE9mID0gcmVxdWlyZSgnLi9fYXJyYXktaW5jbHVkZXMnKShmYWxzZSk7XG52YXIgSUVfUFJPVE8gPSByZXF1aXJlKCcuL19zaGFyZWQta2V5JykoJ0lFX1BST1RPJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG9iamVjdCwgbmFtZXMpIHtcbiAgdmFyIE8gPSB0b0lPYmplY3Qob2JqZWN0KTtcbiAgdmFyIGkgPSAwO1xuICB2YXIgcmVzdWx0ID0gW107XG4gIHZhciBrZXk7XG4gIGZvciAoa2V5IGluIE8pIGlmIChrZXkgIT0gSUVfUFJPVE8pIGhhcyhPLCBrZXkpICYmIHJlc3VsdC5wdXNoKGtleSk7XG4gIC8vIERvbid0IGVudW0gYnVnICYgaGlkZGVuIGtleXNcbiAgd2hpbGUgKG5hbWVzLmxlbmd0aCA+IGkpIGlmIChoYXMoTywga2V5ID0gbmFtZXNbaSsrXSkpIHtcbiAgICB+YXJyYXlJbmRleE9mKHJlc3VsdCwga2V5KSB8fCByZXN1bHQucHVzaChrZXkpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59O1xuIiwiLy8gaGVscGVyIGZvciBTdHJpbmcje3N0YXJ0c1dpdGgsIGVuZHNXaXRoLCBpbmNsdWRlc31cbnZhciBpc1JlZ0V4cCA9IHJlcXVpcmUoJy4vX2lzLXJlZ2V4cCcpO1xudmFyIGRlZmluZWQgPSByZXF1aXJlKCcuL19kZWZpbmVkJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHRoYXQsIHNlYXJjaFN0cmluZywgTkFNRSkge1xuICBpZiAoaXNSZWdFeHAoc2VhcmNoU3RyaW5nKSkgdGhyb3cgVHlwZUVycm9yKCdTdHJpbmcjJyArIE5BTUUgKyBcIiBkb2Vzbid0IGFjY2VwdCByZWdleCFcIik7XG4gIHJldHVybiBTdHJpbmcoZGVmaW5lZCh0aGF0KSk7XG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIHR5cGVvZiBpdCA9PT0gJ29iamVjdCcgPyBpdCAhPT0gbnVsbCA6IHR5cGVvZiBpdCA9PT0gJ2Z1bmN0aW9uJztcbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChkb25lLCB2YWx1ZSkge1xuICByZXR1cm4geyB2YWx1ZTogdmFsdWUsIGRvbmU6ICEhZG9uZSB9O1xufTtcbiIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIGlmICh0eXBlb2YgaXQgIT0gJ2Z1bmN0aW9uJykgdGhyb3cgVHlwZUVycm9yKGl0ICsgJyBpcyBub3QgYSBmdW5jdGlvbiEnKTtcbiAgcmV0dXJuIGl0O1xufTtcbiIsIi8vIElFIDgtIGRvbid0IGVudW0gYnVnIGtleXNcbm1vZHVsZS5leHBvcnRzID0gKFxuICAnY29uc3RydWN0b3IsaGFzT3duUHJvcGVydHksaXNQcm90b3R5cGVPZixwcm9wZXJ0eUlzRW51bWVyYWJsZSx0b0xvY2FsZVN0cmluZyx0b1N0cmluZyx2YWx1ZU9mJ1xuKS5zcGxpdCgnLCcpO1xuIiwiLy8gMjEuMS4zLjE4IFN0cmluZy5wcm90b3R5cGUuc3RhcnRzV2l0aChzZWFyY2hTdHJpbmcgWywgcG9zaXRpb24gXSlcbid1c2Ugc3RyaWN0JztcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgdG9MZW5ndGggPSByZXF1aXJlKCcuL190by1sZW5ndGgnKTtcbnZhciBjb250ZXh0ID0gcmVxdWlyZSgnLi9fc3RyaW5nLWNvbnRleHQnKTtcbnZhciBTVEFSVFNfV0lUSCA9ICdzdGFydHNXaXRoJztcbnZhciAkc3RhcnRzV2l0aCA9ICcnW1NUQVJUU19XSVRIXTtcblxuJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiByZXF1aXJlKCcuL19mYWlscy1pcy1yZWdleHAnKShTVEFSVFNfV0lUSCksICdTdHJpbmcnLCB7XG4gIHN0YXJ0c1dpdGg6IGZ1bmN0aW9uIHN0YXJ0c1dpdGgoc2VhcmNoU3RyaW5nIC8qICwgcG9zaXRpb24gPSAwICovKSB7XG4gICAgdmFyIHRoYXQgPSBjb250ZXh0KHRoaXMsIHNlYXJjaFN0cmluZywgU1RBUlRTX1dJVEgpO1xuICAgIHZhciBpbmRleCA9IHRvTGVuZ3RoKE1hdGgubWluKGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkLCB0aGF0Lmxlbmd0aCkpO1xuICAgIHZhciBzZWFyY2ggPSBTdHJpbmcoc2VhcmNoU3RyaW5nKTtcbiAgICByZXR1cm4gJHN0YXJ0c1dpdGhcbiAgICAgID8gJHN0YXJ0c1dpdGguY2FsbCh0aGF0LCBzZWFyY2gsIGluZGV4KVxuICAgICAgOiB0aGF0LnNsaWNlKGluZGV4LCBpbmRleCArIHNlYXJjaC5sZW5ndGgpID09PSBzZWFyY2g7XG4gIH1cbn0pO1xuIiwiLy8gZG9jdW1lbnQuY3VycmVudFNjcmlwdCBwb2x5ZmlsbCBieSBBZGFtIE1pbGxlclxuXG4vLyBNSVQgbGljZW5zZVxuXG4oZnVuY3Rpb24oZG9jdW1lbnQpe1xuICB2YXIgY3VycmVudFNjcmlwdCA9IFwiY3VycmVudFNjcmlwdFwiLFxuICAgICAgc2NyaXB0cyA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdzY3JpcHQnKTsgLy8gTGl2ZSBOb2RlTGlzdCBjb2xsZWN0aW9uXG5cbiAgLy8gSWYgYnJvd3NlciBuZWVkcyBjdXJyZW50U2NyaXB0IHBvbHlmaWxsLCBhZGQgZ2V0IGN1cnJlbnRTY3JpcHQoKSB0byB0aGUgZG9jdW1lbnQgb2JqZWN0XG4gIGlmICghKGN1cnJlbnRTY3JpcHQgaW4gZG9jdW1lbnQpKSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGRvY3VtZW50LCBjdXJyZW50U2NyaXB0LCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uKCl7XG5cbiAgICAgICAgLy8gSUUgNi0xMCBzdXBwb3J0cyBzY3JpcHQgcmVhZHlTdGF0ZVxuICAgICAgICAvLyBJRSAxMCsgc3VwcG9ydCBzdGFjayB0cmFjZVxuICAgICAgICB0cnkgeyB0aHJvdyBuZXcgRXJyb3IoKTsgfVxuICAgICAgICBjYXRjaCAoZXJyKSB7XG5cbiAgICAgICAgICAvLyBGaW5kIHRoZSBzZWNvbmQgbWF0Y2ggZm9yIHRoZSBcImF0XCIgc3RyaW5nIHRvIGdldCBmaWxlIHNyYyB1cmwgZnJvbSBzdGFjay5cbiAgICAgICAgICAvLyBTcGVjaWZpY2FsbHkgd29ya3Mgd2l0aCB0aGUgZm9ybWF0IG9mIHN0YWNrIHRyYWNlcyBpbiBJRS5cbiAgICAgICAgICB2YXIgaSwgcmVzID0gKCgvLiphdCBbXlxcKF0qXFwoKC4qKTouKzouK1xcKSQvaWcpLmV4ZWMoZXJyLnN0YWNrKSB8fCBbZmFsc2VdKVsxXTtcblxuICAgICAgICAgIC8vIEZvciBhbGwgc2NyaXB0cyBvbiB0aGUgcGFnZSwgaWYgc3JjIG1hdGNoZXMgb3IgaWYgcmVhZHkgc3RhdGUgaXMgaW50ZXJhY3RpdmUsIHJldHVybiB0aGUgc2NyaXB0IHRhZ1xuICAgICAgICAgIGZvcihpIGluIHNjcmlwdHMpe1xuICAgICAgICAgICAgaWYoc2NyaXB0c1tpXS5zcmMgPT0gcmVzIHx8IHNjcmlwdHNbaV0ucmVhZHlTdGF0ZSA9PSBcImludGVyYWN0aXZlXCIpe1xuICAgICAgICAgICAgICByZXR1cm4gc2NyaXB0c1tpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBJZiBubyBtYXRjaCwgcmV0dXJuIG51bGxcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9XG59KShkb2N1bWVudCk7XG4iLCIvLyAxOS4xLjMuMSBPYmplY3QuYXNzaWduKHRhcmdldCwgc291cmNlKVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYsICdPYmplY3QnLCB7IGFzc2lnbjogcmVxdWlyZSgnLi9fb2JqZWN0LWFzc2lnbicpIH0pO1xuIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL19zaGFyZWQnKSgnbmF0aXZlLWZ1bmN0aW9uLXRvLXN0cmluZycsIEZ1bmN0aW9uLnRvU3RyaW5nKTtcbiIsInZhciBkb2N1bWVudCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpLmRvY3VtZW50O1xubW9kdWxlLmV4cG9ydHMgPSBkb2N1bWVudCAmJiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG4iLCIvLyBUaGlzIGZpbGUgaXMgaW1wb3J0ZWQgaW50byBsaWIvd2MgY2xpZW50IGJ1bmRsZXMuXG5cbmlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICBpZiAocHJvY2Vzcy5lbnYuTkVFRF9DVVJSRU5UU0NSSVBUX1BPTFlGSUxMKSB7XG4gICAgcmVxdWlyZSgnY3VycmVudC1zY3JpcHQtcG9seWZpbGwnKVxuICB9XG5cbiAgdmFyIGlcbiAgaWYgKChpID0gd2luZG93LmRvY3VtZW50LmN1cnJlbnRTY3JpcHQpICYmIChpID0gaS5zcmMubWF0Y2goLyguK1xcLylbXi9dK1xcLmpzKFxcPy4qKT8kLykpKSB7XG4gICAgX193ZWJwYWNrX3B1YmxpY19wYXRoX18gPSBpWzFdIC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbiAgfVxufVxuXG4vLyBJbmRpY2F0ZSB0byB3ZWJwYWNrIHRoYXQgdGhpcyBmaWxlIGNhbiBiZSBjb25jYXRlbmF0ZWRcbmV4cG9ydCBkZWZhdWx0IG51bGxcbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIF9hcnJheVdpdGhIb2xlcyhhcnIpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkgcmV0dXJuIGFycjtcbn0iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBfaXRlcmFibGVUb0FycmF5TGltaXQoYXJyLCBpKSB7XG4gIGlmICh0eXBlb2YgU3ltYm9sID09PSBcInVuZGVmaW5lZFwiIHx8ICEoU3ltYm9sLml0ZXJhdG9yIGluIE9iamVjdChhcnIpKSkgcmV0dXJuO1xuICB2YXIgX2FyciA9IFtdO1xuICB2YXIgX24gPSB0cnVlO1xuICB2YXIgX2QgPSBmYWxzZTtcbiAgdmFyIF9lID0gdW5kZWZpbmVkO1xuXG4gIHRyeSB7XG4gICAgZm9yICh2YXIgX2kgPSBhcnJbU3ltYm9sLml0ZXJhdG9yXSgpLCBfczsgIShfbiA9IChfcyA9IF9pLm5leHQoKSkuZG9uZSk7IF9uID0gdHJ1ZSkge1xuICAgICAgX2Fyci5wdXNoKF9zLnZhbHVlKTtcblxuICAgICAgaWYgKGkgJiYgX2Fyci5sZW5ndGggPT09IGkpIGJyZWFrO1xuICAgIH1cbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgX2QgPSB0cnVlO1xuICAgIF9lID0gZXJyO1xuICB9IGZpbmFsbHkge1xuICAgIHRyeSB7XG4gICAgICBpZiAoIV9uICYmIF9pW1wicmV0dXJuXCJdICE9IG51bGwpIF9pW1wicmV0dXJuXCJdKCk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGlmIChfZCkgdGhyb3cgX2U7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIF9hcnI7XG59IiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gX2FycmF5TGlrZVRvQXJyYXkoYXJyLCBsZW4pIHtcbiAgaWYgKGxlbiA9PSBudWxsIHx8IGxlbiA+IGFyci5sZW5ndGgpIGxlbiA9IGFyci5sZW5ndGg7XG5cbiAgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBuZXcgQXJyYXkobGVuKTsgaSA8IGxlbjsgaSsrKSB7XG4gICAgYXJyMltpXSA9IGFycltpXTtcbiAgfVxuXG4gIHJldHVybiBhcnIyO1xufSIsImltcG9ydCBhcnJheUxpa2VUb0FycmF5IGZyb20gXCIuL2FycmF5TGlrZVRvQXJyYXlcIjtcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShvLCBtaW5MZW4pIHtcbiAgaWYgKCFvKSByZXR1cm47XG4gIGlmICh0eXBlb2YgbyA9PT0gXCJzdHJpbmdcIikgcmV0dXJuIGFycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTtcbiAgdmFyIG4gPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykuc2xpY2UoOCwgLTEpO1xuICBpZiAobiA9PT0gXCJPYmplY3RcIiAmJiBvLmNvbnN0cnVjdG9yKSBuID0gby5jb25zdHJ1Y3Rvci5uYW1lO1xuICBpZiAobiA9PT0gXCJNYXBcIiB8fCBuID09PSBcIlNldFwiKSByZXR1cm4gQXJyYXkuZnJvbShvKTtcbiAgaWYgKG4gPT09IFwiQXJndW1lbnRzXCIgfHwgL14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QobikpIHJldHVybiBhcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7XG59IiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gX25vbkl0ZXJhYmxlUmVzdCgpIHtcbiAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBkZXN0cnVjdHVyZSBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTtcbn0iLCJpbXBvcnQgYXJyYXlXaXRoSG9sZXMgZnJvbSBcIi4vYXJyYXlXaXRoSG9sZXNcIjtcbmltcG9ydCBpdGVyYWJsZVRvQXJyYXlMaW1pdCBmcm9tIFwiLi9pdGVyYWJsZVRvQXJyYXlMaW1pdFwiO1xuaW1wb3J0IHVuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5IGZyb20gXCIuL3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5XCI7XG5pbXBvcnQgbm9uSXRlcmFibGVSZXN0IGZyb20gXCIuL25vbkl0ZXJhYmxlUmVzdFwiO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gX3NsaWNlZFRvQXJyYXkoYXJyLCBpKSB7XG4gIHJldHVybiBhcnJheVdpdGhIb2xlcyhhcnIpIHx8IGl0ZXJhYmxlVG9BcnJheUxpbWl0KGFyciwgaSkgfHwgdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkoYXJyLCBpKSB8fCBub25JdGVyYWJsZVJlc3QoKTtcbn0iLCJpbXBvcnQgYXJyYXlMaWtlVG9BcnJheSBmcm9tIFwiLi9hcnJheUxpa2VUb0FycmF5XCI7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBfYXJyYXlXaXRob3V0SG9sZXMoYXJyKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGFycikpIHJldHVybiBhcnJheUxpa2VUb0FycmF5KGFycik7XG59IiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gX2l0ZXJhYmxlVG9BcnJheShpdGVyKSB7XG4gIGlmICh0eXBlb2YgU3ltYm9sICE9PSBcInVuZGVmaW5lZFwiICYmIFN5bWJvbC5pdGVyYXRvciBpbiBPYmplY3QoaXRlcikpIHJldHVybiBBcnJheS5mcm9tKGl0ZXIpO1xufSIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIF9ub25JdGVyYWJsZVNwcmVhZCgpIHtcbiAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBzcHJlYWQgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7XG59IiwiaW1wb3J0IGFycmF5V2l0aG91dEhvbGVzIGZyb20gXCIuL2FycmF5V2l0aG91dEhvbGVzXCI7XG5pbXBvcnQgaXRlcmFibGVUb0FycmF5IGZyb20gXCIuL2l0ZXJhYmxlVG9BcnJheVwiO1xuaW1wb3J0IHVuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5IGZyb20gXCIuL3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5XCI7XG5pbXBvcnQgbm9uSXRlcmFibGVTcHJlYWQgZnJvbSBcIi4vbm9uSXRlcmFibGVTcHJlYWRcIjtcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIF90b0NvbnN1bWFibGVBcnJheShhcnIpIHtcbiAgcmV0dXJuIGFycmF5V2l0aG91dEhvbGVzKGFycikgfHwgaXRlcmFibGVUb0FycmF5KGFycikgfHwgdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkoYXJyKSB8fCBub25JdGVyYWJsZVNwcmVhZCgpO1xufSIsImltcG9ydCBTb3J0YWJsZSBmcm9tIFwic29ydGFibGVqc1wiO1xyXG5pbXBvcnQgeyBpbnNlcnROb2RlQXQsIGNhbWVsaXplLCBjb25zb2xlLCByZW1vdmVOb2RlIH0gZnJvbSBcIi4vdXRpbC9oZWxwZXJcIjtcclxuXHJcbmZ1bmN0aW9uIGJ1aWxkQXR0cmlidXRlKG9iamVjdCwgcHJvcE5hbWUsIHZhbHVlKSB7XHJcbiAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcclxuICAgIHJldHVybiBvYmplY3Q7XHJcbiAgfVxyXG4gIG9iamVjdCA9IG9iamVjdCB8fCB7fTtcclxuICBvYmplY3RbcHJvcE5hbWVdID0gdmFsdWU7XHJcbiAgcmV0dXJuIG9iamVjdDtcclxufVxyXG5cclxuZnVuY3Rpb24gY29tcHV0ZVZtSW5kZXgodm5vZGVzLCBlbGVtZW50KSB7XHJcbiAgcmV0dXJuIHZub2Rlcy5tYXAoZWx0ID0+IGVsdC5lbG0pLmluZGV4T2YoZWxlbWVudCk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGNvbXB1dGVJbmRleGVzKHNsb3RzLCBjaGlsZHJlbiwgaXNUcmFuc2l0aW9uLCBmb290ZXJPZmZzZXQpIHtcclxuICBpZiAoIXNsb3RzKSB7XHJcbiAgICByZXR1cm4gW107XHJcbiAgfVxyXG5cclxuICBjb25zdCBlbG1Gcm9tTm9kZXMgPSBzbG90cy5tYXAoZWx0ID0+IGVsdC5lbG0pO1xyXG4gIGNvbnN0IGZvb3RlckluZGV4ID0gY2hpbGRyZW4ubGVuZ3RoIC0gZm9vdGVyT2Zmc2V0O1xyXG4gIGNvbnN0IHJhd0luZGV4ZXMgPSBbLi4uY2hpbGRyZW5dLm1hcCgoZWx0LCBpZHgpID0+XHJcbiAgICBpZHggPj0gZm9vdGVySW5kZXggPyBlbG1Gcm9tTm9kZXMubGVuZ3RoIDogZWxtRnJvbU5vZGVzLmluZGV4T2YoZWx0KVxyXG4gICk7XHJcbiAgcmV0dXJuIGlzVHJhbnNpdGlvbiA/IHJhd0luZGV4ZXMuZmlsdGVyKGluZCA9PiBpbmQgIT09IC0xKSA6IHJhd0luZGV4ZXM7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGVtaXQoZXZ0TmFtZSwgZXZ0RGF0YSkge1xyXG4gIHRoaXMuJG5leHRUaWNrKCgpID0+IHRoaXMuJGVtaXQoZXZ0TmFtZS50b0xvd2VyQ2FzZSgpLCBldnREYXRhKSk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGRlbGVnYXRlQW5kRW1pdChldnROYW1lKSB7XHJcbiAgcmV0dXJuIGV2dERhdGEgPT4ge1xyXG4gICAgaWYgKHRoaXMucmVhbExpc3QgIT09IG51bGwpIHtcclxuICAgICAgdGhpc1tcIm9uRHJhZ1wiICsgZXZ0TmFtZV0oZXZ0RGF0YSk7XHJcbiAgICB9XHJcbiAgICBlbWl0LmNhbGwodGhpcywgZXZ0TmFtZSwgZXZ0RGF0YSk7XHJcbiAgfTtcclxufVxyXG5cclxuZnVuY3Rpb24gaXNUcmFuc2l0aW9uTmFtZShuYW1lKSB7XHJcbiAgcmV0dXJuIFtcInRyYW5zaXRpb24tZ3JvdXBcIiwgXCJUcmFuc2l0aW9uR3JvdXBcIl0uaW5jbHVkZXMobmFtZSk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGlzVHJhbnNpdGlvbihzbG90cykge1xyXG4gIGlmICghc2xvdHMgfHwgc2xvdHMubGVuZ3RoICE9PSAxKSB7XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbiAgfVxyXG4gIGNvbnN0IFt7IGNvbXBvbmVudE9wdGlvbnMgfV0gPSBzbG90cztcclxuICBpZiAoIWNvbXBvbmVudE9wdGlvbnMpIHtcclxuICAgIHJldHVybiBmYWxzZTtcclxuICB9XHJcbiAgcmV0dXJuIGlzVHJhbnNpdGlvbk5hbWUoY29tcG9uZW50T3B0aW9ucy50YWcpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBnZXRTbG90KHNsb3QsIHNjb3BlZFNsb3QsIGtleSkge1xyXG4gIHJldHVybiBzbG90W2tleV0gfHwgKHNjb3BlZFNsb3Rba2V5XSA/IHNjb3BlZFNsb3Rba2V5XSgpIDogdW5kZWZpbmVkKTtcclxufVxyXG5cclxuZnVuY3Rpb24gY29tcHV0ZUNoaWxkcmVuQW5kT2Zmc2V0cyhjaGlsZHJlbiwgc2xvdCwgc2NvcGVkU2xvdCkge1xyXG4gIGxldCBoZWFkZXJPZmZzZXQgPSAwO1xyXG4gIGxldCBmb290ZXJPZmZzZXQgPSAwO1xyXG4gIGNvbnN0IGhlYWRlciA9IGdldFNsb3Qoc2xvdCwgc2NvcGVkU2xvdCwgXCJoZWFkZXJcIik7XHJcbiAgaWYgKGhlYWRlcikge1xyXG4gICAgaGVhZGVyT2Zmc2V0ID0gaGVhZGVyLmxlbmd0aDtcclxuICAgIGNoaWxkcmVuID0gY2hpbGRyZW4gPyBbLi4uaGVhZGVyLCAuLi5jaGlsZHJlbl0gOiBbLi4uaGVhZGVyXTtcclxuICB9XHJcbiAgY29uc3QgZm9vdGVyID0gZ2V0U2xvdChzbG90LCBzY29wZWRTbG90LCBcImZvb3RlclwiKTtcclxuICBpZiAoZm9vdGVyKSB7XHJcbiAgICBmb290ZXJPZmZzZXQgPSBmb290ZXIubGVuZ3RoO1xyXG4gICAgY2hpbGRyZW4gPSBjaGlsZHJlbiA/IFsuLi5jaGlsZHJlbiwgLi4uZm9vdGVyXSA6IFsuLi5mb290ZXJdO1xyXG4gIH1cclxuICByZXR1cm4geyBjaGlsZHJlbiwgaGVhZGVyT2Zmc2V0LCBmb290ZXJPZmZzZXQgfTtcclxufVxyXG5cclxuZnVuY3Rpb24gZ2V0Q29tcG9uZW50QXR0cmlidXRlcygkYXR0cnMsIGNvbXBvbmVudERhdGEpIHtcclxuICBsZXQgYXR0cmlidXRlcyA9IG51bGw7XHJcbiAgY29uc3QgdXBkYXRlID0gKG5hbWUsIHZhbHVlKSA9PiB7XHJcbiAgICBhdHRyaWJ1dGVzID0gYnVpbGRBdHRyaWJ1dGUoYXR0cmlidXRlcywgbmFtZSwgdmFsdWUpO1xyXG4gIH07XHJcbiAgY29uc3QgYXR0cnMgPSBPYmplY3Qua2V5cygkYXR0cnMpXHJcbiAgICAuZmlsdGVyKGtleSA9PiBrZXkgPT09IFwiaWRcIiB8fCBrZXkuc3RhcnRzV2l0aChcImRhdGEtXCIpKVxyXG4gICAgLnJlZHVjZSgocmVzLCBrZXkpID0+IHtcclxuICAgICAgcmVzW2tleV0gPSAkYXR0cnNba2V5XTtcclxuICAgICAgcmV0dXJuIHJlcztcclxuICAgIH0sIHt9KTtcclxuICB1cGRhdGUoXCJhdHRyc1wiLCBhdHRycyk7XHJcblxyXG4gIGlmICghY29tcG9uZW50RGF0YSkge1xyXG4gICAgcmV0dXJuIGF0dHJpYnV0ZXM7XHJcbiAgfVxyXG4gIGNvbnN0IHsgb24sIHByb3BzLCBhdHRyczogY29tcG9uZW50RGF0YUF0dHJzIH0gPSBjb21wb25lbnREYXRhO1xyXG4gIHVwZGF0ZShcIm9uXCIsIG9uKTtcclxuICB1cGRhdGUoXCJwcm9wc1wiLCBwcm9wcyk7XHJcbiAgT2JqZWN0LmFzc2lnbihhdHRyaWJ1dGVzLmF0dHJzLCBjb21wb25lbnREYXRhQXR0cnMpO1xyXG4gIHJldHVybiBhdHRyaWJ1dGVzO1xyXG59XHJcblxyXG5jb25zdCBldmVudHNMaXN0ZW5lZCA9IFtcIlN0YXJ0XCIsIFwiQWRkXCIsIFwiUmVtb3ZlXCIsIFwiVXBkYXRlXCIsIFwiRW5kXCJdO1xyXG5jb25zdCBldmVudHNUb0VtaXQgPSBbXCJDaG9vc2VcIiwgXCJVbmNob29zZVwiLCBcIlNvcnRcIiwgXCJGaWx0ZXJcIiwgXCJDbG9uZVwiXTtcclxuY29uc3QgcmVhZG9ubHlQcm9wZXJ0aWVzID0gW1wiTW92ZVwiLCAuLi5ldmVudHNMaXN0ZW5lZCwgLi4uZXZlbnRzVG9FbWl0XS5tYXAoXHJcbiAgZXZ0ID0+IFwib25cIiArIGV2dFxyXG4pO1xyXG52YXIgZHJhZ2dpbmdFbGVtZW50ID0gbnVsbDtcclxuXHJcbmNvbnN0IHByb3BzID0ge1xyXG4gIG9wdGlvbnM6IE9iamVjdCxcclxuICBsaXN0OiB7XHJcbiAgICB0eXBlOiBBcnJheSxcclxuICAgIHJlcXVpcmVkOiBmYWxzZSxcclxuICAgIGRlZmF1bHQ6IG51bGxcclxuICB9LFxyXG4gIHZhbHVlOiB7XHJcbiAgICB0eXBlOiBBcnJheSxcclxuICAgIHJlcXVpcmVkOiBmYWxzZSxcclxuICAgIGRlZmF1bHQ6IG51bGxcclxuICB9LFxyXG4gIG5vVHJhbnNpdGlvbk9uRHJhZzoge1xyXG4gICAgdHlwZTogQm9vbGVhbixcclxuICAgIGRlZmF1bHQ6IGZhbHNlXHJcbiAgfSxcclxuICBjbG9uZToge1xyXG4gICAgdHlwZTogRnVuY3Rpb24sXHJcbiAgICBkZWZhdWx0OiBvcmlnaW5hbCA9PiB7XHJcbiAgICAgIHJldHVybiBvcmlnaW5hbDtcclxuICAgIH1cclxuICB9LFxyXG4gIGVsZW1lbnQ6IHtcclxuICAgIHR5cGU6IFN0cmluZyxcclxuICAgIGRlZmF1bHQ6IFwiZGl2XCJcclxuICB9LFxyXG4gIHRhZzoge1xyXG4gICAgdHlwZTogU3RyaW5nLFxyXG4gICAgZGVmYXVsdDogbnVsbFxyXG4gIH0sXHJcbiAgbW92ZToge1xyXG4gICAgdHlwZTogRnVuY3Rpb24sXHJcbiAgICBkZWZhdWx0OiBudWxsXHJcbiAgfSxcclxuICBjb21wb25lbnREYXRhOiB7XHJcbiAgICB0eXBlOiBPYmplY3QsXHJcbiAgICByZXF1aXJlZDogZmFsc2UsXHJcbiAgICBkZWZhdWx0OiBudWxsXHJcbiAgfVxyXG59O1xyXG5cclxuY29uc3QgZHJhZ2dhYmxlQ29tcG9uZW50ID0ge1xyXG4gIG5hbWU6IFwiZHJhZ2dhYmxlXCIsXHJcblxyXG4gIGluaGVyaXRBdHRyczogZmFsc2UsXHJcblxyXG4gIHByb3BzLFxyXG5cclxuICBkYXRhKCkge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgdHJhbnNpdGlvbk1vZGU6IGZhbHNlLFxyXG4gICAgICBub25lRnVuY3Rpb25hbENvbXBvbmVudE1vZGU6IGZhbHNlXHJcbiAgICB9O1xyXG4gIH0sXHJcblxyXG4gIHJlbmRlcihoKSB7XHJcbiAgICBjb25zdCBzbG90cyA9IHRoaXMuJHNsb3RzLmRlZmF1bHQ7XHJcbiAgICB0aGlzLnRyYW5zaXRpb25Nb2RlID0gaXNUcmFuc2l0aW9uKHNsb3RzKTtcclxuICAgIGNvbnN0IHsgY2hpbGRyZW4sIGhlYWRlck9mZnNldCwgZm9vdGVyT2Zmc2V0IH0gPSBjb21wdXRlQ2hpbGRyZW5BbmRPZmZzZXRzKFxyXG4gICAgICBzbG90cyxcclxuICAgICAgdGhpcy4kc2xvdHMsXHJcbiAgICAgIHRoaXMuJHNjb3BlZFNsb3RzXHJcbiAgICApO1xyXG4gICAgdGhpcy5oZWFkZXJPZmZzZXQgPSBoZWFkZXJPZmZzZXQ7XHJcbiAgICB0aGlzLmZvb3Rlck9mZnNldCA9IGZvb3Rlck9mZnNldDtcclxuICAgIGNvbnN0IGF0dHJpYnV0ZXMgPSBnZXRDb21wb25lbnRBdHRyaWJ1dGVzKHRoaXMuJGF0dHJzLCB0aGlzLmNvbXBvbmVudERhdGEpO1xyXG4gICAgcmV0dXJuIGgodGhpcy5nZXRUYWcoKSwgYXR0cmlidXRlcywgY2hpbGRyZW4pO1xyXG4gIH0sXHJcblxyXG4gIGNyZWF0ZWQoKSB7XHJcbiAgICBpZiAodGhpcy5saXN0ICE9PSBudWxsICYmIHRoaXMudmFsdWUgIT09IG51bGwpIHtcclxuICAgICAgY29uc29sZS5lcnJvcihcclxuICAgICAgICBcIlZhbHVlIGFuZCBsaXN0IHByb3BzIGFyZSBtdXR1YWxseSBleGNsdXNpdmUhIFBsZWFzZSBzZXQgb25lIG9yIGFub3RoZXIuXCJcclxuICAgICAgKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAodGhpcy5lbGVtZW50ICE9PSBcImRpdlwiKSB7XHJcbiAgICAgIGNvbnNvbGUud2FybihcclxuICAgICAgICBcIkVsZW1lbnQgcHJvcHMgaXMgZGVwcmVjYXRlZCBwbGVhc2UgdXNlIHRhZyBwcm9wcyBpbnN0ZWFkLiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL1NvcnRhYmxlSlMvVnVlLkRyYWdnYWJsZS9ibG9iL21hc3Rlci9kb2N1bWVudGF0aW9uL21pZ3JhdGUubWQjZWxlbWVudC1wcm9wc1wiXHJcbiAgICAgICk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHRoaXMub3B0aW9ucyAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgIGNvbnNvbGUud2FybihcclxuICAgICAgICBcIk9wdGlvbnMgcHJvcHMgaXMgZGVwcmVjYXRlZCwgYWRkIHNvcnRhYmxlIG9wdGlvbnMgZGlyZWN0bHkgYXMgdnVlLmRyYWdnYWJsZSBpdGVtLCBvciB1c2Ugdi1iaW5kLiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL1NvcnRhYmxlSlMvVnVlLkRyYWdnYWJsZS9ibG9iL21hc3Rlci9kb2N1bWVudGF0aW9uL21pZ3JhdGUubWQjb3B0aW9ucy1wcm9wc1wiXHJcbiAgICAgICk7XHJcbiAgICB9XHJcbiAgfSxcclxuXHJcbiAgbW91bnRlZCgpIHtcclxuICAgIHRoaXMubm9uZUZ1bmN0aW9uYWxDb21wb25lbnRNb2RlID1cclxuICAgICAgdGhpcy5nZXRUYWcoKS50b0xvd2VyQ2FzZSgpICE9PSB0aGlzLiRlbC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpICYmXHJcbiAgICAgICF0aGlzLmdldElzRnVuY3Rpb25hbCgpO1xyXG4gICAgaWYgKHRoaXMubm9uZUZ1bmN0aW9uYWxDb21wb25lbnRNb2RlICYmIHRoaXMudHJhbnNpdGlvbk1vZGUpIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKFxyXG4gICAgICAgIGBUcmFuc2l0aW9uLWdyb3VwIGluc2lkZSBjb21wb25lbnQgaXMgbm90IHN1cHBvcnRlZC4gUGxlYXNlIGFsdGVyIHRhZyB2YWx1ZSBvciByZW1vdmUgdHJhbnNpdGlvbi1ncm91cC4gQ3VycmVudCB0YWcgdmFsdWU6ICR7dGhpcy5nZXRUYWcoKX1gXHJcbiAgICAgICk7XHJcbiAgICB9XHJcbiAgICBjb25zdCBvcHRpb25zQWRkZWQgPSB7fTtcclxuICAgIGV2ZW50c0xpc3RlbmVkLmZvckVhY2goZWx0ID0+IHtcclxuICAgICAgb3B0aW9uc0FkZGVkW1wib25cIiArIGVsdF0gPSBkZWxlZ2F0ZUFuZEVtaXQuY2FsbCh0aGlzLCBlbHQpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgZXZlbnRzVG9FbWl0LmZvckVhY2goZWx0ID0+IHtcclxuICAgICAgb3B0aW9uc0FkZGVkW1wib25cIiArIGVsdF0gPSBlbWl0LmJpbmQodGhpcywgZWx0KTtcclxuICAgIH0pO1xyXG5cclxuICAgIGNvbnN0IGF0dHJpYnV0ZXMgPSBPYmplY3Qua2V5cyh0aGlzLiRhdHRycykucmVkdWNlKChyZXMsIGtleSkgPT4ge1xyXG4gICAgICByZXNbY2FtZWxpemUoa2V5KV0gPSB0aGlzLiRhdHRyc1trZXldO1xyXG4gICAgICByZXR1cm4gcmVzO1xyXG4gICAgfSwge30pO1xyXG5cclxuICAgIGNvbnN0IG9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCB0aGlzLm9wdGlvbnMsIGF0dHJpYnV0ZXMsIG9wdGlvbnNBZGRlZCwge1xyXG4gICAgICBvbk1vdmU6IChldnQsIG9yaWdpbmFsRXZlbnQpID0+IHtcclxuICAgICAgICByZXR1cm4gdGhpcy5vbkRyYWdNb3ZlKGV2dCwgb3JpZ2luYWxFdmVudCk7XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG4gICAgIShcImRyYWdnYWJsZVwiIGluIG9wdGlvbnMpICYmIChvcHRpb25zLmRyYWdnYWJsZSA9IFwiPipcIik7XHJcbiAgICB0aGlzLl9zb3J0YWJsZSA9IG5ldyBTb3J0YWJsZSh0aGlzLnJvb3RDb250YWluZXIsIG9wdGlvbnMpO1xyXG4gICAgdGhpcy5jb21wdXRlSW5kZXhlcygpO1xyXG4gIH0sXHJcblxyXG4gIGJlZm9yZURlc3Ryb3koKSB7XHJcbiAgICBpZiAodGhpcy5fc29ydGFibGUgIT09IHVuZGVmaW5lZCkgdGhpcy5fc29ydGFibGUuZGVzdHJveSgpO1xyXG4gIH0sXHJcblxyXG4gIGNvbXB1dGVkOiB7XHJcbiAgICByb290Q29udGFpbmVyKCkge1xyXG4gICAgICByZXR1cm4gdGhpcy50cmFuc2l0aW9uTW9kZSA/IHRoaXMuJGVsLmNoaWxkcmVuWzBdIDogdGhpcy4kZWw7XHJcbiAgICB9LFxyXG5cclxuICAgIHJlYWxMaXN0KCkge1xyXG4gICAgICByZXR1cm4gdGhpcy5saXN0ID8gdGhpcy5saXN0IDogdGhpcy52YWx1ZTtcclxuICAgIH1cclxuICB9LFxyXG5cclxuICB3YXRjaDoge1xyXG4gICAgb3B0aW9uczoge1xyXG4gICAgICBoYW5kbGVyKG5ld09wdGlvblZhbHVlKSB7XHJcbiAgICAgICAgdGhpcy51cGRhdGVPcHRpb25zKG5ld09wdGlvblZhbHVlKTtcclxuICAgICAgfSxcclxuICAgICAgZGVlcDogdHJ1ZVxyXG4gICAgfSxcclxuXHJcbiAgICAkYXR0cnM6IHtcclxuICAgICAgaGFuZGxlcihuZXdPcHRpb25WYWx1ZSkge1xyXG4gICAgICAgIHRoaXMudXBkYXRlT3B0aW9ucyhuZXdPcHRpb25WYWx1ZSk7XHJcbiAgICAgIH0sXHJcbiAgICAgIGRlZXA6IHRydWVcclxuICAgIH0sXHJcblxyXG4gICAgcmVhbExpc3QoKSB7XHJcbiAgICAgIHRoaXMuY29tcHV0ZUluZGV4ZXMoKTtcclxuICAgIH1cclxuICB9LFxyXG5cclxuICBtZXRob2RzOiB7XHJcbiAgICBnZXRJc0Z1bmN0aW9uYWwoKSB7XHJcbiAgICAgIGNvbnN0IHsgZm5PcHRpb25zIH0gPSB0aGlzLl92bm9kZTtcclxuICAgICAgcmV0dXJuIGZuT3B0aW9ucyAmJiBmbk9wdGlvbnMuZnVuY3Rpb25hbDtcclxuICAgIH0sXHJcblxyXG4gICAgZ2V0VGFnKCkge1xyXG4gICAgICByZXR1cm4gdGhpcy50YWcgfHwgdGhpcy5lbGVtZW50O1xyXG4gICAgfSxcclxuXHJcbiAgICB1cGRhdGVPcHRpb25zKG5ld09wdGlvblZhbHVlKSB7XHJcbiAgICAgIGZvciAodmFyIHByb3BlcnR5IGluIG5ld09wdGlvblZhbHVlKSB7XHJcbiAgICAgICAgY29uc3QgdmFsdWUgPSBjYW1lbGl6ZShwcm9wZXJ0eSk7XHJcbiAgICAgICAgaWYgKHJlYWRvbmx5UHJvcGVydGllcy5pbmRleE9mKHZhbHVlKSA9PT0gLTEpIHtcclxuICAgICAgICAgIHRoaXMuX3NvcnRhYmxlLm9wdGlvbih2YWx1ZSwgbmV3T3B0aW9uVmFsdWVbcHJvcGVydHldKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgZ2V0Q2hpbGRyZW5Ob2RlcygpIHtcclxuICAgICAgaWYgKHRoaXMubm9uZUZ1bmN0aW9uYWxDb21wb25lbnRNb2RlKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuJGNoaWxkcmVuWzBdLiRzbG90cy5kZWZhdWx0O1xyXG4gICAgICB9XHJcbiAgICAgIGNvbnN0IHJhd05vZGVzID0gdGhpcy4kc2xvdHMuZGVmYXVsdDtcclxuICAgICAgcmV0dXJuIHRoaXMudHJhbnNpdGlvbk1vZGUgPyByYXdOb2Rlc1swXS5jaGlsZC4kc2xvdHMuZGVmYXVsdCA6IHJhd05vZGVzO1xyXG4gICAgfSxcclxuXHJcbiAgICBjb21wdXRlSW5kZXhlcygpIHtcclxuICAgICAgdGhpcy4kbmV4dFRpY2soKCkgPT4ge1xyXG4gICAgICAgIHRoaXMudmlzaWJsZUluZGV4ZXMgPSBjb21wdXRlSW5kZXhlcyhcclxuICAgICAgICAgIHRoaXMuZ2V0Q2hpbGRyZW5Ob2RlcygpLFxyXG4gICAgICAgICAgdGhpcy5yb290Q29udGFpbmVyLmNoaWxkcmVuLFxyXG4gICAgICAgICAgdGhpcy50cmFuc2l0aW9uTW9kZSxcclxuICAgICAgICAgIHRoaXMuZm9vdGVyT2Zmc2V0XHJcbiAgICAgICAgKTtcclxuICAgICAgfSk7XHJcbiAgICB9LFxyXG5cclxuICAgIGdldFVuZGVybHlpbmdWbShodG1sRWx0KSB7XHJcbiAgICAgIGNvbnN0IGluZGV4ID0gY29tcHV0ZVZtSW5kZXgodGhpcy5nZXRDaGlsZHJlbk5vZGVzKCkgfHwgW10sIGh0bWxFbHQpO1xyXG4gICAgICBpZiAoaW5kZXggPT09IC0xKSB7XHJcbiAgICAgICAgLy9FZGdlIGNhc2UgZHVyaW5nIG1vdmUgY2FsbGJhY2s6IHJlbGF0ZWQgZWxlbWVudCBtaWdodCBiZVxyXG4gICAgICAgIC8vYW4gZWxlbWVudCBkaWZmZXJlbnQgZnJvbSBjb2xsZWN0aW9uXHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgIH1cclxuICAgICAgY29uc3QgZWxlbWVudCA9IHRoaXMucmVhbExpc3RbaW5kZXhdO1xyXG4gICAgICByZXR1cm4geyBpbmRleCwgZWxlbWVudCB9O1xyXG4gICAgfSxcclxuXHJcbiAgICBnZXRVbmRlcmx5aW5nUG90ZW5jaWFsRHJhZ2dhYmxlQ29tcG9uZW50KHsgX192dWVfXzogdnVlIH0pIHtcclxuICAgICAgaWYgKFxyXG4gICAgICAgICF2dWUgfHxcclxuICAgICAgICAhdnVlLiRvcHRpb25zIHx8XHJcbiAgICAgICAgIWlzVHJhbnNpdGlvbk5hbWUodnVlLiRvcHRpb25zLl9jb21wb25lbnRUYWcpXHJcbiAgICAgICkge1xyXG4gICAgICAgIGlmIChcclxuICAgICAgICAgICEoXCJyZWFsTGlzdFwiIGluIHZ1ZSkgJiZcclxuICAgICAgICAgIHZ1ZS4kY2hpbGRyZW4ubGVuZ3RoID09PSAxICYmXHJcbiAgICAgICAgICBcInJlYWxMaXN0XCIgaW4gdnVlLiRjaGlsZHJlblswXVxyXG4gICAgICAgIClcclxuICAgICAgICAgIHJldHVybiB2dWUuJGNoaWxkcmVuWzBdO1xyXG5cclxuICAgICAgICByZXR1cm4gdnVlO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiB2dWUuJHBhcmVudDtcclxuICAgIH0sXHJcblxyXG4gICAgZW1pdENoYW5nZXMoZXZ0KSB7XHJcbiAgICAgIHRoaXMuJG5leHRUaWNrKCgpID0+IHtcclxuICAgICAgICB0aGlzLiRlbWl0KFwiY2hhbmdlXCIsIGV2dCk7XHJcbiAgICAgIH0pO1xyXG4gICAgfSxcclxuXHJcbiAgICBhbHRlckxpc3Qob25MaXN0KSB7XHJcbiAgICAgIGlmICh0aGlzLmxpc3QpIHtcclxuICAgICAgICBvbkxpc3QodGhpcy5saXN0KTtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuICAgICAgY29uc3QgbmV3TGlzdCA9IFsuLi50aGlzLnZhbHVlXTtcclxuICAgICAgb25MaXN0KG5ld0xpc3QpO1xyXG4gICAgICB0aGlzLiRlbWl0KFwiaW5wdXRcIiwgbmV3TGlzdCk7XHJcbiAgICB9LFxyXG5cclxuICAgIHNwbGljZUxpc3QoKSB7XHJcbiAgICAgIGNvbnN0IHNwbGljZUxpc3QgPSBsaXN0ID0+IGxpc3Quc3BsaWNlKC4uLmFyZ3VtZW50cyk7XHJcbiAgICAgIHRoaXMuYWx0ZXJMaXN0KHNwbGljZUxpc3QpO1xyXG4gICAgfSxcclxuXHJcbiAgICB1cGRhdGVQb3NpdGlvbihvbGRJbmRleCwgbmV3SW5kZXgpIHtcclxuICAgICAgY29uc3QgdXBkYXRlUG9zaXRpb24gPSBsaXN0ID0+XHJcbiAgICAgICAgbGlzdC5zcGxpY2UobmV3SW5kZXgsIDAsIGxpc3Quc3BsaWNlKG9sZEluZGV4LCAxKVswXSk7XHJcbiAgICAgIHRoaXMuYWx0ZXJMaXN0KHVwZGF0ZVBvc2l0aW9uKTtcclxuICAgIH0sXHJcblxyXG4gICAgZ2V0UmVsYXRlZENvbnRleHRGcm9tTW92ZUV2ZW50KHsgdG8sIHJlbGF0ZWQgfSkge1xyXG4gICAgICBjb25zdCBjb21wb25lbnQgPSB0aGlzLmdldFVuZGVybHlpbmdQb3RlbmNpYWxEcmFnZ2FibGVDb21wb25lbnQodG8pO1xyXG4gICAgICBpZiAoIWNvbXBvbmVudCkge1xyXG4gICAgICAgIHJldHVybiB7IGNvbXBvbmVudCB9O1xyXG4gICAgICB9XHJcbiAgICAgIGNvbnN0IGxpc3QgPSBjb21wb25lbnQucmVhbExpc3Q7XHJcbiAgICAgIGNvbnN0IGNvbnRleHQgPSB7IGxpc3QsIGNvbXBvbmVudCB9O1xyXG4gICAgICBpZiAodG8gIT09IHJlbGF0ZWQgJiYgbGlzdCAmJiBjb21wb25lbnQuZ2V0VW5kZXJseWluZ1ZtKSB7XHJcbiAgICAgICAgY29uc3QgZGVzdGluYXRpb24gPSBjb21wb25lbnQuZ2V0VW5kZXJseWluZ1ZtKHJlbGF0ZWQpO1xyXG4gICAgICAgIGlmIChkZXN0aW5hdGlvbikge1xyXG4gICAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oZGVzdGluYXRpb24sIGNvbnRleHQpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gY29udGV4dDtcclxuICAgIH0sXHJcblxyXG4gICAgZ2V0Vm1JbmRleChkb21JbmRleCkge1xyXG4gICAgICBjb25zdCBpbmRleGVzID0gdGhpcy52aXNpYmxlSW5kZXhlcztcclxuICAgICAgY29uc3QgbnVtYmVySW5kZXhlcyA9IGluZGV4ZXMubGVuZ3RoO1xyXG4gICAgICByZXR1cm4gZG9tSW5kZXggPiBudW1iZXJJbmRleGVzIC0gMSA/IG51bWJlckluZGV4ZXMgOiBpbmRleGVzW2RvbUluZGV4XTtcclxuICAgIH0sXHJcblxyXG4gICAgZ2V0Q29tcG9uZW50KCkge1xyXG4gICAgICByZXR1cm4gdGhpcy4kc2xvdHMuZGVmYXVsdFswXS5jb21wb25lbnRJbnN0YW5jZTtcclxuICAgIH0sXHJcblxyXG4gICAgcmVzZXRUcmFuc2l0aW9uRGF0YShpbmRleCkge1xyXG4gICAgICBpZiAoIXRoaXMubm9UcmFuc2l0aW9uT25EcmFnIHx8ICF0aGlzLnRyYW5zaXRpb25Nb2RlKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcbiAgICAgIHZhciBub2RlcyA9IHRoaXMuZ2V0Q2hpbGRyZW5Ob2RlcygpO1xyXG4gICAgICBub2Rlc1tpbmRleF0uZGF0YSA9IG51bGw7XHJcbiAgICAgIGNvbnN0IHRyYW5zaXRpb25Db250YWluZXIgPSB0aGlzLmdldENvbXBvbmVudCgpO1xyXG4gICAgICB0cmFuc2l0aW9uQ29udGFpbmVyLmNoaWxkcmVuID0gW107XHJcbiAgICAgIHRyYW5zaXRpb25Db250YWluZXIua2VwdCA9IHVuZGVmaW5lZDtcclxuICAgIH0sXHJcblxyXG4gICAgb25EcmFnU3RhcnQoZXZ0KSB7XHJcbiAgICAgIHRoaXMuY29udGV4dCA9IHRoaXMuZ2V0VW5kZXJseWluZ1ZtKGV2dC5pdGVtKTtcclxuICAgICAgZXZ0Lml0ZW0uX3VuZGVybHlpbmdfdm1fID0gdGhpcy5jbG9uZSh0aGlzLmNvbnRleHQuZWxlbWVudCk7XHJcbiAgICAgIGRyYWdnaW5nRWxlbWVudCA9IGV2dC5pdGVtO1xyXG4gICAgfSxcclxuXHJcbiAgICBvbkRyYWdBZGQoZXZ0KSB7XHJcbiAgICAgIGNvbnN0IGVsZW1lbnQgPSBldnQuaXRlbS5fdW5kZXJseWluZ192bV87XHJcbiAgICAgIGlmIChlbGVtZW50ID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuICAgICAgcmVtb3ZlTm9kZShldnQuaXRlbSk7XHJcbiAgICAgIGNvbnN0IG5ld0luZGV4ID0gdGhpcy5nZXRWbUluZGV4KGV2dC5uZXdJbmRleCk7XHJcbiAgICAgIHRoaXMuc3BsaWNlTGlzdChuZXdJbmRleCwgMCwgZWxlbWVudCk7XHJcbiAgICAgIHRoaXMuY29tcHV0ZUluZGV4ZXMoKTtcclxuICAgICAgY29uc3QgYWRkZWQgPSB7IGVsZW1lbnQsIG5ld0luZGV4IH07XHJcbiAgICAgIHRoaXMuZW1pdENoYW5nZXMoeyBhZGRlZCB9KTtcclxuICAgIH0sXHJcblxyXG4gICAgb25EcmFnUmVtb3ZlKGV2dCkge1xyXG4gICAgICBpbnNlcnROb2RlQXQodGhpcy5yb290Q29udGFpbmVyLCBldnQuaXRlbSwgZXZ0Lm9sZEluZGV4KTtcclxuICAgICAgaWYgKGV2dC5wdWxsTW9kZSA9PT0gXCJjbG9uZVwiKSB7XHJcbiAgICAgICAgcmVtb3ZlTm9kZShldnQuY2xvbmUpO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG4gICAgICBjb25zdCBvbGRJbmRleCA9IHRoaXMuY29udGV4dC5pbmRleDtcclxuICAgICAgdGhpcy5zcGxpY2VMaXN0KG9sZEluZGV4LCAxKTtcclxuICAgICAgY29uc3QgcmVtb3ZlZCA9IHsgZWxlbWVudDogdGhpcy5jb250ZXh0LmVsZW1lbnQsIG9sZEluZGV4IH07XHJcbiAgICAgIHRoaXMucmVzZXRUcmFuc2l0aW9uRGF0YShvbGRJbmRleCk7XHJcbiAgICAgIHRoaXMuZW1pdENoYW5nZXMoeyByZW1vdmVkIH0pO1xyXG4gICAgfSxcclxuXHJcbiAgICBvbkRyYWdVcGRhdGUoZXZ0KSB7XHJcbiAgICAgIHJlbW92ZU5vZGUoZXZ0Lml0ZW0pO1xyXG4gICAgICBpbnNlcnROb2RlQXQoZXZ0LmZyb20sIGV2dC5pdGVtLCBldnQub2xkSW5kZXgpO1xyXG4gICAgICBjb25zdCBvbGRJbmRleCA9IHRoaXMuY29udGV4dC5pbmRleDtcclxuICAgICAgY29uc3QgbmV3SW5kZXggPSB0aGlzLmdldFZtSW5kZXgoZXZ0Lm5ld0luZGV4KTtcclxuICAgICAgdGhpcy51cGRhdGVQb3NpdGlvbihvbGRJbmRleCwgbmV3SW5kZXgpO1xyXG4gICAgICBjb25zdCBtb3ZlZCA9IHsgZWxlbWVudDogdGhpcy5jb250ZXh0LmVsZW1lbnQsIG9sZEluZGV4LCBuZXdJbmRleCB9O1xyXG4gICAgICB0aGlzLmVtaXRDaGFuZ2VzKHsgbW92ZWQgfSk7XHJcbiAgICB9LFxyXG5cclxuICAgIHVwZGF0ZVByb3BlcnR5KGV2dCwgcHJvcGVydHlOYW1lKSB7XHJcbiAgICAgIGV2dC5oYXNPd25Qcm9wZXJ0eShwcm9wZXJ0eU5hbWUpICYmXHJcbiAgICAgICAgKGV2dFtwcm9wZXJ0eU5hbWVdICs9IHRoaXMuaGVhZGVyT2Zmc2V0KTtcclxuICAgIH0sXHJcblxyXG4gICAgY29tcHV0ZUZ1dHVyZUluZGV4KHJlbGF0ZWRDb250ZXh0LCBldnQpIHtcclxuICAgICAgaWYgKCFyZWxhdGVkQ29udGV4dC5lbGVtZW50KSB7XHJcbiAgICAgICAgcmV0dXJuIDA7XHJcbiAgICAgIH1cclxuICAgICAgY29uc3QgZG9tQ2hpbGRyZW4gPSBbLi4uZXZ0LnRvLmNoaWxkcmVuXS5maWx0ZXIoXHJcbiAgICAgICAgZWwgPT4gZWwuc3R5bGVbXCJkaXNwbGF5XCJdICE9PSBcIm5vbmVcIlxyXG4gICAgICApO1xyXG4gICAgICBjb25zdCBjdXJyZW50RE9NSW5kZXggPSBkb21DaGlsZHJlbi5pbmRleE9mKGV2dC5yZWxhdGVkKTtcclxuICAgICAgY29uc3QgY3VycmVudEluZGV4ID0gcmVsYXRlZENvbnRleHQuY29tcG9uZW50LmdldFZtSW5kZXgoY3VycmVudERPTUluZGV4KTtcclxuICAgICAgY29uc3QgZHJhZ2dlZEluTGlzdCA9IGRvbUNoaWxkcmVuLmluZGV4T2YoZHJhZ2dpbmdFbGVtZW50KSAhPT0gLTE7XHJcbiAgICAgIHJldHVybiBkcmFnZ2VkSW5MaXN0IHx8ICFldnQud2lsbEluc2VydEFmdGVyXHJcbiAgICAgICAgPyBjdXJyZW50SW5kZXhcclxuICAgICAgICA6IGN1cnJlbnRJbmRleCArIDE7XHJcbiAgICB9LFxyXG5cclxuICAgIG9uRHJhZ01vdmUoZXZ0LCBvcmlnaW5hbEV2ZW50KSB7XHJcbiAgICAgIGNvbnN0IG9uTW92ZSA9IHRoaXMubW92ZTtcclxuICAgICAgaWYgKCFvbk1vdmUgfHwgIXRoaXMucmVhbExpc3QpIHtcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgfVxyXG5cclxuICAgICAgY29uc3QgcmVsYXRlZENvbnRleHQgPSB0aGlzLmdldFJlbGF0ZWRDb250ZXh0RnJvbU1vdmVFdmVudChldnQpO1xyXG4gICAgICBjb25zdCBkcmFnZ2VkQ29udGV4dCA9IHRoaXMuY29udGV4dDtcclxuICAgICAgY29uc3QgZnV0dXJlSW5kZXggPSB0aGlzLmNvbXB1dGVGdXR1cmVJbmRleChyZWxhdGVkQ29udGV4dCwgZXZ0KTtcclxuICAgICAgT2JqZWN0LmFzc2lnbihkcmFnZ2VkQ29udGV4dCwgeyBmdXR1cmVJbmRleCB9KTtcclxuICAgICAgY29uc3Qgc2VuZEV2dCA9IE9iamVjdC5hc3NpZ24oe30sIGV2dCwge1xyXG4gICAgICAgIHJlbGF0ZWRDb250ZXh0LFxyXG4gICAgICAgIGRyYWdnZWRDb250ZXh0XHJcbiAgICAgIH0pO1xyXG4gICAgICByZXR1cm4gb25Nb3ZlKHNlbmRFdnQsIG9yaWdpbmFsRXZlbnQpO1xyXG4gICAgfSxcclxuXHJcbiAgICBvbkRyYWdFbmQoKSB7XHJcbiAgICAgIHRoaXMuY29tcHV0ZUluZGV4ZXMoKTtcclxuICAgICAgZHJhZ2dpbmdFbGVtZW50ID0gbnVsbDtcclxuICAgIH1cclxuICB9XHJcbn07XHJcblxyXG5pZiAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJiBcIlZ1ZVwiIGluIHdpbmRvdykge1xyXG4gIHdpbmRvdy5WdWUuY29tcG9uZW50KFwiZHJhZ2dhYmxlXCIsIGRyYWdnYWJsZUNvbXBvbmVudCk7XHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IGRyYWdnYWJsZUNvbXBvbmVudDtcclxuIiwiaW1wb3J0ICcuL3NldFB1YmxpY1BhdGgnXG5pbXBvcnQgbW9kIGZyb20gJ35lbnRyeSdcbmV4cG9ydCBkZWZhdWx0IG1vZFxuZXhwb3J0ICogZnJvbSAnfmVudHJ5J1xuIiwidmFyIGc7XG5cbi8vIFRoaXMgd29ya3MgaW4gbm9uLXN0cmljdCBtb2RlXG5nID0gKGZ1bmN0aW9uKCkge1xuXHRyZXR1cm4gdGhpcztcbn0pKCk7XG5cbnRyeSB7XG5cdC8vIFRoaXMgd29ya3MgaWYgZXZhbCBpcyBhbGxvd2VkIChzZWUgQ1NQKVxuXHRnID0gZyB8fCBuZXcgRnVuY3Rpb24oXCJyZXR1cm4gdGhpc1wiKSgpO1xufSBjYXRjaCAoZSkge1xuXHQvLyBUaGlzIHdvcmtzIGlmIHRoZSB3aW5kb3cgcmVmZXJlbmNlIGlzIGF2YWlsYWJsZVxuXHRpZiAodHlwZW9mIHdpbmRvdyA9PT0gXCJvYmplY3RcIikgZyA9IHdpbmRvdztcbn1cblxuLy8gZyBjYW4gc3RpbGwgYmUgdW5kZWZpbmVkLCBidXQgbm90aGluZyB0byBkbyBhYm91dCBpdC4uLlxuLy8gV2UgcmV0dXJuIHVuZGVmaW5lZCwgaW5zdGVhZCBvZiBub3RoaW5nIGhlcmUsIHNvIGl0J3Ncbi8vIGVhc2llciB0byBoYW5kbGUgdGhpcyBjYXNlLiBpZighZ2xvYmFsKSB7IC4uLn1cblxubW9kdWxlLmV4cG9ydHMgPSBnO1xuIiwiZXhwb3J0ICogZnJvbSBcIi0hLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9kaXN0L2Nqcy5qcyEuLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L2Nqcy5qcyEuLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvbG9hZGVycy9zdHlsZVBvc3RMb2FkZXIuanMhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Nhc3MtbG9hZGVyL2Rpc3QvY2pzLmpzIS4vbWFpbi5zY3NzP3Z1ZSZ0eXBlPXN0eWxlJmluZGV4PTAmbGFuZz1zY3NzJlwiIiwiaW1wb3J0IHsgcmVuZGVyLCBzdGF0aWNSZW5kZXJGbnMgfSBmcm9tIFwiLi9tYWluLnZ1ZT92dWUmdHlwZT10ZW1wbGF0ZSZpZD01ZTIxMDRlZiZcIlxuaW1wb3J0IHNjcmlwdCBmcm9tIFwiLi9tYWluLnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qcyZcIlxuZXhwb3J0ICogZnJvbSBcIi4vbWFpbi52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anMmXCJcbmltcG9ydCBzdHlsZTAgZnJvbSBcIi4vbWFpbi5zY3NzP3Z1ZSZ0eXBlPXN0eWxlJmluZGV4PTAmbGFuZz1zY3NzJlwiXG5cblxuLyogbm9ybWFsaXplIGNvbXBvbmVudCAqL1xuaW1wb3J0IG5vcm1hbGl6ZXIgZnJvbSBcIiEuLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvcnVudGltZS9jb21wb25lbnROb3JtYWxpemVyLmpzXCJcbnZhciBjb21wb25lbnQgPSBub3JtYWxpemVyKFxuICBzY3JpcHQsXG4gIHJlbmRlcixcbiAgc3RhdGljUmVuZGVyRm5zLFxuICBmYWxzZSxcbiAgbnVsbCxcbiAgbnVsbCxcbiAgbnVsbFxuICBcbilcblxuLyogaG90IHJlbG9hZCAqL1xuaWYgKG1vZHVsZS5ob3QpIHtcbiAgdmFyIGFwaSA9IHJlcXVpcmUoXCIvaG9tZS9nYXBwYS/QoNCw0LHQvtGH0LjQuSDRgdGC0L7Quy92dWVfd2VicGFjay9ub2RlX21vZHVsZXMvdnVlLWhvdC1yZWxvYWQtYXBpL2Rpc3QvaW5kZXguanNcIilcbiAgYXBpLmluc3RhbGwocmVxdWlyZSgndnVlJykpXG4gIGlmIChhcGkuY29tcGF0aWJsZSkge1xuICAgIG1vZHVsZS5ob3QuYWNjZXB0KClcbiAgICBpZiAoIWFwaS5pc1JlY29yZGVkKCc1ZTIxMDRlZicpKSB7XG4gICAgICBhcGkuY3JlYXRlUmVjb3JkKCc1ZTIxMDRlZicsIGNvbXBvbmVudC5vcHRpb25zKVxuICAgIH0gZWxzZSB7XG4gICAgICBhcGkucmVsb2FkKCc1ZTIxMDRlZicsIGNvbXBvbmVudC5vcHRpb25zKVxuICAgIH1cbiAgICBtb2R1bGUuaG90LmFjY2VwdChcIi4vbWFpbi52dWU/dnVlJnR5cGU9dGVtcGxhdGUmaWQ9NWUyMTA0ZWYmXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgIGFwaS5yZXJlbmRlcignNWUyMTA0ZWYnLCB7XG4gICAgICAgIHJlbmRlcjogcmVuZGVyLFxuICAgICAgICBzdGF0aWNSZW5kZXJGbnM6IHN0YXRpY1JlbmRlckZuc1xuICAgICAgfSlcbiAgICB9KVxuICB9XG59XG5jb21wb25lbnQub3B0aW9ucy5fX2ZpbGUgPSBcInNyYy9jb21wb25lbnRzL21haW4vbWFpbi52dWVcIlxuZXhwb3J0IGRlZmF1bHQgY29tcG9uZW50LmV4cG9ydHMiLCJpbXBvcnQgbW9kIGZyb20gXCItIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9iYWJlbC1sb2FkZXIvbGliL2luZGV4LmpzIS4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9pbmRleC5qcz8/dnVlLWxvYWRlci1vcHRpb25zIS4vbWFpbi52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anMmXCI7IGV4cG9ydCBkZWZhdWx0IG1vZDsgZXhwb3J0ICogZnJvbSBcIi0hLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2JhYmVsLWxvYWRlci9saWIvaW5kZXguanMhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2luZGV4LmpzPz92dWUtbG9hZGVyLW9wdGlvbnMhLi9tYWluLnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qcyZcIiIsImV4cG9ydCAqIGZyb20gXCItIS4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9sb2FkZXJzL3RlbXBsYXRlTG9hZGVyLmpzPz92dWUtbG9hZGVyLW9wdGlvbnMhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2luZGV4LmpzPz92dWUtbG9hZGVyLW9wdGlvbnMhLi9tYWluLnZ1ZT92dWUmdHlwZT10ZW1wbGF0ZSZpZD01ZTIxMDRlZiZcIiIsImltcG9ydCBWdWUgZnJvbSAndnVlJ1xuaW1wb3J0IE1haW4gZnJvbSAnLi9jb21wb25lbnRzL21haW4vbWFpbi52dWUnO1xuXG5uZXcgVnVlKHtcbiAgICBlbDogJyNyb290JyxcbiAgICByZW5kZXI6IGggPT4gaChNYWluKVxufSk7Il0sInNvdXJjZVJvb3QiOiIifQ==